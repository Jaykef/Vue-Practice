"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source2, exclude) => {
  var target = {};
  for (var prop in source2)
    if (__hasOwnProp.call(source2, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source2[prop];
  if (source2 != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source2)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source2, prop))
        target[prop] = source2[prop];
    }
  return target;
};
var require$$1 = require("electron");
var require$$1$1 = require("path");
var require$$2 = require("url");
var require$$0$2 = require("fs");
var require$$0 = require("constants");
var require$$0$1 = require("stream");
var require$$4 = require("util");
var require$$5 = require("assert");
var require$$0$3 = require("events");
var require$$0$4 = require("crypto");
var require$$1$2 = require("string_decoder");
var require$$4$1 = require("fs/promises");
var require$$1$3 = require("os");
var require$$1$4 = require("child_process");
var require$$2$1 = require("zlib");
var require$$3$1 = require("http");
function _interopDefaultLegacy(e) {
  return e && typeof e === "object" && "default" in e ? e : { "default": e };
}
function _interopNamespace(e) {
  if (e && e.__esModule)
    return e;
  var n = { __proto__: null, [Symbol.toStringTag]: "Module" };
  if (e) {
    Object.keys(e).forEach(function(k) {
      if (k !== "default") {
        var d2 = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d2.get ? d2 : {
          enumerable: true,
          get: function() {
            return e[k];
          }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}
var require$$1__default = /* @__PURE__ */ _interopDefaultLegacy(require$$1);
var require$$1__default$1 = /* @__PURE__ */ _interopDefaultLegacy(require$$1$1);
var require$$2__default = /* @__PURE__ */ _interopDefaultLegacy(require$$2);
var require$$0__default$2 = /* @__PURE__ */ _interopDefaultLegacy(require$$0$2);
var require$$0__default = /* @__PURE__ */ _interopDefaultLegacy(require$$0);
var require$$0__default$1 = /* @__PURE__ */ _interopDefaultLegacy(require$$0$1);
var require$$4__default = /* @__PURE__ */ _interopDefaultLegacy(require$$4);
var require$$5__default = /* @__PURE__ */ _interopDefaultLegacy(require$$5);
var require$$0__default$3 = /* @__PURE__ */ _interopDefaultLegacy(require$$0$3);
var require$$0__default$4 = /* @__PURE__ */ _interopDefaultLegacy(require$$0$4);
var require$$1__default$2 = /* @__PURE__ */ _interopDefaultLegacy(require$$1$2);
var require$$4__default$1 = /* @__PURE__ */ _interopDefaultLegacy(require$$4$1);
var require$$1__default$3 = /* @__PURE__ */ _interopDefaultLegacy(require$$1$3);
var require$$1__default$4 = /* @__PURE__ */ _interopDefaultLegacy(require$$1$4);
var require$$2__default$1 = /* @__PURE__ */ _interopDefaultLegacy(require$$2$1);
var require$$3__default = /* @__PURE__ */ _interopDefaultLegacy(require$$3$1);
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
class NonError extends Error {
  constructor(message) {
    super(NonError._prepareSuperMessage(message));
    Object.defineProperty(this, "name", {
      value: "NonError",
      configurable: true,
      writable: true
    });
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, NonError);
    }
  }
  static _prepareSuperMessage(message) {
    try {
      return JSON.stringify(message);
    } catch {
      return String(message);
    }
  }
}
const commonProperties = [
  { property: "name", enumerable: false },
  { property: "message", enumerable: false },
  { property: "stack", enumerable: false },
  { property: "code", enumerable: true }
];
const isCalled = Symbol(".toJSON called");
const toJSON = (from) => {
  from[isCalled] = true;
  const json2 = from.toJSON();
  delete from[isCalled];
  return json2;
};
const destroyCircular = ({
  from,
  seen,
  to_,
  forceEnumerable,
  maxDepth,
  depth
}) => {
  const to = to_ || (Array.isArray(from) ? [] : {});
  seen.push(from);
  if (depth >= maxDepth) {
    return to;
  }
  if (typeof from.toJSON === "function" && from[isCalled] !== true) {
    return toJSON(from);
  }
  for (const [key, value] of Object.entries(from)) {
    if (typeof Buffer === "function" && Buffer.isBuffer(value)) {
      to[key] = "[object Buffer]";
      continue;
    }
    if (typeof value === "function") {
      continue;
    }
    if (!value || typeof value !== "object") {
      to[key] = value;
      continue;
    }
    if (!seen.includes(from[key])) {
      depth++;
      to[key] = destroyCircular({
        from: from[key],
        seen: seen.slice(),
        forceEnumerable,
        maxDepth,
        depth
      });
      continue;
    }
    to[key] = "[Circular]";
  }
  for (const { property, enumerable } of commonProperties) {
    if (typeof from[property] === "string") {
      Object.defineProperty(to, property, {
        value: from[property],
        enumerable: forceEnumerable ? true : enumerable,
        configurable: true,
        writable: true
      });
    }
  }
  return to;
};
const serializeError$2 = (value, options = {}) => {
  const { maxDepth = Number.POSITIVE_INFINITY } = options;
  if (typeof value === "object" && value !== null) {
    return destroyCircular({
      from: value,
      seen: [],
      forceEnumerable: true,
      maxDepth,
      depth: 0
    });
  }
  if (typeof value === "function") {
    return `[Function: ${value.name || "anonymous"}]`;
  }
  return value;
};
const deserializeError$2 = (value, options = {}) => {
  const { maxDepth = Number.POSITIVE_INFINITY } = options;
  if (value instanceof Error) {
    return value;
  }
  if (typeof value === "object" && value !== null && !Array.isArray(value)) {
    const newError = new Error();
    destroyCircular({
      from: value,
      seen: [],
      to_: newError,
      maxDepth,
      depth: 0
    });
    return newError;
  }
  return new NonError(value);
};
var serializeError_1 = {
  serializeError: serializeError$2,
  deserializeError: deserializeError$2
};
var util$6 = {};
const getUniqueId = () => `${Date.now()}-${Math.random()}`;
const getSendChannel = (channel) => `%better-ipc-send-channel-${channel}`;
const getRendererSendChannel = (channel) => `%better-ipc-send-channel-${channel}`;
util$6.currentWindowChannel = "%better-ipc-current-window";
util$6.getSendChannel = getSendChannel;
util$6.getRendererSendChannel = getRendererSendChannel;
util$6.getResponseChannels = (channel) => {
  const id2 = getUniqueId();
  return {
    sendChannel: getSendChannel(channel),
    dataChannel: `%better-ipc-response-data-channel-${channel}-${id2}`,
    errorChannel: `%better-ipc-response-error-channel-${channel}-${id2}`
  };
};
util$6.getRendererResponseChannels = (channel) => {
  const id2 = getUniqueId();
  return {
    sendChannel: getRendererSendChannel(channel),
    dataChannel: `%better-ipc-response-data-channel-${channel}-${id2}`,
    errorChannel: `%better-ipc-response-error-channel-${channel}-${id2}`
  };
};
const electron$1 = require$$1__default["default"];
const { serializeError: serializeError$1, deserializeError: deserializeError$1 } = serializeError_1;
const util$5 = util$6;
const { ipcRenderer: ipcRenderer$1 } = electron$1;
const ipc$1 = Object.create(ipcRenderer$1 || {});
ipc$1.callMain = (channel, data) => new Promise((resolve2, reject) => {
  const { sendChannel, dataChannel, errorChannel } = util$5.getResponseChannels(channel);
  const cleanup = () => {
    ipcRenderer$1.off(dataChannel, onData);
    ipcRenderer$1.off(errorChannel, onError);
  };
  const onData = (_event, result) => {
    cleanup();
    resolve2(result);
  };
  const onError = (_event, error2) => {
    cleanup();
    reject(deserializeError$1(error2));
  };
  ipcRenderer$1.once(dataChannel, onData);
  ipcRenderer$1.once(errorChannel, onError);
  const completeData = {
    dataChannel,
    errorChannel,
    userData: data
  };
  ipcRenderer$1.send(sendChannel, completeData);
});
ipc$1.answerMain = (channel, callback) => {
  const sendChannel = util$5.getRendererSendChannel(channel);
  const listener = async (_event, data) => {
    const { dataChannel, errorChannel, userData } = data;
    try {
      ipcRenderer$1.send(dataChannel, await callback(userData));
    } catch (error2) {
      ipcRenderer$1.send(errorChannel, serializeError$1(error2));
    }
  };
  ipcRenderer$1.on(sendChannel, listener);
  return () => {
    ipcRenderer$1.off(sendChannel, listener);
  };
};
const electron = require$$1__default["default"];
const { serializeError, deserializeError } = serializeError_1;
const util$4 = util$6;
const { ipcMain: ipcMain$2, BrowserWindow } = electron;
const ipc = Object.create(ipcMain$2 || {});
ipc.callRenderer = (browserWindow, channel, data) => new Promise((resolve2, reject) => {
  if (!browserWindow) {
    throw new Error("Browser window required");
  }
  const { sendChannel, dataChannel, errorChannel } = util$4.getRendererResponseChannels(channel);
  const cleanup = () => {
    ipcMain$2.off(dataChannel, onData);
    ipcMain$2.off(errorChannel, onError);
  };
  const onData = (event, result) => {
    const window2 = BrowserWindow.fromWebContents(event.sender);
    if (window2.id === browserWindow.id) {
      cleanup();
      resolve2(result);
    }
  };
  const onError = (event, error2) => {
    const window2 = BrowserWindow.fromWebContents(event.sender);
    if (window2.id === browserWindow.id) {
      cleanup();
      reject(deserializeError(error2));
    }
  };
  ipcMain$2.on(dataChannel, onData);
  ipcMain$2.on(errorChannel, onError);
  const completeData = {
    dataChannel,
    errorChannel,
    userData: data
  };
  if (browserWindow.webContents) {
    browserWindow.webContents.send(sendChannel, completeData);
  }
});
ipc.callFocusedRenderer = async (...args) => {
  const focusedWindow = BrowserWindow.getFocusedWindow();
  if (!focusedWindow) {
    throw new Error("No browser window in focus");
  }
  return ipc.callRenderer(focusedWindow, ...args);
};
ipc.answerRenderer = (browserWindowOrChannel, channelOrCallback, callbackOrNothing) => {
  let window2;
  let channel;
  let callback;
  if (callbackOrNothing === void 0) {
    channel = browserWindowOrChannel;
    callback = channelOrCallback;
  } else {
    window2 = browserWindowOrChannel;
    channel = channelOrCallback;
    callback = callbackOrNothing;
    if (!window2) {
      throw new Error("Browser window required");
    }
  }
  const sendChannel = util$4.getSendChannel(channel);
  const listener = async (event, data) => {
    const browserWindow = BrowserWindow.fromWebContents(event.sender);
    if (window2 && window2.id !== browserWindow.id) {
      return;
    }
    const send = (channel2, data2) => {
      if (!(browserWindow && browserWindow.isDestroyed())) {
        event.sender.send(channel2, data2);
      }
    };
    const { dataChannel, errorChannel, userData } = data;
    try {
      send(dataChannel, await callback(userData, browserWindow));
    } catch (error2) {
      send(errorChannel, serializeError(error2));
    }
  };
  ipcMain$2.on(sendChannel, listener);
  return () => {
    ipcMain$2.off(sendChannel, listener);
  };
};
ipc.sendToRenderers = (channel, data) => {
  for (const browserWindow of BrowserWindow.getAllWindows()) {
    if (browserWindow.webContents) {
      browserWindow.webContents.send(channel, data);
    }
  }
};
var main$2 = ipc;
var ipcMain$1;
if (process.type === "renderer")
  ;
else {
  ipcMain$1 = main$2;
}
var fs$m = {};
var universalify$1 = {};
universalify$1.fromCallback = function(fn) {
  return Object.defineProperty(function(...args) {
    if (typeof args[args.length - 1] === "function")
      fn.apply(this, args);
    else {
      return new Promise((resolve2, reject) => {
        fn.call(this, ...args, (err, res) => err != null ? reject(err) : resolve2(res));
      });
    }
  }, "name", { value: fn.name });
};
universalify$1.fromPromise = function(fn) {
  return Object.defineProperty(function(...args) {
    const cb = args[args.length - 1];
    if (typeof cb !== "function")
      return fn.apply(this, args);
    else
      fn.apply(this, args.slice(0, -1)).then((r) => cb(null, r), cb);
  }, "name", { value: fn.name });
};
var constants$1 = require$$0__default["default"];
var origCwd = process.cwd;
var cwd = null;
var platform = process.platform;
process.cwd = function() {
  if (!cwd)
    cwd = origCwd.call(process);
  return cwd;
};
try {
  process.cwd();
} catch (er) {
}
if (typeof process.chdir === "function") {
  var chdir = process.chdir;
  process.chdir = function(d2) {
    cwd = null;
    chdir.call(process, d2);
  };
  if (Object.setPrototypeOf)
    Object.setPrototypeOf(process.chdir, chdir);
}
var polyfills$1 = patch$2;
function patch$2(fs2) {
  if (constants$1.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
    patchLchmod(fs2);
  }
  if (!fs2.lutimes) {
    patchLutimes(fs2);
  }
  fs2.chown = chownFix(fs2.chown);
  fs2.fchown = chownFix(fs2.fchown);
  fs2.lchown = chownFix(fs2.lchown);
  fs2.chmod = chmodFix(fs2.chmod);
  fs2.fchmod = chmodFix(fs2.fchmod);
  fs2.lchmod = chmodFix(fs2.lchmod);
  fs2.chownSync = chownFixSync(fs2.chownSync);
  fs2.fchownSync = chownFixSync(fs2.fchownSync);
  fs2.lchownSync = chownFixSync(fs2.lchownSync);
  fs2.chmodSync = chmodFixSync(fs2.chmodSync);
  fs2.fchmodSync = chmodFixSync(fs2.fchmodSync);
  fs2.lchmodSync = chmodFixSync(fs2.lchmodSync);
  fs2.stat = statFix(fs2.stat);
  fs2.fstat = statFix(fs2.fstat);
  fs2.lstat = statFix(fs2.lstat);
  fs2.statSync = statFixSync(fs2.statSync);
  fs2.fstatSync = statFixSync(fs2.fstatSync);
  fs2.lstatSync = statFixSync(fs2.lstatSync);
  if (!fs2.lchmod) {
    fs2.lchmod = function(path2, mode, cb) {
      if (cb)
        process.nextTick(cb);
    };
    fs2.lchmodSync = function() {
    };
  }
  if (!fs2.lchown) {
    fs2.lchown = function(path2, uid, gid, cb) {
      if (cb)
        process.nextTick(cb);
    };
    fs2.lchownSync = function() {
    };
  }
  if (platform === "win32") {
    fs2.rename = function(fs$rename) {
      return function(from, to, cb) {
        var start = Date.now();
        var backoff = 0;
        fs$rename(from, to, function CB(er) {
          if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
            setTimeout(function() {
              fs2.stat(to, function(stater, st) {
                if (stater && stater.code === "ENOENT")
                  fs$rename(from, to, CB);
                else
                  cb(er);
              });
            }, backoff);
            if (backoff < 100)
              backoff += 10;
            return;
          }
          if (cb)
            cb(er);
        });
      };
    }(fs2.rename);
  }
  fs2.read = function(fs$read) {
    function read(fd, buffer, offset, length, position, callback_) {
      var callback;
      if (callback_ && typeof callback_ === "function") {
        var eagCounter = 0;
        callback = function(er, _, __) {
          if (er && er.code === "EAGAIN" && eagCounter < 10) {
            eagCounter++;
            return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
          }
          callback_.apply(this, arguments);
        };
      }
      return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
    }
    if (Object.setPrototypeOf)
      Object.setPrototypeOf(read, fs$read);
    return read;
  }(fs2.read);
  fs2.readSync = function(fs$readSync) {
    return function(fd, buffer, offset, length, position) {
      var eagCounter = 0;
      while (true) {
        try {
          return fs$readSync.call(fs2, fd, buffer, offset, length, position);
        } catch (er) {
          if (er.code === "EAGAIN" && eagCounter < 10) {
            eagCounter++;
            continue;
          }
          throw er;
        }
      }
    };
  }(fs2.readSync);
  function patchLchmod(fs3) {
    fs3.lchmod = function(path2, mode, callback) {
      fs3.open(path2, constants$1.O_WRONLY | constants$1.O_SYMLINK, mode, function(err, fd) {
        if (err) {
          if (callback)
            callback(err);
          return;
        }
        fs3.fchmod(fd, mode, function(err2) {
          fs3.close(fd, function(err22) {
            if (callback)
              callback(err2 || err22);
          });
        });
      });
    };
    fs3.lchmodSync = function(path2, mode) {
      var fd = fs3.openSync(path2, constants$1.O_WRONLY | constants$1.O_SYMLINK, mode);
      var threw = true;
      var ret;
      try {
        ret = fs3.fchmodSync(fd, mode);
        threw = false;
      } finally {
        if (threw) {
          try {
            fs3.closeSync(fd);
          } catch (er) {
          }
        } else {
          fs3.closeSync(fd);
        }
      }
      return ret;
    };
  }
  function patchLutimes(fs3) {
    if (constants$1.hasOwnProperty("O_SYMLINK")) {
      fs3.lutimes = function(path2, at, mt, cb) {
        fs3.open(path2, constants$1.O_SYMLINK, function(er, fd) {
          if (er) {
            if (cb)
              cb(er);
            return;
          }
          fs3.futimes(fd, at, mt, function(er2) {
            fs3.close(fd, function(er22) {
              if (cb)
                cb(er2 || er22);
            });
          });
        });
      };
      fs3.lutimesSync = function(path2, at, mt) {
        var fd = fs3.openSync(path2, constants$1.O_SYMLINK);
        var ret;
        var threw = true;
        try {
          ret = fs3.futimesSync(fd, at, mt);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs3.closeSync(fd);
            } catch (er) {
            }
          } else {
            fs3.closeSync(fd);
          }
        }
        return ret;
      };
    } else {
      fs3.lutimes = function(_a, _b, _c, cb) {
        if (cb)
          process.nextTick(cb);
      };
      fs3.lutimesSync = function() {
      };
    }
  }
  function chmodFix(orig) {
    if (!orig)
      return orig;
    return function(target, mode, cb) {
      return orig.call(fs2, target, mode, function(er) {
        if (chownErOk(er))
          er = null;
        if (cb)
          cb.apply(this, arguments);
      });
    };
  }
  function chmodFixSync(orig) {
    if (!orig)
      return orig;
    return function(target, mode) {
      try {
        return orig.call(fs2, target, mode);
      } catch (er) {
        if (!chownErOk(er))
          throw er;
      }
    };
  }
  function chownFix(orig) {
    if (!orig)
      return orig;
    return function(target, uid, gid, cb) {
      return orig.call(fs2, target, uid, gid, function(er) {
        if (chownErOk(er))
          er = null;
        if (cb)
          cb.apply(this, arguments);
      });
    };
  }
  function chownFixSync(orig) {
    if (!orig)
      return orig;
    return function(target, uid, gid) {
      try {
        return orig.call(fs2, target, uid, gid);
      } catch (er) {
        if (!chownErOk(er))
          throw er;
      }
    };
  }
  function statFix(orig) {
    if (!orig)
      return orig;
    return function(target, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      function callback(er, stats) {
        if (stats) {
          if (stats.uid < 0)
            stats.uid += 4294967296;
          if (stats.gid < 0)
            stats.gid += 4294967296;
        }
        if (cb)
          cb.apply(this, arguments);
      }
      return options ? orig.call(fs2, target, options, callback) : orig.call(fs2, target, callback);
    };
  }
  function statFixSync(orig) {
    if (!orig)
      return orig;
    return function(target, options) {
      var stats = options ? orig.call(fs2, target, options) : orig.call(fs2, target);
      if (stats.uid < 0)
        stats.uid += 4294967296;
      if (stats.gid < 0)
        stats.gid += 4294967296;
      return stats;
    };
  }
  function chownErOk(er) {
    if (!er)
      return true;
    if (er.code === "ENOSYS")
      return true;
    var nonroot = !process.getuid || process.getuid() !== 0;
    if (nonroot) {
      if (er.code === "EINVAL" || er.code === "EPERM")
        return true;
    }
    return false;
  }
}
var Stream = require$$0__default$1["default"].Stream;
var legacyStreams = legacy$1;
function legacy$1(fs2) {
  return {
    ReadStream,
    WriteStream
  };
  function ReadStream(path2, options) {
    if (!(this instanceof ReadStream))
      return new ReadStream(path2, options);
    Stream.call(this);
    var self2 = this;
    this.path = path2;
    this.fd = null;
    this.readable = true;
    this.paused = false;
    this.flags = "r";
    this.mode = 438;
    this.bufferSize = 64 * 1024;
    options = options || {};
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }
    if (this.encoding)
      this.setEncoding(this.encoding);
    if (this.start !== void 0) {
      if (typeof this.start !== "number") {
        throw TypeError("start must be a Number");
      }
      if (this.end === void 0) {
        this.end = Infinity;
      } else if (typeof this.end !== "number") {
        throw TypeError("end must be a Number");
      }
      if (this.start > this.end) {
        throw new Error("start must be <= end");
      }
      this.pos = this.start;
    }
    if (this.fd !== null) {
      process.nextTick(function() {
        self2._read();
      });
      return;
    }
    fs2.open(this.path, this.flags, this.mode, function(err, fd) {
      if (err) {
        self2.emit("error", err);
        self2.readable = false;
        return;
      }
      self2.fd = fd;
      self2.emit("open", fd);
      self2._read();
    });
  }
  function WriteStream(path2, options) {
    if (!(this instanceof WriteStream))
      return new WriteStream(path2, options);
    Stream.call(this);
    this.path = path2;
    this.fd = null;
    this.writable = true;
    this.flags = "w";
    this.encoding = "binary";
    this.mode = 438;
    this.bytesWritten = 0;
    options = options || {};
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }
    if (this.start !== void 0) {
      if (typeof this.start !== "number") {
        throw TypeError("start must be a Number");
      }
      if (this.start < 0) {
        throw new Error("start must be >= zero");
      }
      this.pos = this.start;
    }
    this.busy = false;
    this._queue = [];
    if (this.fd === null) {
      this._open = fs2.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
      this.flush();
    }
  }
}
var clone_1 = clone$1;
var getPrototypeOf = Object.getPrototypeOf || function(obj) {
  return obj.__proto__;
};
function clone$1(obj) {
  if (obj === null || typeof obj !== "object")
    return obj;
  if (obj instanceof Object)
    var copy2 = { __proto__: getPrototypeOf(obj) };
  else
    var copy2 = Object.create(null);
  Object.getOwnPropertyNames(obj).forEach(function(key) {
    Object.defineProperty(copy2, key, Object.getOwnPropertyDescriptor(obj, key));
  });
  return copy2;
}
var fs$l = require$$0__default$2["default"];
var polyfills = polyfills$1;
var legacy = legacyStreams;
var clone = clone_1;
var util$3 = require$$4__default["default"];
var gracefulQueue;
var previousSymbol;
if (typeof Symbol === "function" && typeof Symbol.for === "function") {
  gracefulQueue = Symbol.for("graceful-fs.queue");
  previousSymbol = Symbol.for("graceful-fs.previous");
} else {
  gracefulQueue = "___graceful-fs.queue";
  previousSymbol = "___graceful-fs.previous";
}
function noop() {
}
function publishQueue(context, queue2) {
  Object.defineProperty(context, gracefulQueue, {
    get: function() {
      return queue2;
    }
  });
}
var debug$5 = noop;
if (util$3.debuglog)
  debug$5 = util$3.debuglog("gfs4");
else if (/\bgfs4\b/i.test(""))
  debug$5 = function() {
    var m2 = util$3.format.apply(util$3, arguments);
    m2 = "GFS4: " + m2.split(/\n/).join("\nGFS4: ");
    console.error(m2);
  };
if (!fs$l[gracefulQueue]) {
  var queue = commonjsGlobal[gracefulQueue] || [];
  publishQueue(fs$l, queue);
  fs$l.close = function(fs$close) {
    function close(fd, cb) {
      return fs$close.call(fs$l, fd, function(err) {
        if (!err) {
          resetQueue();
        }
        if (typeof cb === "function")
          cb.apply(this, arguments);
      });
    }
    Object.defineProperty(close, previousSymbol, {
      value: fs$close
    });
    return close;
  }(fs$l.close);
  fs$l.closeSync = function(fs$closeSync) {
    function closeSync(fd) {
      fs$closeSync.apply(fs$l, arguments);
      resetQueue();
    }
    Object.defineProperty(closeSync, previousSymbol, {
      value: fs$closeSync
    });
    return closeSync;
  }(fs$l.closeSync);
  if (/\bgfs4\b/i.test("")) {
    process.on("exit", function() {
      debug$5(fs$l[gracefulQueue]);
      require$$5__default["default"].equal(fs$l[gracefulQueue].length, 0);
    });
  }
}
if (!commonjsGlobal[gracefulQueue]) {
  publishQueue(commonjsGlobal, fs$l[gracefulQueue]);
}
var gracefulFs = patch$1(clone(fs$l));
function patch$1(fs2) {
  polyfills(fs2);
  fs2.gracefulify = patch$1;
  fs2.createReadStream = createReadStream;
  fs2.createWriteStream = createWriteStream;
  var fs$readFile = fs2.readFile;
  fs2.readFile = readFile2;
  function readFile2(path2, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$readFile(path2, options, cb);
    function go$readFile(path3, options2, cb2, startTime) {
      return fs$readFile(path3, options2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$readFile, [path3, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$writeFile = fs2.writeFile;
  fs2.writeFile = writeFile2;
  function writeFile2(path2, data, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$writeFile(path2, data, options, cb);
    function go$writeFile(path3, data2, options2, cb2, startTime) {
      return fs$writeFile(path3, data2, options2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$writeFile, [path3, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$appendFile = fs2.appendFile;
  if (fs$appendFile)
    fs2.appendFile = appendFile;
  function appendFile(path2, data, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$appendFile(path2, data, options, cb);
    function go$appendFile(path3, data2, options2, cb2, startTime) {
      return fs$appendFile(path3, data2, options2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$appendFile, [path3, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$copyFile = fs2.copyFile;
  if (fs$copyFile)
    fs2.copyFile = copyFile2;
  function copyFile2(src, dest, flags, cb) {
    if (typeof flags === "function") {
      cb = flags;
      flags = 0;
    }
    return go$copyFile(src, dest, flags, cb);
    function go$copyFile(src2, dest2, flags2, cb2, startTime) {
      return fs$copyFile(src2, dest2, flags2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$readdir = fs2.readdir;
  fs2.readdir = readdir;
  function readdir(path2, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$readdir(path2, options, cb);
    function go$readdir(path3, options2, cb2, startTime) {
      return fs$readdir(path3, options2, function(err, files) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$readdir, [path3, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (files && files.sort)
            files.sort();
          if (typeof cb2 === "function")
            cb2.call(this, err, files);
        }
      });
    }
  }
  if (process.version.substr(0, 4) === "v0.8") {
    var legStreams = legacy(fs2);
    ReadStream = legStreams.ReadStream;
    WriteStream = legStreams.WriteStream;
  }
  var fs$ReadStream = fs2.ReadStream;
  if (fs$ReadStream) {
    ReadStream.prototype = Object.create(fs$ReadStream.prototype);
    ReadStream.prototype.open = ReadStream$open;
  }
  var fs$WriteStream = fs2.WriteStream;
  if (fs$WriteStream) {
    WriteStream.prototype = Object.create(fs$WriteStream.prototype);
    WriteStream.prototype.open = WriteStream$open;
  }
  Object.defineProperty(fs2, "ReadStream", {
    get: function() {
      return ReadStream;
    },
    set: function(val) {
      ReadStream = val;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(fs2, "WriteStream", {
    get: function() {
      return WriteStream;
    },
    set: function(val) {
      WriteStream = val;
    },
    enumerable: true,
    configurable: true
  });
  var FileReadStream = ReadStream;
  Object.defineProperty(fs2, "FileReadStream", {
    get: function() {
      return FileReadStream;
    },
    set: function(val) {
      FileReadStream = val;
    },
    enumerable: true,
    configurable: true
  });
  var FileWriteStream = WriteStream;
  Object.defineProperty(fs2, "FileWriteStream", {
    get: function() {
      return FileWriteStream;
    },
    set: function(val) {
      FileWriteStream = val;
    },
    enumerable: true,
    configurable: true
  });
  function ReadStream(path2, options) {
    if (this instanceof ReadStream)
      return fs$ReadStream.apply(this, arguments), this;
    else
      return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
  }
  function ReadStream$open() {
    var that = this;
    open(that.path, that.flags, that.mode, function(err, fd) {
      if (err) {
        if (that.autoClose)
          that.destroy();
        that.emit("error", err);
      } else {
        that.fd = fd;
        that.emit("open", fd);
        that.read();
      }
    });
  }
  function WriteStream(path2, options) {
    if (this instanceof WriteStream)
      return fs$WriteStream.apply(this, arguments), this;
    else
      return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
  }
  function WriteStream$open() {
    var that = this;
    open(that.path, that.flags, that.mode, function(err, fd) {
      if (err) {
        that.destroy();
        that.emit("error", err);
      } else {
        that.fd = fd;
        that.emit("open", fd);
      }
    });
  }
  function createReadStream(path2, options) {
    return new fs2.ReadStream(path2, options);
  }
  function createWriteStream(path2, options) {
    return new fs2.WriteStream(path2, options);
  }
  var fs$open = fs2.open;
  fs2.open = open;
  function open(path2, flags, mode, cb) {
    if (typeof mode === "function")
      cb = mode, mode = null;
    return go$open(path2, flags, mode, cb);
    function go$open(path3, flags2, mode2, cb2, startTime) {
      return fs$open(path3, flags2, mode2, function(err, fd) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$open, [path3, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  return fs2;
}
function enqueue(elem) {
  debug$5("ENQUEUE", elem[0].name, elem[1]);
  fs$l[gracefulQueue].push(elem);
  retry();
}
var retryTimer;
function resetQueue() {
  var now = Date.now();
  for (var i2 = 0; i2 < fs$l[gracefulQueue].length; ++i2) {
    if (fs$l[gracefulQueue][i2].length > 2) {
      fs$l[gracefulQueue][i2][3] = now;
      fs$l[gracefulQueue][i2][4] = now;
    }
  }
  retry();
}
function retry() {
  clearTimeout(retryTimer);
  retryTimer = void 0;
  if (fs$l[gracefulQueue].length === 0)
    return;
  var elem = fs$l[gracefulQueue].shift();
  var fn = elem[0];
  var args = elem[1];
  var err = elem[2];
  var startTime = elem[3];
  var lastTime = elem[4];
  if (startTime === void 0) {
    debug$5("RETRY", fn.name, args);
    fn.apply(null, args);
  } else if (Date.now() - startTime >= 6e4) {
    debug$5("TIMEOUT", fn.name, args);
    var cb = args.pop();
    if (typeof cb === "function")
      cb.call(null, err);
  } else {
    var sinceAttempt = Date.now() - lastTime;
    var sinceStart = Math.max(lastTime - startTime, 1);
    var desiredDelay = Math.min(sinceStart * 1.2, 100);
    if (sinceAttempt >= desiredDelay) {
      debug$5("RETRY", fn.name, args);
      fn.apply(null, args.concat([startTime]));
    } else {
      fs$l[gracefulQueue].push(elem);
    }
  }
  if (retryTimer === void 0) {
    retryTimer = setTimeout(retry, 0);
  }
}
(function(exports) {
  const u2 = universalify$1.fromCallback;
  const fs2 = gracefulFs;
  const api = [
    "access",
    "appendFile",
    "chmod",
    "chown",
    "close",
    "copyFile",
    "fchmod",
    "fchown",
    "fdatasync",
    "fstat",
    "fsync",
    "ftruncate",
    "futimes",
    "lchmod",
    "lchown",
    "link",
    "lstat",
    "mkdir",
    "mkdtemp",
    "open",
    "opendir",
    "readdir",
    "readFile",
    "readlink",
    "realpath",
    "rename",
    "rm",
    "rmdir",
    "stat",
    "symlink",
    "truncate",
    "unlink",
    "utimes",
    "writeFile"
  ].filter((key) => {
    return typeof fs2[key] === "function";
  });
  Object.assign(exports, fs2);
  api.forEach((method) => {
    exports[method] = u2(fs2[method]);
  });
  exports.realpath.native = u2(fs2.realpath.native);
  exports.exists = function(filename, callback) {
    if (typeof callback === "function") {
      return fs2.exists(filename, callback);
    }
    return new Promise((resolve2) => {
      return fs2.exists(filename, resolve2);
    });
  };
  exports.read = function(fd, buffer, offset, length, position, callback) {
    if (typeof callback === "function") {
      return fs2.read(fd, buffer, offset, length, position, callback);
    }
    return new Promise((resolve2, reject) => {
      fs2.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
        if (err)
          return reject(err);
        resolve2({ bytesRead, buffer: buffer2 });
      });
    });
  };
  exports.write = function(fd, buffer, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs2.write(fd, buffer, ...args);
    }
    return new Promise((resolve2, reject) => {
      fs2.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
        if (err)
          return reject(err);
        resolve2({ bytesWritten, buffer: buffer2 });
      });
    });
  };
  if (typeof fs2.writev === "function") {
    exports.writev = function(fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs2.writev(fd, buffers, ...args);
      }
      return new Promise((resolve2, reject) => {
        fs2.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
          if (err)
            return reject(err);
          resolve2({ bytesWritten, buffers: buffers2 });
        });
      });
    };
  }
})(fs$m);
var makeDir$1 = {};
var utils$1 = {};
const path$q = require$$1__default$1["default"];
utils$1.checkPath = function checkPath2(pth) {
  if (process.platform === "win32") {
    const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path$q.parse(pth).root, ""));
    if (pathHasInvalidWinCharacters) {
      const error2 = new Error(`Path contains invalid characters: ${pth}`);
      error2.code = "EINVAL";
      throw error2;
    }
  }
};
const fs$k = fs$m;
const { checkPath } = utils$1;
const getMode = (options) => {
  const defaults2 = { mode: 511 };
  if (typeof options === "number")
    return options;
  return __spreadValues(__spreadValues({}, defaults2), options).mode;
};
makeDir$1.makeDir = async (dir, options) => {
  checkPath(dir);
  return fs$k.mkdir(dir, {
    mode: getMode(options),
    recursive: true
  });
};
makeDir$1.makeDirSync = (dir, options) => {
  checkPath(dir);
  return fs$k.mkdirSync(dir, {
    mode: getMode(options),
    recursive: true
  });
};
const u$a = universalify$1.fromPromise;
const { makeDir: _makeDir, makeDirSync } = makeDir$1;
const makeDir = u$a(_makeDir);
var mkdirs$2 = {
  mkdirs: makeDir,
  mkdirsSync: makeDirSync,
  mkdirp: makeDir,
  mkdirpSync: makeDirSync,
  ensureDir: makeDir,
  ensureDirSync: makeDirSync
};
const fs$j = gracefulFs;
function utimesMillis$1(path2, atime, mtime, callback) {
  fs$j.open(path2, "r+", (err, fd) => {
    if (err)
      return callback(err);
    fs$j.futimes(fd, atime, mtime, (futimesErr) => {
      fs$j.close(fd, (closeErr) => {
        if (callback)
          callback(futimesErr || closeErr);
      });
    });
  });
}
function utimesMillisSync$1(path2, atime, mtime) {
  const fd = fs$j.openSync(path2, "r+");
  fs$j.futimesSync(fd, atime, mtime);
  return fs$j.closeSync(fd);
}
var utimes = {
  utimesMillis: utimesMillis$1,
  utimesMillisSync: utimesMillisSync$1
};
const fs$i = fs$m;
const path$p = require$$1__default$1["default"];
const util$2 = require$$4__default["default"];
function getStats$2(src, dest, opts2) {
  const statFunc = opts2.dereference ? (file2) => fs$i.stat(file2, { bigint: true }) : (file2) => fs$i.lstat(file2, { bigint: true });
  return Promise.all([
    statFunc(src),
    statFunc(dest).catch((err) => {
      if (err.code === "ENOENT")
        return null;
      throw err;
    })
  ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
}
function getStatsSync(src, dest, opts2) {
  let destStat;
  const statFunc = opts2.dereference ? (file2) => fs$i.statSync(file2, { bigint: true }) : (file2) => fs$i.lstatSync(file2, { bigint: true });
  const srcStat = statFunc(src);
  try {
    destStat = statFunc(dest);
  } catch (err) {
    if (err.code === "ENOENT")
      return { srcStat, destStat: null };
    throw err;
  }
  return { srcStat, destStat };
}
function checkPaths(src, dest, funcName, opts2, cb) {
  util$2.callbackify(getStats$2)(src, dest, opts2, (err, stats) => {
    if (err)
      return cb(err);
    const { srcStat, destStat } = stats;
    if (destStat) {
      if (areIdentical$2(srcStat, destStat)) {
        const srcBaseName = path$p.basename(src);
        const destBaseName = path$p.basename(dest);
        if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
          return cb(null, { srcStat, destStat, isChangingCase: true });
        }
        return cb(new Error("Source and destination must not be the same."));
      }
      if (srcStat.isDirectory() && !destStat.isDirectory()) {
        return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
      }
      if (!srcStat.isDirectory() && destStat.isDirectory()) {
        return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`));
      }
    }
    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
      return cb(new Error(errMsg(src, dest, funcName)));
    }
    return cb(null, { srcStat, destStat });
  });
}
function checkPathsSync(src, dest, funcName, opts2) {
  const { srcStat, destStat } = getStatsSync(src, dest, opts2);
  if (destStat) {
    if (areIdentical$2(srcStat, destStat)) {
      const srcBaseName = path$p.basename(src);
      const destBaseName = path$p.basename(dest);
      if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
        return { srcStat, destStat, isChangingCase: true };
      }
      throw new Error("Source and destination must not be the same.");
    }
    if (srcStat.isDirectory() && !destStat.isDirectory()) {
      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
    }
    if (!srcStat.isDirectory() && destStat.isDirectory()) {
      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
    }
  }
  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
    throw new Error(errMsg(src, dest, funcName));
  }
  return { srcStat, destStat };
}
function checkParentPaths(src, srcStat, dest, funcName, cb) {
  const srcParent = path$p.resolve(path$p.dirname(src));
  const destParent = path$p.resolve(path$p.dirname(dest));
  if (destParent === srcParent || destParent === path$p.parse(destParent).root)
    return cb();
  fs$i.stat(destParent, { bigint: true }, (err, destStat) => {
    if (err) {
      if (err.code === "ENOENT")
        return cb();
      return cb(err);
    }
    if (areIdentical$2(srcStat, destStat)) {
      return cb(new Error(errMsg(src, dest, funcName)));
    }
    return checkParentPaths(src, srcStat, destParent, funcName, cb);
  });
}
function checkParentPathsSync(src, srcStat, dest, funcName) {
  const srcParent = path$p.resolve(path$p.dirname(src));
  const destParent = path$p.resolve(path$p.dirname(dest));
  if (destParent === srcParent || destParent === path$p.parse(destParent).root)
    return;
  let destStat;
  try {
    destStat = fs$i.statSync(destParent, { bigint: true });
  } catch (err) {
    if (err.code === "ENOENT")
      return;
    throw err;
  }
  if (areIdentical$2(srcStat, destStat)) {
    throw new Error(errMsg(src, dest, funcName));
  }
  return checkParentPathsSync(src, srcStat, destParent, funcName);
}
function areIdentical$2(srcStat, destStat) {
  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
}
function isSrcSubdir(src, dest) {
  const srcArr = path$p.resolve(src).split(path$p.sep).filter((i2) => i2);
  const destArr = path$p.resolve(dest).split(path$p.sep).filter((i2) => i2);
  return srcArr.reduce((acc, cur, i2) => acc && destArr[i2] === cur, true);
}
function errMsg(src, dest, funcName) {
  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
}
var stat$4 = {
  checkPaths,
  checkPathsSync,
  checkParentPaths,
  checkParentPathsSync,
  isSrcSubdir,
  areIdentical: areIdentical$2
};
const fs$h = gracefulFs;
const path$o = require$$1__default$1["default"];
const mkdirsSync$1 = mkdirs$2.mkdirsSync;
const utimesMillisSync = utimes.utimesMillisSync;
const stat$3 = stat$4;
function copySync$2(src, dest, opts2) {
  if (typeof opts2 === "function") {
    opts2 = { filter: opts2 };
  }
  opts2 = opts2 || {};
  opts2.clobber = "clobber" in opts2 ? !!opts2.clobber : true;
  opts2.overwrite = "overwrite" in opts2 ? !!opts2.overwrite : opts2.clobber;
  if (opts2.preserveTimestamps && process.arch === "ia32") {
    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
  }
  const { srcStat, destStat } = stat$3.checkPathsSync(src, dest, "copy", opts2);
  stat$3.checkParentPathsSync(src, srcStat, dest, "copy");
  return handleFilterAndCopy(destStat, src, dest, opts2);
}
function handleFilterAndCopy(destStat, src, dest, opts2) {
  if (opts2.filter && !opts2.filter(src, dest))
    return;
  const destParent = path$o.dirname(dest);
  if (!fs$h.existsSync(destParent))
    mkdirsSync$1(destParent);
  return getStats$1(destStat, src, dest, opts2);
}
function startCopy$1(destStat, src, dest, opts2) {
  if (opts2.filter && !opts2.filter(src, dest))
    return;
  return getStats$1(destStat, src, dest, opts2);
}
function getStats$1(destStat, src, dest, opts2) {
  const statSync = opts2.dereference ? fs$h.statSync : fs$h.lstatSync;
  const srcStat = statSync(src);
  if (srcStat.isDirectory())
    return onDir$1(srcStat, destStat, src, dest, opts2);
  else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
    return onFile$1(srcStat, destStat, src, dest, opts2);
  else if (srcStat.isSymbolicLink())
    return onLink$1(destStat, src, dest, opts2);
  else if (srcStat.isSocket())
    throw new Error(`Cannot copy a socket file: ${src}`);
  else if (srcStat.isFIFO())
    throw new Error(`Cannot copy a FIFO pipe: ${src}`);
  throw new Error(`Unknown file: ${src}`);
}
function onFile$1(srcStat, destStat, src, dest, opts2) {
  if (!destStat)
    return copyFile$1(srcStat, src, dest, opts2);
  return mayCopyFile$1(srcStat, src, dest, opts2);
}
function mayCopyFile$1(srcStat, src, dest, opts2) {
  if (opts2.overwrite) {
    fs$h.unlinkSync(dest);
    return copyFile$1(srcStat, src, dest, opts2);
  } else if (opts2.errorOnExist) {
    throw new Error(`'${dest}' already exists`);
  }
}
function copyFile$1(srcStat, src, dest, opts2) {
  fs$h.copyFileSync(src, dest);
  if (opts2.preserveTimestamps)
    handleTimestamps(srcStat.mode, src, dest);
  return setDestMode$1(dest, srcStat.mode);
}
function handleTimestamps(srcMode, src, dest) {
  if (fileIsNotWritable$1(srcMode))
    makeFileWritable$1(dest, srcMode);
  return setDestTimestamps$1(src, dest);
}
function fileIsNotWritable$1(srcMode) {
  return (srcMode & 128) === 0;
}
function makeFileWritable$1(dest, srcMode) {
  return setDestMode$1(dest, srcMode | 128);
}
function setDestMode$1(dest, srcMode) {
  return fs$h.chmodSync(dest, srcMode);
}
function setDestTimestamps$1(src, dest) {
  const updatedSrcStat = fs$h.statSync(src);
  return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
}
function onDir$1(srcStat, destStat, src, dest, opts2) {
  if (!destStat)
    return mkDirAndCopy$1(srcStat.mode, src, dest, opts2);
  return copyDir$1(src, dest, opts2);
}
function mkDirAndCopy$1(srcMode, src, dest, opts2) {
  fs$h.mkdirSync(dest);
  copyDir$1(src, dest, opts2);
  return setDestMode$1(dest, srcMode);
}
function copyDir$1(src, dest, opts2) {
  fs$h.readdirSync(src).forEach((item) => copyDirItem$1(item, src, dest, opts2));
}
function copyDirItem$1(item, src, dest, opts2) {
  const srcItem = path$o.join(src, item);
  const destItem = path$o.join(dest, item);
  const { destStat } = stat$3.checkPathsSync(srcItem, destItem, "copy", opts2);
  return startCopy$1(destStat, srcItem, destItem, opts2);
}
function onLink$1(destStat, src, dest, opts2) {
  let resolvedSrc = fs$h.readlinkSync(src);
  if (opts2.dereference) {
    resolvedSrc = path$o.resolve(process.cwd(), resolvedSrc);
  }
  if (!destStat) {
    return fs$h.symlinkSync(resolvedSrc, dest);
  } else {
    let resolvedDest;
    try {
      resolvedDest = fs$h.readlinkSync(dest);
    } catch (err) {
      if (err.code === "EINVAL" || err.code === "UNKNOWN")
        return fs$h.symlinkSync(resolvedSrc, dest);
      throw err;
    }
    if (opts2.dereference) {
      resolvedDest = path$o.resolve(process.cwd(), resolvedDest);
    }
    if (stat$3.isSrcSubdir(resolvedSrc, resolvedDest)) {
      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
    }
    if (fs$h.statSync(dest).isDirectory() && stat$3.isSrcSubdir(resolvedDest, resolvedSrc)) {
      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
    }
    return copyLink$1(resolvedSrc, dest);
  }
}
function copyLink$1(resolvedSrc, dest) {
  fs$h.unlinkSync(dest);
  return fs$h.symlinkSync(resolvedSrc, dest);
}
var copySync_1 = copySync$2;
var copySync$1 = {
  copySync: copySync_1
};
const u$9 = universalify$1.fromPromise;
const fs$g = fs$m;
function pathExists$8(path2) {
  return fs$g.access(path2).then(() => true).catch(() => false);
}
var pathExists_1 = {
  pathExists: u$9(pathExists$8),
  pathExistsSync: fs$g.existsSync
};
const fs$f = gracefulFs;
const path$n = require$$1__default$1["default"];
const mkdirs$1 = mkdirs$2.mkdirs;
const pathExists$7 = pathExists_1.pathExists;
const utimesMillis = utimes.utimesMillis;
const stat$2 = stat$4;
function copy$2(src, dest, opts2, cb) {
  if (typeof opts2 === "function" && !cb) {
    cb = opts2;
    opts2 = {};
  } else if (typeof opts2 === "function") {
    opts2 = { filter: opts2 };
  }
  cb = cb || function() {
  };
  opts2 = opts2 || {};
  opts2.clobber = "clobber" in opts2 ? !!opts2.clobber : true;
  opts2.overwrite = "overwrite" in opts2 ? !!opts2.overwrite : opts2.clobber;
  if (opts2.preserveTimestamps && process.arch === "ia32") {
    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
  }
  stat$2.checkPaths(src, dest, "copy", opts2, (err, stats) => {
    if (err)
      return cb(err);
    const { srcStat, destStat } = stats;
    stat$2.checkParentPaths(src, srcStat, dest, "copy", (err2) => {
      if (err2)
        return cb(err2);
      if (opts2.filter)
        return handleFilter(checkParentDir, destStat, src, dest, opts2, cb);
      return checkParentDir(destStat, src, dest, opts2, cb);
    });
  });
}
function checkParentDir(destStat, src, dest, opts2, cb) {
  const destParent = path$n.dirname(dest);
  pathExists$7(destParent, (err, dirExists) => {
    if (err)
      return cb(err);
    if (dirExists)
      return getStats(destStat, src, dest, opts2, cb);
    mkdirs$1(destParent, (err2) => {
      if (err2)
        return cb(err2);
      return getStats(destStat, src, dest, opts2, cb);
    });
  });
}
function handleFilter(onInclude, destStat, src, dest, opts2, cb) {
  Promise.resolve(opts2.filter(src, dest)).then((include) => {
    if (include)
      return onInclude(destStat, src, dest, opts2, cb);
    return cb();
  }, (error2) => cb(error2));
}
function startCopy(destStat, src, dest, opts2, cb) {
  if (opts2.filter)
    return handleFilter(getStats, destStat, src, dest, opts2, cb);
  return getStats(destStat, src, dest, opts2, cb);
}
function getStats(destStat, src, dest, opts2, cb) {
  const stat2 = opts2.dereference ? fs$f.stat : fs$f.lstat;
  stat2(src, (err, srcStat) => {
    if (err)
      return cb(err);
    if (srcStat.isDirectory())
      return onDir(srcStat, destStat, src, dest, opts2, cb);
    else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
      return onFile(srcStat, destStat, src, dest, opts2, cb);
    else if (srcStat.isSymbolicLink())
      return onLink(destStat, src, dest, opts2, cb);
    else if (srcStat.isSocket())
      return cb(new Error(`Cannot copy a socket file: ${src}`));
    else if (srcStat.isFIFO())
      return cb(new Error(`Cannot copy a FIFO pipe: ${src}`));
    return cb(new Error(`Unknown file: ${src}`));
  });
}
function onFile(srcStat, destStat, src, dest, opts2, cb) {
  if (!destStat)
    return copyFile(srcStat, src, dest, opts2, cb);
  return mayCopyFile(srcStat, src, dest, opts2, cb);
}
function mayCopyFile(srcStat, src, dest, opts2, cb) {
  if (opts2.overwrite) {
    fs$f.unlink(dest, (err) => {
      if (err)
        return cb(err);
      return copyFile(srcStat, src, dest, opts2, cb);
    });
  } else if (opts2.errorOnExist) {
    return cb(new Error(`'${dest}' already exists`));
  } else
    return cb();
}
function copyFile(srcStat, src, dest, opts2, cb) {
  fs$f.copyFile(src, dest, (err) => {
    if (err)
      return cb(err);
    if (opts2.preserveTimestamps)
      return handleTimestampsAndMode(srcStat.mode, src, dest, cb);
    return setDestMode(dest, srcStat.mode, cb);
  });
}
function handleTimestampsAndMode(srcMode, src, dest, cb) {
  if (fileIsNotWritable(srcMode)) {
    return makeFileWritable(dest, srcMode, (err) => {
      if (err)
        return cb(err);
      return setDestTimestampsAndMode(srcMode, src, dest, cb);
    });
  }
  return setDestTimestampsAndMode(srcMode, src, dest, cb);
}
function fileIsNotWritable(srcMode) {
  return (srcMode & 128) === 0;
}
function makeFileWritable(dest, srcMode, cb) {
  return setDestMode(dest, srcMode | 128, cb);
}
function setDestTimestampsAndMode(srcMode, src, dest, cb) {
  setDestTimestamps(src, dest, (err) => {
    if (err)
      return cb(err);
    return setDestMode(dest, srcMode, cb);
  });
}
function setDestMode(dest, srcMode, cb) {
  return fs$f.chmod(dest, srcMode, cb);
}
function setDestTimestamps(src, dest, cb) {
  fs$f.stat(src, (err, updatedSrcStat) => {
    if (err)
      return cb(err);
    return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb);
  });
}
function onDir(srcStat, destStat, src, dest, opts2, cb) {
  if (!destStat)
    return mkDirAndCopy(srcStat.mode, src, dest, opts2, cb);
  return copyDir(src, dest, opts2, cb);
}
function mkDirAndCopy(srcMode, src, dest, opts2, cb) {
  fs$f.mkdir(dest, (err) => {
    if (err)
      return cb(err);
    copyDir(src, dest, opts2, (err2) => {
      if (err2)
        return cb(err2);
      return setDestMode(dest, srcMode, cb);
    });
  });
}
function copyDir(src, dest, opts2, cb) {
  fs$f.readdir(src, (err, items2) => {
    if (err)
      return cb(err);
    return copyDirItems(items2, src, dest, opts2, cb);
  });
}
function copyDirItems(items2, src, dest, opts2, cb) {
  const item = items2.pop();
  if (!item)
    return cb();
  return copyDirItem(items2, item, src, dest, opts2, cb);
}
function copyDirItem(items2, item, src, dest, opts2, cb) {
  const srcItem = path$n.join(src, item);
  const destItem = path$n.join(dest, item);
  stat$2.checkPaths(srcItem, destItem, "copy", opts2, (err, stats) => {
    if (err)
      return cb(err);
    const { destStat } = stats;
    startCopy(destStat, srcItem, destItem, opts2, (err2) => {
      if (err2)
        return cb(err2);
      return copyDirItems(items2, src, dest, opts2, cb);
    });
  });
}
function onLink(destStat, src, dest, opts2, cb) {
  fs$f.readlink(src, (err, resolvedSrc) => {
    if (err)
      return cb(err);
    if (opts2.dereference) {
      resolvedSrc = path$n.resolve(process.cwd(), resolvedSrc);
    }
    if (!destStat) {
      return fs$f.symlink(resolvedSrc, dest, cb);
    } else {
      fs$f.readlink(dest, (err2, resolvedDest) => {
        if (err2) {
          if (err2.code === "EINVAL" || err2.code === "UNKNOWN")
            return fs$f.symlink(resolvedSrc, dest, cb);
          return cb(err2);
        }
        if (opts2.dereference) {
          resolvedDest = path$n.resolve(process.cwd(), resolvedDest);
        }
        if (stat$2.isSrcSubdir(resolvedSrc, resolvedDest)) {
          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
        }
        if (destStat.isDirectory() && stat$2.isSrcSubdir(resolvedDest, resolvedSrc)) {
          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
        }
        return copyLink(resolvedSrc, dest, cb);
      });
    }
  });
}
function copyLink(resolvedSrc, dest, cb) {
  fs$f.unlink(dest, (err) => {
    if (err)
      return cb(err);
    return fs$f.symlink(resolvedSrc, dest, cb);
  });
}
var copy_1 = copy$2;
const u$8 = universalify$1.fromCallback;
var copy$1 = {
  copy: u$8(copy_1)
};
const fs$e = gracefulFs;
const path$m = require$$1__default$1["default"];
const assert = require$$5__default["default"];
const isWindows = process.platform === "win32";
function defaults$1(options) {
  const methods = [
    "unlink",
    "chmod",
    "stat",
    "lstat",
    "rmdir",
    "readdir"
  ];
  methods.forEach((m2) => {
    options[m2] = options[m2] || fs$e[m2];
    m2 = m2 + "Sync";
    options[m2] = options[m2] || fs$e[m2];
  });
  options.maxBusyTries = options.maxBusyTries || 3;
}
function rimraf$1(p, options, cb) {
  let busyTries = 0;
  if (typeof options === "function") {
    cb = options;
    options = {};
  }
  assert(p, "rimraf: missing path");
  assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
  assert.strictEqual(typeof cb, "function", "rimraf: callback function required");
  assert(options, "rimraf: invalid options argument provided");
  assert.strictEqual(typeof options, "object", "rimraf: options should be object");
  defaults$1(options);
  rimraf_(p, options, function CB(er) {
    if (er) {
      if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options.maxBusyTries) {
        busyTries++;
        const time = busyTries * 100;
        return setTimeout(() => rimraf_(p, options, CB), time);
      }
      if (er.code === "ENOENT")
        er = null;
    }
    cb(er);
  });
}
function rimraf_(p, options, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === "function");
  options.lstat(p, (er, st) => {
    if (er && er.code === "ENOENT") {
      return cb(null);
    }
    if (er && er.code === "EPERM" && isWindows) {
      return fixWinEPERM(p, options, er, cb);
    }
    if (st && st.isDirectory()) {
      return rmdir(p, options, er, cb);
    }
    options.unlink(p, (er2) => {
      if (er2) {
        if (er2.code === "ENOENT") {
          return cb(null);
        }
        if (er2.code === "EPERM") {
          return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
        }
        if (er2.code === "EISDIR") {
          return rmdir(p, options, er2, cb);
        }
      }
      return cb(er2);
    });
  });
}
function fixWinEPERM(p, options, er, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === "function");
  options.chmod(p, 438, (er2) => {
    if (er2) {
      cb(er2.code === "ENOENT" ? null : er);
    } else {
      options.stat(p, (er3, stats) => {
        if (er3) {
          cb(er3.code === "ENOENT" ? null : er);
        } else if (stats.isDirectory()) {
          rmdir(p, options, er, cb);
        } else {
          options.unlink(p, cb);
        }
      });
    }
  });
}
function fixWinEPERMSync(p, options, er) {
  let stats;
  assert(p);
  assert(options);
  try {
    options.chmodSync(p, 438);
  } catch (er2) {
    if (er2.code === "ENOENT") {
      return;
    } else {
      throw er;
    }
  }
  try {
    stats = options.statSync(p);
  } catch (er3) {
    if (er3.code === "ENOENT") {
      return;
    } else {
      throw er;
    }
  }
  if (stats.isDirectory()) {
    rmdirSync(p, options, er);
  } else {
    options.unlinkSync(p);
  }
}
function rmdir(p, options, originalEr, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === "function");
  options.rmdir(p, (er) => {
    if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) {
      rmkids(p, options, cb);
    } else if (er && er.code === "ENOTDIR") {
      cb(originalEr);
    } else {
      cb(er);
    }
  });
}
function rmkids(p, options, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === "function");
  options.readdir(p, (er, files) => {
    if (er)
      return cb(er);
    let n = files.length;
    let errState;
    if (n === 0)
      return options.rmdir(p, cb);
    files.forEach((f) => {
      rimraf$1(path$m.join(p, f), options, (er2) => {
        if (errState) {
          return;
        }
        if (er2)
          return cb(errState = er2);
        if (--n === 0) {
          options.rmdir(p, cb);
        }
      });
    });
  });
}
function rimrafSync(p, options) {
  let st;
  options = options || {};
  defaults$1(options);
  assert(p, "rimraf: missing path");
  assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
  assert(options, "rimraf: missing options");
  assert.strictEqual(typeof options, "object", "rimraf: options should be object");
  try {
    st = options.lstatSync(p);
  } catch (er) {
    if (er.code === "ENOENT") {
      return;
    }
    if (er.code === "EPERM" && isWindows) {
      fixWinEPERMSync(p, options, er);
    }
  }
  try {
    if (st && st.isDirectory()) {
      rmdirSync(p, options, null);
    } else {
      options.unlinkSync(p);
    }
  } catch (er) {
    if (er.code === "ENOENT") {
      return;
    } else if (er.code === "EPERM") {
      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
    } else if (er.code !== "EISDIR") {
      throw er;
    }
    rmdirSync(p, options, er);
  }
}
function rmdirSync(p, options, originalEr) {
  assert(p);
  assert(options);
  try {
    options.rmdirSync(p);
  } catch (er) {
    if (er.code === "ENOTDIR") {
      throw originalEr;
    } else if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") {
      rmkidsSync(p, options);
    } else if (er.code !== "ENOENT") {
      throw er;
    }
  }
}
function rmkidsSync(p, options) {
  assert(p);
  assert(options);
  options.readdirSync(p).forEach((f) => rimrafSync(path$m.join(p, f), options));
  if (isWindows) {
    const startTime = Date.now();
    do {
      try {
        const ret = options.rmdirSync(p, options);
        return ret;
      } catch {
      }
    } while (Date.now() - startTime < 500);
  } else {
    const ret = options.rmdirSync(p, options);
    return ret;
  }
}
var rimraf_1 = rimraf$1;
rimraf$1.sync = rimrafSync;
const fs$d = gracefulFs;
const u$7 = universalify$1.fromCallback;
const rimraf = rimraf_1;
function remove$2(path2, callback) {
  if (fs$d.rm)
    return fs$d.rm(path2, { recursive: true, force: true }, callback);
  rimraf(path2, callback);
}
function removeSync$1(path2) {
  if (fs$d.rmSync)
    return fs$d.rmSync(path2, { recursive: true, force: true });
  rimraf.sync(path2);
}
var remove_1 = {
  remove: u$7(remove$2),
  removeSync: removeSync$1
};
const u$6 = universalify$1.fromPromise;
const fs$c = fs$m;
const path$l = require$$1__default$1["default"];
const mkdir$3 = mkdirs$2;
const remove$1 = remove_1;
const emptyDir = u$6(async function emptyDir2(dir) {
  let items2;
  try {
    items2 = await fs$c.readdir(dir);
  } catch {
    return mkdir$3.mkdirs(dir);
  }
  return Promise.all(items2.map((item) => remove$1.remove(path$l.join(dir, item))));
});
function emptyDirSync(dir) {
  let items2;
  try {
    items2 = fs$c.readdirSync(dir);
  } catch {
    return mkdir$3.mkdirsSync(dir);
  }
  items2.forEach((item) => {
    item = path$l.join(dir, item);
    remove$1.removeSync(item);
  });
}
var empty = {
  emptyDirSync,
  emptydirSync: emptyDirSync,
  emptyDir,
  emptydir: emptyDir
};
const u$5 = universalify$1.fromCallback;
const path$k = require$$1__default$1["default"];
const fs$b = gracefulFs;
const mkdir$2 = mkdirs$2;
function createFile(file2, callback) {
  function makeFile() {
    fs$b.writeFile(file2, "", (err) => {
      if (err)
        return callback(err);
      callback();
    });
  }
  fs$b.stat(file2, (err, stats) => {
    if (!err && stats.isFile())
      return callback();
    const dir = path$k.dirname(file2);
    fs$b.stat(dir, (err2, stats2) => {
      if (err2) {
        if (err2.code === "ENOENT") {
          return mkdir$2.mkdirs(dir, (err3) => {
            if (err3)
              return callback(err3);
            makeFile();
          });
        }
        return callback(err2);
      }
      if (stats2.isDirectory())
        makeFile();
      else {
        fs$b.readdir(dir, (err3) => {
          if (err3)
            return callback(err3);
        });
      }
    });
  });
}
function createFileSync(file2) {
  let stats;
  try {
    stats = fs$b.statSync(file2);
  } catch {
  }
  if (stats && stats.isFile())
    return;
  const dir = path$k.dirname(file2);
  try {
    if (!fs$b.statSync(dir).isDirectory()) {
      fs$b.readdirSync(dir);
    }
  } catch (err) {
    if (err && err.code === "ENOENT")
      mkdir$2.mkdirsSync(dir);
    else
      throw err;
  }
  fs$b.writeFileSync(file2, "");
}
var file$1 = {
  createFile: u$5(createFile),
  createFileSync
};
const u$4 = universalify$1.fromCallback;
const path$j = require$$1__default$1["default"];
const fs$a = gracefulFs;
const mkdir$1 = mkdirs$2;
const pathExists$6 = pathExists_1.pathExists;
const { areIdentical: areIdentical$1 } = stat$4;
function createLink(srcpath, dstpath, callback) {
  function makeLink(srcpath2, dstpath2) {
    fs$a.link(srcpath2, dstpath2, (err) => {
      if (err)
        return callback(err);
      callback(null);
    });
  }
  fs$a.lstat(dstpath, (_, dstStat) => {
    fs$a.lstat(srcpath, (err, srcStat) => {
      if (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        return callback(err);
      }
      if (dstStat && areIdentical$1(srcStat, dstStat))
        return callback(null);
      const dir = path$j.dirname(dstpath);
      pathExists$6(dir, (err2, dirExists) => {
        if (err2)
          return callback(err2);
        if (dirExists)
          return makeLink(srcpath, dstpath);
        mkdir$1.mkdirs(dir, (err3) => {
          if (err3)
            return callback(err3);
          makeLink(srcpath, dstpath);
        });
      });
    });
  });
}
function createLinkSync(srcpath, dstpath) {
  let dstStat;
  try {
    dstStat = fs$a.lstatSync(dstpath);
  } catch {
  }
  try {
    const srcStat = fs$a.lstatSync(srcpath);
    if (dstStat && areIdentical$1(srcStat, dstStat))
      return;
  } catch (err) {
    err.message = err.message.replace("lstat", "ensureLink");
    throw err;
  }
  const dir = path$j.dirname(dstpath);
  const dirExists = fs$a.existsSync(dir);
  if (dirExists)
    return fs$a.linkSync(srcpath, dstpath);
  mkdir$1.mkdirsSync(dir);
  return fs$a.linkSync(srcpath, dstpath);
}
var link$1 = {
  createLink: u$4(createLink),
  createLinkSync
};
const path$i = require$$1__default$1["default"];
const fs$9 = gracefulFs;
const pathExists$5 = pathExists_1.pathExists;
function symlinkPaths$1(srcpath, dstpath, callback) {
  if (path$i.isAbsolute(srcpath)) {
    return fs$9.lstat(srcpath, (err) => {
      if (err) {
        err.message = err.message.replace("lstat", "ensureSymlink");
        return callback(err);
      }
      return callback(null, {
        toCwd: srcpath,
        toDst: srcpath
      });
    });
  } else {
    const dstdir = path$i.dirname(dstpath);
    const relativeToDst = path$i.join(dstdir, srcpath);
    return pathExists$5(relativeToDst, (err, exists) => {
      if (err)
        return callback(err);
      if (exists) {
        return callback(null, {
          toCwd: relativeToDst,
          toDst: srcpath
        });
      } else {
        return fs$9.lstat(srcpath, (err2) => {
          if (err2) {
            err2.message = err2.message.replace("lstat", "ensureSymlink");
            return callback(err2);
          }
          return callback(null, {
            toCwd: srcpath,
            toDst: path$i.relative(dstdir, srcpath)
          });
        });
      }
    });
  }
}
function symlinkPathsSync$1(srcpath, dstpath) {
  let exists;
  if (path$i.isAbsolute(srcpath)) {
    exists = fs$9.existsSync(srcpath);
    if (!exists)
      throw new Error("absolute srcpath does not exist");
    return {
      toCwd: srcpath,
      toDst: srcpath
    };
  } else {
    const dstdir = path$i.dirname(dstpath);
    const relativeToDst = path$i.join(dstdir, srcpath);
    exists = fs$9.existsSync(relativeToDst);
    if (exists) {
      return {
        toCwd: relativeToDst,
        toDst: srcpath
      };
    } else {
      exists = fs$9.existsSync(srcpath);
      if (!exists)
        throw new Error("relative srcpath does not exist");
      return {
        toCwd: srcpath,
        toDst: path$i.relative(dstdir, srcpath)
      };
    }
  }
}
var symlinkPaths_1 = {
  symlinkPaths: symlinkPaths$1,
  symlinkPathsSync: symlinkPathsSync$1
};
const fs$8 = gracefulFs;
function symlinkType$1(srcpath, type2, callback) {
  callback = typeof type2 === "function" ? type2 : callback;
  type2 = typeof type2 === "function" ? false : type2;
  if (type2)
    return callback(null, type2);
  fs$8.lstat(srcpath, (err, stats) => {
    if (err)
      return callback(null, "file");
    type2 = stats && stats.isDirectory() ? "dir" : "file";
    callback(null, type2);
  });
}
function symlinkTypeSync$1(srcpath, type2) {
  let stats;
  if (type2)
    return type2;
  try {
    stats = fs$8.lstatSync(srcpath);
  } catch {
    return "file";
  }
  return stats && stats.isDirectory() ? "dir" : "file";
}
var symlinkType_1 = {
  symlinkType: symlinkType$1,
  symlinkTypeSync: symlinkTypeSync$1
};
const u$3 = universalify$1.fromCallback;
const path$h = require$$1__default$1["default"];
const fs$7 = fs$m;
const _mkdirs = mkdirs$2;
const mkdirs = _mkdirs.mkdirs;
const mkdirsSync = _mkdirs.mkdirsSync;
const _symlinkPaths = symlinkPaths_1;
const symlinkPaths = _symlinkPaths.symlinkPaths;
const symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
const _symlinkType = symlinkType_1;
const symlinkType = _symlinkType.symlinkType;
const symlinkTypeSync = _symlinkType.symlinkTypeSync;
const pathExists$4 = pathExists_1.pathExists;
const { areIdentical } = stat$4;
function createSymlink(srcpath, dstpath, type2, callback) {
  callback = typeof type2 === "function" ? type2 : callback;
  type2 = typeof type2 === "function" ? false : type2;
  fs$7.lstat(dstpath, (err, stats) => {
    if (!err && stats.isSymbolicLink()) {
      Promise.all([
        fs$7.stat(srcpath),
        fs$7.stat(dstpath)
      ]).then(([srcStat, dstStat]) => {
        if (areIdentical(srcStat, dstStat))
          return callback(null);
        _createSymlink(srcpath, dstpath, type2, callback);
      });
    } else
      _createSymlink(srcpath, dstpath, type2, callback);
  });
}
function _createSymlink(srcpath, dstpath, type2, callback) {
  symlinkPaths(srcpath, dstpath, (err, relative) => {
    if (err)
      return callback(err);
    srcpath = relative.toDst;
    symlinkType(relative.toCwd, type2, (err2, type3) => {
      if (err2)
        return callback(err2);
      const dir = path$h.dirname(dstpath);
      pathExists$4(dir, (err3, dirExists) => {
        if (err3)
          return callback(err3);
        if (dirExists)
          return fs$7.symlink(srcpath, dstpath, type3, callback);
        mkdirs(dir, (err4) => {
          if (err4)
            return callback(err4);
          fs$7.symlink(srcpath, dstpath, type3, callback);
        });
      });
    });
  });
}
function createSymlinkSync(srcpath, dstpath, type2) {
  let stats;
  try {
    stats = fs$7.lstatSync(dstpath);
  } catch {
  }
  if (stats && stats.isSymbolicLink()) {
    const srcStat = fs$7.statSync(srcpath);
    const dstStat = fs$7.statSync(dstpath);
    if (areIdentical(srcStat, dstStat))
      return;
  }
  const relative = symlinkPathsSync(srcpath, dstpath);
  srcpath = relative.toDst;
  type2 = symlinkTypeSync(relative.toCwd, type2);
  const dir = path$h.dirname(dstpath);
  const exists = fs$7.existsSync(dir);
  if (exists)
    return fs$7.symlinkSync(srcpath, dstpath, type2);
  mkdirsSync(dir);
  return fs$7.symlinkSync(srcpath, dstpath, type2);
}
var symlink$1 = {
  createSymlink: u$3(createSymlink),
  createSymlinkSync
};
const file = file$1;
const link = link$1;
const symlink = symlink$1;
var ensure = {
  createFile: file.createFile,
  createFileSync: file.createFileSync,
  ensureFile: file.createFile,
  ensureFileSync: file.createFileSync,
  createLink: link.createLink,
  createLinkSync: link.createLinkSync,
  ensureLink: link.createLink,
  ensureLinkSync: link.createLinkSync,
  createSymlink: symlink.createSymlink,
  createSymlinkSync: symlink.createSymlinkSync,
  ensureSymlink: symlink.createSymlink,
  ensureSymlinkSync: symlink.createSymlinkSync
};
function stringify$4(obj, { EOL = "\n", finalEOL = true, replacer = null, spaces } = {}) {
  const EOF = finalEOL ? EOL : "";
  const str2 = JSON.stringify(obj, replacer, spaces);
  return str2.replace(/\n/g, EOL) + EOF;
}
function stripBom$1(content) {
  if (Buffer.isBuffer(content))
    content = content.toString("utf8");
  return content.replace(/^\uFEFF/, "");
}
var utils = { stringify: stringify$4, stripBom: stripBom$1 };
let _fs;
try {
  _fs = gracefulFs;
} catch (_) {
  _fs = require$$0__default$2["default"];
}
const universalify = universalify$1;
const { stringify: stringify$3, stripBom } = utils;
async function _readFile(file2, options = {}) {
  if (typeof options === "string") {
    options = { encoding: options };
  }
  const fs2 = options.fs || _fs;
  const shouldThrow = "throws" in options ? options.throws : true;
  let data = await universalify.fromCallback(fs2.readFile)(file2, options);
  data = stripBom(data);
  let obj;
  try {
    obj = JSON.parse(data, options ? options.reviver : null);
  } catch (err) {
    if (shouldThrow) {
      err.message = `${file2}: ${err.message}`;
      throw err;
    } else {
      return null;
    }
  }
  return obj;
}
const readFile$1 = universalify.fromPromise(_readFile);
function readFileSync$1(file2, options = {}) {
  if (typeof options === "string") {
    options = { encoding: options };
  }
  const fs2 = options.fs || _fs;
  const shouldThrow = "throws" in options ? options.throws : true;
  try {
    let content = fs2.readFileSync(file2, options);
    content = stripBom(content);
    return JSON.parse(content, options.reviver);
  } catch (err) {
    if (shouldThrow) {
      err.message = `${file2}: ${err.message}`;
      throw err;
    } else {
      return null;
    }
  }
}
async function _writeFile(file2, obj, options = {}) {
  const fs2 = options.fs || _fs;
  const str2 = stringify$3(obj, options);
  await universalify.fromCallback(fs2.writeFile)(file2, str2, options);
}
const writeFile$1 = universalify.fromPromise(_writeFile);
function writeFileSync$1(file2, obj, options = {}) {
  const fs2 = options.fs || _fs;
  const str2 = stringify$3(obj, options);
  return fs2.writeFileSync(file2, str2, options);
}
const jsonfile$1 = {
  readFile: readFile$1,
  readFileSync: readFileSync$1,
  writeFile: writeFile$1,
  writeFileSync: writeFileSync$1
};
var jsonfile_1 = jsonfile$1;
const jsonFile$1 = jsonfile_1;
var jsonfile = {
  readJson: jsonFile$1.readFile,
  readJsonSync: jsonFile$1.readFileSync,
  writeJson: jsonFile$1.writeFile,
  writeJsonSync: jsonFile$1.writeFileSync
};
const u$2 = universalify$1.fromCallback;
const fs$6 = gracefulFs;
const path$g = require$$1__default$1["default"];
const mkdir = mkdirs$2;
const pathExists$3 = pathExists_1.pathExists;
function outputFile$1(file2, data, encoding, callback) {
  if (typeof encoding === "function") {
    callback = encoding;
    encoding = "utf8";
  }
  const dir = path$g.dirname(file2);
  pathExists$3(dir, (err, itDoes) => {
    if (err)
      return callback(err);
    if (itDoes)
      return fs$6.writeFile(file2, data, encoding, callback);
    mkdir.mkdirs(dir, (err2) => {
      if (err2)
        return callback(err2);
      fs$6.writeFile(file2, data, encoding, callback);
    });
  });
}
function outputFileSync$1(file2, ...args) {
  const dir = path$g.dirname(file2);
  if (fs$6.existsSync(dir)) {
    return fs$6.writeFileSync(file2, ...args);
  }
  mkdir.mkdirsSync(dir);
  fs$6.writeFileSync(file2, ...args);
}
var output = {
  outputFile: u$2(outputFile$1),
  outputFileSync: outputFileSync$1
};
const { stringify: stringify$2 } = utils;
const { outputFile } = output;
async function outputJson(file2, data, options = {}) {
  const str2 = stringify$2(data, options);
  await outputFile(file2, str2, options);
}
var outputJson_1 = outputJson;
const { stringify: stringify$1 } = utils;
const { outputFileSync } = output;
function outputJsonSync(file2, data, options) {
  const str2 = stringify$1(data, options);
  outputFileSync(file2, str2, options);
}
var outputJsonSync_1 = outputJsonSync;
const u$1 = universalify$1.fromPromise;
const jsonFile = jsonfile;
jsonFile.outputJson = u$1(outputJson_1);
jsonFile.outputJsonSync = outputJsonSync_1;
jsonFile.outputJSON = jsonFile.outputJson;
jsonFile.outputJSONSync = jsonFile.outputJsonSync;
jsonFile.writeJSON = jsonFile.writeJson;
jsonFile.writeJSONSync = jsonFile.writeJsonSync;
jsonFile.readJSON = jsonFile.readJson;
jsonFile.readJSONSync = jsonFile.readJsonSync;
var json$1 = jsonFile;
const fs$5 = gracefulFs;
const path$f = require$$1__default$1["default"];
const copySync = copySync$1.copySync;
const removeSync = remove_1.removeSync;
const mkdirpSync = mkdirs$2.mkdirpSync;
const stat$1 = stat$4;
function moveSync$1(src, dest, opts2) {
  opts2 = opts2 || {};
  const overwrite = opts2.overwrite || opts2.clobber || false;
  const { srcStat, isChangingCase = false } = stat$1.checkPathsSync(src, dest, "move", opts2);
  stat$1.checkParentPathsSync(src, srcStat, dest, "move");
  if (!isParentRoot$1(dest))
    mkdirpSync(path$f.dirname(dest));
  return doRename$1(src, dest, overwrite, isChangingCase);
}
function isParentRoot$1(dest) {
  const parent = path$f.dirname(dest);
  const parsedPath = path$f.parse(parent);
  return parsedPath.root === parent;
}
function doRename$1(src, dest, overwrite, isChangingCase) {
  if (isChangingCase)
    return rename$1(src, dest, overwrite);
  if (overwrite) {
    removeSync(dest);
    return rename$1(src, dest, overwrite);
  }
  if (fs$5.existsSync(dest))
    throw new Error("dest already exists.");
  return rename$1(src, dest, overwrite);
}
function rename$1(src, dest, overwrite) {
  try {
    fs$5.renameSync(src, dest);
  } catch (err) {
    if (err.code !== "EXDEV")
      throw err;
    return moveAcrossDevice$1(src, dest, overwrite);
  }
}
function moveAcrossDevice$1(src, dest, overwrite) {
  const opts2 = {
    overwrite,
    errorOnExist: true
  };
  copySync(src, dest, opts2);
  return removeSync(src);
}
var moveSync_1 = moveSync$1;
var moveSync = {
  moveSync: moveSync_1
};
const fs$4 = gracefulFs;
const path$e = require$$1__default$1["default"];
const copy = copy$1.copy;
const remove = remove_1.remove;
const mkdirp = mkdirs$2.mkdirp;
const pathExists$2 = pathExists_1.pathExists;
const stat = stat$4;
function move$1(src, dest, opts2, cb) {
  if (typeof opts2 === "function") {
    cb = opts2;
    opts2 = {};
  }
  const overwrite = opts2.overwrite || opts2.clobber || false;
  stat.checkPaths(src, dest, "move", opts2, (err, stats) => {
    if (err)
      return cb(err);
    const { srcStat, isChangingCase = false } = stats;
    stat.checkParentPaths(src, srcStat, dest, "move", (err2) => {
      if (err2)
        return cb(err2);
      if (isParentRoot(dest))
        return doRename(src, dest, overwrite, isChangingCase, cb);
      mkdirp(path$e.dirname(dest), (err3) => {
        if (err3)
          return cb(err3);
        return doRename(src, dest, overwrite, isChangingCase, cb);
      });
    });
  });
}
function isParentRoot(dest) {
  const parent = path$e.dirname(dest);
  const parsedPath = path$e.parse(parent);
  return parsedPath.root === parent;
}
function doRename(src, dest, overwrite, isChangingCase, cb) {
  if (isChangingCase)
    return rename(src, dest, overwrite, cb);
  if (overwrite) {
    return remove(dest, (err) => {
      if (err)
        return cb(err);
      return rename(src, dest, overwrite, cb);
    });
  }
  pathExists$2(dest, (err, destExists) => {
    if (err)
      return cb(err);
    if (destExists)
      return cb(new Error("dest already exists."));
    return rename(src, dest, overwrite, cb);
  });
}
function rename(src, dest, overwrite, cb) {
  fs$4.rename(src, dest, (err) => {
    if (!err)
      return cb();
    if (err.code !== "EXDEV")
      return cb(err);
    return moveAcrossDevice(src, dest, overwrite, cb);
  });
}
function moveAcrossDevice(src, dest, overwrite, cb) {
  const opts2 = {
    overwrite,
    errorOnExist: true
  };
  copy(src, dest, opts2, (err) => {
    if (err)
      return cb(err);
    return remove(src, cb);
  });
}
var move_1 = move$1;
const u = universalify$1.fromCallback;
var move = {
  move: u(move_1)
};
var lib = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, fs$m), copySync$1), copy$1), empty), ensure), json$1), mkdirs$2), moveSync), move), output), pathExists_1), remove_1);
var main$1 = {};
var out = {};
var CancellationToken$1 = {};
Object.defineProperty(CancellationToken$1, "__esModule", { value: true });
CancellationToken$1.CancellationError = CancellationToken$1.CancellationToken = void 0;
const events_1$1 = require$$0__default$3["default"];
class CancellationToken extends events_1$1.EventEmitter {
  constructor(parent) {
    super();
    this.parentCancelHandler = null;
    this._parent = null;
    this._cancelled = false;
    if (parent != null) {
      this.parent = parent;
    }
  }
  get cancelled() {
    return this._cancelled || this._parent != null && this._parent.cancelled;
  }
  set parent(value) {
    this.removeParentCancelHandler();
    this._parent = value;
    this.parentCancelHandler = () => this.cancel();
    this._parent.onCancel(this.parentCancelHandler);
  }
  cancel() {
    this._cancelled = true;
    this.emit("cancel");
  }
  onCancel(handler) {
    if (this.cancelled) {
      handler();
    } else {
      this.once("cancel", handler);
    }
  }
  createPromise(callback) {
    if (this.cancelled) {
      return Promise.reject(new CancellationError());
    }
    const finallyHandler = () => {
      if (cancelHandler != null) {
        try {
          this.removeListener("cancel", cancelHandler);
          cancelHandler = null;
        } catch (ignore) {
        }
      }
    };
    let cancelHandler = null;
    return new Promise((resolve2, reject) => {
      let addedCancelHandler = null;
      cancelHandler = () => {
        try {
          if (addedCancelHandler != null) {
            addedCancelHandler();
            addedCancelHandler = null;
          }
        } finally {
          reject(new CancellationError());
        }
      };
      if (this.cancelled) {
        cancelHandler();
        return;
      }
      this.onCancel(cancelHandler);
      callback(resolve2, reject, (callback2) => {
        addedCancelHandler = callback2;
      });
    }).then((it) => {
      finallyHandler();
      return it;
    }).catch((e) => {
      finallyHandler();
      throw e;
    });
  }
  removeParentCancelHandler() {
    const parent = this._parent;
    if (parent != null && this.parentCancelHandler != null) {
      parent.removeListener("cancel", this.parentCancelHandler);
      this.parentCancelHandler = null;
    }
  }
  dispose() {
    try {
      this.removeParentCancelHandler();
    } finally {
      this.removeAllListeners();
      this._parent = null;
    }
  }
}
CancellationToken$1.CancellationToken = CancellationToken;
class CancellationError extends Error {
  constructor() {
    super("cancelled");
  }
}
CancellationToken$1.CancellationError = CancellationError;
var httpExecutor = {};
var browser = { exports: {} };
var s = 1e3;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
var ms = function(val, options) {
  options = options || {};
  var type2 = typeof val;
  if (type2 === "string" && val.length > 0) {
    return parse$6(val);
  } else if (type2 === "number" && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
};
function parse$6(str2) {
  str2 = String(str2);
  if (str2.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str2);
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type2 = (match[2] || "ms").toLowerCase();
  switch (type2) {
    case "years":
    case "year":
    case "yrs":
    case "yr":
    case "y":
      return n * y;
    case "weeks":
    case "week":
    case "w":
      return n * w;
    case "days":
    case "day":
    case "d":
      return n * d;
    case "hours":
    case "hour":
    case "hrs":
    case "hr":
    case "h":
      return n * h;
    case "minutes":
    case "minute":
    case "mins":
    case "min":
    case "m":
      return n * m;
    case "seconds":
    case "second":
    case "secs":
    case "sec":
    case "s":
      return n * s;
    case "milliseconds":
    case "millisecond":
    case "msecs":
    case "msec":
    case "ms":
      return n;
    default:
      return void 0;
  }
}
function fmtShort(ms2) {
  var msAbs = Math.abs(ms2);
  if (msAbs >= d) {
    return Math.round(ms2 / d) + "d";
  }
  if (msAbs >= h) {
    return Math.round(ms2 / h) + "h";
  }
  if (msAbs >= m) {
    return Math.round(ms2 / m) + "m";
  }
  if (msAbs >= s) {
    return Math.round(ms2 / s) + "s";
  }
  return ms2 + "ms";
}
function fmtLong(ms2) {
  var msAbs = Math.abs(ms2);
  if (msAbs >= d) {
    return plural(ms2, msAbs, d, "day");
  }
  if (msAbs >= h) {
    return plural(ms2, msAbs, h, "hour");
  }
  if (msAbs >= m) {
    return plural(ms2, msAbs, m, "minute");
  }
  if (msAbs >= s) {
    return plural(ms2, msAbs, s, "second");
  }
  return ms2 + " ms";
}
function plural(ms2, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
}
function setup(env2) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce2;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = ms;
  createDebug.destroy = destroy;
  Object.keys(env2).forEach((key) => {
    createDebug[key] = env2[key];
  });
  createDebug.names = [];
  createDebug.skips = [];
  createDebug.formatters = {};
  function selectColor(namespace) {
    let hash = 0;
    for (let i2 = 0; i2 < namespace.length; i2++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i2);
      hash |= 0;
    }
    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }
  createDebug.selectColor = selectColor;
  function createDebug(namespace) {
    let prevTime;
    let enableOverride = null;
    let namespacesCache;
    let enabledCache;
    function debug2(...args) {
      if (!debug2.enabled) {
        return;
      }
      const self2 = debug2;
      const curr = Number(new Date());
      const ms2 = curr - (prevTime || curr);
      self2.diff = ms2;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);
      if (typeof args[0] !== "string") {
        args.unshift("%O");
      }
      let index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
        if (match === "%%") {
          return "%";
        }
        index++;
        const formatter = createDebug.formatters[format2];
        if (typeof formatter === "function") {
          const val = args[index];
          match = formatter.call(self2, val);
          args.splice(index, 1);
          index--;
        }
        return match;
      });
      createDebug.formatArgs.call(self2, args);
      const logFn = self2.log || createDebug.log;
      logFn.apply(self2, args);
    }
    debug2.namespace = namespace;
    debug2.useColors = createDebug.useColors();
    debug2.color = createDebug.selectColor(namespace);
    debug2.extend = extend3;
    debug2.destroy = createDebug.destroy;
    Object.defineProperty(debug2, "enabled", {
      enumerable: true,
      configurable: false,
      get: () => {
        if (enableOverride !== null) {
          return enableOverride;
        }
        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace);
        }
        return enabledCache;
      },
      set: (v) => {
        enableOverride = v;
      }
    });
    if (typeof createDebug.init === "function") {
      createDebug.init(debug2);
    }
    return debug2;
  }
  function extend3(namespace, delimiter) {
    const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }
  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    let i2;
    const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    const len = split.length;
    for (i2 = 0; i2 < len; i2++) {
      if (!split[i2]) {
        continue;
      }
      namespaces = split[i2].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
      } else {
        createDebug.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  function disable() {
    const namespaces = [
      ...createDebug.names.map(toNamespace),
      ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
    ].join(",");
    createDebug.enable("");
    return namespaces;
  }
  function enabled(name) {
    if (name[name.length - 1] === "*") {
      return true;
    }
    let i2;
    let len;
    for (i2 = 0, len = createDebug.skips.length; i2 < len; i2++) {
      if (createDebug.skips[i2].test(name)) {
        return false;
      }
    }
    for (i2 = 0, len = createDebug.names.length; i2 < len; i2++) {
      if (createDebug.names[i2].test(name)) {
        return true;
      }
    }
    return false;
  }
  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function coerce2(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }
    return val;
  }
  function destroy() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  createDebug.enable(createDebug.load());
  return createDebug;
}
var common$6 = setup;
(function(module, exports) {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load2;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports.log = console.debug || console.log || (() => {
  });
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error2) {
    }
  }
  function load2() {
    let r;
    try {
      r = exports.storage.getItem("debug");
    } catch (error2) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = {}.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error2) {
    }
  }
  module.exports = common$6(exports);
  const { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error2) {
      return "[UnexpectedJSONParseError]: " + error2.message;
    }
  };
})(browser, browser.exports);
var ProgressCallbackTransform$1 = {};
Object.defineProperty(ProgressCallbackTransform$1, "__esModule", { value: true });
ProgressCallbackTransform$1.ProgressCallbackTransform = void 0;
const stream_1$3 = require$$0__default$1["default"];
class ProgressCallbackTransform extends stream_1$3.Transform {
  constructor(total, cancellationToken, onProgress) {
    super();
    this.total = total;
    this.cancellationToken = cancellationToken;
    this.onProgress = onProgress;
    this.start = Date.now();
    this.transferred = 0;
    this.delta = 0;
    this.nextUpdate = this.start + 1e3;
  }
  _transform(chunk, encoding, callback) {
    if (this.cancellationToken.cancelled) {
      callback(new Error("cancelled"), null);
      return;
    }
    this.transferred += chunk.length;
    this.delta += chunk.length;
    const now = Date.now();
    if (now >= this.nextUpdate && this.transferred !== this.total) {
      this.nextUpdate = now + 1e3;
      this.onProgress({
        total: this.total,
        delta: this.delta,
        transferred: this.transferred,
        percent: this.transferred / this.total * 100,
        bytesPerSecond: Math.round(this.transferred / ((now - this.start) / 1e3))
      });
      this.delta = 0;
    }
    callback(null, chunk);
  }
  _flush(callback) {
    if (this.cancellationToken.cancelled) {
      callback(new Error("cancelled"));
      return;
    }
    this.onProgress({
      total: this.total,
      delta: this.delta,
      transferred: this.total,
      percent: 100,
      bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1e3))
    });
    this.delta = 0;
    callback(null);
  }
}
ProgressCallbackTransform$1.ProgressCallbackTransform = ProgressCallbackTransform;
Object.defineProperty(httpExecutor, "__esModule", { value: true });
httpExecutor.safeStringifyJson = httpExecutor.configureRequestOptions = httpExecutor.safeGetHeader = httpExecutor.DigestTransform = httpExecutor.configureRequestUrl = httpExecutor.configureRequestOptionsFromUrl = httpExecutor.HttpExecutor = httpExecutor.parseJson = httpExecutor.HttpError = httpExecutor.createHttpError = void 0;
const crypto_1$3 = require$$0__default$4["default"];
const debug_1$1 = browser.exports;
const fs_1$7 = require$$0__default$2["default"];
const stream_1$2 = require$$0__default$1["default"];
const url_1$6 = require$$2__default["default"];
const CancellationToken_1 = CancellationToken$1;
const index_1$2 = out;
const ProgressCallbackTransform_1 = ProgressCallbackTransform$1;
const debug$4 = debug_1$1.default("electron-builder");
function createHttpError(response, description2 = null) {
  return new HttpError(response.statusCode || -1, `${response.statusCode} ${response.statusMessage}` + (description2 == null ? "" : "\n" + JSON.stringify(description2, null, "  ")) + "\nHeaders: " + safeStringifyJson(response.headers), description2);
}
httpExecutor.createHttpError = createHttpError;
const HTTP_STATUS_CODES = new Map([
  [429, "Too many requests"],
  [400, "Bad request"],
  [403, "Forbidden"],
  [404, "Not found"],
  [405, "Method not allowed"],
  [406, "Not acceptable"],
  [408, "Request timeout"],
  [413, "Request entity too large"],
  [500, "Internal server error"],
  [502, "Bad gateway"],
  [503, "Service unavailable"],
  [504, "Gateway timeout"],
  [505, "HTTP version not supported"]
]);
class HttpError extends Error {
  constructor(statusCode, message = `HTTP error: ${HTTP_STATUS_CODES.get(statusCode) || statusCode}`, description2 = null) {
    super(message);
    this.statusCode = statusCode;
    this.description = description2;
    this.name = "HttpError";
    this.code = `HTTP_ERROR_${statusCode}`;
  }
  isServerError() {
    return this.statusCode >= 500 && this.statusCode <= 599;
  }
}
httpExecutor.HttpError = HttpError;
function parseJson(result) {
  return result.then((it) => it == null || it.length === 0 ? null : JSON.parse(it));
}
httpExecutor.parseJson = parseJson;
class HttpExecutor {
  constructor() {
    this.maxRedirects = 10;
  }
  request(options, cancellationToken = new CancellationToken_1.CancellationToken(), data) {
    configureRequestOptions(options);
    const json2 = data == null ? void 0 : JSON.stringify(data);
    const encodedData = json2 ? Buffer.from(json2) : void 0;
    if (encodedData != null) {
      debug$4(json2);
      const _a = options, { headers } = _a, opts2 = __objRest(_a, ["headers"]);
      options = __spreadValues({
        method: "post",
        headers: __spreadValues({
          "Content-Type": "application/json",
          "Content-Length": encodedData.length
        }, headers)
      }, opts2);
    }
    return this.doApiRequest(options, cancellationToken, (it) => {
      it.end(encodedData);
    });
  }
  doApiRequest(options, cancellationToken, requestProcessor, redirectCount = 0) {
    if (debug$4.enabled) {
      debug$4(`Request: ${safeStringifyJson(options)}`);
    }
    return cancellationToken.createPromise((resolve2, reject, onCancel) => {
      const request = this.createRequest(options, (response) => {
        try {
          this.handleResponse(response, options, cancellationToken, resolve2, reject, redirectCount, requestProcessor);
        } catch (e) {
          reject(e);
        }
      });
      this.addErrorAndTimeoutHandlers(request, reject);
      this.addRedirectHandlers(request, options, reject, redirectCount, (options2) => {
        this.doApiRequest(options2, cancellationToken, requestProcessor, redirectCount).then(resolve2).catch(reject);
      });
      requestProcessor(request, reject);
      onCancel(() => request.abort());
    });
  }
  addRedirectHandlers(request, options, reject, redirectCount, handler) {
  }
  addErrorAndTimeoutHandlers(request, reject) {
    this.addTimeOutHandler(request, reject);
    request.on("error", reject);
    request.on("aborted", () => {
      reject(new Error("Request has been aborted by the server"));
    });
  }
  handleResponse(response, options, cancellationToken, resolve2, reject, redirectCount, requestProcessor) {
    var _a;
    if (debug$4.enabled) {
      debug$4(`Response: ${response.statusCode} ${response.statusMessage}, request options: ${safeStringifyJson(options)}`);
    }
    if (response.statusCode === 404) {
      reject(createHttpError(response, `method: ${options.method || "GET"} url: ${options.protocol || "https:"}//${options.hostname}${options.port ? `:${options.port}` : ""}${options.path}

Please double check that your authentication token is correct. Due to security reasons, actual status maybe not reported, but 404.
`));
      return;
    } else if (response.statusCode === 204) {
      resolve2();
      return;
    }
    const code2 = (_a = response.statusCode) !== null && _a !== void 0 ? _a : 0;
    const shouldRedirect = code2 >= 300 && code2 < 400;
    const redirectUrl = safeGetHeader(response, "location");
    if (shouldRedirect && redirectUrl != null) {
      if (redirectCount > this.maxRedirects) {
        reject(this.createMaxRedirectError());
        return;
      }
      this.doApiRequest(HttpExecutor.prepareRedirectUrlOptions(redirectUrl, options), cancellationToken, requestProcessor, redirectCount).then(resolve2).catch(reject);
      return;
    }
    response.setEncoding("utf8");
    let data = "";
    response.on("error", reject);
    response.on("data", (chunk) => data += chunk);
    response.on("end", () => {
      try {
        if (response.statusCode != null && response.statusCode >= 400) {
          const contentType = safeGetHeader(response, "content-type");
          const isJson = contentType != null && (Array.isArray(contentType) ? contentType.find((it) => it.includes("json")) != null : contentType.includes("json"));
          reject(createHttpError(response, `method: ${options.method || "GET"} url: ${options.protocol || "https:"}//${options.hostname}${options.port ? `:${options.port}` : ""}${options.path}

          Data:
          ${isJson ? JSON.stringify(JSON.parse(data)) : data}
          `));
        } else {
          resolve2(data.length === 0 ? null : data);
        }
      } catch (e) {
        reject(e);
      }
    });
  }
  async downloadToBuffer(url, options) {
    return await options.cancellationToken.createPromise((resolve2, reject, onCancel) => {
      let result = null;
      const requestOptions = {
        headers: options.headers || void 0,
        redirect: "manual"
      };
      configureRequestUrl(url, requestOptions);
      configureRequestOptions(requestOptions);
      this.doDownload(requestOptions, {
        destination: null,
        options,
        onCancel,
        callback: (error2) => {
          if (error2 == null) {
            resolve2(result);
          } else {
            reject(error2);
          }
        },
        responseHandler: (response, callback) => {
          const contentLength = safeGetHeader(response, "content-length");
          let position = -1;
          if (contentLength != null) {
            const size = parseInt(contentLength, 10);
            if (size > 0) {
              if (size > 524288e3) {
                callback(new Error("Maximum allowed size is 500 MB"));
                return;
              }
              result = Buffer.alloc(size);
              position = 0;
            }
          }
          response.on("data", (chunk) => {
            if (position !== -1) {
              chunk.copy(result, position);
              position += chunk.length;
            } else if (result == null) {
              result = chunk;
            } else {
              if (result.length > 524288e3) {
                callback(new Error("Maximum allowed size is 500 MB"));
                return;
              }
              result = Buffer.concat([result, chunk]);
            }
          });
          response.on("end", () => {
            if (result != null && position !== -1 && position !== result.length) {
              callback(new Error(`Received data length ${position} is not equal to expected ${result.length}`));
            } else {
              callback(null);
            }
          });
        }
      }, 0);
    });
  }
  doDownload(requestOptions, options, redirectCount) {
    const request = this.createRequest(requestOptions, (response) => {
      if (response.statusCode >= 400) {
        options.callback(new Error(`Cannot download "${requestOptions.protocol || "https:"}//${requestOptions.hostname}${requestOptions.path}", status ${response.statusCode}: ${response.statusMessage}`));
        return;
      }
      response.on("error", options.callback);
      const redirectUrl = safeGetHeader(response, "location");
      if (redirectUrl != null) {
        if (redirectCount < this.maxRedirects) {
          this.doDownload(HttpExecutor.prepareRedirectUrlOptions(redirectUrl, requestOptions), options, redirectCount++);
        } else {
          options.callback(this.createMaxRedirectError());
        }
        return;
      }
      if (options.responseHandler == null) {
        configurePipes(options, response);
      } else {
        options.responseHandler(response, options.callback);
      }
    });
    this.addErrorAndTimeoutHandlers(request, options.callback);
    this.addRedirectHandlers(request, requestOptions, options.callback, redirectCount, (requestOptions2) => {
      this.doDownload(requestOptions2, options, redirectCount++);
    });
    request.end();
  }
  createMaxRedirectError() {
    return new Error(`Too many redirects (> ${this.maxRedirects})`);
  }
  addTimeOutHandler(request, callback) {
    request.on("socket", (socket) => {
      socket.setTimeout(60 * 1e3, () => {
        request.abort();
        callback(new Error("Request timed out"));
      });
    });
  }
  static prepareRedirectUrlOptions(redirectUrl, options) {
    const newOptions = configureRequestOptionsFromUrl(redirectUrl, __spreadValues({}, options));
    const headers = newOptions.headers;
    if (headers === null || headers === void 0 ? void 0 : headers.authorization) {
      const parsedNewUrl = new url_1$6.URL(redirectUrl);
      if (parsedNewUrl.hostname.endsWith(".amazonaws.com") || parsedNewUrl.searchParams.has("X-Amz-Credential")) {
        delete headers.authorization;
      }
    }
    return newOptions;
  }
  static retryOnServerError(task, maxRetries = 3) {
    for (let attemptNumber = 0; ; attemptNumber++) {
      try {
        return task();
      } catch (e) {
        if (attemptNumber < maxRetries && (e instanceof HttpError && e.isServerError() || e.code === "EPIPE")) {
          continue;
        }
        throw e;
      }
    }
  }
}
httpExecutor.HttpExecutor = HttpExecutor;
function configureRequestOptionsFromUrl(url, options) {
  const result = configureRequestOptions(options);
  configureRequestUrl(new url_1$6.URL(url), result);
  return result;
}
httpExecutor.configureRequestOptionsFromUrl = configureRequestOptionsFromUrl;
function configureRequestUrl(url, options) {
  options.protocol = url.protocol;
  options.hostname = url.hostname;
  if (url.port) {
    options.port = url.port;
  } else if (options.port) {
    delete options.port;
  }
  options.path = url.pathname + url.search;
}
httpExecutor.configureRequestUrl = configureRequestUrl;
class DigestTransform extends stream_1$2.Transform {
  constructor(expected, algorithm = "sha512", encoding = "base64") {
    super();
    this.expected = expected;
    this.algorithm = algorithm;
    this.encoding = encoding;
    this._actual = null;
    this.isValidateOnEnd = true;
    this.digester = crypto_1$3.createHash(algorithm);
  }
  get actual() {
    return this._actual;
  }
  _transform(chunk, encoding, callback) {
    this.digester.update(chunk);
    callback(null, chunk);
  }
  _flush(callback) {
    this._actual = this.digester.digest(this.encoding);
    if (this.isValidateOnEnd) {
      try {
        this.validate();
      } catch (e) {
        callback(e);
        return;
      }
    }
    callback(null);
  }
  validate() {
    if (this._actual == null) {
      throw index_1$2.newError("Not finished yet", "ERR_STREAM_NOT_FINISHED");
    }
    if (this._actual !== this.expected) {
      throw index_1$2.newError(`${this.algorithm} checksum mismatch, expected ${this.expected}, got ${this._actual}`, "ERR_CHECKSUM_MISMATCH");
    }
    return null;
  }
}
httpExecutor.DigestTransform = DigestTransform;
function checkSha2(sha2Header, sha2, callback) {
  if (sha2Header != null && sha2 != null && sha2Header !== sha2) {
    callback(new Error(`checksum mismatch: expected ${sha2} but got ${sha2Header} (X-Checksum-Sha2 header)`));
    return false;
  }
  return true;
}
function safeGetHeader(response, headerKey) {
  const value = response.headers[headerKey];
  if (value == null) {
    return null;
  } else if (Array.isArray(value)) {
    return value.length === 0 ? null : value[value.length - 1];
  } else {
    return value;
  }
}
httpExecutor.safeGetHeader = safeGetHeader;
function configurePipes(options, response) {
  if (!checkSha2(safeGetHeader(response, "X-Checksum-Sha2"), options.options.sha2, options.callback)) {
    return;
  }
  const streams = [];
  if (options.options.onProgress != null) {
    const contentLength = safeGetHeader(response, "content-length");
    if (contentLength != null) {
      streams.push(new ProgressCallbackTransform_1.ProgressCallbackTransform(parseInt(contentLength, 10), options.options.cancellationToken, options.options.onProgress));
    }
  }
  const sha512 = options.options.sha512;
  if (sha512 != null) {
    streams.push(new DigestTransform(sha512, "sha512", sha512.length === 128 && !sha512.includes("+") && !sha512.includes("Z") && !sha512.includes("=") ? "hex" : "base64"));
  } else if (options.options.sha2 != null) {
    streams.push(new DigestTransform(options.options.sha2, "sha256", "hex"));
  }
  const fileOut = fs_1$7.createWriteStream(options.destination);
  streams.push(fileOut);
  let lastStream = response;
  for (const stream of streams) {
    stream.on("error", (error2) => {
      if (!options.options.cancellationToken.cancelled) {
        options.callback(error2);
      }
    });
    lastStream = lastStream.pipe(stream);
  }
  fileOut.on("finish", () => {
    fileOut.close(options.callback);
  });
}
function configureRequestOptions(options, token, method) {
  if (method != null) {
    options.method = method;
  }
  options.headers = __spreadValues({}, options.headers);
  const headers = options.headers;
  if (token != null) {
    headers.authorization = token.startsWith("Basic") || token.startsWith("Bearer") ? token : `token ${token}`;
  }
  if (headers["User-Agent"] == null) {
    headers["User-Agent"] = "electron-builder";
  }
  if (method == null || method === "GET" || headers["Cache-Control"] == null) {
    headers["Cache-Control"] = "no-cache";
  }
  if (options.protocol == null && process.versions.electron != null) {
    options.protocol = "https:";
  }
  return options;
}
httpExecutor.configureRequestOptions = configureRequestOptions;
function safeStringifyJson(data, skippedNames) {
  return JSON.stringify(data, (name, value) => {
    if (name.endsWith("Authorization") || name.endsWith("authorization") || name.endsWith("Password") || name.endsWith("PASSWORD") || name.endsWith("Token") || name.includes("password") || name.includes("token") || skippedNames != null && skippedNames.has(name)) {
      return "<stripped sensitive data>";
    }
    return value;
  }, 2);
}
httpExecutor.safeStringifyJson = safeStringifyJson;
var publishOptions = {};
Object.defineProperty(publishOptions, "__esModule", { value: true });
publishOptions.getS3LikeProviderBaseUrl = publishOptions.githubUrl = void 0;
function githubUrl(options, defaultHost = "github.com") {
  return `${options.protocol || "https"}://${options.host || defaultHost}`;
}
publishOptions.githubUrl = githubUrl;
function getS3LikeProviderBaseUrl(configuration) {
  const provider = configuration.provider;
  if (provider === "s3") {
    return s3Url(configuration);
  }
  if (provider === "spaces") {
    return spacesUrl(configuration);
  }
  throw new Error(`Not supported provider: ${provider}`);
}
publishOptions.getS3LikeProviderBaseUrl = getS3LikeProviderBaseUrl;
function s3Url(options) {
  let url;
  if (options.endpoint != null) {
    url = `${options.endpoint}/${options.bucket}`;
  } else if (options.bucket.includes(".")) {
    if (options.region == null) {
      throw new Error(`Bucket name "${options.bucket}" includes a dot, but S3 region is missing`);
    }
    if (options.region === "us-east-1") {
      url = `https://s3.amazonaws.com/${options.bucket}`;
    } else {
      url = `https://s3-${options.region}.amazonaws.com/${options.bucket}`;
    }
  } else if (options.region === "cn-north-1") {
    url = `https://${options.bucket}.s3.${options.region}.amazonaws.com.cn`;
  } else {
    url = `https://${options.bucket}.s3.amazonaws.com`;
  }
  return appendPath(url, options.path);
}
function appendPath(url, p) {
  if (p != null && p.length > 0) {
    if (!p.startsWith("/")) {
      url += "/";
    }
    url += p;
  }
  return url;
}
function spacesUrl(options) {
  if (options.name == null) {
    throw new Error(`name is missing`);
  }
  if (options.region == null) {
    throw new Error(`region is missing`);
  }
  return appendPath(`https://${options.name}.${options.region}.digitaloceanspaces.com`, options.path);
}
var rfc2253Parser = {};
Object.defineProperty(rfc2253Parser, "__esModule", { value: true });
rfc2253Parser.parseDn = void 0;
function parseDn(seq2) {
  let quoted = false;
  let key = null;
  let token = "";
  let nextNonSpace = 0;
  seq2 = seq2.trim();
  const result = new Map();
  for (let i2 = 0; i2 <= seq2.length; i2++) {
    if (i2 === seq2.length) {
      if (key !== null) {
        result.set(key, token);
      }
      break;
    }
    const ch = seq2[i2];
    if (quoted) {
      if (ch === '"') {
        quoted = false;
        continue;
      }
    } else {
      if (ch === '"') {
        quoted = true;
        continue;
      }
      if (ch === "\\") {
        i2++;
        const ord = parseInt(seq2.slice(i2, i2 + 2), 16);
        if (Number.isNaN(ord)) {
          token += seq2[i2];
        } else {
          i2++;
          token += String.fromCharCode(ord);
        }
        continue;
      }
      if (key === null && ch === "=") {
        key = token;
        token = "";
        continue;
      }
      if (ch === "," || ch === ";" || ch === "+") {
        if (key !== null) {
          result.set(key, token);
        }
        key = null;
        token = "";
        continue;
      }
    }
    if (ch === " " && !quoted) {
      if (token.length === 0) {
        continue;
      }
      if (i2 > nextNonSpace) {
        let j = i2;
        while (seq2[j] === " ") {
          j++;
        }
        nextNonSpace = j;
      }
      if (nextNonSpace >= seq2.length || seq2[nextNonSpace] === "," || seq2[nextNonSpace] === ";" || key === null && seq2[nextNonSpace] === "=" || key !== null && seq2[nextNonSpace] === "+") {
        i2 = nextNonSpace - 1;
        continue;
      }
    }
    token += ch;
  }
  return result;
}
rfc2253Parser.parseDn = parseDn;
var uuid = {};
Object.defineProperty(uuid, "__esModule", { value: true });
uuid.nil = uuid.UUID = void 0;
const crypto_1$2 = require$$0__default$4["default"];
const index_1$1 = out;
const invalidName = "options.name must be either a string or a Buffer";
const randomHost = crypto_1$2.randomBytes(16);
randomHost[0] = randomHost[0] | 1;
const hex2byte = {};
const byte2hex = [];
for (let i2 = 0; i2 < 256; i2++) {
  const hex = (i2 + 256).toString(16).substr(1);
  hex2byte[hex] = i2;
  byte2hex[i2] = hex;
}
class UUID {
  constructor(uuid2) {
    this.ascii = null;
    this.binary = null;
    const check = UUID.check(uuid2);
    if (!check) {
      throw new Error("not a UUID");
    }
    this.version = check.version;
    if (check.format === "ascii") {
      this.ascii = uuid2;
    } else {
      this.binary = uuid2;
    }
  }
  static v5(name, namespace) {
    return uuidNamed(name, "sha1", 80, namespace);
  }
  toString() {
    if (this.ascii == null) {
      this.ascii = stringify(this.binary);
    }
    return this.ascii;
  }
  inspect() {
    return `UUID v${this.version} ${this.toString()}`;
  }
  static check(uuid2, offset = 0) {
    if (typeof uuid2 === "string") {
      uuid2 = uuid2.toLowerCase();
      if (!/^[a-f0-9]{8}(-[a-f0-9]{4}){3}-([a-f0-9]{12})$/.test(uuid2)) {
        return false;
      }
      if (uuid2 === "00000000-0000-0000-0000-000000000000") {
        return { version: void 0, variant: "nil", format: "ascii" };
      }
      return {
        version: (hex2byte[uuid2[14] + uuid2[15]] & 240) >> 4,
        variant: getVariant((hex2byte[uuid2[19] + uuid2[20]] & 224) >> 5),
        format: "ascii"
      };
    }
    if (Buffer.isBuffer(uuid2)) {
      if (uuid2.length < offset + 16) {
        return false;
      }
      let i2 = 0;
      for (; i2 < 16; i2++) {
        if (uuid2[offset + i2] !== 0) {
          break;
        }
      }
      if (i2 === 16) {
        return { version: void 0, variant: "nil", format: "binary" };
      }
      return {
        version: (uuid2[offset + 6] & 240) >> 4,
        variant: getVariant((uuid2[offset + 8] & 224) >> 5),
        format: "binary"
      };
    }
    throw index_1$1.newError("Unknown type of uuid", "ERR_UNKNOWN_UUID_TYPE");
  }
  static parse(input) {
    const buffer = Buffer.allocUnsafe(16);
    let j = 0;
    for (let i2 = 0; i2 < 16; i2++) {
      buffer[i2] = hex2byte[input[j++] + input[j++]];
      if (i2 === 3 || i2 === 5 || i2 === 7 || i2 === 9) {
        j += 1;
      }
    }
    return buffer;
  }
}
uuid.UUID = UUID;
UUID.OID = UUID.parse("6ba7b812-9dad-11d1-80b4-00c04fd430c8");
function getVariant(bits) {
  switch (bits) {
    case 0:
    case 1:
    case 3:
      return "ncs";
    case 4:
    case 5:
      return "rfc4122";
    case 6:
      return "microsoft";
    default:
      return "future";
  }
}
var UuidEncoding;
(function(UuidEncoding2) {
  UuidEncoding2[UuidEncoding2["ASCII"] = 0] = "ASCII";
  UuidEncoding2[UuidEncoding2["BINARY"] = 1] = "BINARY";
  UuidEncoding2[UuidEncoding2["OBJECT"] = 2] = "OBJECT";
})(UuidEncoding || (UuidEncoding = {}));
function uuidNamed(name, hashMethod, version, namespace, encoding = UuidEncoding.ASCII) {
  const hash = crypto_1$2.createHash(hashMethod);
  const nameIsNotAString = typeof name !== "string";
  if (nameIsNotAString && !Buffer.isBuffer(name)) {
    throw index_1$1.newError(invalidName, "ERR_INVALID_UUID_NAME");
  }
  hash.update(namespace);
  hash.update(name);
  const buffer = hash.digest();
  let result;
  switch (encoding) {
    case UuidEncoding.BINARY:
      buffer[6] = buffer[6] & 15 | version;
      buffer[8] = buffer[8] & 63 | 128;
      result = buffer;
      break;
    case UuidEncoding.OBJECT:
      buffer[6] = buffer[6] & 15 | version;
      buffer[8] = buffer[8] & 63 | 128;
      result = new UUID(buffer);
      break;
    default:
      result = byte2hex[buffer[0]] + byte2hex[buffer[1]] + byte2hex[buffer[2]] + byte2hex[buffer[3]] + "-" + byte2hex[buffer[4]] + byte2hex[buffer[5]] + "-" + byte2hex[buffer[6] & 15 | version] + byte2hex[buffer[7]] + "-" + byte2hex[buffer[8] & 63 | 128] + byte2hex[buffer[9]] + "-" + byte2hex[buffer[10]] + byte2hex[buffer[11]] + byte2hex[buffer[12]] + byte2hex[buffer[13]] + byte2hex[buffer[14]] + byte2hex[buffer[15]];
      break;
  }
  return result;
}
function stringify(buffer) {
  return byte2hex[buffer[0]] + byte2hex[buffer[1]] + byte2hex[buffer[2]] + byte2hex[buffer[3]] + "-" + byte2hex[buffer[4]] + byte2hex[buffer[5]] + "-" + byte2hex[buffer[6]] + byte2hex[buffer[7]] + "-" + byte2hex[buffer[8]] + byte2hex[buffer[9]] + "-" + byte2hex[buffer[10]] + byte2hex[buffer[11]] + byte2hex[buffer[12]] + byte2hex[buffer[13]] + byte2hex[buffer[14]] + byte2hex[buffer[15]];
}
uuid.nil = new UUID("00000000-0000-0000-0000-000000000000");
var xml = {};
var sax$1 = {};
(function(exports) {
  (function(sax2) {
    sax2.parser = function(strict, opt) {
      return new SAXParser(strict, opt);
    };
    sax2.SAXParser = SAXParser;
    sax2.SAXStream = SAXStream;
    sax2.createStream = createStream;
    sax2.MAX_BUFFER_LENGTH = 64 * 1024;
    var buffers = [
      "comment",
      "sgmlDecl",
      "textNode",
      "tagName",
      "doctype",
      "procInstName",
      "procInstBody",
      "entity",
      "attribName",
      "attribValue",
      "cdata",
      "script"
    ];
    sax2.EVENTS = [
      "text",
      "processinginstruction",
      "sgmldeclaration",
      "doctype",
      "comment",
      "opentagstart",
      "attribute",
      "opentag",
      "closetag",
      "opencdata",
      "cdata",
      "closecdata",
      "error",
      "end",
      "ready",
      "script",
      "opennamespace",
      "closenamespace"
    ];
    function SAXParser(strict, opt) {
      if (!(this instanceof SAXParser)) {
        return new SAXParser(strict, opt);
      }
      var parser = this;
      clearBuffers(parser);
      parser.q = parser.c = "";
      parser.bufferCheckPosition = sax2.MAX_BUFFER_LENGTH;
      parser.opt = opt || {};
      parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
      parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
      parser.tags = [];
      parser.closed = parser.closedRoot = parser.sawRoot = false;
      parser.tag = parser.error = null;
      parser.strict = !!strict;
      parser.noscript = !!(strict || parser.opt.noscript);
      parser.state = S.BEGIN;
      parser.strictEntities = parser.opt.strictEntities;
      parser.ENTITIES = parser.strictEntities ? Object.create(sax2.XML_ENTITIES) : Object.create(sax2.ENTITIES);
      parser.attribList = [];
      if (parser.opt.xmlns) {
        parser.ns = Object.create(rootNS);
      }
      parser.trackPosition = parser.opt.position !== false;
      if (parser.trackPosition) {
        parser.position = parser.line = parser.column = 0;
      }
      emit(parser, "onready");
    }
    if (!Object.create) {
      Object.create = function(o) {
        function F() {
        }
        F.prototype = o;
        var newf = new F();
        return newf;
      };
    }
    if (!Object.keys) {
      Object.keys = function(o) {
        var a = [];
        for (var i2 in o)
          if (o.hasOwnProperty(i2))
            a.push(i2);
        return a;
      };
    }
    function checkBufferLength(parser) {
      var maxAllowed = Math.max(sax2.MAX_BUFFER_LENGTH, 10);
      var maxActual = 0;
      for (var i2 = 0, l = buffers.length; i2 < l; i2++) {
        var len = parser[buffers[i2]].length;
        if (len > maxAllowed) {
          switch (buffers[i2]) {
            case "textNode":
              closeText(parser);
              break;
            case "cdata":
              emitNode(parser, "oncdata", parser.cdata);
              parser.cdata = "";
              break;
            case "script":
              emitNode(parser, "onscript", parser.script);
              parser.script = "";
              break;
            default:
              error2(parser, "Max buffer length exceeded: " + buffers[i2]);
          }
        }
        maxActual = Math.max(maxActual, len);
      }
      var m2 = sax2.MAX_BUFFER_LENGTH - maxActual;
      parser.bufferCheckPosition = m2 + parser.position;
    }
    function clearBuffers(parser) {
      for (var i2 = 0, l = buffers.length; i2 < l; i2++) {
        parser[buffers[i2]] = "";
      }
    }
    function flushBuffers(parser) {
      closeText(parser);
      if (parser.cdata !== "") {
        emitNode(parser, "oncdata", parser.cdata);
        parser.cdata = "";
      }
      if (parser.script !== "") {
        emitNode(parser, "onscript", parser.script);
        parser.script = "";
      }
    }
    SAXParser.prototype = {
      end: function() {
        end(this);
      },
      write,
      resume: function() {
        this.error = null;
        return this;
      },
      close: function() {
        return this.write(null);
      },
      flush: function() {
        flushBuffers(this);
      }
    };
    var Stream2;
    try {
      Stream2 = require$$0__default$1["default"].Stream;
    } catch (ex) {
      Stream2 = function() {
      };
    }
    var streamWraps = sax2.EVENTS.filter(function(ev) {
      return ev !== "error" && ev !== "end";
    });
    function createStream(strict, opt) {
      return new SAXStream(strict, opt);
    }
    function SAXStream(strict, opt) {
      if (!(this instanceof SAXStream)) {
        return new SAXStream(strict, opt);
      }
      Stream2.apply(this);
      this._parser = new SAXParser(strict, opt);
      this.writable = true;
      this.readable = true;
      var me = this;
      this._parser.onend = function() {
        me.emit("end");
      };
      this._parser.onerror = function(er) {
        me.emit("error", er);
        me._parser.error = null;
      };
      this._decoder = null;
      streamWraps.forEach(function(ev) {
        Object.defineProperty(me, "on" + ev, {
          get: function() {
            return me._parser["on" + ev];
          },
          set: function(h2) {
            if (!h2) {
              me.removeAllListeners(ev);
              me._parser["on" + ev] = h2;
              return h2;
            }
            me.on(ev, h2);
          },
          enumerable: true,
          configurable: false
        });
      });
    }
    SAXStream.prototype = Object.create(Stream2.prototype, {
      constructor: {
        value: SAXStream
      }
    });
    SAXStream.prototype.write = function(data) {
      if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
        if (!this._decoder) {
          var SD = require$$1__default$2["default"].StringDecoder;
          this._decoder = new SD("utf8");
        }
        data = this._decoder.write(data);
      }
      this._parser.write(data.toString());
      this.emit("data", data);
      return true;
    };
    SAXStream.prototype.end = function(chunk) {
      if (chunk && chunk.length) {
        this.write(chunk);
      }
      this._parser.end();
      return true;
    };
    SAXStream.prototype.on = function(ev, handler) {
      var me = this;
      if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
        me._parser["on" + ev] = function() {
          var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
          args.splice(0, 0, ev);
          me.emit.apply(me, args);
        };
      }
      return Stream2.prototype.on.call(me, ev, handler);
    };
    var CDATA = "[CDATA[";
    var DOCTYPE = "DOCTYPE";
    var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
    var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
    var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
    var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    function isWhitespace2(c) {
      return c === " " || c === "\n" || c === "\r" || c === "	";
    }
    function isQuote(c) {
      return c === '"' || c === "'";
    }
    function isAttribEnd(c) {
      return c === ">" || isWhitespace2(c);
    }
    function isMatch(regex, c) {
      return regex.test(c);
    }
    function notMatch(regex, c) {
      return !isMatch(regex, c);
    }
    var S = 0;
    sax2.STATE = {
      BEGIN: S++,
      BEGIN_WHITESPACE: S++,
      TEXT: S++,
      TEXT_ENTITY: S++,
      OPEN_WAKA: S++,
      SGML_DECL: S++,
      SGML_DECL_QUOTED: S++,
      DOCTYPE: S++,
      DOCTYPE_QUOTED: S++,
      DOCTYPE_DTD: S++,
      DOCTYPE_DTD_QUOTED: S++,
      COMMENT_STARTING: S++,
      COMMENT: S++,
      COMMENT_ENDING: S++,
      COMMENT_ENDED: S++,
      CDATA: S++,
      CDATA_ENDING: S++,
      CDATA_ENDING_2: S++,
      PROC_INST: S++,
      PROC_INST_BODY: S++,
      PROC_INST_ENDING: S++,
      OPEN_TAG: S++,
      OPEN_TAG_SLASH: S++,
      ATTRIB: S++,
      ATTRIB_NAME: S++,
      ATTRIB_NAME_SAW_WHITE: S++,
      ATTRIB_VALUE: S++,
      ATTRIB_VALUE_QUOTED: S++,
      ATTRIB_VALUE_CLOSED: S++,
      ATTRIB_VALUE_UNQUOTED: S++,
      ATTRIB_VALUE_ENTITY_Q: S++,
      ATTRIB_VALUE_ENTITY_U: S++,
      CLOSE_TAG: S++,
      CLOSE_TAG_SAW_WHITE: S++,
      SCRIPT: S++,
      SCRIPT_ENDING: S++
    };
    sax2.XML_ENTITIES = {
      "amp": "&",
      "gt": ">",
      "lt": "<",
      "quot": '"',
      "apos": "'"
    };
    sax2.ENTITIES = {
      "amp": "&",
      "gt": ">",
      "lt": "<",
      "quot": '"',
      "apos": "'",
      "AElig": 198,
      "Aacute": 193,
      "Acirc": 194,
      "Agrave": 192,
      "Aring": 197,
      "Atilde": 195,
      "Auml": 196,
      "Ccedil": 199,
      "ETH": 208,
      "Eacute": 201,
      "Ecirc": 202,
      "Egrave": 200,
      "Euml": 203,
      "Iacute": 205,
      "Icirc": 206,
      "Igrave": 204,
      "Iuml": 207,
      "Ntilde": 209,
      "Oacute": 211,
      "Ocirc": 212,
      "Ograve": 210,
      "Oslash": 216,
      "Otilde": 213,
      "Ouml": 214,
      "THORN": 222,
      "Uacute": 218,
      "Ucirc": 219,
      "Ugrave": 217,
      "Uuml": 220,
      "Yacute": 221,
      "aacute": 225,
      "acirc": 226,
      "aelig": 230,
      "agrave": 224,
      "aring": 229,
      "atilde": 227,
      "auml": 228,
      "ccedil": 231,
      "eacute": 233,
      "ecirc": 234,
      "egrave": 232,
      "eth": 240,
      "euml": 235,
      "iacute": 237,
      "icirc": 238,
      "igrave": 236,
      "iuml": 239,
      "ntilde": 241,
      "oacute": 243,
      "ocirc": 244,
      "ograve": 242,
      "oslash": 248,
      "otilde": 245,
      "ouml": 246,
      "szlig": 223,
      "thorn": 254,
      "uacute": 250,
      "ucirc": 251,
      "ugrave": 249,
      "uuml": 252,
      "yacute": 253,
      "yuml": 255,
      "copy": 169,
      "reg": 174,
      "nbsp": 160,
      "iexcl": 161,
      "cent": 162,
      "pound": 163,
      "curren": 164,
      "yen": 165,
      "brvbar": 166,
      "sect": 167,
      "uml": 168,
      "ordf": 170,
      "laquo": 171,
      "not": 172,
      "shy": 173,
      "macr": 175,
      "deg": 176,
      "plusmn": 177,
      "sup1": 185,
      "sup2": 178,
      "sup3": 179,
      "acute": 180,
      "micro": 181,
      "para": 182,
      "middot": 183,
      "cedil": 184,
      "ordm": 186,
      "raquo": 187,
      "frac14": 188,
      "frac12": 189,
      "frac34": 190,
      "iquest": 191,
      "times": 215,
      "divide": 247,
      "OElig": 338,
      "oelig": 339,
      "Scaron": 352,
      "scaron": 353,
      "Yuml": 376,
      "fnof": 402,
      "circ": 710,
      "tilde": 732,
      "Alpha": 913,
      "Beta": 914,
      "Gamma": 915,
      "Delta": 916,
      "Epsilon": 917,
      "Zeta": 918,
      "Eta": 919,
      "Theta": 920,
      "Iota": 921,
      "Kappa": 922,
      "Lambda": 923,
      "Mu": 924,
      "Nu": 925,
      "Xi": 926,
      "Omicron": 927,
      "Pi": 928,
      "Rho": 929,
      "Sigma": 931,
      "Tau": 932,
      "Upsilon": 933,
      "Phi": 934,
      "Chi": 935,
      "Psi": 936,
      "Omega": 937,
      "alpha": 945,
      "beta": 946,
      "gamma": 947,
      "delta": 948,
      "epsilon": 949,
      "zeta": 950,
      "eta": 951,
      "theta": 952,
      "iota": 953,
      "kappa": 954,
      "lambda": 955,
      "mu": 956,
      "nu": 957,
      "xi": 958,
      "omicron": 959,
      "pi": 960,
      "rho": 961,
      "sigmaf": 962,
      "sigma": 963,
      "tau": 964,
      "upsilon": 965,
      "phi": 966,
      "chi": 967,
      "psi": 968,
      "omega": 969,
      "thetasym": 977,
      "upsih": 978,
      "piv": 982,
      "ensp": 8194,
      "emsp": 8195,
      "thinsp": 8201,
      "zwnj": 8204,
      "zwj": 8205,
      "lrm": 8206,
      "rlm": 8207,
      "ndash": 8211,
      "mdash": 8212,
      "lsquo": 8216,
      "rsquo": 8217,
      "sbquo": 8218,
      "ldquo": 8220,
      "rdquo": 8221,
      "bdquo": 8222,
      "dagger": 8224,
      "Dagger": 8225,
      "bull": 8226,
      "hellip": 8230,
      "permil": 8240,
      "prime": 8242,
      "Prime": 8243,
      "lsaquo": 8249,
      "rsaquo": 8250,
      "oline": 8254,
      "frasl": 8260,
      "euro": 8364,
      "image": 8465,
      "weierp": 8472,
      "real": 8476,
      "trade": 8482,
      "alefsym": 8501,
      "larr": 8592,
      "uarr": 8593,
      "rarr": 8594,
      "darr": 8595,
      "harr": 8596,
      "crarr": 8629,
      "lArr": 8656,
      "uArr": 8657,
      "rArr": 8658,
      "dArr": 8659,
      "hArr": 8660,
      "forall": 8704,
      "part": 8706,
      "exist": 8707,
      "empty": 8709,
      "nabla": 8711,
      "isin": 8712,
      "notin": 8713,
      "ni": 8715,
      "prod": 8719,
      "sum": 8721,
      "minus": 8722,
      "lowast": 8727,
      "radic": 8730,
      "prop": 8733,
      "infin": 8734,
      "ang": 8736,
      "and": 8743,
      "or": 8744,
      "cap": 8745,
      "cup": 8746,
      "int": 8747,
      "there4": 8756,
      "sim": 8764,
      "cong": 8773,
      "asymp": 8776,
      "ne": 8800,
      "equiv": 8801,
      "le": 8804,
      "ge": 8805,
      "sub": 8834,
      "sup": 8835,
      "nsub": 8836,
      "sube": 8838,
      "supe": 8839,
      "oplus": 8853,
      "otimes": 8855,
      "perp": 8869,
      "sdot": 8901,
      "lceil": 8968,
      "rceil": 8969,
      "lfloor": 8970,
      "rfloor": 8971,
      "lang": 9001,
      "rang": 9002,
      "loz": 9674,
      "spades": 9824,
      "clubs": 9827,
      "hearts": 9829,
      "diams": 9830
    };
    Object.keys(sax2.ENTITIES).forEach(function(key) {
      var e = sax2.ENTITIES[key];
      var s3 = typeof e === "number" ? String.fromCharCode(e) : e;
      sax2.ENTITIES[key] = s3;
    });
    for (var s2 in sax2.STATE) {
      sax2.STATE[sax2.STATE[s2]] = s2;
    }
    S = sax2.STATE;
    function emit(parser, event, data) {
      parser[event] && parser[event](data);
    }
    function emitNode(parser, nodeType, data) {
      if (parser.textNode)
        closeText(parser);
      emit(parser, nodeType, data);
    }
    function closeText(parser) {
      parser.textNode = textopts(parser.opt, parser.textNode);
      if (parser.textNode)
        emit(parser, "ontext", parser.textNode);
      parser.textNode = "";
    }
    function textopts(opt, text) {
      if (opt.trim)
        text = text.trim();
      if (opt.normalize)
        text = text.replace(/\s+/g, " ");
      return text;
    }
    function error2(parser, er) {
      closeText(parser);
      if (parser.trackPosition) {
        er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
      }
      er = new Error(er);
      parser.error = er;
      emit(parser, "onerror", er);
      return parser;
    }
    function end(parser) {
      if (parser.sawRoot && !parser.closedRoot)
        strictFail(parser, "Unclosed root tag");
      if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
        error2(parser, "Unexpected end");
      }
      closeText(parser);
      parser.c = "";
      parser.closed = true;
      emit(parser, "onend");
      SAXParser.call(parser, parser.strict, parser.opt);
      return parser;
    }
    function strictFail(parser, message) {
      if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
        throw new Error("bad call to strictFail");
      }
      if (parser.strict) {
        error2(parser, message);
      }
    }
    function newTag(parser) {
      if (!parser.strict)
        parser.tagName = parser.tagName[parser.looseCase]();
      var parent = parser.tags[parser.tags.length - 1] || parser;
      var tag = parser.tag = { name: parser.tagName, attributes: {} };
      if (parser.opt.xmlns) {
        tag.ns = parent.ns;
      }
      parser.attribList.length = 0;
      emitNode(parser, "onopentagstart", tag);
    }
    function qname(name, attribute) {
      var i2 = name.indexOf(":");
      var qualName = i2 < 0 ? ["", name] : name.split(":");
      var prefix = qualName[0];
      var local = qualName[1];
      if (attribute && name === "xmlns") {
        prefix = "xmlns";
        local = "";
      }
      return { prefix, local };
    }
    function attrib(parser) {
      if (!parser.strict) {
        parser.attribName = parser.attribName[parser.looseCase]();
      }
      if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
        parser.attribName = parser.attribValue = "";
        return;
      }
      if (parser.opt.xmlns) {
        var qn = qname(parser.attribName, true);
        var prefix = qn.prefix;
        var local = qn.local;
        if (prefix === "xmlns") {
          if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
            strictFail(parser, "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue);
          } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
            strictFail(parser, "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue);
          } else {
            var tag = parser.tag;
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (tag.ns === parent.ns) {
              tag.ns = Object.create(parent.ns);
            }
            tag.ns[local] = parser.attribValue;
          }
        }
        parser.attribList.push([parser.attribName, parser.attribValue]);
      } else {
        parser.tag.attributes[parser.attribName] = parser.attribValue;
        emitNode(parser, "onattribute", {
          name: parser.attribName,
          value: parser.attribValue
        });
      }
      parser.attribName = parser.attribValue = "";
    }
    function openTag(parser, selfClosing) {
      if (parser.opt.xmlns) {
        var tag = parser.tag;
        var qn = qname(parser.tagName);
        tag.prefix = qn.prefix;
        tag.local = qn.local;
        tag.uri = tag.ns[qn.prefix] || "";
        if (tag.prefix && !tag.uri) {
          strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
          tag.uri = qn.prefix;
        }
        var parent = parser.tags[parser.tags.length - 1] || parser;
        if (tag.ns && parent.ns !== tag.ns) {
          Object.keys(tag.ns).forEach(function(p) {
            emitNode(parser, "onopennamespace", {
              prefix: p,
              uri: tag.ns[p]
            });
          });
        }
        for (var i2 = 0, l = parser.attribList.length; i2 < l; i2++) {
          var nv = parser.attribList[i2];
          var name = nv[0];
          var value = nv[1];
          var qualName = qname(name, true);
          var prefix = qualName.prefix;
          var local = qualName.local;
          var uri = prefix === "" ? "" : tag.ns[prefix] || "";
          var a = {
            name,
            value,
            prefix,
            local,
            uri
          };
          if (prefix && prefix !== "xmlns" && !uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
            a.uri = prefix;
          }
          parser.tag.attributes[name] = a;
          emitNode(parser, "onattribute", a);
        }
        parser.attribList.length = 0;
      }
      parser.tag.isSelfClosing = !!selfClosing;
      parser.sawRoot = true;
      parser.tags.push(parser.tag);
      emitNode(parser, "onopentag", parser.tag);
      if (!selfClosing) {
        if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
          parser.state = S.SCRIPT;
        } else {
          parser.state = S.TEXT;
        }
        parser.tag = null;
        parser.tagName = "";
      }
      parser.attribName = parser.attribValue = "";
      parser.attribList.length = 0;
    }
    function closeTag(parser) {
      if (!parser.tagName) {
        strictFail(parser, "Weird empty close tag.");
        parser.textNode += "</>";
        parser.state = S.TEXT;
        return;
      }
      if (parser.script) {
        if (parser.tagName !== "script") {
          parser.script += "</" + parser.tagName + ">";
          parser.tagName = "";
          parser.state = S.SCRIPT;
          return;
        }
        emitNode(parser, "onscript", parser.script);
        parser.script = "";
      }
      var t2 = parser.tags.length;
      var tagName = parser.tagName;
      if (!parser.strict) {
        tagName = tagName[parser.looseCase]();
      }
      var closeTo = tagName;
      while (t2--) {
        var close = parser.tags[t2];
        if (close.name !== closeTo) {
          strictFail(parser, "Unexpected close tag");
        } else {
          break;
        }
      }
      if (t2 < 0) {
        strictFail(parser, "Unmatched closing tag: " + parser.tagName);
        parser.textNode += "</" + parser.tagName + ">";
        parser.state = S.TEXT;
        return;
      }
      parser.tagName = tagName;
      var s3 = parser.tags.length;
      while (s3-- > t2) {
        var tag = parser.tag = parser.tags.pop();
        parser.tagName = parser.tag.name;
        emitNode(parser, "onclosetag", parser.tagName);
        var x = {};
        for (var i2 in tag.ns) {
          x[i2] = tag.ns[i2];
        }
        var parent = parser.tags[parser.tags.length - 1] || parser;
        if (parser.opt.xmlns && tag.ns !== parent.ns) {
          Object.keys(tag.ns).forEach(function(p) {
            var n = tag.ns[p];
            emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
          });
        }
      }
      if (t2 === 0)
        parser.closedRoot = true;
      parser.tagName = parser.attribValue = parser.attribName = "";
      parser.attribList.length = 0;
      parser.state = S.TEXT;
    }
    function parseEntity(parser) {
      var entity = parser.entity;
      var entityLC = entity.toLowerCase();
      var num;
      var numStr = "";
      if (parser.ENTITIES[entity]) {
        return parser.ENTITIES[entity];
      }
      if (parser.ENTITIES[entityLC]) {
        return parser.ENTITIES[entityLC];
      }
      entity = entityLC;
      if (entity.charAt(0) === "#") {
        if (entity.charAt(1) === "x") {
          entity = entity.slice(2);
          num = parseInt(entity, 16);
          numStr = num.toString(16);
        } else {
          entity = entity.slice(1);
          num = parseInt(entity, 10);
          numStr = num.toString(10);
        }
      }
      entity = entity.replace(/^0+/, "");
      if (isNaN(num) || numStr.toLowerCase() !== entity) {
        strictFail(parser, "Invalid character entity");
        return "&" + parser.entity + ";";
      }
      return String.fromCodePoint(num);
    }
    function beginWhiteSpace(parser, c) {
      if (c === "<") {
        parser.state = S.OPEN_WAKA;
        parser.startTagPosition = parser.position;
      } else if (!isWhitespace2(c)) {
        strictFail(parser, "Non-whitespace before first tag.");
        parser.textNode = c;
        parser.state = S.TEXT;
      }
    }
    function charAt(chunk, i2) {
      var result = "";
      if (i2 < chunk.length) {
        result = chunk.charAt(i2);
      }
      return result;
    }
    function write(chunk) {
      var parser = this;
      if (this.error) {
        throw this.error;
      }
      if (parser.closed) {
        return error2(parser, "Cannot write after close. Assign an onready handler.");
      }
      if (chunk === null) {
        return end(parser);
      }
      if (typeof chunk === "object") {
        chunk = chunk.toString();
      }
      var i2 = 0;
      var c = "";
      while (true) {
        c = charAt(chunk, i2++);
        parser.c = c;
        if (!c) {
          break;
        }
        if (parser.trackPosition) {
          parser.position++;
          if (c === "\n") {
            parser.line++;
            parser.column = 0;
          } else {
            parser.column++;
          }
        }
        switch (parser.state) {
          case S.BEGIN:
            parser.state = S.BEGIN_WHITESPACE;
            if (c === "\uFEFF") {
              continue;
            }
            beginWhiteSpace(parser, c);
            continue;
          case S.BEGIN_WHITESPACE:
            beginWhiteSpace(parser, c);
            continue;
          case S.TEXT:
            if (parser.sawRoot && !parser.closedRoot) {
              var starti = i2 - 1;
              while (c && c !== "<" && c !== "&") {
                c = charAt(chunk, i2++);
                if (c && parser.trackPosition) {
                  parser.position++;
                  if (c === "\n") {
                    parser.line++;
                    parser.column = 0;
                  } else {
                    parser.column++;
                  }
                }
              }
              parser.textNode += chunk.substring(starti, i2 - 1);
            }
            if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
              parser.state = S.OPEN_WAKA;
              parser.startTagPosition = parser.position;
            } else {
              if (!isWhitespace2(c) && (!parser.sawRoot || parser.closedRoot)) {
                strictFail(parser, "Text data outside of root node.");
              }
              if (c === "&") {
                parser.state = S.TEXT_ENTITY;
              } else {
                parser.textNode += c;
              }
            }
            continue;
          case S.SCRIPT:
            if (c === "<") {
              parser.state = S.SCRIPT_ENDING;
            } else {
              parser.script += c;
            }
            continue;
          case S.SCRIPT_ENDING:
            if (c === "/") {
              parser.state = S.CLOSE_TAG;
            } else {
              parser.script += "<" + c;
              parser.state = S.SCRIPT;
            }
            continue;
          case S.OPEN_WAKA:
            if (c === "!") {
              parser.state = S.SGML_DECL;
              parser.sgmlDecl = "";
            } else if (isWhitespace2(c))
              ;
            else if (isMatch(nameStart, c)) {
              parser.state = S.OPEN_TAG;
              parser.tagName = c;
            } else if (c === "/") {
              parser.state = S.CLOSE_TAG;
              parser.tagName = "";
            } else if (c === "?") {
              parser.state = S.PROC_INST;
              parser.procInstName = parser.procInstBody = "";
            } else {
              strictFail(parser, "Unencoded <");
              if (parser.startTagPosition + 1 < parser.position) {
                var pad = parser.position - parser.startTagPosition;
                c = new Array(pad).join(" ") + c;
              }
              parser.textNode += "<" + c;
              parser.state = S.TEXT;
            }
            continue;
          case S.SGML_DECL:
            if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
              emitNode(parser, "onopencdata");
              parser.state = S.CDATA;
              parser.sgmlDecl = "";
              parser.cdata = "";
            } else if (parser.sgmlDecl + c === "--") {
              parser.state = S.COMMENT;
              parser.comment = "";
              parser.sgmlDecl = "";
            } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
              parser.state = S.DOCTYPE;
              if (parser.doctype || parser.sawRoot) {
                strictFail(parser, "Inappropriately located doctype declaration");
              }
              parser.doctype = "";
              parser.sgmlDecl = "";
            } else if (c === ">") {
              emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
              parser.sgmlDecl = "";
              parser.state = S.TEXT;
            } else if (isQuote(c)) {
              parser.state = S.SGML_DECL_QUOTED;
              parser.sgmlDecl += c;
            } else {
              parser.sgmlDecl += c;
            }
            continue;
          case S.SGML_DECL_QUOTED:
            if (c === parser.q) {
              parser.state = S.SGML_DECL;
              parser.q = "";
            }
            parser.sgmlDecl += c;
            continue;
          case S.DOCTYPE:
            if (c === ">") {
              parser.state = S.TEXT;
              emitNode(parser, "ondoctype", parser.doctype);
              parser.doctype = true;
            } else {
              parser.doctype += c;
              if (c === "[") {
                parser.state = S.DOCTYPE_DTD;
              } else if (isQuote(c)) {
                parser.state = S.DOCTYPE_QUOTED;
                parser.q = c;
              }
            }
            continue;
          case S.DOCTYPE_QUOTED:
            parser.doctype += c;
            if (c === parser.q) {
              parser.q = "";
              parser.state = S.DOCTYPE;
            }
            continue;
          case S.DOCTYPE_DTD:
            parser.doctype += c;
            if (c === "]") {
              parser.state = S.DOCTYPE;
            } else if (isQuote(c)) {
              parser.state = S.DOCTYPE_DTD_QUOTED;
              parser.q = c;
            }
            continue;
          case S.DOCTYPE_DTD_QUOTED:
            parser.doctype += c;
            if (c === parser.q) {
              parser.state = S.DOCTYPE_DTD;
              parser.q = "";
            }
            continue;
          case S.COMMENT:
            if (c === "-") {
              parser.state = S.COMMENT_ENDING;
            } else {
              parser.comment += c;
            }
            continue;
          case S.COMMENT_ENDING:
            if (c === "-") {
              parser.state = S.COMMENT_ENDED;
              parser.comment = textopts(parser.opt, parser.comment);
              if (parser.comment) {
                emitNode(parser, "oncomment", parser.comment);
              }
              parser.comment = "";
            } else {
              parser.comment += "-" + c;
              parser.state = S.COMMENT;
            }
            continue;
          case S.COMMENT_ENDED:
            if (c !== ">") {
              strictFail(parser, "Malformed comment");
              parser.comment += "--" + c;
              parser.state = S.COMMENT;
            } else {
              parser.state = S.TEXT;
            }
            continue;
          case S.CDATA:
            if (c === "]") {
              parser.state = S.CDATA_ENDING;
            } else {
              parser.cdata += c;
            }
            continue;
          case S.CDATA_ENDING:
            if (c === "]") {
              parser.state = S.CDATA_ENDING_2;
            } else {
              parser.cdata += "]" + c;
              parser.state = S.CDATA;
            }
            continue;
          case S.CDATA_ENDING_2:
            if (c === ">") {
              if (parser.cdata) {
                emitNode(parser, "oncdata", parser.cdata);
              }
              emitNode(parser, "onclosecdata");
              parser.cdata = "";
              parser.state = S.TEXT;
            } else if (c === "]") {
              parser.cdata += "]";
            } else {
              parser.cdata += "]]" + c;
              parser.state = S.CDATA;
            }
            continue;
          case S.PROC_INST:
            if (c === "?") {
              parser.state = S.PROC_INST_ENDING;
            } else if (isWhitespace2(c)) {
              parser.state = S.PROC_INST_BODY;
            } else {
              parser.procInstName += c;
            }
            continue;
          case S.PROC_INST_BODY:
            if (!parser.procInstBody && isWhitespace2(c)) {
              continue;
            } else if (c === "?") {
              parser.state = S.PROC_INST_ENDING;
            } else {
              parser.procInstBody += c;
            }
            continue;
          case S.PROC_INST_ENDING:
            if (c === ">") {
              emitNode(parser, "onprocessinginstruction", {
                name: parser.procInstName,
                body: parser.procInstBody
              });
              parser.procInstName = parser.procInstBody = "";
              parser.state = S.TEXT;
            } else {
              parser.procInstBody += "?" + c;
              parser.state = S.PROC_INST_BODY;
            }
            continue;
          case S.OPEN_TAG:
            if (isMatch(nameBody, c)) {
              parser.tagName += c;
            } else {
              newTag(parser);
              if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else {
                if (!isWhitespace2(c)) {
                  strictFail(parser, "Invalid character in tag name");
                }
                parser.state = S.ATTRIB;
              }
            }
            continue;
          case S.OPEN_TAG_SLASH:
            if (c === ">") {
              openTag(parser, true);
              closeTag(parser);
            } else {
              strictFail(parser, "Forward-slash in opening tag not followed by >");
              parser.state = S.ATTRIB;
            }
            continue;
          case S.ATTRIB:
            if (isWhitespace2(c)) {
              continue;
            } else if (c === ">") {
              openTag(parser);
            } else if (c === "/") {
              parser.state = S.OPEN_TAG_SLASH;
            } else if (isMatch(nameStart, c)) {
              parser.attribName = c;
              parser.attribValue = "";
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_NAME:
            if (c === "=") {
              parser.state = S.ATTRIB_VALUE;
            } else if (c === ">") {
              strictFail(parser, "Attribute without value");
              parser.attribValue = parser.attribName;
              attrib(parser);
              openTag(parser);
            } else if (isWhitespace2(c)) {
              parser.state = S.ATTRIB_NAME_SAW_WHITE;
            } else if (isMatch(nameBody, c)) {
              parser.attribName += c;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_NAME_SAW_WHITE:
            if (c === "=") {
              parser.state = S.ATTRIB_VALUE;
            } else if (isWhitespace2(c)) {
              continue;
            } else {
              strictFail(parser, "Attribute without value");
              parser.tag.attributes[parser.attribName] = "";
              parser.attribValue = "";
              emitNode(parser, "onattribute", {
                name: parser.attribName,
                value: ""
              });
              parser.attribName = "";
              if (c === ">") {
                openTag(parser);
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
                parser.state = S.ATTRIB;
              }
            }
            continue;
          case S.ATTRIB_VALUE:
            if (isWhitespace2(c)) {
              continue;
            } else if (isQuote(c)) {
              parser.q = c;
              parser.state = S.ATTRIB_VALUE_QUOTED;
            } else {
              strictFail(parser, "Unquoted attribute value");
              parser.state = S.ATTRIB_VALUE_UNQUOTED;
              parser.attribValue = c;
            }
            continue;
          case S.ATTRIB_VALUE_QUOTED:
            if (c !== parser.q) {
              if (c === "&") {
                parser.state = S.ATTRIB_VALUE_ENTITY_Q;
              } else {
                parser.attribValue += c;
              }
              continue;
            }
            attrib(parser);
            parser.q = "";
            parser.state = S.ATTRIB_VALUE_CLOSED;
            continue;
          case S.ATTRIB_VALUE_CLOSED:
            if (isWhitespace2(c)) {
              parser.state = S.ATTRIB;
            } else if (c === ">") {
              openTag(parser);
            } else if (c === "/") {
              parser.state = S.OPEN_TAG_SLASH;
            } else if (isMatch(nameStart, c)) {
              strictFail(parser, "No whitespace between attributes");
              parser.attribName = c;
              parser.attribValue = "";
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_VALUE_UNQUOTED:
            if (!isAttribEnd(c)) {
              if (c === "&") {
                parser.state = S.ATTRIB_VALUE_ENTITY_U;
              } else {
                parser.attribValue += c;
              }
              continue;
            }
            attrib(parser);
            if (c === ">") {
              openTag(parser);
            } else {
              parser.state = S.ATTRIB;
            }
            continue;
          case S.CLOSE_TAG:
            if (!parser.tagName) {
              if (isWhitespace2(c)) {
                continue;
              } else if (notMatch(nameStart, c)) {
                if (parser.script) {
                  parser.script += "</" + c;
                  parser.state = S.SCRIPT;
                } else {
                  strictFail(parser, "Invalid tagname in closing tag.");
                }
              } else {
                parser.tagName = c;
              }
            } else if (c === ">") {
              closeTag(parser);
            } else if (isMatch(nameBody, c)) {
              parser.tagName += c;
            } else if (parser.script) {
              parser.script += "</" + parser.tagName;
              parser.tagName = "";
              parser.state = S.SCRIPT;
            } else {
              if (!isWhitespace2(c)) {
                strictFail(parser, "Invalid tagname in closing tag");
              }
              parser.state = S.CLOSE_TAG_SAW_WHITE;
            }
            continue;
          case S.CLOSE_TAG_SAW_WHITE:
            if (isWhitespace2(c)) {
              continue;
            }
            if (c === ">") {
              closeTag(parser);
            } else {
              strictFail(parser, "Invalid characters in closing tag");
            }
            continue;
          case S.TEXT_ENTITY:
          case S.ATTRIB_VALUE_ENTITY_Q:
          case S.ATTRIB_VALUE_ENTITY_U:
            var returnState;
            var buffer;
            switch (parser.state) {
              case S.TEXT_ENTITY:
                returnState = S.TEXT;
                buffer = "textNode";
                break;
              case S.ATTRIB_VALUE_ENTITY_Q:
                returnState = S.ATTRIB_VALUE_QUOTED;
                buffer = "attribValue";
                break;
              case S.ATTRIB_VALUE_ENTITY_U:
                returnState = S.ATTRIB_VALUE_UNQUOTED;
                buffer = "attribValue";
                break;
            }
            if (c === ";") {
              parser[buffer] += parseEntity(parser);
              parser.entity = "";
              parser.state = returnState;
            } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
              parser.entity += c;
            } else {
              strictFail(parser, "Invalid character in entity name");
              parser[buffer] += "&" + parser.entity + c;
              parser.entity = "";
              parser.state = returnState;
            }
            continue;
          default:
            throw new Error(parser, "Unknown state: " + parser.state);
        }
      }
      if (parser.position >= parser.bufferCheckPosition) {
        checkBufferLength(parser);
      }
      return parser;
    }
    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
    if (!String.fromCodePoint) {
      (function() {
        var stringFromCharCode = String.fromCharCode;
        var floor = Math.floor;
        var fromCodePoint = function() {
          var MAX_SIZE = 16384;
          var codeUnits = [];
          var highSurrogate;
          var lowSurrogate;
          var index = -1;
          var length = arguments.length;
          if (!length) {
            return "";
          }
          var result = "";
          while (++index < length) {
            var codePoint = Number(arguments[index]);
            if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || floor(codePoint) !== codePoint) {
              throw RangeError("Invalid code point: " + codePoint);
            }
            if (codePoint <= 65535) {
              codeUnits.push(codePoint);
            } else {
              codePoint -= 65536;
              highSurrogate = (codePoint >> 10) + 55296;
              lowSurrogate = codePoint % 1024 + 56320;
              codeUnits.push(highSurrogate, lowSurrogate);
            }
            if (index + 1 === length || codeUnits.length > MAX_SIZE) {
              result += stringFromCharCode.apply(null, codeUnits);
              codeUnits.length = 0;
            }
          }
          return result;
        };
        if (Object.defineProperty) {
          Object.defineProperty(String, "fromCodePoint", {
            value: fromCodePoint,
            configurable: true,
            writable: true
          });
        } else {
          String.fromCodePoint = fromCodePoint;
        }
      })();
    }
  })(exports);
})(sax$1);
Object.defineProperty(xml, "__esModule", { value: true });
xml.parseXml = xml.XElement = void 0;
const sax = sax$1;
const index_1 = out;
class XElement {
  constructor(name) {
    this.name = name;
    this.value = "";
    this.attributes = null;
    this.isCData = false;
    this.elements = null;
    if (!name) {
      throw index_1.newError("Element name cannot be empty", "ERR_XML_ELEMENT_NAME_EMPTY");
    }
    if (!isValidName(name)) {
      throw index_1.newError(`Invalid element name: ${name}`, "ERR_XML_ELEMENT_INVALID_NAME");
    }
  }
  attribute(name) {
    const result = this.attributes === null ? null : this.attributes[name];
    if (result == null) {
      throw index_1.newError(`No attribute "${name}"`, "ERR_XML_MISSED_ATTRIBUTE");
    }
    return result;
  }
  removeAttribute(name) {
    if (this.attributes !== null) {
      delete this.attributes[name];
    }
  }
  element(name, ignoreCase = false, errorIfMissed = null) {
    const result = this.elementOrNull(name, ignoreCase);
    if (result === null) {
      throw index_1.newError(errorIfMissed || `No element "${name}"`, "ERR_XML_MISSED_ELEMENT");
    }
    return result;
  }
  elementOrNull(name, ignoreCase = false) {
    if (this.elements === null) {
      return null;
    }
    for (const element of this.elements) {
      if (isNameEquals(element, name, ignoreCase)) {
        return element;
      }
    }
    return null;
  }
  getElements(name, ignoreCase = false) {
    if (this.elements === null) {
      return [];
    }
    return this.elements.filter((it) => isNameEquals(it, name, ignoreCase));
  }
  elementValueOrEmpty(name, ignoreCase = false) {
    const element = this.elementOrNull(name, ignoreCase);
    return element === null ? "" : element.value;
  }
}
xml.XElement = XElement;
const NAME_REG_EXP = new RegExp(/^[A-Za-z_][:A-Za-z0-9_-]*$/i);
function isValidName(name) {
  return NAME_REG_EXP.test(name);
}
function isNameEquals(element, name, ignoreCase) {
  const elementName = element.name;
  return elementName === name || ignoreCase === true && elementName.length === name.length && elementName.toLowerCase() === name.toLowerCase();
}
function parseXml(data) {
  let rootElement = null;
  const parser = sax.parser(true, {});
  const elements = [];
  parser.onopentag = (saxElement) => {
    const element = new XElement(saxElement.name);
    element.attributes = saxElement.attributes;
    if (rootElement === null) {
      rootElement = element;
    } else {
      const parent = elements[elements.length - 1];
      if (parent.elements == null) {
        parent.elements = [];
      }
      parent.elements.push(element);
    }
    elements.push(element);
  };
  parser.onclosetag = () => {
    elements.pop();
  };
  parser.ontext = (text) => {
    if (elements.length > 0) {
      elements[elements.length - 1].value = text;
    }
  };
  parser.oncdata = (cdata) => {
    const element = elements[elements.length - 1];
    element.value = cdata;
    element.isCData = true;
  };
  parser.onerror = (err) => {
    throw err;
  };
  parser.write(data);
  return rootElement;
}
xml.parseXml = parseXml;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.newError = exports.asArray = exports.CURRENT_APP_PACKAGE_FILE_NAME = exports.CURRENT_APP_INSTALLER_FILE_NAME = exports.XElement = exports.parseXml = exports.ProgressCallbackTransform = exports.UUID = exports.parseDn = exports.githubUrl = exports.getS3LikeProviderBaseUrl = exports.configureRequestUrl = exports.parseJson = exports.safeStringifyJson = exports.configureRequestOptionsFromUrl = exports.configureRequestOptions = exports.safeGetHeader = exports.DigestTransform = exports.HttpExecutor = exports.createHttpError = exports.HttpError = exports.CancellationError = exports.CancellationToken = void 0;
  var CancellationToken_12 = CancellationToken$1;
  Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function() {
    return CancellationToken_12.CancellationToken;
  } });
  Object.defineProperty(exports, "CancellationError", { enumerable: true, get: function() {
    return CancellationToken_12.CancellationError;
  } });
  var httpExecutor_12 = httpExecutor;
  Object.defineProperty(exports, "HttpError", { enumerable: true, get: function() {
    return httpExecutor_12.HttpError;
  } });
  Object.defineProperty(exports, "createHttpError", { enumerable: true, get: function() {
    return httpExecutor_12.createHttpError;
  } });
  Object.defineProperty(exports, "HttpExecutor", { enumerable: true, get: function() {
    return httpExecutor_12.HttpExecutor;
  } });
  Object.defineProperty(exports, "DigestTransform", { enumerable: true, get: function() {
    return httpExecutor_12.DigestTransform;
  } });
  Object.defineProperty(exports, "safeGetHeader", { enumerable: true, get: function() {
    return httpExecutor_12.safeGetHeader;
  } });
  Object.defineProperty(exports, "configureRequestOptions", { enumerable: true, get: function() {
    return httpExecutor_12.configureRequestOptions;
  } });
  Object.defineProperty(exports, "configureRequestOptionsFromUrl", { enumerable: true, get: function() {
    return httpExecutor_12.configureRequestOptionsFromUrl;
  } });
  Object.defineProperty(exports, "safeStringifyJson", { enumerable: true, get: function() {
    return httpExecutor_12.safeStringifyJson;
  } });
  Object.defineProperty(exports, "parseJson", { enumerable: true, get: function() {
    return httpExecutor_12.parseJson;
  } });
  Object.defineProperty(exports, "configureRequestUrl", { enumerable: true, get: function() {
    return httpExecutor_12.configureRequestUrl;
  } });
  var publishOptions_1 = publishOptions;
  Object.defineProperty(exports, "getS3LikeProviderBaseUrl", { enumerable: true, get: function() {
    return publishOptions_1.getS3LikeProviderBaseUrl;
  } });
  Object.defineProperty(exports, "githubUrl", { enumerable: true, get: function() {
    return publishOptions_1.githubUrl;
  } });
  var rfc2253Parser_1 = rfc2253Parser;
  Object.defineProperty(exports, "parseDn", { enumerable: true, get: function() {
    return rfc2253Parser_1.parseDn;
  } });
  var uuid_1 = uuid;
  Object.defineProperty(exports, "UUID", { enumerable: true, get: function() {
    return uuid_1.UUID;
  } });
  var ProgressCallbackTransform_12 = ProgressCallbackTransform$1;
  Object.defineProperty(exports, "ProgressCallbackTransform", { enumerable: true, get: function() {
    return ProgressCallbackTransform_12.ProgressCallbackTransform;
  } });
  var xml_1 = xml;
  Object.defineProperty(exports, "parseXml", { enumerable: true, get: function() {
    return xml_1.parseXml;
  } });
  Object.defineProperty(exports, "XElement", { enumerable: true, get: function() {
    return xml_1.XElement;
  } });
  exports.CURRENT_APP_INSTALLER_FILE_NAME = "installer.exe";
  exports.CURRENT_APP_PACKAGE_FILE_NAME = "package.7z";
  function asArray(v) {
    if (v == null) {
      return [];
    } else if (Array.isArray(v)) {
      return v;
    } else {
      return [v];
    }
  }
  exports.asArray = asArray;
  function newError(message, code2) {
    const error2 = new Error(message);
    error2.code = code2;
    return error2;
  }
  exports.newError = newError;
})(out);
var AppUpdater$1 = {};
var jsYaml = {};
var loader$1 = {};
var common$5 = {};
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence))
    return sequence;
  else if (isNothing(sequence))
    return [];
  return [sequence];
}
function extend(target, source2) {
  var index, length, key, sourceKeys;
  if (source2) {
    sourceKeys = Object.keys(source2);
    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source2[key];
    }
  }
  return target;
}
function repeat(string, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }
  return result;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
common$5.isNothing = isNothing;
common$5.isObject = isObject;
common$5.toArray = toArray;
common$5.repeat = repeat;
common$5.isNegativeZero = isNegativeZero;
common$5.extend = extend;
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark)
    return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$4(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$4.prototype = Object.create(Error.prototype);
YAMLException$4.prototype.constructor = YAMLException$4;
YAMLException$4.prototype.toString = function toString2(compact) {
  return this.name + ": " + formatError(this, compact);
};
var exception = YAMLException$4;
var common$4 = common$5;
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
    pos: position - lineStart + head.length
  };
}
function padStart(string, max) {
  return common$4.repeat(" ", max - string.length) + string;
}
function makeSnippet$1(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer)
    return null;
  if (!options.maxLength)
    options.maxLength = 79;
  if (typeof options.indent !== "number")
    options.indent = 1;
  if (typeof options.linesBefore !== "number")
    options.linesBefore = 3;
  if (typeof options.linesAfter !== "number")
    options.linesAfter = 2;
  var re2 = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;
  while (match = re2.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);
    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0)
    foundLineNo = lineStarts.length - 1;
  var result = "", i2, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i2 = 1; i2 <= options.linesBefore; i2++) {
    if (foundLineNo - i2 < 0)
      break;
    line = getLine(mark.buffer, lineStarts[foundLineNo - i2], lineEnds[foundLineNo - i2], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i2]), maxLineLength);
    result = common$4.repeat(" ", options.indent) + padStart((mark.line - i2 + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common$4.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common$4.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i2 = 1; i2 <= options.linesAfter; i2++) {
    if (foundLineNo + i2 >= lineEnds.length)
      break;
    line = getLine(mark.buffer, lineStarts[foundLineNo + i2], lineEnds[foundLineNo + i2], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i2]), maxLineLength);
    result += common$4.repeat(" ", options.indent) + padStart((mark.line + i2 + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
var snippet = makeSnippet$1;
var YAMLException$3 = exception;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map2) {
  var result = {};
  if (map2 !== null) {
    Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$e(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new YAMLException$3('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new YAMLException$3('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
var type$2 = Type$e;
var YAMLException$2 = exception;
var Type$d = type$2;
function compileList(schema2, name) {
  var result = [];
  schema2[name].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index, length;
  function collectType(type2) {
    if (type2.multi) {
      result.multi[type2.kind].push(type2);
      result.multi["fallback"].push(type2);
    } else {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
  }
  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function extend2(definition) {
  var implicit = [];
  var explicit = [];
  if (definition instanceof Type$d) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit)
      implicit = implicit.concat(definition.implicit);
    if (definition.explicit)
      explicit = explicit.concat(definition.explicit);
  } else {
    throw new YAMLException$2("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type2) {
    if (!(type2 instanceof Type$d)) {
      throw new YAMLException$2("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type2.loadKind && type2.loadKind !== "scalar") {
      throw new YAMLException$2("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type2.multi) {
      throw new YAMLException$2("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type2) {
    if (!(type2 instanceof Type$d)) {
      throw new YAMLException$2("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result = Object.create(Schema$1.prototype);
  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);
  result.compiledImplicit = compileList(result, "implicit");
  result.compiledExplicit = compileList(result, "explicit");
  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
  return result;
};
var schema$2 = Schema$1;
var Type$c = type$2;
var str = new Type$c("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
});
var Type$b = type$2;
var seq = new Type$b("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
});
var Type$a = type$2;
var map = new Type$a("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
});
var Schema = schema$2;
var failsafe = new Schema({
  explicit: [
    str,
    seq,
    map
  ]
});
var Type$9 = type$2;
function resolveYamlNull(data) {
  if (data === null)
    return true;
  var max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var _null = new Type$9("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
var Type$8 = type$2;
function resolveYamlBoolean(data) {
  if (data === null)
    return false;
  var max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool = new Type$8("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object) {
      return object ? "true" : "false";
    },
    uppercase: function(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase: function(object) {
      return object ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
var common$3 = common$5;
var Type$7 = type$2;
function isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
function isOctCode(c) {
  return 48 <= c && c <= 55;
}
function isDecCode(c) {
  return 48 <= c && c <= 57;
}
function resolveYamlInteger(data) {
  if (data === null)
    return false;
  var max = data.length, index = 0, hasDigits = false, ch;
  if (!max)
    return false;
  ch = data[index];
  if (ch === "-" || ch === "+") {
    ch = data[++index];
  }
  if (ch === "0") {
    if (index + 1 === max)
      return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (ch !== "0" && ch !== "1")
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isHexCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isOctCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_")
    return false;
  for (; index < max; index++) {
    ch = data[index];
    if (ch === "_")
      continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_")
    return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-")
      sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0")
    return 0;
  if (ch === "0") {
    if (value[1] === "b")
      return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x")
      return sign * parseInt(value.slice(2), 16);
    if (value[1] === "o")
      return sign * parseInt(value.slice(2), 8);
  }
  return sign * parseInt(value, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common$3.isNegativeZero(object));
}
var int = new Type$7("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var common$2 = common$5;
var Type$6 = type$2;
var YAML_FLOAT_PATTERN = new RegExp("^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
function resolveYamlFloat(data) {
  if (data === null)
    return false;
  if (!YAML_FLOAT_PATTERN.test(data) || data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign;
  value = data.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  var res;
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common$2.isNegativeZero(object)) {
    return "-0.0";
  }
  res = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common$2.isNegativeZero(object));
}
var float = new Type$6("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});
var core$3 = json;
var Type$5 = type$2;
var YAML_DATE_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$");
var YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
function resolveYamlTimestamp(data) {
  if (data === null)
    return false;
  if (YAML_DATE_REGEXP.exec(data) !== null)
    return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
    return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null)
    match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null)
    throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-")
      delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta)
    date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
var timestamp = new Type$5("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
var Type$4 = type$2;
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge = new Type$4("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var Type$3 = type$2;
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null)
    return false;
  var code2, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code2 = map2.indexOf(data.charAt(idx));
    if (code2 > 64)
      continue;
    if (code2 < 0)
      return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map2.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map2[bits >> 18 & 63];
    result += map2[bits >> 12 & 63];
    result += map2[bits >> 6 & 63];
    result += map2[bits & 63];
  } else if (tail === 2) {
    result += map2[bits >> 10 & 63];
    result += map2[bits >> 4 & 63];
    result += map2[bits << 2 & 63];
    result += map2[64];
  } else if (tail === 1) {
    result += map2[bits >> 2 & 63];
    result += map2[bits << 4 & 63];
    result += map2[64];
    result += map2[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary = new Type$3("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var Type$2 = type$2;
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null)
    return true;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]")
      return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey)
          pairHasKey = true;
        else
          return false;
      }
    }
    if (!pairHasKey)
      return false;
    if (objectKeys.indexOf(pairKey) === -1)
      objectKeys.push(pairKey);
    else
      return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new Type$2("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var Type$1 = type$2;
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null)
    return true;
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    if (_toString$1.call(pair) !== "[object Object]")
      return false;
    keys = Object.keys(pair);
    if (keys.length !== 1)
      return false;
    result[index] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null)
    return [];
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    keys = Object.keys(pair);
    result[index] = [keys[0], pair[keys[0]]];
  }
  return result;
}
var pairs = new Type$1("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var Type = type$2;
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null)
    return true;
  var key, object = data;
  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null)
        return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set = new Type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default = core$3.extend({
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
});
var common$1 = common$5;
var YAMLException$1 = exception;
var makeSnippet = snippet;
var DEFAULT_SCHEMA$1 = _default;
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
  return c === 10 || c === 13;
}
function is_WHITE_SPACE(c) {
  return c === 9 || c === 32;
}
function is_WS_OR_EOL(c) {
  return c === 9 || c === 32 || c === 10 || c === 13;
}
function is_FLOW_INDICATOR(c) {
  return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
}
function fromHexCode(c) {
  var lc;
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  lc = c | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c) {
  if (c === 120) {
    return 2;
  }
  if (c === 117) {
    return 4;
  }
  if (c === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c) {
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  return -1;
}
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
function charFromCodepoint(c) {
  if (c <= 65535) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode((c - 65536 >> 10) + 55296, (c - 65536 & 1023) + 56320);
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || DEFAULT_SCHEMA$1;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = makeSnippet(mark);
  return new YAMLException$1(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state, name, args) {
    var match, major2, minor2;
    if (state.version !== null) {
      throwError(state, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      throwError(state, "YAML directive accepts exactly one argument");
    }
    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match === null) {
      throwError(state, "ill-formed argument of the YAML directive");
    }
    major2 = parseInt(match[1], 10);
    minor2 = parseInt(match[2], 10);
    if (major2 !== 1) {
      throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args[0];
    state.checkLineBreaks = minor2 < 2;
    if (minor2 !== 1 && minor2 !== 2) {
      throwWarning(state, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state, name, args) {
    var handle, prefix;
    if (args.length !== 2) {
      throwError(state, "TAG directive accepts exactly two arguments");
    }
    handle = args[0];
    prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, "tag prefix is malformed: " + prefix);
    }
    state.tagMap[handle] = prefix;
  }
};
function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source2, overridableKeys) {
  var sourceKeys, key, index, quantity;
  if (!common$1.isObject(source2)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source2);
  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source2[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
        keyNode[index] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += common$1.repeat("\n", count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common$1.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common$1.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common$1.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common$1.repeat("\n", emptyLines);
      }
    } else {
      state.result += common$1.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33)
    return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38)
    return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42)
    return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state.implicitTypes[typeIndex];
      if (type2.resolve(state.result)) {
        state.result = type2.construct(state.result);
        state.tag = type2.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type2 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type2.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
    }
    if (!type2.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type2.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = Object.create(null);
  state.anchorMap = Object.create(null);
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch))
        break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0)
      readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll(input, iterator2, options) {
  if (iterator2 !== null && typeof iterator2 === "object" && typeof options === "undefined") {
    options = iterator2;
    iterator2 = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator2 !== "function") {
    return documents;
  }
  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator2(documents[index]);
  }
}
function load(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new YAMLException$1("expected a single document in the stream, but found more");
}
loader$1.loadAll = loadAll;
loader$1.load = load;
var dumper$1 = {};
var common = common$5;
var YAMLException = exception;
var DEFAULT_SCHEMA = _default;
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_BOM = 65279;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema2, map2) {
  var result, keys, index, length, tag, style, type2;
  if (map2 === null)
    return {};
  result = {};
  keys = Object.keys(map2);
  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map2[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string.length) + string;
}
var QUOTING_TYPE_SINGLE = 1, QUOTING_TYPE_DOUBLE = 2;
function State(options) {
  this.schema = options["schema"] || DEFAULT_SCHEMA;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
  while (position < length) {
    next = string.indexOf("\n", position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n")
      result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index, length, type2;
  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type2 = state.implicitTypes[index];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}
function isPrintable(c) {
  return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
}
function isNsCharOrWhitespace(c) {
  return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (inblock ? cIsNsCharOrWhitespace : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar;
}
function isPlainSafeFirst(c) {
  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c) {
  return !isWhitespace(c) && c !== CHAR_COLON;
}
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
var STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i2;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i2 = 0; i2 < string.length; char >= 65536 ? i2 += 2 : i2++) {
      char = codePointAt(string, i2);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i2 = 0; i2 < string.length; char >= 65536 ? i2 += 2 : i2++) {
      char = codePointAt(string, i2);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || i2 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i2;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i2 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state, string, level, iskey, inblock) {
  state.dump = function() {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      }
    }
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state, string2);
    }
    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new YAMLException("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
  var clip = string[string.length - 1] === "\n";
  var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string) {
  return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string)) {
    var prefix = match[1], line = match[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ")
    return line;
  var breakRe = / [^ ]/g;
  var match;
  var start = 0, end, curr = 0, next = 0;
  var result = "";
  while (match = breakRe.exec(line)) {
    next = match.index;
    if (next - start > width) {
      end = curr > start ? curr : next;
      result += "\n" + line.slice(start, end);
      start = end + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }
  return result.slice(1);
}
function escapeString(string) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i2 = 0; i2 < string.length; char >= 65536 ? i2 += 2 : i2++) {
    char = codePointAt(string, i2);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string[i2];
      if (char >= 65536)
        result += string[i2 + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state, level, object) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
      if (_result !== "")
        _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object, compact) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (_result !== "")
      pairBuffer += ", ";
    if (state.condenseFlow)
      pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024)
      pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new YAMLException("sortKeys must be a boolean or a function");
  }
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (!compact || _result !== "") {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object, explicit) {
  var _result, typeList, index, length, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index = 0, length = typeList.length; index < length; index += 1) {
    type2 = typeList[index];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state.tag = type2.representName(object);
        } else {
          state.tag = type2.tag;
        }
      } else {
        state.tag = "?";
      }
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object, style);
        } else {
          throw new YAMLException("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;
  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }
  var type2 = _toString.call(state.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state.skipInvalid)
        return false;
      throw new YAMLException("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      tagStr = encodeURI(state.tag[0] === "!" ? state.tag.slice(1) : state.tag).replace(/!/g, "%21");
      if (state.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state.dump = tagStr + " " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object, state) {
  var objects = [], duplicatesIndexes = [], index, length;
  inspectNode(object, objects, duplicatesIndexes);
  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object !== null && typeof object === "object") {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);
      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump(input, options) {
  options = options || {};
  var state = new State(options);
  if (!state.noRefs)
    getDuplicateReferences(input, state);
  var value = input;
  if (state.replacer) {
    value = state.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state, 0, value, true, true))
    return state.dump + "\n";
  return "";
}
dumper$1.dump = dump;
var loader = loader$1;
var dumper = dumper$1;
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
jsYaml.Type = type$2;
jsYaml.Schema = schema$2;
jsYaml.FAILSAFE_SCHEMA = failsafe;
jsYaml.JSON_SCHEMA = json;
jsYaml.CORE_SCHEMA = core$3;
jsYaml.DEFAULT_SCHEMA = _default;
jsYaml.load = loader.load;
jsYaml.loadAll = loader.loadAll;
jsYaml.dump = dumper.dump;
jsYaml.YAMLException = exception;
jsYaml.types = {
  binary,
  float,
  map,
  null: _null,
  pairs,
  set,
  timestamp,
  bool,
  int,
  merge,
  omap,
  seq,
  str
};
jsYaml.safeLoad = renamed("safeLoad", "load");
jsYaml.safeLoadAll = renamed("safeLoadAll", "loadAll");
jsYaml.safeDump = renamed("safeDump", "dump");
var main = {};
Object.defineProperty(main, "__esModule", { value: true });
main.Lazy = void 0;
class Lazy {
  constructor(creator) {
    this._value = null;
    this.creator = creator;
  }
  get hasValue() {
    return this.creator == null;
  }
  get value() {
    if (this.creator == null) {
      return this._value;
    }
    const result = this.creator();
    this.value = result;
    return result;
  }
  set value(value) {
    this._value = value;
    this.creator = null;
  }
}
main.Lazy = Lazy;
var re$5 = { exports: {} };
const SEMVER_SPEC_VERSION = "2.0.0";
const MAX_LENGTH$2 = 256;
const MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || 9007199254740991;
const MAX_SAFE_COMPONENT_LENGTH = 16;
var constants = {
  SEMVER_SPEC_VERSION,
  MAX_LENGTH: MAX_LENGTH$2,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
  MAX_SAFE_COMPONENT_LENGTH
};
const debug$3 = typeof process === "object" && process.env && {}.NODE_DEBUG && /\bsemver\b/i.test({}.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
};
var debug_1 = debug$3;
(function(module, exports) {
  const { MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH2 } = constants;
  const debug2 = debug_1;
  exports = module.exports = {};
  const re2 = exports.re = [];
  const src = exports.src = [];
  const t2 = exports.t = {};
  let R = 0;
  const createToken = (name, value, isGlobal) => {
    const index = R++;
    debug2(index, value);
    t2[name] = index;
    src[index] = value;
    re2[index] = new RegExp(value, isGlobal ? "g" : void 0);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
  createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
  createToken("MAINVERSION", `(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t2.NUMERICIDENTIFIER]}|${src[t2.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t2.NUMERICIDENTIFIERLOOSE]}|${src[t2.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASE", `(?:-(${src[t2.PRERELEASEIDENTIFIER]}(?:\\.${src[t2.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t2.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
  createToken("BUILD", `(?:\\+(${src[t2.BUILDIDENTIFIER]}(?:\\.${src[t2.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t2.MAINVERSION]}${src[t2.PRERELEASE]}?${src[t2.BUILD]}?`);
  createToken("FULL", `^${src[t2.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t2.MAINVERSIONLOOSE]}${src[t2.PRERELEASELOOSE]}?${src[t2.BUILD]}?`);
  createToken("LOOSE", `^${src[t2.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t2.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:${src[t2.PRERELEASE]})?${src[t2.BUILD]}?)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:${src[t2.PRERELEASELOOSE]})?${src[t2.BUILD]}?)?)?`);
  createToken("XRANGE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH2}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:$|[^\\d])`);
  createToken("COERCERTL", src[t2.COERCE], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t2.LONETILDE]}\\s+`, true);
  exports.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t2.LONECARET]}\\s+`, true);
  exports.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src[t2.GTLT]}\\s*(${src[t2.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]}|${src[t2.XRANGEPLAIN]})`, true);
  exports.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t2.XRANGEPLAIN]})\\s+-\\s+(${src[t2.XRANGEPLAIN]})\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t2.XRANGEPLAINLOOSE]})\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0.0.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
})(re$5, re$5.exports);
const opts = ["includePrerelease", "loose", "rtl"];
const parseOptions$4 = (options) => !options ? {} : typeof options !== "object" ? { loose: true } : opts.filter((k) => options[k]).reduce((options2, k) => {
  options2[k] = true;
  return options2;
}, {});
var parseOptions_1 = parseOptions$4;
const numeric = /^[0-9]+$/;
const compareIdentifiers$1 = (a, b) => {
  const anum = numeric.test(a);
  const bnum = numeric.test(b);
  if (anum && bnum) {
    a = +a;
    b = +b;
  }
  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};
const rcompareIdentifiers = (a, b) => compareIdentifiers$1(b, a);
var identifiers = {
  compareIdentifiers: compareIdentifiers$1,
  rcompareIdentifiers
};
const debug$2 = debug_1;
const { MAX_LENGTH: MAX_LENGTH$1, MAX_SAFE_INTEGER } = constants;
const { re: re$4, t: t$4 } = re$5.exports;
const parseOptions$3 = parseOptions_1;
const { compareIdentifiers } = identifiers;
class SemVer$e {
  constructor(version, options) {
    options = parseOptions$3(options);
    if (version instanceof SemVer$e) {
      if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== "string") {
      throw new TypeError(`Invalid Version: ${version}`);
    }
    if (version.length > MAX_LENGTH$1) {
      throw new TypeError(`version is longer than ${MAX_LENGTH$1} characters`);
    }
    debug$2("SemVer", version, options);
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    const m2 = version.trim().match(options.loose ? re$4[t$4.LOOSE] : re$4[t$4.FULL]);
    if (!m2) {
      throw new TypeError(`Invalid Version: ${version}`);
    }
    this.raw = version;
    this.major = +m2[1];
    this.minor = +m2[2];
    this.patch = +m2[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m2[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m2[4].split(".").map((id2) => {
        if (/^[0-9]+$/.test(id2)) {
          const num = +id2;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id2;
      });
    }
    this.build = m2[5] ? m2[5].split(".") : [];
    this.format();
  }
  format() {
    this.version = `${this.major}.${this.minor}.${this.patch}`;
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join(".")}`;
    }
    return this.version;
  }
  toString() {
    return this.version;
  }
  compare(other) {
    debug$2("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer$e)) {
      if (typeof other === "string" && other === this.version) {
        return 0;
      }
      other = new SemVer$e(other, this.options);
    }
    if (other.version === this.version) {
      return 0;
    }
    return this.compareMain(other) || this.comparePre(other);
  }
  compareMain(other) {
    if (!(other instanceof SemVer$e)) {
      other = new SemVer$e(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  }
  comparePre(other) {
    if (!(other instanceof SemVer$e)) {
      other = new SemVer$e(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    let i2 = 0;
    do {
      const a = this.prerelease[i2];
      const b = other.prerelease[i2];
      debug$2("prerelease compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  }
  compareBuild(other) {
    if (!(other instanceof SemVer$e)) {
      other = new SemVer$e(other, this.options);
    }
    let i2 = 0;
    do {
      const a = this.build[i2];
      const b = other.build[i2];
      debug$2("prerelease compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  }
  inc(release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier);
        this.inc("pre", identifier);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier);
        }
        this.inc("pre", identifier);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          let i2 = this.prerelease.length;
          while (--i2 >= 0) {
            if (typeof this.prerelease[i2] === "number") {
              this.prerelease[i2]++;
              i2 = -2;
            }
          }
          if (i2 === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error(`invalid increment argument: ${release}`);
    }
    this.format();
    this.raw = this.version;
    return this;
  }
}
var semver$2 = SemVer$e;
const { MAX_LENGTH } = constants;
const { re: re$3, t: t$3 } = re$5.exports;
const SemVer$d = semver$2;
const parseOptions$2 = parseOptions_1;
const parse$5 = (version, options) => {
  options = parseOptions$2(options);
  if (version instanceof SemVer$d) {
    return version;
  }
  if (typeof version !== "string") {
    return null;
  }
  if (version.length > MAX_LENGTH) {
    return null;
  }
  const r = options.loose ? re$3[t$3.LOOSE] : re$3[t$3.FULL];
  if (!r.test(version)) {
    return null;
  }
  try {
    return new SemVer$d(version, options);
  } catch (er) {
    return null;
  }
};
var parse_1 = parse$5;
const parse$4 = parse_1;
const valid$1 = (version, options) => {
  const v = parse$4(version, options);
  return v ? v.version : null;
};
var valid_1 = valid$1;
const parse$3 = parse_1;
const clean = (version, options) => {
  const s2 = parse$3(version.trim().replace(/^[=v]+/, ""), options);
  return s2 ? s2.version : null;
};
var clean_1 = clean;
const SemVer$c = semver$2;
const inc = (version, release, options, identifier) => {
  if (typeof options === "string") {
    identifier = options;
    options = void 0;
  }
  try {
    return new SemVer$c(version, options).inc(release, identifier).version;
  } catch (er) {
    return null;
  }
};
var inc_1 = inc;
const SemVer$b = semver$2;
const compare$a = (a, b, loose) => new SemVer$b(a, loose).compare(new SemVer$b(b, loose));
var compare_1 = compare$a;
const compare$9 = compare_1;
const eq$2 = (a, b, loose) => compare$9(a, b, loose) === 0;
var eq_1 = eq$2;
const parse$2 = parse_1;
const eq$1 = eq_1;
const diff = (version1, version2) => {
  if (eq$1(version1, version2)) {
    return null;
  } else {
    const v1 = parse$2(version1);
    const v2 = parse$2(version2);
    const hasPre = v1.prerelease.length || v2.prerelease.length;
    const prefix = hasPre ? "pre" : "";
    const defaultResult = hasPre ? "prerelease" : "";
    for (const key in v1) {
      if (key === "major" || key === "minor" || key === "patch") {
        if (v1[key] !== v2[key]) {
          return prefix + key;
        }
      }
    }
    return defaultResult;
  }
};
var diff_1 = diff;
const SemVer$a = semver$2;
const major = (a, loose) => new SemVer$a(a, loose).major;
var major_1 = major;
const SemVer$9 = semver$2;
const minor = (a, loose) => new SemVer$9(a, loose).minor;
var minor_1 = minor;
const SemVer$8 = semver$2;
const patch = (a, loose) => new SemVer$8(a, loose).patch;
var patch_1 = patch;
const parse$1 = parse_1;
const prerelease = (version, options) => {
  const parsed = parse$1(version, options);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
};
var prerelease_1 = prerelease;
const compare$8 = compare_1;
const rcompare = (a, b, loose) => compare$8(b, a, loose);
var rcompare_1 = rcompare;
const compare$7 = compare_1;
const compareLoose = (a, b) => compare$7(a, b, true);
var compareLoose_1 = compareLoose;
const SemVer$7 = semver$2;
const compareBuild$2 = (a, b, loose) => {
  const versionA = new SemVer$7(a, loose);
  const versionB = new SemVer$7(b, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB);
};
var compareBuild_1 = compareBuild$2;
const compareBuild$1 = compareBuild_1;
const sort = (list, loose) => list.sort((a, b) => compareBuild$1(a, b, loose));
var sort_1 = sort;
const compareBuild = compareBuild_1;
const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
var rsort_1 = rsort;
const compare$6 = compare_1;
const gt$3 = (a, b, loose) => compare$6(a, b, loose) > 0;
var gt_1 = gt$3;
const compare$5 = compare_1;
const lt$2 = (a, b, loose) => compare$5(a, b, loose) < 0;
var lt_1 = lt$2;
const compare$4 = compare_1;
const neq$1 = (a, b, loose) => compare$4(a, b, loose) !== 0;
var neq_1 = neq$1;
const compare$3 = compare_1;
const gte$2 = (a, b, loose) => compare$3(a, b, loose) >= 0;
var gte_1 = gte$2;
const compare$2 = compare_1;
const lte$2 = (a, b, loose) => compare$2(a, b, loose) <= 0;
var lte_1 = lte$2;
const eq = eq_1;
const neq = neq_1;
const gt$2 = gt_1;
const gte$1 = gte_1;
const lt$1 = lt_1;
const lte$1 = lte_1;
const cmp$1 = (a, op, b, loose) => {
  switch (op) {
    case "===":
      if (typeof a === "object")
        a = a.version;
      if (typeof b === "object")
        b = b.version;
      return a === b;
    case "!==":
      if (typeof a === "object")
        a = a.version;
      if (typeof b === "object")
        b = b.version;
      return a !== b;
    case "":
    case "=":
    case "==":
      return eq(a, b, loose);
    case "!=":
      return neq(a, b, loose);
    case ">":
      return gt$2(a, b, loose);
    case ">=":
      return gte$1(a, b, loose);
    case "<":
      return lt$1(a, b, loose);
    case "<=":
      return lte$1(a, b, loose);
    default:
      throw new TypeError(`Invalid operator: ${op}`);
  }
};
var cmp_1 = cmp$1;
const SemVer$6 = semver$2;
const parse = parse_1;
const { re: re$2, t: t$2 } = re$5.exports;
const coerce = (version, options) => {
  if (version instanceof SemVer$6) {
    return version;
  }
  if (typeof version === "number") {
    version = String(version);
  }
  if (typeof version !== "string") {
    return null;
  }
  options = options || {};
  let match = null;
  if (!options.rtl) {
    match = version.match(re$2[t$2.COERCE]);
  } else {
    let next;
    while ((next = re$2[t$2.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
      if (!match || next.index + next[0].length !== match.index + match[0].length) {
        match = next;
      }
      re$2[t$2.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
    }
    re$2[t$2.COERCERTL].lastIndex = -1;
  }
  if (match === null)
    return null;
  return parse(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
};
var coerce_1 = coerce;
var iterator = function(Yallist2) {
  Yallist2.prototype[Symbol.iterator] = function* () {
    for (let walker = this.head; walker; walker = walker.next) {
      yield walker.value;
    }
  };
};
var yallist = Yallist$1;
Yallist$1.Node = Node;
Yallist$1.create = Yallist$1;
function Yallist$1(list) {
  var self2 = this;
  if (!(self2 instanceof Yallist$1)) {
    self2 = new Yallist$1();
  }
  self2.tail = null;
  self2.head = null;
  self2.length = 0;
  if (list && typeof list.forEach === "function") {
    list.forEach(function(item) {
      self2.push(item);
    });
  } else if (arguments.length > 0) {
    for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
      self2.push(arguments[i2]);
    }
  }
  return self2;
}
Yallist$1.prototype.removeNode = function(node) {
  if (node.list !== this) {
    throw new Error("removing node which does not belong to this list");
  }
  var next = node.next;
  var prev = node.prev;
  if (next) {
    next.prev = prev;
  }
  if (prev) {
    prev.next = next;
  }
  if (node === this.head) {
    this.head = next;
  }
  if (node === this.tail) {
    this.tail = prev;
  }
  node.list.length--;
  node.next = null;
  node.prev = null;
  node.list = null;
  return next;
};
Yallist$1.prototype.unshiftNode = function(node) {
  if (node === this.head) {
    return;
  }
  if (node.list) {
    node.list.removeNode(node);
  }
  var head = this.head;
  node.list = this;
  node.next = head;
  if (head) {
    head.prev = node;
  }
  this.head = node;
  if (!this.tail) {
    this.tail = node;
  }
  this.length++;
};
Yallist$1.prototype.pushNode = function(node) {
  if (node === this.tail) {
    return;
  }
  if (node.list) {
    node.list.removeNode(node);
  }
  var tail = this.tail;
  node.list = this;
  node.prev = tail;
  if (tail) {
    tail.next = node;
  }
  this.tail = node;
  if (!this.head) {
    this.head = node;
  }
  this.length++;
};
Yallist$1.prototype.push = function() {
  for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
    push(this, arguments[i2]);
  }
  return this.length;
};
Yallist$1.prototype.unshift = function() {
  for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
    unshift(this, arguments[i2]);
  }
  return this.length;
};
Yallist$1.prototype.pop = function() {
  if (!this.tail) {
    return void 0;
  }
  var res = this.tail.value;
  this.tail = this.tail.prev;
  if (this.tail) {
    this.tail.next = null;
  } else {
    this.head = null;
  }
  this.length--;
  return res;
};
Yallist$1.prototype.shift = function() {
  if (!this.head) {
    return void 0;
  }
  var res = this.head.value;
  this.head = this.head.next;
  if (this.head) {
    this.head.prev = null;
  } else {
    this.tail = null;
  }
  this.length--;
  return res;
};
Yallist$1.prototype.forEach = function(fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.head, i2 = 0; walker !== null; i2++) {
    fn.call(thisp, walker.value, i2, this);
    walker = walker.next;
  }
};
Yallist$1.prototype.forEachReverse = function(fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.tail, i2 = this.length - 1; walker !== null; i2--) {
    fn.call(thisp, walker.value, i2, this);
    walker = walker.prev;
  }
};
Yallist$1.prototype.get = function(n) {
  for (var i2 = 0, walker = this.head; walker !== null && i2 < n; i2++) {
    walker = walker.next;
  }
  if (i2 === n && walker !== null) {
    return walker.value;
  }
};
Yallist$1.prototype.getReverse = function(n) {
  for (var i2 = 0, walker = this.tail; walker !== null && i2 < n; i2++) {
    walker = walker.prev;
  }
  if (i2 === n && walker !== null) {
    return walker.value;
  }
};
Yallist$1.prototype.map = function(fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist$1();
  for (var walker = this.head; walker !== null; ) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.next;
  }
  return res;
};
Yallist$1.prototype.mapReverse = function(fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist$1();
  for (var walker = this.tail; walker !== null; ) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.prev;
  }
  return res;
};
Yallist$1.prototype.reduce = function(fn, initial) {
  var acc;
  var walker = this.head;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.head) {
    walker = this.head.next;
    acc = this.head.value;
  } else {
    throw new TypeError("Reduce of empty list with no initial value");
  }
  for (var i2 = 0; walker !== null; i2++) {
    acc = fn(acc, walker.value, i2);
    walker = walker.next;
  }
  return acc;
};
Yallist$1.prototype.reduceReverse = function(fn, initial) {
  var acc;
  var walker = this.tail;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.tail) {
    walker = this.tail.prev;
    acc = this.tail.value;
  } else {
    throw new TypeError("Reduce of empty list with no initial value");
  }
  for (var i2 = this.length - 1; walker !== null; i2--) {
    acc = fn(acc, walker.value, i2);
    walker = walker.prev;
  }
  return acc;
};
Yallist$1.prototype.toArray = function() {
  var arr = new Array(this.length);
  for (var i2 = 0, walker = this.head; walker !== null; i2++) {
    arr[i2] = walker.value;
    walker = walker.next;
  }
  return arr;
};
Yallist$1.prototype.toArrayReverse = function() {
  var arr = new Array(this.length);
  for (var i2 = 0, walker = this.tail; walker !== null; i2++) {
    arr[i2] = walker.value;
    walker = walker.prev;
  }
  return arr;
};
Yallist$1.prototype.slice = function(from, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from = from || 0;
  if (from < 0) {
    from += this.length;
  }
  var ret = new Yallist$1();
  if (to < from || to < 0) {
    return ret;
  }
  if (from < 0) {
    from = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i2 = 0, walker = this.head; walker !== null && i2 < from; i2++) {
    walker = walker.next;
  }
  for (; walker !== null && i2 < to; i2++, walker = walker.next) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist$1.prototype.sliceReverse = function(from, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from = from || 0;
  if (from < 0) {
    from += this.length;
  }
  var ret = new Yallist$1();
  if (to < from || to < 0) {
    return ret;
  }
  if (from < 0) {
    from = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i2 = this.length, walker = this.tail; walker !== null && i2 > to; i2--) {
    walker = walker.prev;
  }
  for (; walker !== null && i2 > from; i2--, walker = walker.prev) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist$1.prototype.splice = function(start, deleteCount, ...nodes) {
  if (start > this.length) {
    start = this.length - 1;
  }
  if (start < 0) {
    start = this.length + start;
  }
  for (var i2 = 0, walker = this.head; walker !== null && i2 < start; i2++) {
    walker = walker.next;
  }
  var ret = [];
  for (var i2 = 0; walker && i2 < deleteCount; i2++) {
    ret.push(walker.value);
    walker = this.removeNode(walker);
  }
  if (walker === null) {
    walker = this.tail;
  }
  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev;
  }
  for (var i2 = 0; i2 < nodes.length; i2++) {
    walker = insert(this, walker, nodes[i2]);
  }
  return ret;
};
Yallist$1.prototype.reverse = function() {
  var head = this.head;
  var tail = this.tail;
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev;
    walker.prev = walker.next;
    walker.next = p;
  }
  this.head = tail;
  this.tail = head;
  return this;
};
function insert(self2, node, value) {
  var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
  if (inserted.next === null) {
    self2.tail = inserted;
  }
  if (inserted.prev === null) {
    self2.head = inserted;
  }
  self2.length++;
  return inserted;
}
function push(self2, item) {
  self2.tail = new Node(item, self2.tail, null, self2);
  if (!self2.head) {
    self2.head = self2.tail;
  }
  self2.length++;
}
function unshift(self2, item) {
  self2.head = new Node(item, null, self2.head, self2);
  if (!self2.tail) {
    self2.tail = self2.head;
  }
  self2.length++;
}
function Node(value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list);
  }
  this.list = list;
  this.value = value;
  if (prev) {
    prev.next = this;
    this.prev = prev;
  } else {
    this.prev = null;
  }
  if (next) {
    next.prev = this;
    this.next = next;
  } else {
    this.next = null;
  }
}
try {
  iterator(Yallist$1);
} catch (er) {
}
const Yallist = yallist;
const MAX = Symbol("max");
const LENGTH = Symbol("length");
const LENGTH_CALCULATOR = Symbol("lengthCalculator");
const ALLOW_STALE = Symbol("allowStale");
const MAX_AGE = Symbol("maxAge");
const DISPOSE = Symbol("dispose");
const NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
const LRU_LIST = Symbol("lruList");
const CACHE = Symbol("cache");
const UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
const naiveLength = () => 1;
class LRUCache {
  constructor(options) {
    if (typeof options === "number")
      options = { max: options };
    if (!options)
      options = {};
    if (options.max && (typeof options.max !== "number" || options.max < 0))
      throw new TypeError("max must be a non-negative number");
    this[MAX] = options.max || Infinity;
    const lc = options.length || naiveLength;
    this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
    this[ALLOW_STALE] = options.stale || false;
    if (options.maxAge && typeof options.maxAge !== "number")
      throw new TypeError("maxAge must be a number");
    this[MAX_AGE] = options.maxAge || 0;
    this[DISPOSE] = options.dispose;
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
    this.reset();
  }
  set max(mL) {
    if (typeof mL !== "number" || mL < 0)
      throw new TypeError("max must be a non-negative number");
    this[MAX] = mL || Infinity;
    trim(this);
  }
  get max() {
    return this[MAX];
  }
  set allowStale(allowStale) {
    this[ALLOW_STALE] = !!allowStale;
  }
  get allowStale() {
    return this[ALLOW_STALE];
  }
  set maxAge(mA) {
    if (typeof mA !== "number")
      throw new TypeError("maxAge must be a non-negative number");
    this[MAX_AGE] = mA;
    trim(this);
  }
  get maxAge() {
    return this[MAX_AGE];
  }
  set lengthCalculator(lC) {
    if (typeof lC !== "function")
      lC = naiveLength;
    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC;
      this[LENGTH] = 0;
      this[LRU_LIST].forEach((hit) => {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
        this[LENGTH] += hit.length;
      });
    }
    trim(this);
  }
  get lengthCalculator() {
    return this[LENGTH_CALCULATOR];
  }
  get length() {
    return this[LENGTH];
  }
  get itemCount() {
    return this[LRU_LIST].length;
  }
  rforEach(fn, thisp) {
    thisp = thisp || this;
    for (let walker = this[LRU_LIST].tail; walker !== null; ) {
      const prev = walker.prev;
      forEachStep(this, fn, walker, thisp);
      walker = prev;
    }
  }
  forEach(fn, thisp) {
    thisp = thisp || this;
    for (let walker = this[LRU_LIST].head; walker !== null; ) {
      const next = walker.next;
      forEachStep(this, fn, walker, thisp);
      walker = next;
    }
  }
  keys() {
    return this[LRU_LIST].toArray().map((k) => k.key);
  }
  values() {
    return this[LRU_LIST].toArray().map((k) => k.value);
  }
  reset() {
    if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
      this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
    }
    this[CACHE] = new Map();
    this[LRU_LIST] = new Yallist();
    this[LENGTH] = 0;
  }
  dump() {
    return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
      k: hit.key,
      v: hit.value,
      e: hit.now + (hit.maxAge || 0)
    }).toArray().filter((h2) => h2);
  }
  dumpLru() {
    return this[LRU_LIST];
  }
  set(key, value, maxAge) {
    maxAge = maxAge || this[MAX_AGE];
    if (maxAge && typeof maxAge !== "number")
      throw new TypeError("maxAge must be a number");
    const now = maxAge ? Date.now() : 0;
    const len = this[LENGTH_CALCULATOR](value, key);
    if (this[CACHE].has(key)) {
      if (len > this[MAX]) {
        del(this, this[CACHE].get(key));
        return false;
      }
      const node = this[CACHE].get(key);
      const item = node.value;
      if (this[DISPOSE]) {
        if (!this[NO_DISPOSE_ON_SET])
          this[DISPOSE](key, item.value);
      }
      item.now = now;
      item.maxAge = maxAge;
      item.value = value;
      this[LENGTH] += len - item.length;
      item.length = len;
      this.get(key);
      trim(this);
      return true;
    }
    const hit = new Entry(key, value, len, now, maxAge);
    if (hit.length > this[MAX]) {
      if (this[DISPOSE])
        this[DISPOSE](key, value);
      return false;
    }
    this[LENGTH] += hit.length;
    this[LRU_LIST].unshift(hit);
    this[CACHE].set(key, this[LRU_LIST].head);
    trim(this);
    return true;
  }
  has(key) {
    if (!this[CACHE].has(key))
      return false;
    const hit = this[CACHE].get(key).value;
    return !isStale(this, hit);
  }
  get(key) {
    return get(this, key, true);
  }
  peek(key) {
    return get(this, key, false);
  }
  pop() {
    const node = this[LRU_LIST].tail;
    if (!node)
      return null;
    del(this, node);
    return node.value;
  }
  del(key) {
    del(this, this[CACHE].get(key));
  }
  load(arr) {
    this.reset();
    const now = Date.now();
    for (let l = arr.length - 1; l >= 0; l--) {
      const hit = arr[l];
      const expiresAt = hit.e || 0;
      if (expiresAt === 0)
        this.set(hit.k, hit.v);
      else {
        const maxAge = expiresAt - now;
        if (maxAge > 0) {
          this.set(hit.k, hit.v, maxAge);
        }
      }
    }
  }
  prune() {
    this[CACHE].forEach((value, key) => get(this, key, false));
  }
}
const get = (self2, key, doUse) => {
  const node = self2[CACHE].get(key);
  if (node) {
    const hit = node.value;
    if (isStale(self2, hit)) {
      del(self2, node);
      if (!self2[ALLOW_STALE])
        return void 0;
    } else {
      if (doUse) {
        if (self2[UPDATE_AGE_ON_GET])
          node.value.now = Date.now();
        self2[LRU_LIST].unshiftNode(node);
      }
    }
    return hit.value;
  }
};
const isStale = (self2, hit) => {
  if (!hit || !hit.maxAge && !self2[MAX_AGE])
    return false;
  const diff2 = Date.now() - hit.now;
  return hit.maxAge ? diff2 > hit.maxAge : self2[MAX_AGE] && diff2 > self2[MAX_AGE];
};
const trim = (self2) => {
  if (self2[LENGTH] > self2[MAX]) {
    for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
      const prev = walker.prev;
      del(self2, walker);
      walker = prev;
    }
  }
};
const del = (self2, node) => {
  if (node) {
    const hit = node.value;
    if (self2[DISPOSE])
      self2[DISPOSE](hit.key, hit.value);
    self2[LENGTH] -= hit.length;
    self2[CACHE].delete(hit.key);
    self2[LRU_LIST].removeNode(node);
  }
};
class Entry {
  constructor(key, value, length, now, maxAge) {
    this.key = key;
    this.value = value;
    this.length = length;
    this.now = now;
    this.maxAge = maxAge || 0;
  }
}
const forEachStep = (self2, fn, node, thisp) => {
  let hit = node.value;
  if (isStale(self2, hit)) {
    del(self2, node);
    if (!self2[ALLOW_STALE])
      hit = void 0;
  }
  if (hit)
    fn.call(thisp, hit.value, hit.key, self2);
};
var lruCache = LRUCache;
class Range$a {
  constructor(range2, options) {
    options = parseOptions$1(options);
    if (range2 instanceof Range$a) {
      if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
        return range2;
      } else {
        return new Range$a(range2.raw, options);
      }
    }
    if (range2 instanceof Comparator$3) {
      this.raw = range2.value;
      this.set = [[range2]];
      this.format();
      return this;
    }
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    this.raw = range2;
    this.set = range2.split(/\s*\|\|\s*/).map((range3) => this.parseRange(range3.trim())).filter((c) => c.length);
    if (!this.set.length) {
      throw new TypeError(`Invalid SemVer Range: ${range2}`);
    }
    if (this.set.length > 1) {
      const first = this.set[0];
      this.set = this.set.filter((c) => !isNullSet(c[0]));
      if (this.set.length === 0)
        this.set = [first];
      else if (this.set.length > 1) {
        for (const c of this.set) {
          if (c.length === 1 && isAny(c[0])) {
            this.set = [c];
            break;
          }
        }
      }
    }
    this.format();
  }
  format() {
    this.range = this.set.map((comps) => {
      return comps.join(" ").trim();
    }).join("||").trim();
    return this.range;
  }
  toString() {
    return this.range;
  }
  parseRange(range2) {
    range2 = range2.trim();
    const memoOpts = Object.keys(this.options).join(",");
    const memoKey = `parseRange:${memoOpts}:${range2}`;
    const cached = cache.get(memoKey);
    if (cached)
      return cached;
    const loose = this.options.loose;
    const hr = loose ? re$1[t$1.HYPHENRANGELOOSE] : re$1[t$1.HYPHENRANGE];
    range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
    debug$1("hyphen replace", range2);
    range2 = range2.replace(re$1[t$1.COMPARATORTRIM], comparatorTrimReplace);
    debug$1("comparator trim", range2, re$1[t$1.COMPARATORTRIM]);
    range2 = range2.replace(re$1[t$1.TILDETRIM], tildeTrimReplace);
    range2 = range2.replace(re$1[t$1.CARETTRIM], caretTrimReplace);
    range2 = range2.split(/\s+/).join(" ");
    const compRe = loose ? re$1[t$1.COMPARATORLOOSE] : re$1[t$1.COMPARATOR];
    const rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options)).filter(this.options.loose ? (comp) => !!comp.match(compRe) : () => true).map((comp) => new Comparator$3(comp, this.options));
    rangeList.length;
    const rangeMap = new Map();
    for (const comp of rangeList) {
      if (isNullSet(comp))
        return [comp];
      rangeMap.set(comp.value, comp);
    }
    if (rangeMap.size > 1 && rangeMap.has(""))
      rangeMap.delete("");
    const result = [...rangeMap.values()];
    cache.set(memoKey, result);
    return result;
  }
  intersects(range2, options) {
    if (!(range2 instanceof Range$a)) {
      throw new TypeError("a Range is required");
    }
    return this.set.some((thisComparators) => {
      return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
        return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
          return rangeComparators.every((rangeComparator) => {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  }
  test(version) {
    if (!version) {
      return false;
    }
    if (typeof version === "string") {
      try {
        version = new SemVer$5(version, this.options);
      } catch (er) {
        return false;
      }
    }
    for (let i2 = 0; i2 < this.set.length; i2++) {
      if (testSet(this.set[i2], version, this.options)) {
        return true;
      }
    }
    return false;
  }
}
var range = Range$a;
const LRU = lruCache;
const cache = new LRU({ max: 1e3 });
const parseOptions$1 = parseOptions_1;
const Comparator$3 = comparator;
const debug$1 = debug_1;
const SemVer$5 = semver$2;
const {
  re: re$1,
  t: t$1,
  comparatorTrimReplace,
  tildeTrimReplace,
  caretTrimReplace
} = re$5.exports;
const isNullSet = (c) => c.value === "<0.0.0-0";
const isAny = (c) => c.value === "";
const isSatisfiable = (comparators, options) => {
  let result = true;
  const remainingComparators = comparators.slice();
  let testComparator = remainingComparators.pop();
  while (result && remainingComparators.length) {
    result = remainingComparators.every((otherComparator) => {
      return testComparator.intersects(otherComparator, options);
    });
    testComparator = remainingComparators.pop();
  }
  return result;
};
const parseComparator = (comp, options) => {
  debug$1("comp", comp, options);
  comp = replaceCarets(comp, options);
  debug$1("caret", comp);
  comp = replaceTildes(comp, options);
  debug$1("tildes", comp);
  comp = replaceXRanges(comp, options);
  debug$1("xrange", comp);
  comp = replaceStars(comp, options);
  debug$1("stars", comp);
  return comp;
};
const isX = (id2) => !id2 || id2.toLowerCase() === "x" || id2 === "*";
const replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
  return replaceTilde(comp2, options);
}).join(" ");
const replaceTilde = (comp, options) => {
  const r = options.loose ? re$1[t$1.TILDELOOSE] : re$1[t$1.TILDE];
  return comp.replace(r, (_, M, m2, p, pr) => {
    debug$1("tilde", comp, _, M, m2, p, pr);
    let ret;
    if (isX(M)) {
      ret = "";
    } else if (isX(m2)) {
      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
    } else if (isX(p)) {
      ret = `>=${M}.${m2}.0 <${M}.${+m2 + 1}.0-0`;
    } else if (pr) {
      debug$1("replaceTilde pr", pr);
      ret = `>=${M}.${m2}.${p}-${pr} <${M}.${+m2 + 1}.0-0`;
    } else {
      ret = `>=${M}.${m2}.${p} <${M}.${+m2 + 1}.0-0`;
    }
    debug$1("tilde return", ret);
    return ret;
  });
};
const replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
  return replaceCaret(comp2, options);
}).join(" ");
const replaceCaret = (comp, options) => {
  debug$1("caret", comp, options);
  const r = options.loose ? re$1[t$1.CARETLOOSE] : re$1[t$1.CARET];
  const z = options.includePrerelease ? "-0" : "";
  return comp.replace(r, (_, M, m2, p, pr) => {
    debug$1("caret", comp, _, M, m2, p, pr);
    let ret;
    if (isX(M)) {
      ret = "";
    } else if (isX(m2)) {
      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
    } else if (isX(p)) {
      if (M === "0") {
        ret = `>=${M}.${m2}.0${z} <${M}.${+m2 + 1}.0-0`;
      } else {
        ret = `>=${M}.${m2}.0${z} <${+M + 1}.0.0-0`;
      }
    } else if (pr) {
      debug$1("replaceCaret pr", pr);
      if (M === "0") {
        if (m2 === "0") {
          ret = `>=${M}.${m2}.${p}-${pr} <${M}.${m2}.${+p + 1}-0`;
        } else {
          ret = `>=${M}.${m2}.${p}-${pr} <${M}.${+m2 + 1}.0-0`;
        }
      } else {
        ret = `>=${M}.${m2}.${p}-${pr} <${+M + 1}.0.0-0`;
      }
    } else {
      debug$1("no pr");
      if (M === "0") {
        if (m2 === "0") {
          ret = `>=${M}.${m2}.${p}${z} <${M}.${m2}.${+p + 1}-0`;
        } else {
          ret = `>=${M}.${m2}.${p}${z} <${M}.${+m2 + 1}.0-0`;
        }
      } else {
        ret = `>=${M}.${m2}.${p} <${+M + 1}.0.0-0`;
      }
    }
    debug$1("caret return", ret);
    return ret;
  });
};
const replaceXRanges = (comp, options) => {
  debug$1("replaceXRanges", comp, options);
  return comp.split(/\s+/).map((comp2) => {
    return replaceXRange(comp2, options);
  }).join(" ");
};
const replaceXRange = (comp, options) => {
  comp = comp.trim();
  const r = options.loose ? re$1[t$1.XRANGELOOSE] : re$1[t$1.XRANGE];
  return comp.replace(r, (ret, gtlt, M, m2, p, pr) => {
    debug$1("xRange", comp, ret, gtlt, M, m2, p, pr);
    const xM = isX(M);
    const xm = xM || isX(m2);
    const xp = xm || isX(p);
    const anyX = xp;
    if (gtlt === "=" && anyX) {
      gtlt = "";
    }
    pr = options.includePrerelease ? "-0" : "";
    if (xM) {
      if (gtlt === ">" || gtlt === "<") {
        ret = "<0.0.0-0";
      } else {
        ret = "*";
      }
    } else if (gtlt && anyX) {
      if (xm) {
        m2 = 0;
      }
      p = 0;
      if (gtlt === ">") {
        gtlt = ">=";
        if (xm) {
          M = +M + 1;
          m2 = 0;
          p = 0;
        } else {
          m2 = +m2 + 1;
          p = 0;
        }
      } else if (gtlt === "<=") {
        gtlt = "<";
        if (xm) {
          M = +M + 1;
        } else {
          m2 = +m2 + 1;
        }
      }
      if (gtlt === "<")
        pr = "-0";
      ret = `${gtlt + M}.${m2}.${p}${pr}`;
    } else if (xm) {
      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
    } else if (xp) {
      ret = `>=${M}.${m2}.0${pr} <${M}.${+m2 + 1}.0-0`;
    }
    debug$1("xRange return", ret);
    return ret;
  });
};
const replaceStars = (comp, options) => {
  debug$1("replaceStars", comp, options);
  return comp.trim().replace(re$1[t$1.STAR], "");
};
const replaceGTE0 = (comp, options) => {
  debug$1("replaceGTE0", comp, options);
  return comp.trim().replace(re$1[options.includePrerelease ? t$1.GTE0PRE : t$1.GTE0], "");
};
const hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
  if (isX(fM)) {
    from = "";
  } else if (isX(fm)) {
    from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
  } else if (isX(fp)) {
    from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
  } else if (fpr) {
    from = `>=${from}`;
  } else {
    from = `>=${from}${incPr ? "-0" : ""}`;
  }
  if (isX(tM)) {
    to = "";
  } else if (isX(tm)) {
    to = `<${+tM + 1}.0.0-0`;
  } else if (isX(tp)) {
    to = `<${tM}.${+tm + 1}.0-0`;
  } else if (tpr) {
    to = `<=${tM}.${tm}.${tp}-${tpr}`;
  } else if (incPr) {
    to = `<${tM}.${tm}.${+tp + 1}-0`;
  } else {
    to = `<=${to}`;
  }
  return `${from} ${to}`.trim();
};
const testSet = (set2, version, options) => {
  for (let i2 = 0; i2 < set2.length; i2++) {
    if (!set2[i2].test(version)) {
      return false;
    }
  }
  if (version.prerelease.length && !options.includePrerelease) {
    for (let i2 = 0; i2 < set2.length; i2++) {
      debug$1(set2[i2].semver);
      if (set2[i2].semver === Comparator$3.ANY) {
        continue;
      }
      if (set2[i2].semver.prerelease.length > 0) {
        const allowed = set2[i2].semver;
        if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
          return true;
        }
      }
    }
    return false;
  }
  return true;
};
const ANY$2 = Symbol("SemVer ANY");
class Comparator$2 {
  static get ANY() {
    return ANY$2;
  }
  constructor(comp, options) {
    options = parseOptions(options);
    if (comp instanceof Comparator$2) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }
    debug("comparator", comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);
    if (this.semver === ANY$2) {
      this.value = "";
    } else {
      this.value = this.operator + this.semver.version;
    }
    debug("comp", this);
  }
  parse(comp) {
    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
    const m2 = comp.match(r);
    if (!m2) {
      throw new TypeError(`Invalid comparator: ${comp}`);
    }
    this.operator = m2[1] !== void 0 ? m2[1] : "";
    if (this.operator === "=") {
      this.operator = "";
    }
    if (!m2[2]) {
      this.semver = ANY$2;
    } else {
      this.semver = new SemVer$4(m2[2], this.options.loose);
    }
  }
  toString() {
    return this.value;
  }
  test(version) {
    debug("Comparator.test", version, this.options.loose);
    if (this.semver === ANY$2 || version === ANY$2) {
      return true;
    }
    if (typeof version === "string") {
      try {
        version = new SemVer$4(version, this.options);
      } catch (er) {
        return false;
      }
    }
    return cmp(version, this.operator, this.semver, this.options);
  }
  intersects(comp, options) {
    if (!(comp instanceof Comparator$2)) {
      throw new TypeError("a Comparator is required");
    }
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (this.operator === "") {
      if (this.value === "") {
        return true;
      }
      return new Range$9(comp.value, options).test(this.value);
    } else if (comp.operator === "") {
      if (comp.value === "") {
        return true;
      }
      return new Range$9(this.value, options).test(comp.semver);
    }
    const sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
    const sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
    const sameSemVer = this.semver.version === comp.semver.version;
    const differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
    const oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<");
    const oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  }
}
var comparator = Comparator$2;
const parseOptions = parseOptions_1;
const { re, t } = re$5.exports;
const cmp = cmp_1;
const debug = debug_1;
const SemVer$4 = semver$2;
const Range$9 = range;
const Range$8 = range;
const satisfies$3 = (version, range2, options) => {
  try {
    range2 = new Range$8(range2, options);
  } catch (er) {
    return false;
  }
  return range2.test(version);
};
var satisfies_1 = satisfies$3;
const Range$7 = range;
const toComparators = (range2, options) => new Range$7(range2, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
var toComparators_1 = toComparators;
const SemVer$3 = semver$2;
const Range$6 = range;
const maxSatisfying = (versions, range2, options) => {
  let max = null;
  let maxSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$6(range2, options);
  } catch (er) {
    return null;
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!max || maxSV.compare(v) === -1) {
        max = v;
        maxSV = new SemVer$3(max, options);
      }
    }
  });
  return max;
};
var maxSatisfying_1 = maxSatisfying;
const SemVer$2 = semver$2;
const Range$5 = range;
const minSatisfying = (versions, range2, options) => {
  let min = null;
  let minSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$5(range2, options);
  } catch (er) {
    return null;
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!min || minSV.compare(v) === 1) {
        min = v;
        minSV = new SemVer$2(min, options);
      }
    }
  });
  return min;
};
var minSatisfying_1 = minSatisfying;
const SemVer$1 = semver$2;
const Range$4 = range;
const gt$1 = gt_1;
const minVersion = (range2, loose) => {
  range2 = new Range$4(range2, loose);
  let minver = new SemVer$1("0.0.0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = new SemVer$1("0.0.0-0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = null;
  for (let i2 = 0; i2 < range2.set.length; ++i2) {
    const comparators = range2.set[i2];
    let setMin = null;
    comparators.forEach((comparator2) => {
      const compver = new SemVer$1(comparator2.semver.version);
      switch (comparator2.operator) {
        case ">":
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }
          compver.raw = compver.format();
        case "":
        case ">=":
          if (!setMin || gt$1(compver, setMin)) {
            setMin = compver;
          }
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${comparator2.operator}`);
      }
    });
    if (setMin && (!minver || gt$1(minver, setMin)))
      minver = setMin;
  }
  if (minver && range2.test(minver)) {
    return minver;
  }
  return null;
};
var minVersion_1 = minVersion;
const Range$3 = range;
const validRange = (range2, options) => {
  try {
    return new Range$3(range2, options).range || "*";
  } catch (er) {
    return null;
  }
};
var valid = validRange;
const SemVer = semver$2;
const Comparator$1 = comparator;
const { ANY: ANY$1 } = Comparator$1;
const Range$2 = range;
const satisfies$2 = satisfies_1;
const gt = gt_1;
const lt = lt_1;
const lte = lte_1;
const gte = gte_1;
const outside$2 = (version, range2, hilo, options) => {
  version = new SemVer(version, options);
  range2 = new Range$2(range2, options);
  let gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case ">":
      gtfn = gt;
      ltefn = lte;
      ltfn = lt;
      comp = ">";
      ecomp = ">=";
      break;
    case "<":
      gtfn = lt;
      ltefn = gte;
      ltfn = gt;
      comp = "<";
      ecomp = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (satisfies$2(version, range2, options)) {
    return false;
  }
  for (let i2 = 0; i2 < range2.set.length; ++i2) {
    const comparators = range2.set[i2];
    let high = null;
    let low = null;
    comparators.forEach((comparator2) => {
      if (comparator2.semver === ANY$1) {
        comparator2 = new Comparator$1(">=0.0.0");
      }
      high = high || comparator2;
      low = low || comparator2;
      if (gtfn(comparator2.semver, high.semver, options)) {
        high = comparator2;
      } else if (ltfn(comparator2.semver, low.semver, options)) {
        low = comparator2;
      }
    });
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }
    if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false;
    }
  }
  return true;
};
var outside_1 = outside$2;
const outside$1 = outside_1;
const gtr = (version, range2, options) => outside$1(version, range2, ">", options);
var gtr_1 = gtr;
const outside = outside_1;
const ltr = (version, range2, options) => outside(version, range2, "<", options);
var ltr_1 = ltr;
const Range$1 = range;
const intersects = (r1, r2, options) => {
  r1 = new Range$1(r1, options);
  r2 = new Range$1(r2, options);
  return r1.intersects(r2);
};
var intersects_1 = intersects;
const satisfies$1 = satisfies_1;
const compare$1 = compare_1;
var simplify = (versions, range2, options) => {
  const set2 = [];
  let min = null;
  let prev = null;
  const v = versions.sort((a, b) => compare$1(a, b, options));
  for (const version of v) {
    const included = satisfies$1(version, range2, options);
    if (included) {
      prev = version;
      if (!min)
        min = version;
    } else {
      if (prev) {
        set2.push([min, prev]);
      }
      prev = null;
      min = null;
    }
  }
  if (min)
    set2.push([min, null]);
  const ranges = [];
  for (const [min2, max] of set2) {
    if (min2 === max)
      ranges.push(min2);
    else if (!max && min2 === v[0])
      ranges.push("*");
    else if (!max)
      ranges.push(`>=${min2}`);
    else if (min2 === v[0])
      ranges.push(`<=${max}`);
    else
      ranges.push(`${min2} - ${max}`);
  }
  const simplified = ranges.join(" || ");
  const original = typeof range2.raw === "string" ? range2.raw : String(range2);
  return simplified.length < original.length ? simplified : range2;
};
const Range = range;
const Comparator = comparator;
const { ANY } = Comparator;
const satisfies = satisfies_1;
const compare = compare_1;
const subset = (sub, dom, options = {}) => {
  if (sub === dom)
    return true;
  sub = new Range(sub, options);
  dom = new Range(dom, options);
  let sawNonNull = false;
  OUTER:
    for (const simpleSub of sub.set) {
      for (const simpleDom of dom.set) {
        const isSub = simpleSubset(simpleSub, simpleDom, options);
        sawNonNull = sawNonNull || isSub !== null;
        if (isSub)
          continue OUTER;
      }
      if (sawNonNull)
        return false;
    }
  return true;
};
const simpleSubset = (sub, dom, options) => {
  if (sub === dom)
    return true;
  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY)
      return true;
    else if (options.includePrerelease)
      sub = [new Comparator(">=0.0.0-0")];
    else
      sub = [new Comparator(">=0.0.0")];
  }
  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease)
      return true;
    else
      dom = [new Comparator(">=0.0.0")];
  }
  const eqSet = new Set();
  let gt2, lt2;
  for (const c of sub) {
    if (c.operator === ">" || c.operator === ">=")
      gt2 = higherGT(gt2, c, options);
    else if (c.operator === "<" || c.operator === "<=")
      lt2 = lowerLT(lt2, c, options);
    else
      eqSet.add(c.semver);
  }
  if (eqSet.size > 1)
    return null;
  let gtltComp;
  if (gt2 && lt2) {
    gtltComp = compare(gt2.semver, lt2.semver, options);
    if (gtltComp > 0)
      return null;
    else if (gtltComp === 0 && (gt2.operator !== ">=" || lt2.operator !== "<="))
      return null;
  }
  for (const eq2 of eqSet) {
    if (gt2 && !satisfies(eq2, String(gt2), options))
      return null;
    if (lt2 && !satisfies(eq2, String(lt2), options))
      return null;
    for (const c of dom) {
      if (!satisfies(eq2, String(c), options))
        return false;
    }
    return true;
  }
  let higher, lower;
  let hasDomLT, hasDomGT;
  let needDomLTPre = lt2 && !options.includePrerelease && lt2.semver.prerelease.length ? lt2.semver : false;
  let needDomGTPre = gt2 && !options.includePrerelease && gt2.semver.prerelease.length ? gt2.semver : false;
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt2.operator === "<" && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false;
  }
  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
    hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
    if (gt2) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false;
        }
      }
      if (c.operator === ">" || c.operator === ">=") {
        higher = higherGT(gt2, c, options);
        if (higher === c && higher !== gt2)
          return false;
      } else if (gt2.operator === ">=" && !satisfies(gt2.semver, String(c), options))
        return false;
    }
    if (lt2) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false;
        }
      }
      if (c.operator === "<" || c.operator === "<=") {
        lower = lowerLT(lt2, c, options);
        if (lower === c && lower !== lt2)
          return false;
      } else if (lt2.operator === "<=" && !satisfies(lt2.semver, String(c), options))
        return false;
    }
    if (!c.operator && (lt2 || gt2) && gtltComp !== 0)
      return false;
  }
  if (gt2 && hasDomLT && !lt2 && gtltComp !== 0)
    return false;
  if (lt2 && hasDomGT && !gt2 && gtltComp !== 0)
    return false;
  if (needDomGTPre || needDomLTPre)
    return false;
  return true;
};
const higherGT = (a, b, options) => {
  if (!a)
    return b;
  const comp = compare(a.semver, b.semver, options);
  return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
};
const lowerLT = (a, b, options) => {
  if (!a)
    return b;
  const comp = compare(a.semver, b.semver, options);
  return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
};
var subset_1 = subset;
const internalRe = re$5.exports;
var semver$1 = {
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
  SemVer: semver$2,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers,
  parse: parse_1,
  valid: valid_1,
  clean: clean_1,
  inc: inc_1,
  diff: diff_1,
  major: major_1,
  minor: minor_1,
  patch: patch_1,
  prerelease: prerelease_1,
  compare: compare_1,
  rcompare: rcompare_1,
  compareLoose: compareLoose_1,
  compareBuild: compareBuild_1,
  sort: sort_1,
  rsort: rsort_1,
  gt: gt_1,
  lt: lt_1,
  eq: eq_1,
  neq: neq_1,
  gte: gte_1,
  lte: lte_1,
  cmp: cmp_1,
  coerce: coerce_1,
  Comparator: comparator,
  Range: range,
  satisfies: satisfies_1,
  toComparators: toComparators_1,
  maxSatisfying: maxSatisfying_1,
  minSatisfying: minSatisfying_1,
  minVersion: minVersion_1,
  validRange: valid,
  outside: outside_1,
  gtr: gtr_1,
  ltr: ltr_1,
  intersects: intersects_1,
  simplifyRange: simplify,
  subset: subset_1
};
var DownloadedUpdateHelper$1 = {};
var lodash_isequal = { exports: {} };
(function(module, exports) {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  var MAX_SAFE_INTEGER2 = 9007199254740991;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag2 = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
  var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil = function() {
    try {
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  function arrayFilter(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }
  function arraySome(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }
  function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  function cacheHas(cache2, key) {
    return cache2.has(key);
  }
  function getValue(object, key) {
    return object == null ? void 0 : object[key];
  }
  function mapToArray(map2) {
    var index = -1, result = Array(map2.size);
    map2.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  function setToArray(set2) {
    var index = -1, result = Array(set2.size);
    set2.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }
  var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto2 = Object.prototype;
  var coreJsData = root2["__core-js_shared__"];
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto2.hasOwnProperty;
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var nativeObjectToString = objectProto2.toString;
  var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  var Buffer2 = moduleExports ? root2.Buffer : void 0, Symbol2 = root2.Symbol, Uint8Array2 = root2.Uint8Array, propertyIsEnumerable = objectProto2.propertyIsEnumerable, splice = arrayProto.splice, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
  var DataView = getNative(root2, "DataView"), Map2 = getNative(root2, "Map"), Promise2 = getNative(root2, "Promise"), Set2 = getNative(root2, "Set"), WeakMap2 = getNative(root2, "WeakMap"), nativeCreate = getNative(Object, "create");
  var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
  var symbolProto2 = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
  function Hash(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : void 0;
  }
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
  }
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }
  function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? void 0 : data[index][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map2 || ListCache)(),
      "string": new Hash()
    };
  }
  function mapCacheDelete(key) {
    var result = getMapData(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    var data = getMapData(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function SetCache(values) {
    var index = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache();
    while (++index < length) {
      this.add(values[index]);
    }
  }
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }
  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }
  function stackDelete(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs2 = data.__data__;
      if (!Map2 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
        pairs2.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs2);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq2(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString2(value);
  }
  function baseIsArguments(value) {
    return isObjectLike2(value) && baseGetTag(value) == argsTag;
  }
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer(object)) {
      if (!isBuffer(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack());
      return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack());
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }
  function baseIsNative(value) {
    if (!isObject2(value) || isMasked(value)) {
      return false;
    }
    var pattern2 = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern2.test(toSource(value));
  }
  function baseIsTypedArray(value) {
    return isObjectLike2(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var stacked = stack.get(array);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
    stack.set(array, other);
    stack.set(other, array);
    while (++index < arrLength) {
      var arrValue = array[index], othValue = other[index];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }
    stack["delete"](array);
    stack["delete"](other);
    return result;
  }
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;
      case arrayBufferTag:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
          return false;
        }
        return true;
      case boolTag:
      case dateTag:
      case numberTag:
        return eq2(+object, +other);
      case errorTag:
        return object.name == other.name && object.message == other.message;
      case regexpTag:
      case stringTag:
        return object == other + "";
      case mapTag:
        var convert = mapToArray;
      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
        convert || (convert = setToArray);
        if (object.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG;
        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack["delete"](object);
        return result;
      case symbolTag2:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
        return false;
      }
    }
    var stacked = stack.get(object);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key], othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack["delete"](object);
    stack["delete"](other);
    return result;
  }
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }
  function getMapData(map2, key) {
    var data = map2.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : void 0;
  }
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };
  var getTag = baseGetTag;
  if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
    getTag = function(value) {
      var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER2 : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isKeyable(value) {
    var type2 = typeof value;
    return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
    return value === proto;
  }
  function objectToString2(value) {
    return nativeObjectToString.call(value);
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  function eq2(value, other) {
    return value === other || value !== value && other !== other;
  }
  var isArguments = baseIsArguments(function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike2(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  var isArray = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  var isBuffer = nativeIsBuffer || stubFalse;
  function isEqual2(value, other) {
    return baseIsEqual(value, other);
  }
  function isFunction(value) {
    if (!isObject2(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
  }
  function isObject2(value) {
    var type2 = typeof value;
    return value != null && (type2 == "object" || type2 == "function");
  }
  function isObjectLike2(value) {
    return value != null && typeof value == "object";
  }
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  function stubArray() {
    return [];
  }
  function stubFalse() {
    return false;
  }
  module.exports = isEqual2;
})(lodash_isequal, lodash_isequal.exports);
Object.defineProperty(DownloadedUpdateHelper$1, "__esModule", { value: true });
DownloadedUpdateHelper$1.createTempUpdateFile = DownloadedUpdateHelper$1.DownloadedUpdateHelper = void 0;
const crypto_1$1 = require$$0__default$4["default"];
const fs_1$6 = require$$0__default$2["default"];
const isEqual = lodash_isequal.exports;
const fs_extra_1$6 = lib;
const path$d = require$$1__default$1["default"];
class DownloadedUpdateHelper {
  constructor(cacheDir) {
    this.cacheDir = cacheDir;
    this._file = null;
    this._packageFile = null;
    this.versionInfo = null;
    this.fileInfo = null;
    this._downloadedFileInfo = null;
  }
  get downloadedFileInfo() {
    return this._downloadedFileInfo;
  }
  get file() {
    return this._file;
  }
  get packageFile() {
    return this._packageFile;
  }
  get cacheDirForPendingUpdate() {
    return path$d.join(this.cacheDir, "pending");
  }
  async validateDownloadedPath(updateFile, updateInfo, fileInfo, logger) {
    if (this.versionInfo != null && this.file === updateFile && this.fileInfo != null) {
      if (isEqual(this.versionInfo, updateInfo) && isEqual(this.fileInfo.info, fileInfo.info) && await fs_extra_1$6.pathExists(updateFile)) {
        return updateFile;
      } else {
        return null;
      }
    }
    const cachedUpdateFile = await this.getValidCachedUpdateFile(fileInfo, logger);
    if (cachedUpdateFile === null) {
      return null;
    }
    logger.info(`Update has already been downloaded to ${updateFile}).`);
    this._file = cachedUpdateFile;
    return cachedUpdateFile;
  }
  async setDownloadedFile(downloadedFile, packageFile, versionInfo, fileInfo, updateFileName, isSaveCache) {
    this._file = downloadedFile;
    this._packageFile = packageFile;
    this.versionInfo = versionInfo;
    this.fileInfo = fileInfo;
    this._downloadedFileInfo = {
      fileName: updateFileName,
      sha512: fileInfo.info.sha512,
      isAdminRightsRequired: fileInfo.info.isAdminRightsRequired === true
    };
    if (isSaveCache) {
      await fs_extra_1$6.outputJson(this.getUpdateInfoFile(), this._downloadedFileInfo);
    }
  }
  async clear() {
    this._file = null;
    this._packageFile = null;
    this.versionInfo = null;
    this.fileInfo = null;
    await this.cleanCacheDirForPendingUpdate();
  }
  async cleanCacheDirForPendingUpdate() {
    try {
      await fs_extra_1$6.emptyDir(this.cacheDirForPendingUpdate);
    } catch (ignore) {
    }
  }
  async getValidCachedUpdateFile(fileInfo, logger) {
    var _a;
    const updateInfoFilePath = this.getUpdateInfoFile();
    const doesUpdateInfoFileExist = await fs_extra_1$6.pathExists(updateInfoFilePath);
    if (!doesUpdateInfoFileExist) {
      return null;
    }
    let cachedInfo;
    try {
      cachedInfo = await fs_extra_1$6.readJson(updateInfoFilePath);
    } catch (error2) {
      let message = `No cached update info available`;
      if (error2.code !== "ENOENT") {
        await this.cleanCacheDirForPendingUpdate();
        message += ` (error on read: ${error2.message})`;
      }
      logger.info(message);
      return null;
    }
    const isCachedInfoFileNameValid = (_a = (cachedInfo === null || cachedInfo === void 0 ? void 0 : cachedInfo.fileName) !== null) !== null && _a !== void 0 ? _a : false;
    if (!isCachedInfoFileNameValid) {
      logger.warn(`Cached update info is corrupted: no fileName, directory for cached update will be cleaned`);
      await this.cleanCacheDirForPendingUpdate();
      return null;
    }
    if (fileInfo.info.sha512 !== cachedInfo.sha512) {
      logger.info(`Cached update sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${cachedInfo.sha512}, expected: ${fileInfo.info.sha512}. Directory for cached update will be cleaned`);
      await this.cleanCacheDirForPendingUpdate();
      return null;
    }
    const updateFile = path$d.join(this.cacheDirForPendingUpdate, cachedInfo.fileName);
    if (!await fs_extra_1$6.pathExists(updateFile)) {
      logger.info("Cached update file doesn't exist");
      return null;
    }
    const sha512 = await hashFile(updateFile);
    if (fileInfo.info.sha512 !== sha512) {
      logger.warn(`Sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${sha512}, expected: ${fileInfo.info.sha512}`);
      await this.cleanCacheDirForPendingUpdate();
      return null;
    }
    this._downloadedFileInfo = cachedInfo;
    return updateFile;
  }
  getUpdateInfoFile() {
    return path$d.join(this.cacheDirForPendingUpdate, "update-info.json");
  }
}
DownloadedUpdateHelper$1.DownloadedUpdateHelper = DownloadedUpdateHelper;
function hashFile(file2, algorithm = "sha512", encoding = "base64", options) {
  return new Promise((resolve2, reject) => {
    const hash = crypto_1$1.createHash(algorithm);
    hash.on("error", reject).setEncoding(encoding);
    fs_1$6.createReadStream(file2, __spreadProps(__spreadValues({}, options), { highWaterMark: 1024 * 1024 })).on("error", reject).on("end", () => {
      hash.end();
      resolve2(hash.read());
    }).pipe(hash, { end: false });
  });
}
async function createTempUpdateFile(name, cacheDir, log) {
  let nameCounter = 0;
  let result = path$d.join(cacheDir, name);
  for (let i2 = 0; i2 < 3; i2++) {
    try {
      await fs_extra_1$6.unlink(result);
      return result;
    } catch (e) {
      if (e.code === "ENOENT") {
        return result;
      }
      log.warn(`Error on remove temp update file: ${e}`);
      result = path$d.join(cacheDir, `${nameCounter++}-${name}`);
    }
  }
  return result;
}
DownloadedUpdateHelper$1.createTempUpdateFile = createTempUpdateFile;
var ElectronAppAdapter$1 = {};
var AppAdapter = {};
Object.defineProperty(AppAdapter, "__esModule", { value: true });
AppAdapter.getAppCacheDir = void 0;
const path$c = require$$1__default$1["default"];
const os_1 = require$$1__default$3["default"];
function getAppCacheDir() {
  const homedir2 = os_1.homedir();
  let result;
  if (process.platform === "win32") {
    result = process.env["LOCALAPPDATA"] || path$c.join(homedir2, "AppData", "Local");
  } else if (process.platform === "darwin") {
    result = path$c.join(homedir2, "Library", "Application Support", "Caches");
  } else {
    result = process.env["XDG_CACHE_HOME"] || path$c.join(homedir2, ".cache");
  }
  return result;
}
AppAdapter.getAppCacheDir = getAppCacheDir;
Object.defineProperty(ElectronAppAdapter$1, "__esModule", { value: true });
ElectronAppAdapter$1.ElectronAppAdapter = void 0;
const path$b = require$$1__default$1["default"];
const AppAdapter_1 = AppAdapter;
class ElectronAppAdapter {
  constructor(app2 = require$$1__default["default"].app) {
    this.app = app2;
  }
  whenReady() {
    return this.app.whenReady();
  }
  get version() {
    return this.app.getVersion();
  }
  get name() {
    return this.app.getName();
  }
  get isPackaged() {
    return this.app.isPackaged === true;
  }
  get appUpdateConfigPath() {
    return this.isPackaged ? path$b.join(process.resourcesPath, "app-update.yml") : path$b.join(this.app.getAppPath(), "dev-app-update.yml");
  }
  get userDataPath() {
    return this.app.getPath("userData");
  }
  get baseCachePath() {
    return AppAdapter_1.getAppCacheDir();
  }
  quit() {
    this.app.quit();
  }
  onQuit(handler) {
    this.app.once("quit", (_, exitCode) => handler(exitCode));
  }
}
ElectronAppAdapter$1.ElectronAppAdapter = ElectronAppAdapter;
var electronHttpExecutor = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ElectronHttpExecutor = exports.getNetSession = exports.NET_SESSION_NAME = void 0;
  const builder_util_runtime_12 = out;
  exports.NET_SESSION_NAME = "electron-updater";
  function getNetSession() {
    return require$$1__default["default"].session.fromPartition(exports.NET_SESSION_NAME, {
      cache: false
    });
  }
  exports.getNetSession = getNetSession;
  class ElectronHttpExecutor extends builder_util_runtime_12.HttpExecutor {
    constructor(proxyLoginCallback) {
      super();
      this.proxyLoginCallback = proxyLoginCallback;
      this.cachedSession = null;
    }
    async download(url, destination, options) {
      return await options.cancellationToken.createPromise((resolve2, reject, onCancel) => {
        const requestOptions = {
          headers: options.headers || void 0,
          redirect: "manual"
        };
        builder_util_runtime_12.configureRequestUrl(url, requestOptions);
        builder_util_runtime_12.configureRequestOptions(requestOptions);
        this.doDownload(requestOptions, {
          destination,
          options,
          onCancel,
          callback: (error2) => {
            if (error2 == null) {
              resolve2(destination);
            } else {
              reject(error2);
            }
          },
          responseHandler: null
        }, 0);
      });
    }
    createRequest(options, callback) {
      if (options.headers && options.headers.Host) {
        options.host = options.headers.Host;
        delete options.headers.Host;
      }
      if (this.cachedSession == null) {
        this.cachedSession = getNetSession();
      }
      const request = require$$1__default["default"].net.request(__spreadProps(__spreadValues({}, options), {
        session: this.cachedSession
      }));
      request.on("response", callback);
      if (this.proxyLoginCallback != null) {
        request.on("login", this.proxyLoginCallback);
      }
      return request;
    }
    addRedirectHandlers(request, options, reject, redirectCount, handler) {
      request.on("redirect", (statusCode, method, redirectUrl) => {
        request.abort();
        if (redirectCount > this.maxRedirects) {
          reject(this.createMaxRedirectError());
        } else {
          handler(builder_util_runtime_12.HttpExecutor.prepareRedirectUrlOptions(redirectUrl, options));
        }
      });
    }
  }
  exports.ElectronHttpExecutor = ElectronHttpExecutor;
})(electronHttpExecutor);
var GenericProvider$1 = {};
var util$1 = {};
var INFINITY = 1 / 0;
var symbolTag = "[object Symbol]";
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function("return this")();
var objectProto = Object.prototype;
var objectToString = objectProto.toString;
var Symbol$1 = root.Symbol;
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function isObjectLike(value) {
  return !!value && typeof value == "object";
}
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function escapeRegExp$1(string) {
  string = toString(string);
  return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
}
var lodash_escaperegexp = escapeRegExp$1;
Object.defineProperty(util$1, "__esModule", { value: true });
util$1.blockmapFiles = util$1.getChannelFilename = util$1.newUrlFromBase = util$1.newBaseUrl = void 0;
const url_1$5 = require$$2__default["default"];
const escapeRegExp = lodash_escaperegexp;
function newBaseUrl(url) {
  const result = new url_1$5.URL(url);
  if (!result.pathname.endsWith("/")) {
    result.pathname += "/";
  }
  return result;
}
util$1.newBaseUrl = newBaseUrl;
function newUrlFromBase(pathname, baseUrl, addRandomQueryToAvoidCaching = false) {
  const result = new url_1$5.URL(pathname, baseUrl);
  const search = baseUrl.search;
  if (search != null && search.length !== 0) {
    result.search = search;
  } else if (addRandomQueryToAvoidCaching) {
    result.search = `noCache=${Date.now().toString(32)}`;
  }
  return result;
}
util$1.newUrlFromBase = newUrlFromBase;
function getChannelFilename(channel) {
  return `${channel}.yml`;
}
util$1.getChannelFilename = getChannelFilename;
function blockmapFiles(baseUrl, oldVersion, newVersion) {
  const newBlockMapUrl = newUrlFromBase(`${baseUrl.pathname}.blockmap`, baseUrl);
  const oldBlockMapUrl = newUrlFromBase(`${baseUrl.pathname.replace(new RegExp(escapeRegExp(newVersion), "g"), oldVersion)}.blockmap`, baseUrl);
  return [oldBlockMapUrl, newBlockMapUrl];
}
util$1.blockmapFiles = blockmapFiles;
var Provider$1 = {};
Object.defineProperty(Provider$1, "__esModule", { value: true });
Provider$1.resolveFiles = Provider$1.getFileList = Provider$1.parseUpdateInfo = Provider$1.findFile = Provider$1.Provider = void 0;
const builder_util_runtime_1$e = out;
const js_yaml_1$2 = jsYaml;
const util_1$w = util$1;
class Provider {
  constructor(runtimeOptions) {
    this.runtimeOptions = runtimeOptions;
    this.requestHeaders = null;
    this.executor = runtimeOptions.executor;
  }
  get isUseMultipleRangeRequest() {
    return this.runtimeOptions.isUseMultipleRangeRequest !== false;
  }
  getChannelFilePrefix() {
    if (this.runtimeOptions.platform === "linux") {
      const arch = process.env["TEST_UPDATER_ARCH"] || process.arch;
      const archSuffix = arch === "x64" ? "" : `-${arch}`;
      return "-linux" + archSuffix;
    } else {
      return this.runtimeOptions.platform === "darwin" ? "-mac" : "";
    }
  }
  getDefaultChannelName() {
    return this.getCustomChannelName("latest");
  }
  getCustomChannelName(channel) {
    return `${channel}${this.getChannelFilePrefix()}`;
  }
  get fileExtraDownloadHeaders() {
    return null;
  }
  setRequestHeaders(value) {
    this.requestHeaders = value;
  }
  httpRequest(url, headers, cancellationToken) {
    return this.executor.request(this.createRequestOptions(url, headers), cancellationToken);
  }
  createRequestOptions(url, headers) {
    const result = {};
    if (this.requestHeaders == null) {
      if (headers != null) {
        result.headers = headers;
      }
    } else {
      result.headers = headers == null ? this.requestHeaders : __spreadValues(__spreadValues({}, this.requestHeaders), headers);
    }
    builder_util_runtime_1$e.configureRequestUrl(url, result);
    return result;
  }
}
Provider$1.Provider = Provider;
function findFile(files, extension, not2) {
  if (files.length === 0) {
    throw builder_util_runtime_1$e.newError("No files provided", "ERR_UPDATER_NO_FILES_PROVIDED");
  }
  const result = files.find((it) => it.url.pathname.toLowerCase().endsWith(`.${extension}`));
  if (result != null) {
    return result;
  } else if (not2 == null) {
    return files[0];
  } else {
    return files.find((fileInfo) => !not2.some((ext) => fileInfo.url.pathname.toLowerCase().endsWith(`.${ext}`)));
  }
}
Provider$1.findFile = findFile;
function parseUpdateInfo(rawData, channelFile, channelFileUrl) {
  if (rawData == null) {
    throw builder_util_runtime_1$e.newError(`Cannot parse update info from ${channelFile} in the latest release artifacts (${channelFileUrl}): rawData: null`, "ERR_UPDATER_INVALID_UPDATE_INFO");
  }
  let result;
  try {
    result = js_yaml_1$2.load(rawData);
  } catch (e) {
    throw builder_util_runtime_1$e.newError(`Cannot parse update info from ${channelFile} in the latest release artifacts (${channelFileUrl}): ${e.stack || e.message}, rawData: ${rawData}`, "ERR_UPDATER_INVALID_UPDATE_INFO");
  }
  return result;
}
Provider$1.parseUpdateInfo = parseUpdateInfo;
function getFileList(updateInfo) {
  const files = updateInfo.files;
  if (files != null && files.length > 0) {
    return files;
  }
  if (updateInfo.path != null) {
    return [
      {
        url: updateInfo.path,
        sha2: updateInfo.sha2,
        sha512: updateInfo.sha512
      }
    ];
  } else {
    throw builder_util_runtime_1$e.newError(`No files provided: ${builder_util_runtime_1$e.safeStringifyJson(updateInfo)}`, "ERR_UPDATER_NO_FILES_PROVIDED");
  }
}
Provider$1.getFileList = getFileList;
function resolveFiles(updateInfo, baseUrl, pathTransformer = (p) => p) {
  const files = getFileList(updateInfo);
  const result = files.map((fileInfo) => {
    if (fileInfo.sha2 == null && fileInfo.sha512 == null) {
      throw builder_util_runtime_1$e.newError(`Update info doesn't contain nor sha256 neither sha512 checksum: ${builder_util_runtime_1$e.safeStringifyJson(fileInfo)}`, "ERR_UPDATER_NO_CHECKSUM");
    }
    return {
      url: util_1$w.newUrlFromBase(pathTransformer(fileInfo.url), baseUrl),
      info: fileInfo
    };
  });
  const packages = updateInfo.packages;
  const packageInfo = packages == null ? null : packages[process.arch] || packages.ia32;
  if (packageInfo != null) {
    result[0].packageInfo = __spreadProps(__spreadValues({}, packageInfo), {
      path: util_1$w.newUrlFromBase(pathTransformer(packageInfo.path), baseUrl).href
    });
  }
  return result;
}
Provider$1.resolveFiles = resolveFiles;
Object.defineProperty(GenericProvider$1, "__esModule", { value: true });
GenericProvider$1.GenericProvider = void 0;
const builder_util_runtime_1$d = out;
const util_1$v = util$1;
const Provider_1$7 = Provider$1;
class GenericProvider extends Provider_1$7.Provider {
  constructor(configuration, updater, runtimeOptions) {
    super(runtimeOptions);
    this.configuration = configuration;
    this.updater = updater;
    this.baseUrl = util_1$v.newBaseUrl(this.configuration.url);
  }
  get channel() {
    const result = this.updater.channel || this.configuration.channel;
    return result == null ? this.getDefaultChannelName() : this.getCustomChannelName(result);
  }
  async getLatestVersion() {
    const channelFile = util_1$v.getChannelFilename(this.channel);
    const channelUrl = util_1$v.newUrlFromBase(channelFile, this.baseUrl, this.updater.isAddNoCacheQuery);
    for (let attemptNumber = 0; ; attemptNumber++) {
      try {
        return Provider_1$7.parseUpdateInfo(await this.httpRequest(channelUrl), channelFile, channelUrl);
      } catch (e) {
        if (e instanceof builder_util_runtime_1$d.HttpError && e.statusCode === 404) {
          throw builder_util_runtime_1$d.newError(`Cannot find channel "${channelFile}" update info: ${e.stack || e.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
        } else if (e.code === "ECONNREFUSED") {
          if (attemptNumber < 3) {
            await new Promise((resolve2, reject) => {
              try {
                setTimeout(resolve2, 1e3 * attemptNumber);
              } catch (e2) {
                reject(e2);
              }
            });
            continue;
          }
        }
        throw e;
      }
    }
  }
  resolveFiles(updateInfo) {
    return Provider_1$7.resolveFiles(updateInfo, this.baseUrl);
  }
}
GenericProvider$1.GenericProvider = GenericProvider;
var providerFactory = {};
var BintrayProvider$1 = {};
var bintray = {};
Object.defineProperty(bintray, "__esModule", { value: true });
bintray.BintrayClient = void 0;
const httpExecutor_1 = httpExecutor;
class BintrayClient {
  constructor(options, httpExecutor2, cancellationToken, apiKey) {
    this.httpExecutor = httpExecutor2;
    this.cancellationToken = cancellationToken;
    this.requestHeaders = null;
    if (options.owner == null) {
      throw new Error("owner is not specified");
    }
    if (options.package == null) {
      throw new Error("package is not specified");
    }
    this.repo = options.repo || "generic";
    this.packageName = options.package;
    this.owner = options.owner;
    this.user = options.user || options.owner;
    this.component = options.component || null;
    this.distribution = options.distribution || "stable";
    this.auth = apiKey == null ? null : `Basic ${Buffer.from(`${this.user}:${apiKey}`).toString("base64")}`;
    this.basePath = `/packages/${this.owner}/${this.repo}/${this.packageName}`;
  }
  setRequestHeaders(value) {
    this.requestHeaders = value;
  }
  bintrayRequest(path2, auth, data = null, cancellationToken, method) {
    return httpExecutor_1.parseJson(this.httpExecutor.request(httpExecutor_1.configureRequestOptions({ hostname: "api.bintray.com", path: path2, headers: this.requestHeaders || void 0 }, auth, method), cancellationToken, data));
  }
  getVersion(version) {
    return this.bintrayRequest(`${this.basePath}/versions/${version}`, this.auth, null, this.cancellationToken);
  }
  getVersionFiles(version) {
    return this.bintrayRequest(`${this.basePath}/versions/${version}/files`, this.auth, null, this.cancellationToken);
  }
  createVersion(version) {
    return this.bintrayRequest(`${this.basePath}/versions`, this.auth, {
      name: version
    }, this.cancellationToken);
  }
  deleteVersion(version) {
    return this.bintrayRequest(`${this.basePath}/versions/${version}`, this.auth, null, this.cancellationToken, "DELETE");
  }
}
bintray.BintrayClient = BintrayClient;
Object.defineProperty(BintrayProvider$1, "__esModule", { value: true });
BintrayProvider$1.BintrayProvider = void 0;
const builder_util_runtime_1$c = out;
const bintray_1 = bintray;
const url_1$4 = require$$2__default["default"];
const util_1$u = util$1;
const Provider_1$6 = Provider$1;
class BintrayProvider extends Provider_1$6.Provider {
  constructor(configuration, runtimeOptions) {
    super(runtimeOptions);
    this.client = new bintray_1.BintrayClient(configuration, runtimeOptions.executor, new builder_util_runtime_1$c.CancellationToken());
    this.baseUrl = util_1$u.newBaseUrl(`https://dl.bintray.com/${this.client.owner}/${this.client.repo}`);
  }
  setRequestHeaders(value) {
    super.setRequestHeaders(value);
    this.client.setRequestHeaders(value);
  }
  async getLatestVersion() {
    try {
      const data = await this.client.getVersion("_latest");
      const channelFilename = util_1$u.getChannelFilename(this.getDefaultChannelName());
      const files = await this.client.getVersionFiles(data.name);
      const channelFile = files.find((it) => it.name.endsWith(`_${channelFilename}`) || it.name.endsWith(`-${channelFilename}`));
      if (channelFile == null) {
        throw builder_util_runtime_1$c.newError(`Cannot find channel file "${channelFilename}", existing files:
${files.map((it) => JSON.stringify(it, null, 2)).join(",\n")}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
      }
      const channelFileUrl = new url_1$4.URL(`https://dl.bintray.com/${this.client.owner}/${this.client.repo}/${channelFile.name}`);
      return Provider_1$6.parseUpdateInfo(await this.httpRequest(channelFileUrl), channelFilename, channelFileUrl);
    } catch (e) {
      if ("statusCode" in e && e.statusCode === 404) {
        throw builder_util_runtime_1$c.newError(`No latest version, please ensure that user, package and repository correctly configured. Or at least one version is published. ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
      }
      throw e;
    }
  }
  resolveFiles(updateInfo) {
    return Provider_1$6.resolveFiles(updateInfo, this.baseUrl);
  }
}
BintrayProvider$1.BintrayProvider = BintrayProvider;
var GitHubProvider$1 = {};
Object.defineProperty(GitHubProvider$1, "__esModule", { value: true });
GitHubProvider$1.computeReleaseNotes = GitHubProvider$1.GitHubProvider = GitHubProvider$1.BaseGitHubProvider = void 0;
const builder_util_runtime_1$b = out;
const semver = semver$1;
const url_1$3 = require$$2__default["default"];
const util_1$t = util$1;
const Provider_1$5 = Provider$1;
const hrefRegExp = /\/tag\/([^/]+)$/;
class BaseGitHubProvider extends Provider_1$5.Provider {
  constructor(options, defaultHost, runtimeOptions) {
    super(__spreadProps(__spreadValues({}, runtimeOptions), {
      isUseMultipleRangeRequest: false
    }));
    this.options = options;
    this.baseUrl = util_1$t.newBaseUrl(builder_util_runtime_1$b.githubUrl(options, defaultHost));
    const apiHost = defaultHost === "github.com" ? "api.github.com" : defaultHost;
    this.baseApiUrl = util_1$t.newBaseUrl(builder_util_runtime_1$b.githubUrl(options, apiHost));
  }
  computeGithubBasePath(result) {
    const host = this.options.host;
    return host != null && host !== "github.com" && host !== "api.github.com" ? `/api/v3${result}` : result;
  }
}
GitHubProvider$1.BaseGitHubProvider = BaseGitHubProvider;
class GitHubProvider extends BaseGitHubProvider {
  constructor(options, updater, runtimeOptions) {
    super(options, "github.com", runtimeOptions);
    this.options = options;
    this.updater = updater;
  }
  async getLatestVersion() {
    const cancellationToken = new builder_util_runtime_1$b.CancellationToken();
    const feedXml = await this.httpRequest(util_1$t.newUrlFromBase(`${this.basePath}.atom`, this.baseUrl), {
      accept: "application/xml, application/atom+xml, text/xml, */*"
    }, cancellationToken);
    const feed = builder_util_runtime_1$b.parseXml(feedXml);
    let latestRelease = feed.element("entry", false, `No published versions on GitHub`);
    let tag;
    try {
      if (this.updater.allowPrerelease) {
        tag = hrefRegExp.exec(latestRelease.element("link").attribute("href"))[1];
      } else {
        tag = await this.getLatestTagName(cancellationToken);
        for (const element of feed.getElements("entry")) {
          if (hrefRegExp.exec(element.element("link").attribute("href"))[1] === tag) {
            latestRelease = element;
            break;
          }
        }
      }
    } catch (e) {
      throw builder_util_runtime_1$b.newError(`Cannot parse releases feed: ${e.stack || e.message},
XML:
${feedXml}`, "ERR_UPDATER_INVALID_RELEASE_FEED");
    }
    if (tag == null) {
      throw builder_util_runtime_1$b.newError(`No published versions on GitHub`, "ERR_UPDATER_NO_PUBLISHED_VERSIONS");
    }
    const channelFile = util_1$t.getChannelFilename(this.getDefaultChannelName());
    const channelFileUrl = util_1$t.newUrlFromBase(this.getBaseDownloadPath(tag, channelFile), this.baseUrl);
    const requestOptions = this.createRequestOptions(channelFileUrl);
    let rawData;
    try {
      rawData = await this.executor.request(requestOptions, cancellationToken);
    } catch (e) {
      if (!this.updater.allowPrerelease && e instanceof builder_util_runtime_1$b.HttpError && e.statusCode === 404) {
        throw builder_util_runtime_1$b.newError(`Cannot find ${channelFile} in the latest release artifacts (${channelFileUrl}): ${e.stack || e.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
      }
      throw e;
    }
    const result = Provider_1$5.parseUpdateInfo(rawData, channelFile, channelFileUrl);
    if (result.releaseName == null) {
      result.releaseName = latestRelease.elementValueOrEmpty("title");
    }
    if (result.releaseNotes == null) {
      result.releaseNotes = computeReleaseNotes(this.updater.currentVersion, this.updater.fullChangelog, feed, latestRelease);
    }
    return __spreadValues({
      tag
    }, result);
  }
  async getLatestTagName(cancellationToken) {
    const options = this.options;
    const url = options.host == null || options.host === "github.com" ? util_1$t.newUrlFromBase(`${this.basePath}/latest`, this.baseUrl) : new url_1$3.URL(`${this.computeGithubBasePath(`/repos/${options.owner}/${options.repo}/releases`)}/latest`, this.baseApiUrl);
    try {
      const rawData = await this.httpRequest(url, { Accept: "application/json" }, cancellationToken);
      if (rawData == null) {
        return null;
      }
      const releaseInfo = JSON.parse(rawData);
      return releaseInfo.tag_name;
    } catch (e) {
      throw builder_util_runtime_1$b.newError(`Unable to find latest version on GitHub (${url}), please ensure a production release exists: ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
    }
  }
  get basePath() {
    return `/${this.options.owner}/${this.options.repo}/releases`;
  }
  resolveFiles(updateInfo) {
    return Provider_1$5.resolveFiles(updateInfo, this.baseUrl, (p) => this.getBaseDownloadPath(updateInfo.tag, p.replace(/ /g, "-")));
  }
  getBaseDownloadPath(tag, fileName) {
    return `${this.basePath}/download/${tag}/${fileName}`;
  }
}
GitHubProvider$1.GitHubProvider = GitHubProvider;
function getNoteValue(parent) {
  const result = parent.elementValueOrEmpty("content");
  return result === "No content." ? "" : result;
}
function computeReleaseNotes(currentVersion, isFullChangelog, feed, latestRelease) {
  if (!isFullChangelog) {
    return getNoteValue(latestRelease);
  }
  const releaseNotes = [];
  for (const release of feed.getElements("entry")) {
    const versionRelease = /\/tag\/v?([^/]+)$/.exec(release.element("link").attribute("href"))[1];
    if (semver.lt(currentVersion, versionRelease)) {
      releaseNotes.push({
        version: versionRelease,
        note: getNoteValue(release)
      });
    }
  }
  return releaseNotes.sort((a, b) => semver.rcompare(a.version, b.version));
}
GitHubProvider$1.computeReleaseNotes = computeReleaseNotes;
var KeygenProvider$1 = {};
Object.defineProperty(KeygenProvider$1, "__esModule", { value: true });
KeygenProvider$1.KeygenProvider = void 0;
const builder_util_runtime_1$a = out;
const util_1$s = util$1;
const Provider_1$4 = Provider$1;
class KeygenProvider extends Provider_1$4.Provider {
  constructor(configuration, updater, runtimeOptions) {
    super(__spreadProps(__spreadValues({}, runtimeOptions), {
      isUseMultipleRangeRequest: false
    }));
    this.configuration = configuration;
    this.updater = updater;
    this.baseUrl = util_1$s.newBaseUrl(`https://api.keygen.sh/v1/accounts/${this.configuration.account}/artifacts`);
  }
  get channel() {
    return this.updater.channel || this.configuration.channel || "stable";
  }
  async getLatestVersion() {
    const cancellationToken = new builder_util_runtime_1$a.CancellationToken();
    const channelFile = util_1$s.getChannelFilename(this.getCustomChannelName(this.channel));
    const channelUrl = util_1$s.newUrlFromBase(channelFile, this.baseUrl, this.updater.isAddNoCacheQuery);
    try {
      const updateInfo = await this.httpRequest(channelUrl, {
        Accept: "application/vnd.api+json"
      }, cancellationToken);
      return Provider_1$4.parseUpdateInfo(updateInfo, channelFile, channelUrl);
    } catch (e) {
      throw builder_util_runtime_1$a.newError(`Unable to find latest version on ${this.toString()}, please ensure release exists: ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
    }
  }
  resolveFiles(updateInfo) {
    return Provider_1$4.resolveFiles(updateInfo, this.baseUrl);
  }
  toString() {
    const { account, product, platform: platform2 } = this.configuration;
    return `Keygen (account: ${account}, product: ${product}, platform: ${platform2}, channel: ${this.channel})`;
  }
}
KeygenProvider$1.KeygenProvider = KeygenProvider;
var PrivateGitHubProvider$1 = {};
Object.defineProperty(PrivateGitHubProvider$1, "__esModule", { value: true });
PrivateGitHubProvider$1.PrivateGitHubProvider = void 0;
const builder_util_runtime_1$9 = out;
const js_yaml_1$1 = jsYaml;
const path$a = require$$1__default$1["default"];
const url_1$2 = require$$2__default["default"];
const util_1$r = util$1;
const GitHubProvider_1$1 = GitHubProvider$1;
const Provider_1$3 = Provider$1;
class PrivateGitHubProvider extends GitHubProvider_1$1.BaseGitHubProvider {
  constructor(options, updater, token, runtimeOptions) {
    super(options, "api.github.com", runtimeOptions);
    this.updater = updater;
    this.token = token;
  }
  createRequestOptions(url, headers) {
    const result = super.createRequestOptions(url, headers);
    result.redirect = "manual";
    return result;
  }
  async getLatestVersion() {
    const cancellationToken = new builder_util_runtime_1$9.CancellationToken();
    const channelFile = util_1$r.getChannelFilename(this.getDefaultChannelName());
    const releaseInfo = await this.getLatestVersionInfo(cancellationToken);
    const asset = releaseInfo.assets.find((it) => it.name === channelFile);
    if (asset == null) {
      throw builder_util_runtime_1$9.newError(`Cannot find ${channelFile} in the release ${releaseInfo.html_url || releaseInfo.name}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
    }
    const url = new url_1$2.URL(asset.url);
    let result;
    try {
      result = js_yaml_1$1.load(await this.httpRequest(url, this.configureHeaders("application/octet-stream"), cancellationToken));
    } catch (e) {
      if (e instanceof builder_util_runtime_1$9.HttpError && e.statusCode === 404) {
        throw builder_util_runtime_1$9.newError(`Cannot find ${channelFile} in the latest release artifacts (${url}): ${e.stack || e.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
      }
      throw e;
    }
    result.assets = releaseInfo.assets;
    return result;
  }
  get fileExtraDownloadHeaders() {
    return this.configureHeaders("application/octet-stream");
  }
  configureHeaders(accept) {
    return {
      accept,
      authorization: `token ${this.token}`
    };
  }
  async getLatestVersionInfo(cancellationToken) {
    const allowPrerelease = this.updater.allowPrerelease;
    let basePath = this.basePath;
    if (!allowPrerelease) {
      basePath = `${basePath}/latest`;
    }
    const url = util_1$r.newUrlFromBase(basePath, this.baseUrl);
    try {
      const version = JSON.parse(await this.httpRequest(url, this.configureHeaders("application/vnd.github.v3+json"), cancellationToken));
      if (allowPrerelease) {
        return version.find((it) => it.prerelease) || version[0];
      } else {
        return version;
      }
    } catch (e) {
      throw builder_util_runtime_1$9.newError(`Unable to find latest version on GitHub (${url}), please ensure a production release exists: ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
    }
  }
  get basePath() {
    return this.computeGithubBasePath(`/repos/${this.options.owner}/${this.options.repo}/releases`);
  }
  resolveFiles(updateInfo) {
    return Provider_1$3.getFileList(updateInfo).map((it) => {
      const name = path$a.posix.basename(it.url).replace(/ /g, "-");
      const asset = updateInfo.assets.find((it2) => it2 != null && it2.name === name);
      if (asset == null) {
        throw builder_util_runtime_1$9.newError(`Cannot find asset "${name}" in: ${JSON.stringify(updateInfo.assets, null, 2)}`, "ERR_UPDATER_ASSET_NOT_FOUND");
      }
      return {
        url: new url_1$2.URL(asset.url),
        info: it
      };
    });
  }
}
PrivateGitHubProvider$1.PrivateGitHubProvider = PrivateGitHubProvider;
Object.defineProperty(providerFactory, "__esModule", { value: true });
providerFactory.createClient = providerFactory.isUrlProbablySupportMultiRangeRequests = void 0;
const builder_util_runtime_1$8 = out;
const BintrayProvider_1 = BintrayProvider$1;
const GenericProvider_1$1 = GenericProvider$1;
const GitHubProvider_1 = GitHubProvider$1;
const KeygenProvider_1 = KeygenProvider$1;
const PrivateGitHubProvider_1 = PrivateGitHubProvider$1;
function isUrlProbablySupportMultiRangeRequests(url) {
  return !url.includes("s3.amazonaws.com");
}
providerFactory.isUrlProbablySupportMultiRangeRequests = isUrlProbablySupportMultiRangeRequests;
function createClient(data, updater, runtimeOptions) {
  if (typeof data === "string") {
    throw builder_util_runtime_1$8.newError("Please pass PublishConfiguration object", "ERR_UPDATER_INVALID_PROVIDER_CONFIGURATION");
  }
  const provider = data.provider;
  switch (provider) {
    case "github": {
      const githubOptions = data;
      const token = (githubOptions.private ? process.env["GH_TOKEN"] || process.env["GITHUB_TOKEN"] : null) || githubOptions.token;
      if (token == null) {
        return new GitHubProvider_1.GitHubProvider(githubOptions, updater, runtimeOptions);
      } else {
        return new PrivateGitHubProvider_1.PrivateGitHubProvider(githubOptions, updater, token, runtimeOptions);
      }
    }
    case "keygen":
      return new KeygenProvider_1.KeygenProvider(data, updater, runtimeOptions);
    case "s3":
    case "spaces":
      return new GenericProvider_1$1.GenericProvider({
        provider: "generic",
        url: builder_util_runtime_1$8.getS3LikeProviderBaseUrl(data),
        channel: data.channel || null
      }, updater, __spreadProps(__spreadValues({}, runtimeOptions), {
        isUseMultipleRangeRequest: false
      }));
    case "generic": {
      const options = data;
      return new GenericProvider_1$1.GenericProvider(options, updater, __spreadProps(__spreadValues({}, runtimeOptions), {
        isUseMultipleRangeRequest: options.useMultipleRangeRequest !== false && isUrlProbablySupportMultiRangeRequests(options.url)
      }));
    }
    case "bintray":
      return new BintrayProvider_1.BintrayProvider(data, runtimeOptions);
    case "custom": {
      const options = data;
      const constructor = options.updateProvider;
      if (!constructor) {
        throw builder_util_runtime_1$8.newError("Custom provider not specified", "ERR_UPDATER_INVALID_PROVIDER_CONFIGURATION");
      }
      return new constructor(options, updater, runtimeOptions);
    }
    default:
      throw builder_util_runtime_1$8.newError(`Unsupported provider: ${provider}`, "ERR_UPDATER_UNSUPPORTED_PROVIDER");
  }
}
providerFactory.createClient = createClient;
Object.defineProperty(AppUpdater$1, "__esModule", { value: true });
AppUpdater$1.NoOpLogger = AppUpdater$1.AppUpdater = void 0;
const builder_util_runtime_1$7 = out;
const crypto_1 = require$$0__default$4["default"];
const events_1 = require$$0__default$3["default"];
const fs_extra_1$5 = lib;
const promises_1 = require$$4__default$1["default"];
const js_yaml_1 = jsYaml;
const lazy_val_1 = main;
const path$9 = require$$1__default$1["default"];
const semver_1 = semver$1;
const DownloadedUpdateHelper_1 = DownloadedUpdateHelper$1;
const ElectronAppAdapter_1 = ElectronAppAdapter$1;
const electronHttpExecutor_1 = electronHttpExecutor;
const GenericProvider_1 = GenericProvider$1;
const main_1$2 = main$1;
const providerFactory_1 = providerFactory;
class AppUpdater extends events_1.EventEmitter {
  constructor(options, app2) {
    super();
    this.autoDownload = true;
    this.autoInstallOnAppQuit = true;
    this.allowPrerelease = false;
    this.fullChangelog = false;
    this.allowDowngrade = false;
    this._channel = null;
    this.downloadedUpdateHelper = null;
    this.requestHeaders = null;
    this._logger = console;
    this.signals = new main_1$2.UpdaterSignal(this);
    this._appUpdateConfigPath = null;
    this.clientPromise = null;
    this.stagingUserIdPromise = new lazy_val_1.Lazy(() => this.getOrCreateStagingUserId());
    this.configOnDisk = new lazy_val_1.Lazy(() => this.loadUpdateConfig());
    this.checkForUpdatesPromise = null;
    this.updateInfoAndProvider = null;
    this._testOnlyOptions = null;
    this.on("error", (error2) => {
      this._logger.error(`Error: ${error2.stack || error2.message}`);
    });
    if (app2 == null) {
      this.app = new ElectronAppAdapter_1.ElectronAppAdapter();
      this.httpExecutor = new electronHttpExecutor_1.ElectronHttpExecutor((authInfo, callback) => this.emit("login", authInfo, callback));
    } else {
      this.app = app2;
      this.httpExecutor = null;
    }
    const currentVersionString = this.app.version;
    const currentVersion = semver_1.parse(currentVersionString);
    if (currentVersion == null) {
      throw builder_util_runtime_1$7.newError(`App version is not a valid semver version: "${currentVersionString}"`, "ERR_UPDATER_INVALID_VERSION");
    }
    this.currentVersion = currentVersion;
    this.allowPrerelease = hasPrereleaseComponents(currentVersion);
    if (options != null) {
      this.setFeedURL(options);
      if (typeof options !== "string" && options.requestHeaders) {
        this.requestHeaders = options.requestHeaders;
      }
    }
  }
  get channel() {
    return this._channel;
  }
  set channel(value) {
    if (this._channel != null) {
      if (typeof value !== "string") {
        throw builder_util_runtime_1$7.newError(`Channel must be a string, but got: ${value}`, "ERR_UPDATER_INVALID_CHANNEL");
      } else if (value.length === 0) {
        throw builder_util_runtime_1$7.newError(`Channel must be not an empty string`, "ERR_UPDATER_INVALID_CHANNEL");
      }
    }
    this._channel = value;
    this.allowDowngrade = true;
  }
  addAuthHeader(token) {
    this.requestHeaders = Object.assign({}, this.requestHeaders, {
      authorization: token
    });
  }
  get netSession() {
    return electronHttpExecutor_1.getNetSession();
  }
  get logger() {
    return this._logger;
  }
  set logger(value) {
    this._logger = value == null ? new NoOpLogger() : value;
  }
  set updateConfigPath(value) {
    this.clientPromise = null;
    this._appUpdateConfigPath = value;
    this.configOnDisk = new lazy_val_1.Lazy(() => this.loadUpdateConfig());
  }
  getFeedURL() {
    return "Deprecated. Do not use it.";
  }
  setFeedURL(options) {
    const runtimeOptions = this.createProviderRuntimeOptions();
    let provider;
    if (typeof options === "string") {
      provider = new GenericProvider_1.GenericProvider({ provider: "generic", url: options }, this, __spreadProps(__spreadValues({}, runtimeOptions), {
        isUseMultipleRangeRequest: providerFactory_1.isUrlProbablySupportMultiRangeRequests(options)
      }));
    } else {
      provider = providerFactory_1.createClient(options, this, runtimeOptions);
    }
    this.clientPromise = Promise.resolve(provider);
  }
  checkForUpdates() {
    let checkForUpdatesPromise = this.checkForUpdatesPromise;
    if (checkForUpdatesPromise != null) {
      this._logger.info("Checking for update (already in progress)");
      return checkForUpdatesPromise;
    }
    const nullizePromise = () => this.checkForUpdatesPromise = null;
    this._logger.info("Checking for update");
    checkForUpdatesPromise = this.doCheckForUpdates().then((it) => {
      nullizePromise();
      return it;
    }).catch((e) => {
      nullizePromise();
      this.emit("error", e, `Cannot check for updates: ${(e.stack || e).toString()}`);
      throw e;
    });
    this.checkForUpdatesPromise = checkForUpdatesPromise;
    return checkForUpdatesPromise;
  }
  isUpdaterActive() {
    if (!this.app.isPackaged) {
      this._logger.info("Skip checkForUpdatesAndNotify because application is not packed");
      return false;
    }
    return true;
  }
  checkForUpdatesAndNotify(downloadNotification) {
    if (!this.isUpdaterActive()) {
      return Promise.resolve(null);
    }
    return this.checkForUpdates().then((it) => {
      const downloadPromise = it.downloadPromise;
      if (downloadPromise == null) {
        if (this._logger.debug != null) {
          this._logger.debug("checkForUpdatesAndNotify called, downloadPromise is null");
        }
        return it;
      }
      void downloadPromise.then(() => {
        const notificationContent = AppUpdater.formatDownloadNotification(it.updateInfo.version, this.app.name, downloadNotification);
        new require$$1__default["default"].Notification(notificationContent).show();
      });
      return it;
    });
  }
  static formatDownloadNotification(version, appName, downloadNotification) {
    if (downloadNotification == null) {
      downloadNotification = {
        title: "A new update is ready to install",
        body: `{appName} version {version} has been downloaded and will be automatically installed on exit`
      };
    }
    downloadNotification = {
      title: downloadNotification.title.replace("{appName}", appName).replace("{version}", version),
      body: downloadNotification.body.replace("{appName}", appName).replace("{version}", version)
    };
    return downloadNotification;
  }
  async isStagingMatch(updateInfo) {
    const rawStagingPercentage = updateInfo.stagingPercentage;
    let stagingPercentage = rawStagingPercentage;
    if (stagingPercentage == null) {
      return true;
    }
    stagingPercentage = parseInt(stagingPercentage, 10);
    if (isNaN(stagingPercentage)) {
      this._logger.warn(`Staging percentage is NaN: ${rawStagingPercentage}`);
      return true;
    }
    stagingPercentage = stagingPercentage / 100;
    const stagingUserId = await this.stagingUserIdPromise.value;
    const val = builder_util_runtime_1$7.UUID.parse(stagingUserId).readUInt32BE(12);
    const percentage = val / 4294967295;
    this._logger.info(`Staging percentage: ${stagingPercentage}, percentage: ${percentage}, user id: ${stagingUserId}`);
    return percentage < stagingPercentage;
  }
  computeFinalHeaders(headers) {
    if (this.requestHeaders != null) {
      Object.assign(headers, this.requestHeaders);
    }
    return headers;
  }
  async isUpdateAvailable(updateInfo) {
    const latestVersion = semver_1.parse(updateInfo.version);
    if (latestVersion == null) {
      throw builder_util_runtime_1$7.newError(`This file could not be downloaded, or the latest version (from update server) does not have a valid semver version: "${updateInfo.version}"`, "ERR_UPDATER_INVALID_VERSION");
    }
    const currentVersion = this.currentVersion;
    if (semver_1.eq(latestVersion, currentVersion)) {
      return false;
    }
    const isStagingMatch = await this.isStagingMatch(updateInfo);
    if (!isStagingMatch) {
      return false;
    }
    const isLatestVersionNewer = semver_1.gt(latestVersion, currentVersion);
    const isLatestVersionOlder = semver_1.lt(latestVersion, currentVersion);
    if (isLatestVersionNewer) {
      return true;
    }
    return this.allowDowngrade && isLatestVersionOlder;
  }
  async getUpdateInfoAndProvider() {
    await this.app.whenReady();
    if (this.clientPromise == null) {
      this.clientPromise = this.configOnDisk.value.then((it) => providerFactory_1.createClient(it, this, this.createProviderRuntimeOptions()));
    }
    const client = await this.clientPromise;
    const stagingUserId = await this.stagingUserIdPromise.value;
    client.setRequestHeaders(this.computeFinalHeaders({ "x-user-staging-id": stagingUserId }));
    return {
      info: await client.getLatestVersion(),
      provider: client
    };
  }
  createProviderRuntimeOptions() {
    return {
      isUseMultipleRangeRequest: true,
      platform: this._testOnlyOptions == null ? process.platform : this._testOnlyOptions.platform,
      executor: this.httpExecutor
    };
  }
  async doCheckForUpdates() {
    this.emit("checking-for-update");
    const result = await this.getUpdateInfoAndProvider();
    const updateInfo = result.info;
    if (!await this.isUpdateAvailable(updateInfo)) {
      this._logger.info(`Update for version ${this.currentVersion} is not available (latest version: ${updateInfo.version}, downgrade is ${this.allowDowngrade ? "allowed" : "disallowed"}).`);
      this.emit("update-not-available", updateInfo);
      return {
        versionInfo: updateInfo,
        updateInfo
      };
    }
    this.updateInfoAndProvider = result;
    this.onUpdateAvailable(updateInfo);
    const cancellationToken = new builder_util_runtime_1$7.CancellationToken();
    return {
      versionInfo: updateInfo,
      updateInfo,
      cancellationToken,
      downloadPromise: this.autoDownload ? this.downloadUpdate(cancellationToken) : null
    };
  }
  onUpdateAvailable(updateInfo) {
    this._logger.info(`Found version ${updateInfo.version} (url: ${builder_util_runtime_1$7.asArray(updateInfo.files).map((it) => it.url).join(", ")})`);
    this.emit("update-available", updateInfo);
  }
  downloadUpdate(cancellationToken = new builder_util_runtime_1$7.CancellationToken()) {
    const updateInfoAndProvider = this.updateInfoAndProvider;
    if (updateInfoAndProvider == null) {
      const error2 = new Error("Please check update first");
      this.dispatchError(error2);
      return Promise.reject(error2);
    }
    this._logger.info(`Downloading update from ${builder_util_runtime_1$7.asArray(updateInfoAndProvider.info.files).map((it) => it.url).join(", ")}`);
    const errorHandler = (e) => {
      if (!(e instanceof builder_util_runtime_1$7.CancellationError)) {
        try {
          this.dispatchError(e);
        } catch (nestedError) {
          this._logger.warn(`Cannot dispatch error event: ${nestedError.stack || nestedError}`);
        }
      }
      return e;
    };
    try {
      return this.doDownloadUpdate({
        updateInfoAndProvider,
        requestHeaders: this.computeRequestHeaders(updateInfoAndProvider.provider),
        cancellationToken
      }).catch((e) => {
        throw errorHandler(e);
      });
    } catch (e) {
      return Promise.reject(errorHandler(e));
    }
  }
  dispatchError(e) {
    this.emit("error", e, (e.stack || e).toString());
  }
  dispatchUpdateDownloaded(event) {
    this.emit(main_1$2.UPDATE_DOWNLOADED, event);
  }
  async loadUpdateConfig() {
    if (this._appUpdateConfigPath == null) {
      this._appUpdateConfigPath = this.app.appUpdateConfigPath;
    }
    return js_yaml_1.load(await promises_1.readFile(this._appUpdateConfigPath, "utf-8"));
  }
  computeRequestHeaders(provider) {
    const fileExtraDownloadHeaders = provider.fileExtraDownloadHeaders;
    if (fileExtraDownloadHeaders != null) {
      const requestHeaders = this.requestHeaders;
      return requestHeaders == null ? fileExtraDownloadHeaders : __spreadValues(__spreadValues({}, fileExtraDownloadHeaders), requestHeaders);
    }
    return this.computeFinalHeaders({ accept: "*/*" });
  }
  async getOrCreateStagingUserId() {
    const file2 = path$9.join(this.app.userDataPath, ".updaterId");
    try {
      const id3 = await promises_1.readFile(file2, "utf-8");
      if (builder_util_runtime_1$7.UUID.check(id3)) {
        return id3;
      } else {
        this._logger.warn(`Staging user id file exists, but content was invalid: ${id3}`);
      }
    } catch (e) {
      if (e.code !== "ENOENT") {
        this._logger.warn(`Couldn't read staging user ID, creating a blank one: ${e}`);
      }
    }
    const id2 = builder_util_runtime_1$7.UUID.v5(crypto_1.randomBytes(4096), builder_util_runtime_1$7.UUID.OID);
    this._logger.info(`Generated new staging user ID: ${id2}`);
    try {
      await fs_extra_1$5.outputFile(file2, id2);
    } catch (e) {
      this._logger.warn(`Couldn't write out staging user ID: ${e}`);
    }
    return id2;
  }
  get isAddNoCacheQuery() {
    const headers = this.requestHeaders;
    if (headers == null) {
      return true;
    }
    for (const headerName of Object.keys(headers)) {
      const s2 = headerName.toLowerCase();
      if (s2 === "authorization" || s2 === "private-token") {
        return false;
      }
    }
    return true;
  }
  async getOrCreateDownloadHelper() {
    let result = this.downloadedUpdateHelper;
    if (result == null) {
      const dirName = (await this.configOnDisk.value).updaterCacheDirName;
      const logger = this._logger;
      if (dirName == null) {
        logger.error("updaterCacheDirName is not specified in app-update.yml Was app build using at least electron-builder 20.34.0?");
      }
      const cacheDir = path$9.join(this.app.baseCachePath, dirName || this.app.name);
      if (logger.debug != null) {
        logger.debug(`updater cache dir: ${cacheDir}`);
      }
      result = new DownloadedUpdateHelper_1.DownloadedUpdateHelper(cacheDir);
      this.downloadedUpdateHelper = result;
    }
    return result;
  }
  async executeDownload(taskOptions) {
    const fileInfo = taskOptions.fileInfo;
    const downloadOptions = {
      headers: taskOptions.downloadUpdateOptions.requestHeaders,
      cancellationToken: taskOptions.downloadUpdateOptions.cancellationToken,
      sha2: fileInfo.info.sha2,
      sha512: fileInfo.info.sha512
    };
    if (this.listenerCount(main_1$2.DOWNLOAD_PROGRESS) > 0) {
      downloadOptions.onProgress = (it) => this.emit(main_1$2.DOWNLOAD_PROGRESS, it);
    }
    const updateInfo = taskOptions.downloadUpdateOptions.updateInfoAndProvider.info;
    const version = updateInfo.version;
    const packageInfo = fileInfo.packageInfo;
    function getCacheUpdateFileName() {
      const urlPath = decodeURIComponent(taskOptions.fileInfo.url.pathname);
      if (urlPath.endsWith(`.${taskOptions.fileExtension}`)) {
        return path$9.posix.basename(urlPath);
      } else {
        return `update.${taskOptions.fileExtension}`;
      }
    }
    const downloadedUpdateHelper = await this.getOrCreateDownloadHelper();
    const cacheDir = downloadedUpdateHelper.cacheDirForPendingUpdate;
    await promises_1.mkdir(cacheDir, { recursive: true });
    const updateFileName = getCacheUpdateFileName();
    let updateFile = path$9.join(cacheDir, updateFileName);
    const packageFile = packageInfo == null ? null : path$9.join(cacheDir, `package-${version}${path$9.extname(packageInfo.path) || ".7z"}`);
    const done = async (isSaveCache) => {
      await downloadedUpdateHelper.setDownloadedFile(updateFile, packageFile, updateInfo, fileInfo, updateFileName, isSaveCache);
      await taskOptions.done(__spreadProps(__spreadValues({}, updateInfo), {
        downloadedFile: updateFile
      }));
      return packageFile == null ? [updateFile] : [updateFile, packageFile];
    };
    const log = this._logger;
    const cachedUpdateFile = await downloadedUpdateHelper.validateDownloadedPath(updateFile, updateInfo, fileInfo, log);
    if (cachedUpdateFile != null) {
      updateFile = cachedUpdateFile;
      return await done(false);
    }
    const removeFileIfAny = async () => {
      await downloadedUpdateHelper.clear().catch(() => {
      });
      return await promises_1.unlink(updateFile).catch(() => {
      });
    };
    const tempUpdateFile = await DownloadedUpdateHelper_1.createTempUpdateFile(`temp-${updateFileName}`, cacheDir, log);
    try {
      await taskOptions.task(tempUpdateFile, downloadOptions, packageFile, removeFileIfAny);
      await promises_1.rename(tempUpdateFile, updateFile);
    } catch (e) {
      await removeFileIfAny();
      if (e instanceof builder_util_runtime_1$7.CancellationError) {
        log.info("cancelled");
        this.emit("update-cancelled", updateInfo);
      }
      throw e;
    }
    log.info(`New version ${version} has been downloaded to ${updateFile}`);
    return await done(true);
  }
}
AppUpdater$1.AppUpdater = AppUpdater;
function hasPrereleaseComponents(version) {
  const versionPrereleaseComponent = semver_1.prerelease(version);
  return versionPrereleaseComponent != null && versionPrereleaseComponent.length > 0;
}
class NoOpLogger {
  info(message) {
  }
  warn(message) {
  }
  error(message) {
  }
}
AppUpdater$1.NoOpLogger = NoOpLogger;
var AppImageUpdater$1 = {};
var BaseUpdater$1 = {};
Object.defineProperty(BaseUpdater$1, "__esModule", { value: true });
BaseUpdater$1.BaseUpdater = void 0;
const fs$3 = require$$0__default$2["default"];
const path$8 = require$$1__default$1["default"];
const AppUpdater_1$1 = AppUpdater$1;
class BaseUpdater extends AppUpdater_1$1.AppUpdater {
  constructor(options, app2) {
    super(options, app2);
    this.quitAndInstallCalled = false;
    this.quitHandlerAdded = false;
  }
  quitAndInstall(isSilent = false, isForceRunAfter = false) {
    this._logger.info(`Install on explicit quitAndInstall`);
    const isInstalled = this.install(isSilent, isSilent ? isForceRunAfter : true);
    if (isInstalled) {
      setImmediate(() => {
        this.app.quit();
      });
    } else {
      this.quitAndInstallCalled = false;
    }
  }
  executeDownload(taskOptions) {
    return super.executeDownload(__spreadProps(__spreadValues({}, taskOptions), {
      done: (event) => {
        this.dispatchUpdateDownloaded(event);
        this.addQuitHandler();
        return Promise.resolve();
      }
    }));
  }
  install(isSilent, isForceRunAfter) {
    if (this.quitAndInstallCalled) {
      this._logger.warn("install call ignored: quitAndInstallCalled is set to true");
      return false;
    }
    const downloadedUpdateHelper = this.downloadedUpdateHelper;
    const installerPath = downloadedUpdateHelper == null ? null : downloadedUpdateHelper.file;
    const downloadedFileInfo = downloadedUpdateHelper == null ? null : downloadedUpdateHelper.downloadedFileInfo;
    if (installerPath == null || downloadedFileInfo == null) {
      this.dispatchError(new Error("No valid update available, can't quit and install"));
      return false;
    }
    this.quitAndInstallCalled = true;
    try {
      let installPathRequiresElevation = false;
      if (process.platform === "win32") {
        try {
          const accessTestPath = path$8.join(path$8.dirname(process.execPath), `access-${Math.floor(Math.random() * 100)}.tmp`);
          fs$3.writeFileSync(accessTestPath, " ");
          fs$3.rmSync(accessTestPath);
        } catch (err) {
          installPathRequiresElevation = true;
        }
      }
      this._logger.info(`Install: isSilent: ${isSilent}, isForceRunAfter: ${isForceRunAfter}, installPathRequiresElevation: ${installPathRequiresElevation}`);
      return this.doInstall({
        installerPath,
        isSilent,
        isForceRunAfter,
        isAdminRightsRequired: installPathRequiresElevation || downloadedFileInfo.isAdminRightsRequired
      });
    } catch (e) {
      this.dispatchError(e);
      return false;
    }
  }
  addQuitHandler() {
    if (this.quitHandlerAdded || !this.autoInstallOnAppQuit) {
      return;
    }
    this.quitHandlerAdded = true;
    this.app.onQuit((exitCode) => {
      if (this.quitAndInstallCalled) {
        this._logger.info("Update installer has already been triggered. Quitting application.");
        return;
      }
      if (!this.autoInstallOnAppQuit) {
        this._logger.info("Update will not be installed on quit because autoInstallOnAppQuit is set to false.");
        return;
      }
      if (exitCode !== 0) {
        this._logger.info(`Update will be not installed on quit because application is quitting with exit code ${exitCode}`);
        return;
      }
      this._logger.info("Auto install update on quit");
      this.install(true, false);
    });
  }
}
BaseUpdater$1.BaseUpdater = BaseUpdater;
var FileWithEmbeddedBlockMapDifferentialDownloader$1 = {};
var DifferentialDownloader$1 = {};
var DataSplitter$1 = {};
var downloadPlanBuilder = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.computeOperations = exports.OperationKind = void 0;
  var OperationKind2;
  (function(OperationKind3) {
    OperationKind3[OperationKind3["COPY"] = 0] = "COPY";
    OperationKind3[OperationKind3["DOWNLOAD"] = 1] = "DOWNLOAD";
  })(OperationKind2 = exports.OperationKind || (exports.OperationKind = {}));
  function computeOperations(oldBlockMap, newBlockMap, logger) {
    const nameToOldBlocks = buildBlockFileMap(oldBlockMap.files);
    const nameToNewBlocks = buildBlockFileMap(newBlockMap.files);
    let lastOperation = null;
    const blockMapFile = newBlockMap.files[0];
    const operations = [];
    const name = blockMapFile.name;
    const oldEntry = nameToOldBlocks.get(name);
    if (oldEntry == null) {
      throw new Error(`no file ${name} in old blockmap`);
    }
    const newFile = nameToNewBlocks.get(name);
    let changedBlockCount = 0;
    const { checksumToOffset: checksumToOldOffset, checksumToOldSize } = buildChecksumMap(nameToOldBlocks.get(name), oldEntry.offset, logger);
    let newOffset = blockMapFile.offset;
    for (let i2 = 0; i2 < newFile.checksums.length; newOffset += newFile.sizes[i2], i2++) {
      const blockSize = newFile.sizes[i2];
      const checksum = newFile.checksums[i2];
      let oldOffset = checksumToOldOffset.get(checksum);
      if (oldOffset != null && checksumToOldSize.get(checksum) !== blockSize) {
        logger.warn(`Checksum ("${checksum}") matches, but size differs (old: ${checksumToOldSize.get(checksum)}, new: ${blockSize})`);
        oldOffset = void 0;
      }
      if (oldOffset === void 0) {
        changedBlockCount++;
        if (lastOperation != null && lastOperation.kind === OperationKind2.DOWNLOAD && lastOperation.end === newOffset) {
          lastOperation.end += blockSize;
        } else {
          lastOperation = {
            kind: OperationKind2.DOWNLOAD,
            start: newOffset,
            end: newOffset + blockSize
          };
          validateAndAdd(lastOperation, operations, checksum, i2);
        }
      } else {
        if (lastOperation != null && lastOperation.kind === OperationKind2.COPY && lastOperation.end === oldOffset) {
          lastOperation.end += blockSize;
        } else {
          lastOperation = {
            kind: OperationKind2.COPY,
            start: oldOffset,
            end: oldOffset + blockSize
          };
          validateAndAdd(lastOperation, operations, checksum, i2);
        }
      }
    }
    if (changedBlockCount > 0) {
      logger.info(`File${blockMapFile.name === "file" ? "" : " " + blockMapFile.name} has ${changedBlockCount} changed blocks`);
    }
    return operations;
  }
  exports.computeOperations = computeOperations;
  const isValidateOperationRange = process.env["DIFFERENTIAL_DOWNLOAD_PLAN_BUILDER_VALIDATE_RANGES"] === "true";
  function validateAndAdd(operation, operations, checksum, index) {
    if (isValidateOperationRange && operations.length !== 0) {
      const lastOperation = operations[operations.length - 1];
      if (lastOperation.kind === operation.kind && operation.start < lastOperation.end && operation.start > lastOperation.start) {
        const min = [lastOperation.start, lastOperation.end, operation.start, operation.end].reduce((p, v) => p < v ? p : v);
        throw new Error(`operation (block index: ${index}, checksum: ${checksum}, kind: ${OperationKind2[operation.kind]}) overlaps previous operation (checksum: ${checksum}):
abs: ${lastOperation.start} until ${lastOperation.end} and ${operation.start} until ${operation.end}
rel: ${lastOperation.start - min} until ${lastOperation.end - min} and ${operation.start - min} until ${operation.end - min}`);
      }
    }
    operations.push(operation);
  }
  function buildChecksumMap(file2, fileOffset, logger) {
    const checksumToOffset = new Map();
    const checksumToSize = new Map();
    let offset = fileOffset;
    for (let i2 = 0; i2 < file2.checksums.length; i2++) {
      const checksum = file2.checksums[i2];
      const size = file2.sizes[i2];
      const existing = checksumToSize.get(checksum);
      if (existing === void 0) {
        checksumToOffset.set(checksum, offset);
        checksumToSize.set(checksum, size);
      } else if (logger.debug != null) {
        const sizeExplanation = existing === size ? "(same size)" : `(size: ${existing}, this size: ${size})`;
        logger.debug(`${checksum} duplicated in blockmap ${sizeExplanation}, it doesn't lead to broken differential downloader, just corresponding block will be skipped)`);
      }
      offset += size;
    }
    return { checksumToOffset, checksumToOldSize: checksumToSize };
  }
  function buildBlockFileMap(list) {
    const result = new Map();
    for (const item of list) {
      result.set(item.name, item);
    }
    return result;
  }
})(downloadPlanBuilder);
Object.defineProperty(DataSplitter$1, "__esModule", { value: true });
DataSplitter$1.DataSplitter = DataSplitter$1.copyData = void 0;
const builder_util_runtime_1$6 = out;
const fs_1$5 = require$$0__default$2["default"];
const stream_1$1 = require$$0__default$1["default"];
const downloadPlanBuilder_1$2 = downloadPlanBuilder;
const DOUBLE_CRLF = Buffer.from("\r\n\r\n");
var ReadState;
(function(ReadState2) {
  ReadState2[ReadState2["INIT"] = 0] = "INIT";
  ReadState2[ReadState2["HEADER"] = 1] = "HEADER";
  ReadState2[ReadState2["BODY"] = 2] = "BODY";
})(ReadState || (ReadState = {}));
function copyData(task, out2, oldFileFd, reject, resolve2) {
  const readStream = fs_1$5.createReadStream("", {
    fd: oldFileFd,
    autoClose: false,
    start: task.start,
    end: task.end - 1
  });
  readStream.on("error", reject);
  readStream.once("end", resolve2);
  readStream.pipe(out2, {
    end: false
  });
}
DataSplitter$1.copyData = copyData;
class DataSplitter extends stream_1$1.Writable {
  constructor(out2, options, partIndexToTaskIndex, boundary, partIndexToLength, finishHandler) {
    super();
    this.out = out2;
    this.options = options;
    this.partIndexToTaskIndex = partIndexToTaskIndex;
    this.partIndexToLength = partIndexToLength;
    this.finishHandler = finishHandler;
    this.partIndex = -1;
    this.headerListBuffer = null;
    this.readState = ReadState.INIT;
    this.ignoreByteCount = 0;
    this.remainingPartDataCount = 0;
    this.actualPartLength = 0;
    this.boundaryLength = boundary.length + 4;
    this.ignoreByteCount = this.boundaryLength - 2;
  }
  get isFinished() {
    return this.partIndex === this.partIndexToLength.length;
  }
  _write(data, encoding, callback) {
    if (this.isFinished) {
      console.error(`Trailing ignored data: ${data.length} bytes`);
      return;
    }
    this.handleData(data).then(callback).catch(callback);
  }
  async handleData(chunk) {
    let start = 0;
    if (this.ignoreByteCount !== 0 && this.remainingPartDataCount !== 0) {
      throw builder_util_runtime_1$6.newError("Internal error", "ERR_DATA_SPLITTER_BYTE_COUNT_MISMATCH");
    }
    if (this.ignoreByteCount > 0) {
      const toIgnore = Math.min(this.ignoreByteCount, chunk.length);
      this.ignoreByteCount -= toIgnore;
      start = toIgnore;
    } else if (this.remainingPartDataCount > 0) {
      const toRead = Math.min(this.remainingPartDataCount, chunk.length);
      this.remainingPartDataCount -= toRead;
      await this.processPartData(chunk, 0, toRead);
      start = toRead;
    }
    if (start === chunk.length) {
      return;
    }
    if (this.readState === ReadState.HEADER) {
      const headerListEnd = this.searchHeaderListEnd(chunk, start);
      if (headerListEnd === -1) {
        return;
      }
      start = headerListEnd;
      this.readState = ReadState.BODY;
      this.headerListBuffer = null;
    }
    while (true) {
      if (this.readState === ReadState.BODY) {
        this.readState = ReadState.INIT;
      } else {
        this.partIndex++;
        let taskIndex = this.partIndexToTaskIndex.get(this.partIndex);
        if (taskIndex == null) {
          if (this.isFinished) {
            taskIndex = this.options.end;
          } else {
            throw builder_util_runtime_1$6.newError("taskIndex is null", "ERR_DATA_SPLITTER_TASK_INDEX_IS_NULL");
          }
        }
        const prevTaskIndex = this.partIndex === 0 ? this.options.start : this.partIndexToTaskIndex.get(this.partIndex - 1) + 1;
        if (prevTaskIndex < taskIndex) {
          await this.copyExistingData(prevTaskIndex, taskIndex);
        } else if (prevTaskIndex > taskIndex) {
          throw builder_util_runtime_1$6.newError("prevTaskIndex must be < taskIndex", "ERR_DATA_SPLITTER_TASK_INDEX_ASSERT_FAILED");
        }
        if (this.isFinished) {
          this.onPartEnd();
          this.finishHandler();
          return;
        }
        start = this.searchHeaderListEnd(chunk, start);
        if (start === -1) {
          this.readState = ReadState.HEADER;
          return;
        }
      }
      const partLength = this.partIndexToLength[this.partIndex];
      const end = start + partLength;
      const effectiveEnd = Math.min(end, chunk.length);
      await this.processPartStarted(chunk, start, effectiveEnd);
      this.remainingPartDataCount = partLength - (effectiveEnd - start);
      if (this.remainingPartDataCount > 0) {
        return;
      }
      start = end + this.boundaryLength;
      if (start >= chunk.length) {
        this.ignoreByteCount = this.boundaryLength - (chunk.length - end);
        return;
      }
    }
  }
  copyExistingData(index, end) {
    return new Promise((resolve2, reject) => {
      const w2 = () => {
        if (index === end) {
          resolve2();
          return;
        }
        const task = this.options.tasks[index];
        if (task.kind !== downloadPlanBuilder_1$2.OperationKind.COPY) {
          reject(new Error("Task kind must be COPY"));
          return;
        }
        copyData(task, this.out, this.options.oldFileFd, reject, () => {
          index++;
          w2();
        });
      };
      w2();
    });
  }
  searchHeaderListEnd(chunk, readOffset) {
    const headerListEnd = chunk.indexOf(DOUBLE_CRLF, readOffset);
    if (headerListEnd !== -1) {
      return headerListEnd + DOUBLE_CRLF.length;
    }
    const partialChunk = readOffset === 0 ? chunk : chunk.slice(readOffset);
    if (this.headerListBuffer == null) {
      this.headerListBuffer = partialChunk;
    } else {
      this.headerListBuffer = Buffer.concat([this.headerListBuffer, partialChunk]);
    }
    return -1;
  }
  onPartEnd() {
    const expectedLength = this.partIndexToLength[this.partIndex - 1];
    if (this.actualPartLength !== expectedLength) {
      throw builder_util_runtime_1$6.newError(`Expected length: ${expectedLength} differs from actual: ${this.actualPartLength}`, "ERR_DATA_SPLITTER_LENGTH_MISMATCH");
    }
    this.actualPartLength = 0;
  }
  processPartStarted(data, start, end) {
    if (this.partIndex !== 0) {
      this.onPartEnd();
    }
    return this.processPartData(data, start, end);
  }
  processPartData(data, start, end) {
    this.actualPartLength += end - start;
    const out2 = this.out;
    if (out2.write(start === 0 && data.length === end ? data : data.slice(start, end))) {
      return Promise.resolve();
    } else {
      return new Promise((resolve2, reject) => {
        out2.on("error", reject);
        out2.once("drain", () => {
          out2.removeListener("error", reject);
          resolve2();
        });
      });
    }
  }
}
DataSplitter$1.DataSplitter = DataSplitter;
var multipleRangeDownloader = {};
Object.defineProperty(multipleRangeDownloader, "__esModule", { value: true });
multipleRangeDownloader.checkIsRangesSupported = multipleRangeDownloader.executeTasksUsingMultipleRangeRequests = void 0;
const builder_util_runtime_1$5 = out;
const DataSplitter_1$1 = DataSplitter$1;
const downloadPlanBuilder_1$1 = downloadPlanBuilder;
function executeTasksUsingMultipleRangeRequests(differentialDownloader, tasks, out2, oldFileFd, reject) {
  const w2 = (taskOffset) => {
    if (taskOffset >= tasks.length) {
      if (differentialDownloader.fileMetadataBuffer != null) {
        out2.write(differentialDownloader.fileMetadataBuffer);
      }
      out2.end();
      return;
    }
    const nextOffset = taskOffset + 1e3;
    doExecuteTasks(differentialDownloader, {
      tasks,
      start: taskOffset,
      end: Math.min(tasks.length, nextOffset),
      oldFileFd
    }, out2, () => w2(nextOffset), reject);
  };
  return w2;
}
multipleRangeDownloader.executeTasksUsingMultipleRangeRequests = executeTasksUsingMultipleRangeRequests;
function doExecuteTasks(differentialDownloader, options, out2, resolve2, reject) {
  let ranges = "bytes=";
  let partCount = 0;
  const partIndexToTaskIndex = new Map();
  const partIndexToLength = [];
  for (let i2 = options.start; i2 < options.end; i2++) {
    const task = options.tasks[i2];
    if (task.kind === downloadPlanBuilder_1$1.OperationKind.DOWNLOAD) {
      ranges += `${task.start}-${task.end - 1}, `;
      partIndexToTaskIndex.set(partCount, i2);
      partCount++;
      partIndexToLength.push(task.end - task.start);
    }
  }
  if (partCount <= 1) {
    const w2 = (index) => {
      if (index >= options.end) {
        resolve2();
        return;
      }
      const task = options.tasks[index++];
      if (task.kind === downloadPlanBuilder_1$1.OperationKind.COPY) {
        DataSplitter_1$1.copyData(task, out2, options.oldFileFd, reject, () => w2(index));
      } else {
        const requestOptions2 = differentialDownloader.createRequestOptions();
        requestOptions2.headers.Range = `bytes=${task.start}-${task.end - 1}`;
        const request2 = differentialDownloader.httpExecutor.createRequest(requestOptions2, (response) => {
          if (!checkIsRangesSupported(response, reject)) {
            return;
          }
          response.pipe(out2, {
            end: false
          });
          response.once("end", () => w2(index));
        });
        differentialDownloader.httpExecutor.addErrorAndTimeoutHandlers(request2, reject);
        request2.end();
      }
    };
    w2(options.start);
    return;
  }
  const requestOptions = differentialDownloader.createRequestOptions();
  requestOptions.headers.Range = ranges.substring(0, ranges.length - 2);
  const request = differentialDownloader.httpExecutor.createRequest(requestOptions, (response) => {
    if (!checkIsRangesSupported(response, reject)) {
      return;
    }
    const contentType = builder_util_runtime_1$5.safeGetHeader(response, "content-type");
    const m2 = /^multipart\/.+?(?:; boundary=(?:(?:"(.+)")|(?:([^\s]+))))$/i.exec(contentType);
    if (m2 == null) {
      reject(new Error(`Content-Type "multipart/byteranges" is expected, but got "${contentType}"`));
      return;
    }
    const dicer = new DataSplitter_1$1.DataSplitter(out2, options, partIndexToTaskIndex, m2[1] || m2[2], partIndexToLength, resolve2);
    dicer.on("error", reject);
    response.pipe(dicer);
    response.on("end", () => {
      setTimeout(() => {
        request.abort();
        reject(new Error("Response ends without calling any handlers"));
      }, 1e4);
    });
  });
  differentialDownloader.httpExecutor.addErrorAndTimeoutHandlers(request, reject);
  request.end();
}
function checkIsRangesSupported(response, reject) {
  if (response.statusCode >= 400) {
    reject(builder_util_runtime_1$5.createHttpError(response));
    return false;
  }
  if (response.statusCode !== 206) {
    const acceptRanges = builder_util_runtime_1$5.safeGetHeader(response, "accept-ranges");
    if (acceptRanges == null || acceptRanges === "none") {
      reject(new Error(`Server doesn't support Accept-Ranges (response code ${response.statusCode})`));
      return false;
    }
  }
  return true;
}
multipleRangeDownloader.checkIsRangesSupported = checkIsRangesSupported;
var ProgressDifferentialDownloadCallbackTransform$1 = {};
Object.defineProperty(ProgressDifferentialDownloadCallbackTransform$1, "__esModule", { value: true });
ProgressDifferentialDownloadCallbackTransform$1.ProgressDifferentialDownloadCallbackTransform = void 0;
const stream_1 = require$$0__default$1["default"];
var OperationKind;
(function(OperationKind2) {
  OperationKind2[OperationKind2["COPY"] = 0] = "COPY";
  OperationKind2[OperationKind2["DOWNLOAD"] = 1] = "DOWNLOAD";
})(OperationKind || (OperationKind = {}));
class ProgressDifferentialDownloadCallbackTransform extends stream_1.Transform {
  constructor(progressDifferentialDownloadInfo, cancellationToken, onProgress) {
    super();
    this.progressDifferentialDownloadInfo = progressDifferentialDownloadInfo;
    this.cancellationToken = cancellationToken;
    this.onProgress = onProgress;
    this.start = Date.now();
    this.transferred = 0;
    this.delta = 0;
    this.expectedBytes = 0;
    this.index = 0;
    this.operationType = OperationKind.COPY;
    this.nextUpdate = this.start + 1e3;
  }
  _transform(chunk, encoding, callback) {
    if (this.cancellationToken.cancelled) {
      callback(new Error("cancelled"), null);
      return;
    }
    if (this.operationType == OperationKind.COPY) {
      callback(null, chunk);
      return;
    }
    this.transferred += chunk.length;
    this.delta += chunk.length;
    const now = Date.now();
    if (now >= this.nextUpdate && this.transferred !== this.expectedBytes && this.transferred !== this.progressDifferentialDownloadInfo.grandTotal) {
      this.nextUpdate = now + 1e3;
      this.onProgress({
        total: this.progressDifferentialDownloadInfo.grandTotal,
        delta: this.delta,
        transferred: this.transferred,
        percent: this.transferred / this.progressDifferentialDownloadInfo.grandTotal * 100,
        bytesPerSecond: Math.round(this.transferred / ((now - this.start) / 1e3))
      });
      this.delta = 0;
    }
    callback(null, chunk);
  }
  beginFileCopy() {
    this.operationType = OperationKind.COPY;
  }
  beginRangeDownload() {
    this.operationType = OperationKind.DOWNLOAD;
    this.expectedBytes += this.progressDifferentialDownloadInfo.expectedByteCounts[this.index++];
  }
  endRangeDownload() {
    if (this.transferred !== this.progressDifferentialDownloadInfo.grandTotal) {
      this.onProgress({
        total: this.progressDifferentialDownloadInfo.grandTotal,
        delta: this.delta,
        transferred: this.transferred,
        percent: this.transferred / this.progressDifferentialDownloadInfo.grandTotal * 100,
        bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1e3))
      });
    }
  }
  _flush(callback) {
    if (this.cancellationToken.cancelled) {
      callback(new Error("cancelled"));
      return;
    }
    this.onProgress({
      total: this.progressDifferentialDownloadInfo.grandTotal,
      delta: this.delta,
      transferred: this.transferred,
      percent: 100,
      bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1e3))
    });
    this.delta = 0;
    this.transferred = 0;
    callback(null);
  }
}
ProgressDifferentialDownloadCallbackTransform$1.ProgressDifferentialDownloadCallbackTransform = ProgressDifferentialDownloadCallbackTransform;
Object.defineProperty(DifferentialDownloader$1, "__esModule", { value: true });
DifferentialDownloader$1.DifferentialDownloader = void 0;
const builder_util_runtime_1$4 = out;
const fs_extra_1$4 = lib;
const fs_1$4 = require$$0__default$2["default"];
const DataSplitter_1 = DataSplitter$1;
const url_1$1 = require$$2__default["default"];
const downloadPlanBuilder_1 = downloadPlanBuilder;
const multipleRangeDownloader_1 = multipleRangeDownloader;
const ProgressDifferentialDownloadCallbackTransform_1 = ProgressDifferentialDownloadCallbackTransform$1;
class DifferentialDownloader {
  constructor(blockAwareFileInfo, httpExecutor2, options) {
    this.blockAwareFileInfo = blockAwareFileInfo;
    this.httpExecutor = httpExecutor2;
    this.options = options;
    this.fileMetadataBuffer = null;
    this.logger = options.logger;
  }
  createRequestOptions() {
    const result = {
      headers: __spreadProps(__spreadValues({}, this.options.requestHeaders), {
        accept: "*/*"
      })
    };
    builder_util_runtime_1$4.configureRequestUrl(this.options.newUrl, result);
    builder_util_runtime_1$4.configureRequestOptions(result);
    return result;
  }
  doDownload(oldBlockMap, newBlockMap) {
    if (oldBlockMap.version !== newBlockMap.version) {
      throw new Error(`version is different (${oldBlockMap.version} - ${newBlockMap.version}), full download is required`);
    }
    const logger = this.logger;
    const operations = downloadPlanBuilder_1.computeOperations(oldBlockMap, newBlockMap, logger);
    if (logger.debug != null) {
      logger.debug(JSON.stringify(operations, null, 2));
    }
    let downloadSize = 0;
    let copySize = 0;
    for (const operation of operations) {
      const length = operation.end - operation.start;
      if (operation.kind === downloadPlanBuilder_1.OperationKind.DOWNLOAD) {
        downloadSize += length;
      } else {
        copySize += length;
      }
    }
    const newSize = this.blockAwareFileInfo.size;
    if (downloadSize + copySize + (this.fileMetadataBuffer == null ? 0 : this.fileMetadataBuffer.length) !== newSize) {
      throw new Error(`Internal error, size mismatch: downloadSize: ${downloadSize}, copySize: ${copySize}, newSize: ${newSize}`);
    }
    logger.info(`Full: ${formatBytes(newSize)}, To download: ${formatBytes(downloadSize)} (${Math.round(downloadSize / (newSize / 100))}%)`);
    return this.downloadFile(operations);
  }
  downloadFile(tasks) {
    const fdList = [];
    const closeFiles = () => {
      return Promise.all(fdList.map((openedFile) => {
        return fs_extra_1$4.close(openedFile.descriptor).catch((e) => {
          this.logger.error(`cannot close file "${openedFile.path}": ${e}`);
        });
      }));
    };
    return this.doDownloadFile(tasks, fdList).then(closeFiles).catch((e) => {
      return closeFiles().catch((closeFilesError) => {
        try {
          this.logger.error(`cannot close files: ${closeFilesError}`);
        } catch (errorOnLog) {
          try {
            console.error(errorOnLog);
          } catch (ignored) {
          }
        }
        throw e;
      }).then(() => {
        throw e;
      });
    });
  }
  async doDownloadFile(tasks, fdList) {
    const oldFileFd = await fs_extra_1$4.open(this.options.oldFile, "r");
    fdList.push({ descriptor: oldFileFd, path: this.options.oldFile });
    const newFileFd = await fs_extra_1$4.open(this.options.newFile, "w");
    fdList.push({ descriptor: newFileFd, path: this.options.newFile });
    const fileOut = fs_1$4.createWriteStream(this.options.newFile, { fd: newFileFd });
    await new Promise((resolve2, reject) => {
      const streams = [];
      let downloadInfoTransform = void 0;
      if (!this.options.isUseMultipleRangeRequest && this.options.onProgress) {
        const expectedByteCounts = [];
        let grandTotalBytes = 0;
        for (const task of tasks) {
          if (task.kind === downloadPlanBuilder_1.OperationKind.DOWNLOAD) {
            expectedByteCounts.push(task.end - task.start);
            grandTotalBytes += task.end - task.start;
          }
        }
        const progressDifferentialDownloadInfo = {
          expectedByteCounts,
          grandTotal: grandTotalBytes
        };
        downloadInfoTransform = new ProgressDifferentialDownloadCallbackTransform_1.ProgressDifferentialDownloadCallbackTransform(progressDifferentialDownloadInfo, this.options.cancellationToken, this.options.onProgress);
        streams.push(downloadInfoTransform);
      }
      const digestTransform = new builder_util_runtime_1$4.DigestTransform(this.blockAwareFileInfo.sha512);
      digestTransform.isValidateOnEnd = false;
      streams.push(digestTransform);
      fileOut.on("finish", () => {
        fileOut.close(() => {
          fdList.splice(1, 1);
          try {
            digestTransform.validate();
          } catch (e) {
            reject(e);
            return;
          }
          resolve2(void 0);
        });
      });
      streams.push(fileOut);
      let lastStream = null;
      for (const stream of streams) {
        stream.on("error", reject);
        if (lastStream == null) {
          lastStream = stream;
        } else {
          lastStream = lastStream.pipe(stream);
        }
      }
      const firstStream = streams[0];
      let w2;
      if (this.options.isUseMultipleRangeRequest) {
        w2 = multipleRangeDownloader_1.executeTasksUsingMultipleRangeRequests(this, tasks, firstStream, oldFileFd, reject);
        w2(0);
        return;
      }
      let downloadOperationCount = 0;
      let actualUrl = null;
      this.logger.info(`Differential download: ${this.options.newUrl}`);
      const requestOptions = this.createRequestOptions();
      requestOptions.redirect = "manual";
      w2 = (index) => {
        var _a, _b;
        if (index >= tasks.length) {
          if (this.fileMetadataBuffer != null) {
            firstStream.write(this.fileMetadataBuffer);
          }
          firstStream.end();
          return;
        }
        const operation = tasks[index++];
        if (operation.kind === downloadPlanBuilder_1.OperationKind.COPY) {
          if (downloadInfoTransform) {
            downloadInfoTransform.beginFileCopy();
          }
          DataSplitter_1.copyData(operation, firstStream, oldFileFd, reject, () => w2(index));
          return;
        }
        const range2 = `bytes=${operation.start}-${operation.end - 1}`;
        requestOptions.headers.range = range2;
        (_b = (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug) === null || _b === void 0 ? void 0 : _b.call(_a, `download range: ${range2}`);
        if (downloadInfoTransform) {
          downloadInfoTransform.beginRangeDownload();
        }
        const request = this.httpExecutor.createRequest(requestOptions, (response) => {
          if (response.statusCode >= 400) {
            reject(builder_util_runtime_1$4.createHttpError(response));
          }
          response.pipe(firstStream, {
            end: false
          });
          response.once("end", () => {
            if (downloadInfoTransform) {
              downloadInfoTransform.endRangeDownload();
            }
            if (++downloadOperationCount === 100) {
              downloadOperationCount = 0;
              setTimeout(() => w2(index), 1e3);
            } else {
              w2(index);
            }
          });
        });
        request.on("redirect", (statusCode, method, redirectUrl) => {
          this.logger.info(`Redirect to ${removeQuery(redirectUrl)}`);
          actualUrl = redirectUrl;
          builder_util_runtime_1$4.configureRequestUrl(new url_1$1.URL(actualUrl), requestOptions);
          request.followRedirect();
        });
        this.httpExecutor.addErrorAndTimeoutHandlers(request, reject);
        request.end();
      };
      w2(0);
    });
  }
  async readRemoteBytes(start, endInclusive) {
    const buffer = Buffer.allocUnsafe(endInclusive + 1 - start);
    const requestOptions = this.createRequestOptions();
    requestOptions.headers.range = `bytes=${start}-${endInclusive}`;
    let position = 0;
    await this.request(requestOptions, (chunk) => {
      chunk.copy(buffer, position);
      position += chunk.length;
    });
    if (position !== buffer.length) {
      throw new Error(`Received data length ${position} is not equal to expected ${buffer.length}`);
    }
    return buffer;
  }
  request(requestOptions, dataHandler) {
    return new Promise((resolve2, reject) => {
      const request = this.httpExecutor.createRequest(requestOptions, (response) => {
        if (!multipleRangeDownloader_1.checkIsRangesSupported(response, reject)) {
          return;
        }
        response.on("data", dataHandler);
        response.on("end", () => resolve2());
      });
      this.httpExecutor.addErrorAndTimeoutHandlers(request, reject);
      request.end();
    });
  }
}
DifferentialDownloader$1.DifferentialDownloader = DifferentialDownloader;
function formatBytes(value, symbol = " KB") {
  return new Intl.NumberFormat("en").format((value / 1024).toFixed(2)) + symbol;
}
function removeQuery(url) {
  const index = url.indexOf("?");
  return index < 0 ? url : url.substring(0, index);
}
Object.defineProperty(FileWithEmbeddedBlockMapDifferentialDownloader$1, "__esModule", { value: true });
FileWithEmbeddedBlockMapDifferentialDownloader$1.FileWithEmbeddedBlockMapDifferentialDownloader = void 0;
const fs_extra_1$3 = lib;
const DifferentialDownloader_1$1 = DifferentialDownloader$1;
const zlib_1$1 = require$$2__default$1["default"];
class FileWithEmbeddedBlockMapDifferentialDownloader extends DifferentialDownloader_1$1.DifferentialDownloader {
  async download() {
    const packageInfo = this.blockAwareFileInfo;
    const fileSize = packageInfo.size;
    const offset = fileSize - (packageInfo.blockMapSize + 4);
    this.fileMetadataBuffer = await this.readRemoteBytes(offset, fileSize - 1);
    const newBlockMap = readBlockMap(this.fileMetadataBuffer.slice(0, this.fileMetadataBuffer.length - 4));
    await this.doDownload(await readEmbeddedBlockMapData(this.options.oldFile), newBlockMap);
  }
}
FileWithEmbeddedBlockMapDifferentialDownloader$1.FileWithEmbeddedBlockMapDifferentialDownloader = FileWithEmbeddedBlockMapDifferentialDownloader;
function readBlockMap(data) {
  return JSON.parse(zlib_1$1.inflateRawSync(data).toString());
}
async function readEmbeddedBlockMapData(file2) {
  const fd = await fs_extra_1$3.open(file2, "r");
  try {
    const fileSize = (await fs_extra_1$3.fstat(fd)).size;
    const sizeBuffer = Buffer.allocUnsafe(4);
    await fs_extra_1$3.read(fd, sizeBuffer, 0, sizeBuffer.length, fileSize - sizeBuffer.length);
    const dataBuffer = Buffer.allocUnsafe(sizeBuffer.readUInt32BE(0));
    await fs_extra_1$3.read(fd, dataBuffer, 0, dataBuffer.length, fileSize - sizeBuffer.length - dataBuffer.length);
    await fs_extra_1$3.close(fd);
    return readBlockMap(dataBuffer);
  } catch (e) {
    await fs_extra_1$3.close(fd);
    throw e;
  }
}
Object.defineProperty(AppImageUpdater$1, "__esModule", { value: true });
AppImageUpdater$1.AppImageUpdater = void 0;
const builder_util_runtime_1$3 = out;
const child_process_1$3 = require$$1__default$4["default"];
const fs_extra_1$2 = lib;
const fs_1$3 = require$$0__default$2["default"];
const path$7 = require$$1__default$1["default"];
const BaseUpdater_1$1 = BaseUpdater$1;
const FileWithEmbeddedBlockMapDifferentialDownloader_1$1 = FileWithEmbeddedBlockMapDifferentialDownloader$1;
const main_1$1 = main$1;
const Provider_1$2 = Provider$1;
class AppImageUpdater extends BaseUpdater_1$1.BaseUpdater {
  constructor(options, app2) {
    super(options, app2);
  }
  isUpdaterActive() {
    if (process.env["APPIMAGE"] == null) {
      if (process.env["SNAP"] == null) {
        this._logger.warn("APPIMAGE env is not defined, current application is not an AppImage");
      } else {
        this._logger.info("SNAP env is defined, updater is disabled");
      }
      return false;
    }
    return super.isUpdaterActive();
  }
  doDownloadUpdate(downloadUpdateOptions) {
    const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
    const fileInfo = Provider_1$2.findFile(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), "AppImage");
    return this.executeDownload({
      fileExtension: "AppImage",
      fileInfo,
      downloadUpdateOptions,
      task: async (updateFile, downloadOptions) => {
        const oldFile = process.env["APPIMAGE"];
        if (oldFile == null) {
          throw builder_util_runtime_1$3.newError("APPIMAGE env is not defined", "ERR_UPDATER_OLD_FILE_NOT_FOUND");
        }
        let isDownloadFull = false;
        try {
          const downloadOptions2 = {
            newUrl: fileInfo.url,
            oldFile,
            logger: this._logger,
            newFile: updateFile,
            isUseMultipleRangeRequest: provider.isUseMultipleRangeRequest,
            requestHeaders: downloadUpdateOptions.requestHeaders,
            cancellationToken: downloadUpdateOptions.cancellationToken
          };
          if (this.listenerCount(main_1$1.DOWNLOAD_PROGRESS) > 0) {
            downloadOptions2.onProgress = (it) => this.emit(main_1$1.DOWNLOAD_PROGRESS, it);
          }
          await new FileWithEmbeddedBlockMapDifferentialDownloader_1$1.FileWithEmbeddedBlockMapDifferentialDownloader(fileInfo.info, this.httpExecutor, downloadOptions2).download();
        } catch (e) {
          this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);
          isDownloadFull = process.platform === "linux";
        }
        if (isDownloadFull) {
          await this.httpExecutor.download(fileInfo.url, updateFile, downloadOptions);
        }
        await fs_extra_1$2.chmod(updateFile, 493);
      }
    });
  }
  doInstall(options) {
    const appImageFile = process.env["APPIMAGE"];
    if (appImageFile == null) {
      throw builder_util_runtime_1$3.newError("APPIMAGE env is not defined", "ERR_UPDATER_OLD_FILE_NOT_FOUND");
    }
    fs_1$3.unlinkSync(appImageFile);
    let destination;
    const existingBaseName = path$7.basename(appImageFile);
    if (path$7.basename(options.installerPath) === existingBaseName || !/\d+\.\d+\.\d+/.test(existingBaseName)) {
      destination = appImageFile;
    } else {
      destination = path$7.join(path$7.dirname(appImageFile), path$7.basename(options.installerPath));
    }
    child_process_1$3.execFileSync("mv", ["-f", options.installerPath, destination]);
    if (destination !== appImageFile) {
      this.emit("appimage-filename-updated", destination);
    }
    const env2 = __spreadProps(__spreadValues({}, process.env), {
      APPIMAGE_SILENT_INSTALL: "true"
    });
    if (options.isForceRunAfter) {
      child_process_1$3.spawn(destination, [], {
        detached: true,
        stdio: "ignore",
        env: env2
      }).unref();
    } else {
      env2.APPIMAGE_EXIT_AFTER_INSTALL = "true";
      child_process_1$3.execFileSync(destination, [], { env: env2 });
    }
    return true;
  }
}
AppImageUpdater$1.AppImageUpdater = AppImageUpdater;
var MacUpdater$1 = {};
Object.defineProperty(MacUpdater$1, "__esModule", { value: true });
MacUpdater$1.MacUpdater = void 0;
const builder_util_runtime_1$2 = out;
const fs_extra_1$1 = lib;
const fs_1$2 = require$$0__default$2["default"];
const http_1 = require$$3__default["default"];
const AppUpdater_1 = AppUpdater$1;
const Provider_1$1 = Provider$1;
const child_process_1$2 = require$$1__default$4["default"];
class MacUpdater extends AppUpdater_1.AppUpdater {
  constructor(options, app2) {
    super(options, app2);
    this.nativeUpdater = require$$1__default["default"].autoUpdater;
    this.squirrelDownloadedUpdate = false;
    this.nativeUpdater.on("error", (it) => {
      this._logger.warn(it);
      this.emit("error", it);
    });
    this.nativeUpdater.on("update-downloaded", () => {
      this.squirrelDownloadedUpdate = true;
    });
  }
  debug(message) {
    if (this._logger.debug != null) {
      this._logger.debug(message);
    }
  }
  async doDownloadUpdate(downloadUpdateOptions) {
    let files = downloadUpdateOptions.updateInfoAndProvider.provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info);
    const log = this._logger;
    const sysctlRosettaInfoKey = "sysctl.proc_translated";
    let isRosetta;
    try {
      this.debug("Checking for macOS Rosetta environment");
      const result = child_process_1$2.execFileSync("sysctl", [sysctlRosettaInfoKey], { encoding: "utf8" });
      isRosetta = result.includes(`${sysctlRosettaInfoKey}: 1`);
      log.info(`Checked for macOS Rosetta environment (isRosetta=${isRosetta})`);
    } catch (e) {
      log.warn(`sysctl shell command to check for macOS Rosetta environment failed: ${e}`);
    }
    const isArm64 = (file2) => {
      var _a;
      return file2.url.pathname.includes("arm64") || ((_a = file2.info.url) === null || _a === void 0 ? void 0 : _a.includes("arm64"));
    };
    if (files.some(isArm64)) {
      files = files.filter((file2) => (process.arch === "arm64" || isRosetta) === isArm64(file2));
    }
    const zipFileInfo = Provider_1$1.findFile(files, "zip", ["pkg", "dmg"]);
    if (zipFileInfo == null) {
      throw builder_util_runtime_1$2.newError(`ZIP file not provided: ${builder_util_runtime_1$2.safeStringifyJson(files)}`, "ERR_UPDATER_ZIP_FILE_NOT_FOUND");
    }
    return this.executeDownload({
      fileExtension: "zip",
      fileInfo: zipFileInfo,
      downloadUpdateOptions,
      task: (destinationFile, downloadOptions) => {
        return this.httpExecutor.download(zipFileInfo.url, destinationFile, downloadOptions);
      },
      done: (event) => this.updateDownloaded(zipFileInfo, event)
    });
  }
  async updateDownloaded(zipFileInfo, event) {
    var _a;
    const downloadedFile = event.downloadedFile;
    const updateFileSize = (_a = zipFileInfo.info.size) !== null && _a !== void 0 ? _a : (await fs_extra_1$1.stat(downloadedFile)).size;
    const log = this._logger;
    const logContext = `fileToProxy=${zipFileInfo.url.href}`;
    this.debug(`Creating proxy server for native Squirrel.Mac (${logContext})`);
    const server = http_1.createServer();
    this.debug(`Proxy server for native Squirrel.Mac is created (${logContext})`);
    server.on("close", () => {
      log.info(`Proxy server for native Squirrel.Mac is closed (${logContext})`);
    });
    function getServerUrl() {
      const address = server.address();
      return `http://127.0.0.1:${address.port}`;
    }
    return await new Promise((resolve2, reject) => {
      const fileUrl = `/${Date.now().toString(16)}-${Math.floor(Math.random() * 9999).toString(16)}.zip`;
      server.on("request", (request, response) => {
        const requestUrl = request.url;
        log.info(`${requestUrl} requested`);
        if (requestUrl === "/") {
          const data = Buffer.from(`{ "url": "${getServerUrl()}${fileUrl}" }`);
          response.writeHead(200, { "Content-Type": "application/json", "Content-Length": data.length });
          response.end(data);
          return;
        }
        if (!requestUrl.startsWith(fileUrl)) {
          log.warn(`${requestUrl} requested, but not supported`);
          response.writeHead(404);
          response.end();
          return;
        }
        log.info(`${fileUrl} requested by Squirrel.Mac, pipe ${downloadedFile}`);
        let errorOccurred = false;
        response.on("finish", () => {
          try {
            setImmediate(() => server.close());
          } finally {
            if (!errorOccurred) {
              this.nativeUpdater.removeListener("error", reject);
              resolve2([]);
            }
          }
        });
        const readStream = fs_1$2.createReadStream(downloadedFile);
        readStream.on("error", (error2) => {
          try {
            response.end();
          } catch (e) {
            log.warn(`cannot end response: ${e}`);
          }
          errorOccurred = true;
          this.nativeUpdater.removeListener("error", reject);
          reject(new Error(`Cannot pipe "${downloadedFile}": ${error2}`));
        });
        response.writeHead(200, {
          "Content-Type": "application/zip",
          "Content-Length": updateFileSize
        });
        readStream.pipe(response);
      });
      this.debug(`Proxy server for native Squirrel.Mac is starting to listen (${logContext})`);
      server.listen(0, "127.0.0.1", () => {
        this.debug(`Proxy server for native Squirrel.Mac is listening (address=${getServerUrl()}, ${logContext})`);
        this.nativeUpdater.setFeedURL({
          url: getServerUrl(),
          headers: { "Cache-Control": "no-cache" }
        });
        this.dispatchUpdateDownloaded(event);
        if (this.autoInstallOnAppQuit) {
          this.nativeUpdater.once("error", reject);
          this.nativeUpdater.checkForUpdates();
        } else {
          resolve2([]);
        }
      });
    });
  }
  quitAndInstall() {
    if (this.squirrelDownloadedUpdate) {
      this.nativeUpdater.quitAndInstall();
    } else {
      this.nativeUpdater.on("update-downloaded", () => {
        this.nativeUpdater.quitAndInstall();
      });
    }
  }
}
MacUpdater$1.MacUpdater = MacUpdater;
var NsisUpdater$1 = {};
var GenericDifferentialDownloader$1 = {};
Object.defineProperty(GenericDifferentialDownloader$1, "__esModule", { value: true });
GenericDifferentialDownloader$1.GenericDifferentialDownloader = void 0;
const DifferentialDownloader_1 = DifferentialDownloader$1;
class GenericDifferentialDownloader extends DifferentialDownloader_1.DifferentialDownloader {
  download(oldBlockMap, newBlockMap) {
    return this.doDownload(oldBlockMap, newBlockMap);
  }
}
GenericDifferentialDownloader$1.GenericDifferentialDownloader = GenericDifferentialDownloader;
var windowsExecutableCodeSignatureVerifier = {};
Object.defineProperty(windowsExecutableCodeSignatureVerifier, "__esModule", { value: true });
windowsExecutableCodeSignatureVerifier.verifySignature = void 0;
const builder_util_runtime_1$1 = out;
const child_process_1$1 = require$$1__default$4["default"];
const os$1 = require$$1__default$3["default"];
function verifySignature(publisherNames, unescapedTempUpdateFile, logger) {
  return new Promise((resolve2) => {
    const tempUpdateFile = unescapedTempUpdateFile.replace(/'/g, "''").replace(/`/g, "``");
    child_process_1$1.execFile("powershell.exe", [
      "-NoProfile",
      "-NonInteractive",
      "-InputFormat",
      "None",
      "-Command",
      `Get-AuthenticodeSignature '${tempUpdateFile}' | ConvertTo-Json -Compress | ForEach-Object { [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($_)) }`
    ], {
      timeout: 20 * 1e3
    }, (error2, stdout, stderr) => {
      try {
        if (error2 != null || stderr) {
          handleError(logger, error2, stderr);
          resolve2(null);
          return;
        }
        const data = parseOut(Buffer.from(stdout, "base64").toString("utf-8"));
        if (data.Status === 0) {
          const name = builder_util_runtime_1$1.parseDn(data.SignerCertificate.Subject).get("CN");
          if (publisherNames.includes(name)) {
            resolve2(null);
            return;
          }
        }
        const result = `publisherNames: ${publisherNames.join(" | ")}, raw info: ` + JSON.stringify(data, (name, value) => name === "RawData" ? void 0 : value, 2);
        logger.warn(`Sign verification failed, installer signed with incorrect certificate: ${result}`);
        resolve2(result);
      } catch (e) {
        logger.warn(`Cannot execute Get-AuthenticodeSignature: ${error2}. Ignoring signature validation due to unknown error.`);
        resolve2(null);
        return;
      }
    });
  });
}
windowsExecutableCodeSignatureVerifier.verifySignature = verifySignature;
function parseOut(out2) {
  const data = JSON.parse(out2);
  delete data.PrivateKey;
  delete data.IsOSBinary;
  delete data.SignatureType;
  const signerCertificate = data.SignerCertificate;
  if (signerCertificate != null) {
    delete signerCertificate.Archived;
    delete signerCertificate.Extensions;
    delete signerCertificate.Handle;
    delete signerCertificate.HasPrivateKey;
    delete signerCertificate.SubjectName;
  }
  delete data.Path;
  return data;
}
function handleError(logger, error2, stderr) {
  if (isOldWin6()) {
    logger.warn(`Cannot execute Get-AuthenticodeSignature: ${error2 || stderr}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`);
    return;
  }
  try {
    child_process_1$1.execFileSync("powershell.exe", ["-NoProfile", "-NonInteractive", "-Command", "ConvertTo-Json test"], { timeout: 10 * 1e3 });
  } catch (testError) {
    logger.warn(`Cannot execute ConvertTo-Json: ${testError.message}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`);
    return;
  }
  if (error2 != null) {
    throw error2;
  }
  if (stderr) {
    logger.warn(`Cannot execute Get-AuthenticodeSignature, stderr: ${stderr}. Ignoring signature validation due to unknown stderr.`);
    return;
  }
}
function isOldWin6() {
  const winVersion = os$1.release();
  return winVersion.startsWith("6.") && !winVersion.startsWith("6.3");
}
Object.defineProperty(NsisUpdater$1, "__esModule", { value: true });
NsisUpdater$1.NsisUpdater = void 0;
const builder_util_runtime_1 = out;
const child_process_1 = require$$1__default$4["default"];
const path$6 = require$$1__default$1["default"];
const BaseUpdater_1 = BaseUpdater$1;
const FileWithEmbeddedBlockMapDifferentialDownloader_1 = FileWithEmbeddedBlockMapDifferentialDownloader$1;
const GenericDifferentialDownloader_1 = GenericDifferentialDownloader$1;
const main_1 = main$1;
const util_1$q = util$1;
const Provider_1 = Provider$1;
const fs_extra_1 = lib;
const windowsExecutableCodeSignatureVerifier_1 = windowsExecutableCodeSignatureVerifier;
const url_1 = require$$2__default["default"];
const zlib_1 = require$$2__default$1["default"];
class NsisUpdater extends BaseUpdater_1.BaseUpdater {
  constructor(options, app2) {
    super(options, app2);
  }
  doDownloadUpdate(downloadUpdateOptions) {
    const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
    const fileInfo = Provider_1.findFile(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), "exe");
    return this.executeDownload({
      fileExtension: "exe",
      downloadUpdateOptions,
      fileInfo,
      task: async (destinationFile, downloadOptions, packageFile, removeTempDirIfAny) => {
        const packageInfo = fileInfo.packageInfo;
        const isWebInstaller = packageInfo != null && packageFile != null;
        if (isWebInstaller || await this.differentialDownloadInstaller(fileInfo, downloadUpdateOptions, destinationFile, provider)) {
          await this.httpExecutor.download(fileInfo.url, destinationFile, downloadOptions);
        }
        const signatureVerificationStatus = await this.verifySignature(destinationFile);
        if (signatureVerificationStatus != null) {
          await removeTempDirIfAny();
          throw builder_util_runtime_1.newError(`New version ${downloadUpdateOptions.updateInfoAndProvider.info.version} is not signed by the application owner: ${signatureVerificationStatus}`, "ERR_UPDATER_INVALID_SIGNATURE");
        }
        if (isWebInstaller) {
          if (await this.differentialDownloadWebPackage(downloadUpdateOptions, packageInfo, packageFile, provider)) {
            try {
              await this.httpExecutor.download(new url_1.URL(packageInfo.path), packageFile, {
                headers: downloadUpdateOptions.requestHeaders,
                cancellationToken: downloadUpdateOptions.cancellationToken,
                sha512: packageInfo.sha512
              });
            } catch (e) {
              try {
                await fs_extra_1.unlink(packageFile);
              } catch (ignored) {
              }
              throw e;
            }
          }
        }
      }
    });
  }
  async verifySignature(tempUpdateFile) {
    let publisherName;
    try {
      publisherName = (await this.configOnDisk.value).publisherName;
      if (publisherName == null) {
        return null;
      }
    } catch (e) {
      if (e.code === "ENOENT") {
        return null;
      }
      throw e;
    }
    return await windowsExecutableCodeSignatureVerifier_1.verifySignature(Array.isArray(publisherName) ? publisherName : [publisherName], tempUpdateFile, this._logger);
  }
  doInstall(options) {
    const args = ["--updated"];
    if (options.isSilent) {
      args.push("/S");
    }
    if (options.isForceRunAfter) {
      args.push("--force-run");
    }
    const packagePath = this.downloadedUpdateHelper == null ? null : this.downloadedUpdateHelper.packageFile;
    if (packagePath != null) {
      args.push(`--package-file=${packagePath}`);
    }
    const callUsingElevation = () => {
      _spawn(path$6.join(process.resourcesPath, "elevate.exe"), [options.installerPath].concat(args)).catch((e) => this.dispatchError(e));
    };
    if (options.isAdminRightsRequired) {
      this._logger.info("isAdminRightsRequired is set to true, run installer using elevate.exe");
      callUsingElevation();
      return true;
    }
    _spawn(options.installerPath, args).catch((e) => {
      const errorCode = e.code;
      this._logger.info(`Cannot run installer: error code: ${errorCode}, error message: "${e.message}", will be executed again using elevate if EACCES"`);
      if (errorCode === "UNKNOWN" || errorCode === "EACCES") {
        callUsingElevation();
      } else {
        this.dispatchError(e);
      }
    });
    return true;
  }
  async differentialDownloadInstaller(fileInfo, downloadUpdateOptions, installerPath, provider) {
    try {
      if (this._testOnlyOptions != null && !this._testOnlyOptions.isUseDifferentialDownload) {
        return true;
      }
      const blockmapFileUrls = util_1$q.blockmapFiles(fileInfo.url, this.app.version, downloadUpdateOptions.updateInfoAndProvider.info.version);
      this._logger.info(`Download block maps (old: "${blockmapFileUrls[0]}", new: ${blockmapFileUrls[1]})`);
      const downloadBlockMap = async (url) => {
        const data = await this.httpExecutor.downloadToBuffer(url, {
          headers: downloadUpdateOptions.requestHeaders,
          cancellationToken: downloadUpdateOptions.cancellationToken
        });
        if (data == null || data.length === 0) {
          throw new Error(`Blockmap "${url.href}" is empty`);
        }
        try {
          return JSON.parse(zlib_1.gunzipSync(data).toString());
        } catch (e) {
          throw new Error(`Cannot parse blockmap "${url.href}", error: ${e}`);
        }
      };
      const downloadOptions = {
        newUrl: fileInfo.url,
        oldFile: path$6.join(this.downloadedUpdateHelper.cacheDir, builder_util_runtime_1.CURRENT_APP_INSTALLER_FILE_NAME),
        logger: this._logger,
        newFile: installerPath,
        isUseMultipleRangeRequest: provider.isUseMultipleRangeRequest,
        requestHeaders: downloadUpdateOptions.requestHeaders,
        cancellationToken: downloadUpdateOptions.cancellationToken
      };
      if (this.listenerCount(main_1.DOWNLOAD_PROGRESS) > 0) {
        downloadOptions.onProgress = (it) => this.emit(main_1.DOWNLOAD_PROGRESS, it);
      }
      const blockMapDataList = await Promise.all(blockmapFileUrls.map((u2) => downloadBlockMap(u2)));
      await new GenericDifferentialDownloader_1.GenericDifferentialDownloader(fileInfo.info, this.httpExecutor, downloadOptions).download(blockMapDataList[0], blockMapDataList[1]);
      return false;
    } catch (e) {
      this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);
      if (this._testOnlyOptions != null) {
        throw e;
      }
      return true;
    }
  }
  async differentialDownloadWebPackage(downloadUpdateOptions, packageInfo, packagePath, provider) {
    if (packageInfo.blockMapSize == null) {
      return true;
    }
    try {
      const downloadOptions = {
        newUrl: new url_1.URL(packageInfo.path),
        oldFile: path$6.join(this.downloadedUpdateHelper.cacheDir, builder_util_runtime_1.CURRENT_APP_PACKAGE_FILE_NAME),
        logger: this._logger,
        newFile: packagePath,
        requestHeaders: this.requestHeaders,
        isUseMultipleRangeRequest: provider.isUseMultipleRangeRequest,
        cancellationToken: downloadUpdateOptions.cancellationToken
      };
      if (this.listenerCount(main_1.DOWNLOAD_PROGRESS) > 0) {
        downloadOptions.onProgress = (it) => this.emit(main_1.DOWNLOAD_PROGRESS, it);
      }
      await new FileWithEmbeddedBlockMapDifferentialDownloader_1.FileWithEmbeddedBlockMapDifferentialDownloader(packageInfo, this.httpExecutor, downloadOptions).download();
    } catch (e) {
      this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);
      return process.platform === "win32";
    }
    return false;
  }
}
NsisUpdater$1.NsisUpdater = NsisUpdater;
async function _spawn(exe, args) {
  return new Promise((resolve2, reject) => {
    try {
      const process2 = child_process_1.spawn(exe, args, {
        detached: true,
        stdio: "ignore"
      });
      process2.on("error", (error2) => {
        reject(error2);
      });
      process2.unref();
      if (process2.pid !== void 0) {
        resolve2(true);
      }
    } catch (error2) {
      reject(error2);
    }
  });
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UpdaterSignal = exports.UPDATE_DOWNLOADED = exports.DOWNLOAD_PROGRESS = exports.NsisUpdater = exports.MacUpdater = exports.AppImageUpdater = exports.Provider = exports.CancellationToken = exports.NoOpLogger = exports.AppUpdater = void 0;
  const builder_util_runtime_12 = out;
  Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function() {
    return builder_util_runtime_12.CancellationToken;
  } });
  var AppUpdater_12 = AppUpdater$1;
  Object.defineProperty(exports, "AppUpdater", { enumerable: true, get: function() {
    return AppUpdater_12.AppUpdater;
  } });
  Object.defineProperty(exports, "NoOpLogger", { enumerable: true, get: function() {
    return AppUpdater_12.NoOpLogger;
  } });
  var Provider_12 = Provider$1;
  Object.defineProperty(exports, "Provider", { enumerable: true, get: function() {
    return Provider_12.Provider;
  } });
  var AppImageUpdater_1 = AppImageUpdater$1;
  Object.defineProperty(exports, "AppImageUpdater", { enumerable: true, get: function() {
    return AppImageUpdater_1.AppImageUpdater;
  } });
  var MacUpdater_1 = MacUpdater$1;
  Object.defineProperty(exports, "MacUpdater", { enumerable: true, get: function() {
    return MacUpdater_1.MacUpdater;
  } });
  var NsisUpdater_1 = NsisUpdater$1;
  Object.defineProperty(exports, "NsisUpdater", { enumerable: true, get: function() {
    return NsisUpdater_1.NsisUpdater;
  } });
  let _autoUpdater;
  function doLoadAutoUpdater() {
    if (process.platform === "win32") {
      _autoUpdater = new NsisUpdater$1.NsisUpdater();
    } else if (process.platform === "darwin") {
      _autoUpdater = new MacUpdater$1.MacUpdater();
    } else {
      _autoUpdater = new AppImageUpdater$1.AppImageUpdater();
    }
    return _autoUpdater;
  }
  Object.defineProperty(exports, "autoUpdater", {
    enumerable: true,
    get: () => {
      return _autoUpdater || doLoadAutoUpdater();
    }
  });
  exports.DOWNLOAD_PROGRESS = "download-progress";
  exports.UPDATE_DOWNLOADED = "update-downloaded";
  class UpdaterSignal {
    constructor(emitter) {
      this.emitter = emitter;
    }
    login(handler) {
      addHandler(this.emitter, "login", handler);
    }
    progress(handler) {
      addHandler(this.emitter, exports.DOWNLOAD_PROGRESS, handler);
    }
    updateDownloaded(handler) {
      addHandler(this.emitter, exports.UPDATE_DOWNLOADED, handler);
    }
    updateCancelled(handler) {
      addHandler(this.emitter, "update-cancelled", handler);
    }
  }
  exports.UpdaterSignal = UpdaterSignal;
  function addHandler(emitter, event, handler) {
    {
      emitter.on(event, handler);
    }
  }
})(main$1);
var source = { exports: {} };
var isObj$1 = (value) => {
  const type2 = typeof value;
  return value !== null && (type2 === "object" || type2 === "function");
};
const isObj = isObj$1;
const disallowedKeys = new Set([
  "__proto__",
  "prototype",
  "constructor"
]);
const isValidPath = (pathSegments) => !pathSegments.some((segment) => disallowedKeys.has(segment));
function getPathSegments(path2) {
  const pathArray = path2.split(".");
  const parts = [];
  for (let i2 = 0; i2 < pathArray.length; i2++) {
    let p = pathArray[i2];
    while (p[p.length - 1] === "\\" && pathArray[i2 + 1] !== void 0) {
      p = p.slice(0, -1) + ".";
      p += pathArray[++i2];
    }
    parts.push(p);
  }
  if (!isValidPath(parts)) {
    return [];
  }
  return parts;
}
var dotProp = {
  get(object, path2, value) {
    if (!isObj(object) || typeof path2 !== "string") {
      return value === void 0 ? object : value;
    }
    const pathArray = getPathSegments(path2);
    if (pathArray.length === 0) {
      return;
    }
    for (let i2 = 0; i2 < pathArray.length; i2++) {
      object = object[pathArray[i2]];
      if (object === void 0 || object === null) {
        if (i2 !== pathArray.length - 1) {
          return value;
        }
        break;
      }
    }
    return object === void 0 ? value : object;
  },
  set(object, path2, value) {
    if (!isObj(object) || typeof path2 !== "string") {
      return object;
    }
    const root2 = object;
    const pathArray = getPathSegments(path2);
    for (let i2 = 0; i2 < pathArray.length; i2++) {
      const p = pathArray[i2];
      if (!isObj(object[p])) {
        object[p] = {};
      }
      if (i2 === pathArray.length - 1) {
        object[p] = value;
      }
      object = object[p];
    }
    return root2;
  },
  delete(object, path2) {
    if (!isObj(object) || typeof path2 !== "string") {
      return false;
    }
    const pathArray = getPathSegments(path2);
    for (let i2 = 0; i2 < pathArray.length; i2++) {
      const p = pathArray[i2];
      if (i2 === pathArray.length - 1) {
        delete object[p];
        return true;
      }
      object = object[p];
      if (!isObj(object)) {
        return false;
      }
    }
  },
  has(object, path2) {
    if (!isObj(object) || typeof path2 !== "string") {
      return false;
    }
    const pathArray = getPathSegments(path2);
    if (pathArray.length === 0) {
      return false;
    }
    for (let i2 = 0; i2 < pathArray.length; i2++) {
      if (isObj(object)) {
        if (!(pathArray[i2] in object)) {
          return false;
        }
        object = object[pathArray[i2]];
      } else {
        return false;
      }
    }
    return true;
  }
};
var pkgUp = { exports: {} };
var findUp$1 = { exports: {} };
var locatePath$1 = { exports: {} };
var pathExists$1 = { exports: {} };
const fs$2 = require$$0__default$2["default"];
pathExists$1.exports = (fp) => new Promise((resolve2) => {
  fs$2.access(fp, (err) => {
    resolve2(!err);
  });
});
pathExists$1.exports.sync = (fp) => {
  try {
    fs$2.accessSync(fp);
    return true;
  } catch (err) {
    return false;
  }
};
var pLimit$2 = { exports: {} };
var pTry$2 = { exports: {} };
const pTry$1 = (fn, ...arguments_) => new Promise((resolve2) => {
  resolve2(fn(...arguments_));
});
pTry$2.exports = pTry$1;
pTry$2.exports.default = pTry$1;
const pTry = pTry$2.exports;
const pLimit$1 = (concurrency) => {
  if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
    return Promise.reject(new TypeError("Expected `concurrency` to be a number from 1 and up"));
  }
  const queue2 = [];
  let activeCount = 0;
  const next = () => {
    activeCount--;
    if (queue2.length > 0) {
      queue2.shift()();
    }
  };
  const run = (fn, resolve2, ...args) => {
    activeCount++;
    const result = pTry(fn, ...args);
    resolve2(result);
    result.then(next, next);
  };
  const enqueue2 = (fn, resolve2, ...args) => {
    if (activeCount < concurrency) {
      run(fn, resolve2, ...args);
    } else {
      queue2.push(run.bind(null, fn, resolve2, ...args));
    }
  };
  const generator = (fn, ...args) => new Promise((resolve2) => enqueue2(fn, resolve2, ...args));
  Object.defineProperties(generator, {
    activeCount: {
      get: () => activeCount
    },
    pendingCount: {
      get: () => queue2.length
    },
    clearQueue: {
      value: () => {
        queue2.length = 0;
      }
    }
  });
  return generator;
};
pLimit$2.exports = pLimit$1;
pLimit$2.exports.default = pLimit$1;
const pLimit = pLimit$2.exports;
class EndError extends Error {
  constructor(value) {
    super();
    this.value = value;
  }
}
const testElement = (el, tester) => Promise.resolve(el).then(tester);
const finder = (el) => Promise.all(el).then((val) => val[1] === true && Promise.reject(new EndError(val[0])));
var pLocate$1 = (iterable, tester, opts2) => {
  opts2 = Object.assign({
    concurrency: Infinity,
    preserveOrder: true
  }, opts2);
  const limit2 = pLimit(opts2.concurrency);
  const items2 = [...iterable].map((el) => [el, limit2(testElement, el, tester)]);
  const checkLimit = pLimit(opts2.preserveOrder ? 1 : Infinity);
  return Promise.all(items2.map((el) => checkLimit(finder, el))).then(() => {
  }).catch((err) => err instanceof EndError ? err.value : Promise.reject(err));
};
const path$5 = require$$1__default$1["default"];
const pathExists = pathExists$1.exports;
const pLocate = pLocate$1;
locatePath$1.exports = (iterable, options) => {
  options = Object.assign({
    cwd: process.cwd()
  }, options);
  return pLocate(iterable, (el) => pathExists(path$5.resolve(options.cwd, el)), options);
};
locatePath$1.exports.sync = (iterable, options) => {
  options = Object.assign({
    cwd: process.cwd()
  }, options);
  for (const el of iterable) {
    if (pathExists.sync(path$5.resolve(options.cwd, el))) {
      return el;
    }
  }
};
const path$4 = require$$1__default$1["default"];
const locatePath = locatePath$1.exports;
findUp$1.exports = (filename, opts2 = {}) => {
  const startDir = path$4.resolve(opts2.cwd || "");
  const { root: root2 } = path$4.parse(startDir);
  const filenames = [].concat(filename);
  return new Promise((resolve2) => {
    (function find(dir) {
      locatePath(filenames, { cwd: dir }).then((file2) => {
        if (file2) {
          resolve2(path$4.join(dir, file2));
        } else if (dir === root2) {
          resolve2(null);
        } else {
          find(path$4.dirname(dir));
        }
      });
    })(startDir);
  });
};
findUp$1.exports.sync = (filename, opts2 = {}) => {
  let dir = path$4.resolve(opts2.cwd || "");
  const { root: root2 } = path$4.parse(dir);
  const filenames = [].concat(filename);
  while (true) {
    const file2 = locatePath.sync(filenames, { cwd: dir });
    if (file2) {
      return path$4.join(dir, file2);
    }
    if (dir === root2) {
      return null;
    }
    dir = path$4.dirname(dir);
  }
};
const findUp = findUp$1.exports;
pkgUp.exports = async ({ cwd: cwd2 } = {}) => findUp("package.json", { cwd: cwd2 });
pkgUp.exports.sync = ({ cwd: cwd2 } = {}) => findUp.sync("package.json", { cwd: cwd2 });
var envPaths$1 = { exports: {} };
const path$3 = require$$1__default$1["default"];
const os = require$$1__default$3["default"];
const homedir = os.homedir();
const tmpdir = os.tmpdir();
const { env: env$1 } = process;
const macos = (name) => {
  const library = path$3.join(homedir, "Library");
  return {
    data: path$3.join(library, "Application Support", name),
    config: path$3.join(library, "Preferences", name),
    cache: path$3.join(library, "Caches", name),
    log: path$3.join(library, "Logs", name),
    temp: path$3.join(tmpdir, name)
  };
};
const windows = (name) => {
  const appData = env$1.APPDATA || path$3.join(homedir, "AppData", "Roaming");
  const localAppData = env$1.LOCALAPPDATA || path$3.join(homedir, "AppData", "Local");
  return {
    data: path$3.join(localAppData, name, "Data"),
    config: path$3.join(appData, name, "Config"),
    cache: path$3.join(localAppData, name, "Cache"),
    log: path$3.join(localAppData, name, "Log"),
    temp: path$3.join(tmpdir, name)
  };
};
const linux = (name) => {
  const username = path$3.basename(homedir);
  return {
    data: path$3.join(env$1.XDG_DATA_HOME || path$3.join(homedir, ".local", "share"), name),
    config: path$3.join(env$1.XDG_CONFIG_HOME || path$3.join(homedir, ".config"), name),
    cache: path$3.join(env$1.XDG_CACHE_HOME || path$3.join(homedir, ".cache"), name),
    log: path$3.join(env$1.XDG_STATE_HOME || path$3.join(homedir, ".local", "state"), name),
    temp: path$3.join(tmpdir, username, name)
  };
};
const envPaths = (name, options) => {
  if (typeof name !== "string") {
    throw new TypeError(`Expected string, got ${typeof name}`);
  }
  options = Object.assign({ suffix: "nodejs" }, options);
  if (options.suffix) {
    name += `-${options.suffix}`;
  }
  if (process.platform === "darwin") {
    return macos(name);
  }
  if (process.platform === "win32") {
    return windows(name);
  }
  return linux(name);
};
envPaths$1.exports = envPaths;
envPaths$1.exports.default = envPaths;
var dist$1 = {};
var consts = {};
Object.defineProperty(consts, "__esModule", { value: true });
consts.NOOP = consts.LIMIT_FILES_DESCRIPTORS = consts.LIMIT_BASENAME_LENGTH = consts.IS_USER_ROOT = consts.IS_POSIX = consts.DEFAULT_TIMEOUT_SYNC = consts.DEFAULT_TIMEOUT_ASYNC = consts.DEFAULT_WRITE_OPTIONS = consts.DEFAULT_READ_OPTIONS = consts.DEFAULT_FOLDER_MODE = consts.DEFAULT_FILE_MODE = consts.DEFAULT_ENCODING = void 0;
const DEFAULT_ENCODING = "utf8";
consts.DEFAULT_ENCODING = DEFAULT_ENCODING;
const DEFAULT_FILE_MODE = 438;
consts.DEFAULT_FILE_MODE = DEFAULT_FILE_MODE;
const DEFAULT_FOLDER_MODE = 511;
consts.DEFAULT_FOLDER_MODE = DEFAULT_FOLDER_MODE;
const DEFAULT_READ_OPTIONS = {};
consts.DEFAULT_READ_OPTIONS = DEFAULT_READ_OPTIONS;
const DEFAULT_WRITE_OPTIONS = {};
consts.DEFAULT_WRITE_OPTIONS = DEFAULT_WRITE_OPTIONS;
const DEFAULT_TIMEOUT_ASYNC = 5e3;
consts.DEFAULT_TIMEOUT_ASYNC = DEFAULT_TIMEOUT_ASYNC;
const DEFAULT_TIMEOUT_SYNC = 100;
consts.DEFAULT_TIMEOUT_SYNC = DEFAULT_TIMEOUT_SYNC;
const IS_POSIX = !!process.getuid;
consts.IS_POSIX = IS_POSIX;
const IS_USER_ROOT = process.getuid ? !process.getuid() : false;
consts.IS_USER_ROOT = IS_USER_ROOT;
const LIMIT_BASENAME_LENGTH = 128;
consts.LIMIT_BASENAME_LENGTH = LIMIT_BASENAME_LENGTH;
const LIMIT_FILES_DESCRIPTORS = 1e4;
consts.LIMIT_FILES_DESCRIPTORS = LIMIT_FILES_DESCRIPTORS;
const NOOP = () => {
};
consts.NOOP = NOOP;
var fs$1 = {};
var attemptify = {};
Object.defineProperty(attemptify, "__esModule", { value: true });
attemptify.attemptifySync = attemptify.attemptifyAsync = void 0;
const consts_1$4 = consts;
const attemptifyAsync = (fn, onError = consts_1$4.NOOP) => {
  return function() {
    return fn.apply(void 0, arguments).catch(onError);
  };
};
attemptify.attemptifyAsync = attemptifyAsync;
const attemptifySync = (fn, onError = consts_1$4.NOOP) => {
  return function() {
    try {
      return fn.apply(void 0, arguments);
    } catch (error2) {
      return onError(error2);
    }
  };
};
attemptify.attemptifySync = attemptifySync;
var fs_handlers = {};
Object.defineProperty(fs_handlers, "__esModule", { value: true });
const consts_1$3 = consts;
const Handlers = {
  isChangeErrorOk: (error2) => {
    const { code: code2 } = error2;
    if (code2 === "ENOSYS")
      return true;
    if (!consts_1$3.IS_USER_ROOT && (code2 === "EINVAL" || code2 === "EPERM"))
      return true;
    return false;
  },
  isRetriableError: (error2) => {
    const { code: code2 } = error2;
    if (code2 === "EMFILE" || code2 === "ENFILE" || code2 === "EAGAIN" || code2 === "EBUSY" || code2 === "EACCESS" || code2 === "EACCS" || code2 === "EPERM")
      return true;
    return false;
  },
  onChangeError: (error2) => {
    if (Handlers.isChangeErrorOk(error2))
      return;
    throw error2;
  }
};
fs_handlers.default = Handlers;
var retryify = {};
var retryify_queue = {};
Object.defineProperty(retryify_queue, "__esModule", { value: true });
const consts_1$2 = consts;
const RetryfyQueue = {
  interval: 25,
  intervalId: void 0,
  limit: consts_1$2.LIMIT_FILES_DESCRIPTORS,
  queueActive: new Set(),
  queueWaiting: new Set(),
  init: () => {
    if (RetryfyQueue.intervalId)
      return;
    RetryfyQueue.intervalId = setInterval(RetryfyQueue.tick, RetryfyQueue.interval);
  },
  reset: () => {
    if (!RetryfyQueue.intervalId)
      return;
    clearInterval(RetryfyQueue.intervalId);
    delete RetryfyQueue.intervalId;
  },
  add: (fn) => {
    RetryfyQueue.queueWaiting.add(fn);
    if (RetryfyQueue.queueActive.size < RetryfyQueue.limit / 2) {
      RetryfyQueue.tick();
    } else {
      RetryfyQueue.init();
    }
  },
  remove: (fn) => {
    RetryfyQueue.queueWaiting.delete(fn);
    RetryfyQueue.queueActive.delete(fn);
  },
  schedule: () => {
    return new Promise((resolve2) => {
      const cleanup = () => RetryfyQueue.remove(resolver);
      const resolver = () => resolve2(cleanup);
      RetryfyQueue.add(resolver);
    });
  },
  tick: () => {
    if (RetryfyQueue.queueActive.size >= RetryfyQueue.limit)
      return;
    if (!RetryfyQueue.queueWaiting.size)
      return RetryfyQueue.reset();
    for (const fn of RetryfyQueue.queueWaiting) {
      if (RetryfyQueue.queueActive.size >= RetryfyQueue.limit)
        break;
      RetryfyQueue.queueWaiting.delete(fn);
      RetryfyQueue.queueActive.add(fn);
      fn();
    }
  }
};
retryify_queue.default = RetryfyQueue;
Object.defineProperty(retryify, "__esModule", { value: true });
retryify.retryifySync = retryify.retryifyAsync = void 0;
const retryify_queue_1 = retryify_queue;
const retryifyAsync = (fn, isRetriableError) => {
  return function(timestamp2) {
    return function attempt() {
      return retryify_queue_1.default.schedule().then((cleanup) => {
        return fn.apply(void 0, arguments).then((result) => {
          cleanup();
          return result;
        }, (error2) => {
          cleanup();
          if (Date.now() >= timestamp2)
            throw error2;
          if (isRetriableError(error2)) {
            const delay = Math.round(100 + 400 * Math.random()), delayPromise = new Promise((resolve2) => setTimeout(resolve2, delay));
            return delayPromise.then(() => attempt.apply(void 0, arguments));
          }
          throw error2;
        });
      });
    };
  };
};
retryify.retryifyAsync = retryifyAsync;
const retryifySync = (fn, isRetriableError) => {
  return function(timestamp2) {
    return function attempt() {
      try {
        return fn.apply(void 0, arguments);
      } catch (error2) {
        if (Date.now() > timestamp2)
          throw error2;
        if (isRetriableError(error2))
          return attempt.apply(void 0, arguments);
        throw error2;
      }
    };
  };
};
retryify.retryifySync = retryifySync;
Object.defineProperty(fs$1, "__esModule", { value: true });
const fs = require$$0__default$2["default"];
const util_1$p = require$$4__default["default"];
const attemptify_1 = attemptify;
const fs_handlers_1 = fs_handlers;
const retryify_1 = retryify;
const FS = {
  chmodAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.chmod), fs_handlers_1.default.onChangeError),
  chownAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.chown), fs_handlers_1.default.onChangeError),
  closeAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.close)),
  fsyncAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.fsync)),
  mkdirAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.mkdir)),
  realpathAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.realpath)),
  statAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.stat)),
  unlinkAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.unlink)),
  closeRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.close), fs_handlers_1.default.isRetriableError),
  fsyncRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.fsync), fs_handlers_1.default.isRetriableError),
  openRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.open), fs_handlers_1.default.isRetriableError),
  readFileRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.readFile), fs_handlers_1.default.isRetriableError),
  renameRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.rename), fs_handlers_1.default.isRetriableError),
  statRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.stat), fs_handlers_1.default.isRetriableError),
  writeRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.write), fs_handlers_1.default.isRetriableError),
  chmodSyncAttempt: attemptify_1.attemptifySync(fs.chmodSync, fs_handlers_1.default.onChangeError),
  chownSyncAttempt: attemptify_1.attemptifySync(fs.chownSync, fs_handlers_1.default.onChangeError),
  closeSyncAttempt: attemptify_1.attemptifySync(fs.closeSync),
  mkdirSyncAttempt: attemptify_1.attemptifySync(fs.mkdirSync),
  realpathSyncAttempt: attemptify_1.attemptifySync(fs.realpathSync),
  statSyncAttempt: attemptify_1.attemptifySync(fs.statSync),
  unlinkSyncAttempt: attemptify_1.attemptifySync(fs.unlinkSync),
  closeSyncRetry: retryify_1.retryifySync(fs.closeSync, fs_handlers_1.default.isRetriableError),
  fsyncSyncRetry: retryify_1.retryifySync(fs.fsyncSync, fs_handlers_1.default.isRetriableError),
  openSyncRetry: retryify_1.retryifySync(fs.openSync, fs_handlers_1.default.isRetriableError),
  readFileSyncRetry: retryify_1.retryifySync(fs.readFileSync, fs_handlers_1.default.isRetriableError),
  renameSyncRetry: retryify_1.retryifySync(fs.renameSync, fs_handlers_1.default.isRetriableError),
  statSyncRetry: retryify_1.retryifySync(fs.statSync, fs_handlers_1.default.isRetriableError),
  writeSyncRetry: retryify_1.retryifySync(fs.writeSync, fs_handlers_1.default.isRetriableError)
};
fs$1.default = FS;
var lang = {};
Object.defineProperty(lang, "__esModule", { value: true });
const Lang = {
  isFunction: (x) => {
    return typeof x === "function";
  },
  isString: (x) => {
    return typeof x === "string";
  },
  isUndefined: (x) => {
    return typeof x === "undefined";
  }
};
lang.default = Lang;
var scheduler = {};
Object.defineProperty(scheduler, "__esModule", { value: true });
const Queues = {};
const Scheduler = {
  next: (id2) => {
    const queue2 = Queues[id2];
    if (!queue2)
      return;
    queue2.shift();
    const job = queue2[0];
    if (job) {
      job(() => Scheduler.next(id2));
    } else {
      delete Queues[id2];
    }
  },
  schedule: (id2) => {
    return new Promise((resolve2) => {
      let queue2 = Queues[id2];
      if (!queue2)
        queue2 = Queues[id2] = [];
      queue2.push(resolve2);
      if (queue2.length > 1)
        return;
      resolve2(() => Scheduler.next(id2));
    });
  }
};
scheduler.default = Scheduler;
var temp = {};
Object.defineProperty(temp, "__esModule", { value: true });
const path$2 = require$$1__default$1["default"];
const consts_1$1 = consts;
const fs_1$1 = fs$1;
const Temp = {
  store: {},
  create: (filePath) => {
    const randomness = `000000${Math.floor(Math.random() * 16777215).toString(16)}`.slice(-6), timestamp2 = Date.now().toString().slice(-10), prefix = "tmp-", suffix = `.${prefix}${timestamp2}${randomness}`, tempPath = `${filePath}${suffix}`;
    return tempPath;
  },
  get: (filePath, creator, purge = true) => {
    const tempPath = Temp.truncate(creator(filePath));
    if (tempPath in Temp.store)
      return Temp.get(filePath, creator, purge);
    Temp.store[tempPath] = purge;
    const disposer = () => delete Temp.store[tempPath];
    return [tempPath, disposer];
  },
  purge: (filePath) => {
    if (!Temp.store[filePath])
      return;
    delete Temp.store[filePath];
    fs_1$1.default.unlinkAttempt(filePath);
  },
  purgeSync: (filePath) => {
    if (!Temp.store[filePath])
      return;
    delete Temp.store[filePath];
    fs_1$1.default.unlinkSyncAttempt(filePath);
  },
  purgeSyncAll: () => {
    for (const filePath in Temp.store) {
      Temp.purgeSync(filePath);
    }
  },
  truncate: (filePath) => {
    const basename = path$2.basename(filePath);
    if (basename.length <= consts_1$1.LIMIT_BASENAME_LENGTH)
      return filePath;
    const truncable = /^(\.?)(.*?)((?:\.[^.]+)?(?:\.tmp-\d{10}[a-f0-9]{6})?)$/.exec(basename);
    if (!truncable)
      return filePath;
    const truncationLength = basename.length - consts_1$1.LIMIT_BASENAME_LENGTH;
    return `${filePath.slice(0, -basename.length)}${truncable[1]}${truncable[2].slice(0, -truncationLength)}${truncable[3]}`;
  }
};
process.on("exit", Temp.purgeSyncAll);
temp.default = Temp;
Object.defineProperty(dist$1, "__esModule", { value: true });
dist$1.writeFileSync = dist$1.writeFile = dist$1.readFileSync = dist$1.readFile = void 0;
const path$1 = require$$1__default$1["default"];
const consts_1 = consts;
const fs_1 = fs$1;
const lang_1 = lang;
const scheduler_1 = scheduler;
const temp_1 = temp;
function readFile(filePath, options = consts_1.DEFAULT_READ_OPTIONS) {
  var _a;
  if (lang_1.default.isString(options))
    return readFile(filePath, { encoding: options });
  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_ASYNC);
  return fs_1.default.readFileRetry(timeout)(filePath, options);
}
dist$1.readFile = readFile;
function readFileSync(filePath, options = consts_1.DEFAULT_READ_OPTIONS) {
  var _a;
  if (lang_1.default.isString(options))
    return readFileSync(filePath, { encoding: options });
  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_SYNC);
  return fs_1.default.readFileSyncRetry(timeout)(filePath, options);
}
dist$1.readFileSync = readFileSync;
const writeFile = (filePath, data, options, callback) => {
  if (lang_1.default.isFunction(options))
    return writeFile(filePath, data, consts_1.DEFAULT_WRITE_OPTIONS, options);
  const promise = writeFileAsync(filePath, data, options);
  if (callback)
    promise.then(callback, callback);
  return promise;
};
dist$1.writeFile = writeFile;
const writeFileAsync = async (filePath, data, options = consts_1.DEFAULT_WRITE_OPTIONS) => {
  var _a;
  if (lang_1.default.isString(options))
    return writeFileAsync(filePath, data, { encoding: options });
  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_ASYNC);
  let schedulerCustomDisposer = null, schedulerDisposer = null, tempDisposer = null, tempPath = null, fd = null;
  try {
    if (options.schedule)
      schedulerCustomDisposer = await options.schedule(filePath);
    schedulerDisposer = await scheduler_1.default.schedule(filePath);
    filePath = await fs_1.default.realpathAttempt(filePath) || filePath;
    [tempPath, tempDisposer] = temp_1.default.get(filePath, options.tmpCreate || temp_1.default.create, !(options.tmpPurge === false));
    const useStatChown = consts_1.IS_POSIX && lang_1.default.isUndefined(options.chown), useStatMode = lang_1.default.isUndefined(options.mode);
    if (useStatChown || useStatMode) {
      const stat2 = await fs_1.default.statAttempt(filePath);
      if (stat2) {
        options = __spreadValues({}, options);
        if (useStatChown)
          options.chown = { uid: stat2.uid, gid: stat2.gid };
        if (useStatMode)
          options.mode = stat2.mode;
      }
    }
    const parentPath = path$1.dirname(filePath);
    await fs_1.default.mkdirAttempt(parentPath, {
      mode: consts_1.DEFAULT_FOLDER_MODE,
      recursive: true
    });
    fd = await fs_1.default.openRetry(timeout)(tempPath, "w", options.mode || consts_1.DEFAULT_FILE_MODE);
    if (options.tmpCreated)
      options.tmpCreated(tempPath);
    if (lang_1.default.isString(data)) {
      await fs_1.default.writeRetry(timeout)(fd, data, 0, options.encoding || consts_1.DEFAULT_ENCODING);
    } else if (!lang_1.default.isUndefined(data)) {
      await fs_1.default.writeRetry(timeout)(fd, data, 0, data.length, 0);
    }
    if (options.fsync !== false) {
      if (options.fsyncWait !== false) {
        await fs_1.default.fsyncRetry(timeout)(fd);
      } else {
        fs_1.default.fsyncAttempt(fd);
      }
    }
    await fs_1.default.closeRetry(timeout)(fd);
    fd = null;
    if (options.chown)
      await fs_1.default.chownAttempt(tempPath, options.chown.uid, options.chown.gid);
    if (options.mode)
      await fs_1.default.chmodAttempt(tempPath, options.mode);
    try {
      await fs_1.default.renameRetry(timeout)(tempPath, filePath);
    } catch (error2) {
      if (error2.code !== "ENAMETOOLONG")
        throw error2;
      await fs_1.default.renameRetry(timeout)(tempPath, temp_1.default.truncate(filePath));
    }
    tempDisposer();
    tempPath = null;
  } finally {
    if (fd)
      await fs_1.default.closeAttempt(fd);
    if (tempPath)
      temp_1.default.purge(tempPath);
    if (schedulerCustomDisposer)
      schedulerCustomDisposer();
    if (schedulerDisposer)
      schedulerDisposer();
  }
};
const writeFileSync = (filePath, data, options = consts_1.DEFAULT_WRITE_OPTIONS) => {
  var _a;
  if (lang_1.default.isString(options))
    return writeFileSync(filePath, data, { encoding: options });
  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_SYNC);
  let tempDisposer = null, tempPath = null, fd = null;
  try {
    filePath = fs_1.default.realpathSyncAttempt(filePath) || filePath;
    [tempPath, tempDisposer] = temp_1.default.get(filePath, options.tmpCreate || temp_1.default.create, !(options.tmpPurge === false));
    const useStatChown = consts_1.IS_POSIX && lang_1.default.isUndefined(options.chown), useStatMode = lang_1.default.isUndefined(options.mode);
    if (useStatChown || useStatMode) {
      const stat2 = fs_1.default.statSyncAttempt(filePath);
      if (stat2) {
        options = __spreadValues({}, options);
        if (useStatChown)
          options.chown = { uid: stat2.uid, gid: stat2.gid };
        if (useStatMode)
          options.mode = stat2.mode;
      }
    }
    const parentPath = path$1.dirname(filePath);
    fs_1.default.mkdirSyncAttempt(parentPath, {
      mode: consts_1.DEFAULT_FOLDER_MODE,
      recursive: true
    });
    fd = fs_1.default.openSyncRetry(timeout)(tempPath, "w", options.mode || consts_1.DEFAULT_FILE_MODE);
    if (options.tmpCreated)
      options.tmpCreated(tempPath);
    if (lang_1.default.isString(data)) {
      fs_1.default.writeSyncRetry(timeout)(fd, data, 0, options.encoding || consts_1.DEFAULT_ENCODING);
    } else if (!lang_1.default.isUndefined(data)) {
      fs_1.default.writeSyncRetry(timeout)(fd, data, 0, data.length, 0);
    }
    if (options.fsync !== false) {
      if (options.fsyncWait !== false) {
        fs_1.default.fsyncSyncRetry(timeout)(fd);
      } else {
        fs_1.default.fsyncAttempt(fd);
      }
    }
    fs_1.default.closeSyncRetry(timeout)(fd);
    fd = null;
    if (options.chown)
      fs_1.default.chownSyncAttempt(tempPath, options.chown.uid, options.chown.gid);
    if (options.mode)
      fs_1.default.chmodSyncAttempt(tempPath, options.mode);
    try {
      fs_1.default.renameSyncRetry(timeout)(tempPath, filePath);
    } catch (error2) {
      if (error2.code !== "ENAMETOOLONG")
        throw error2;
      fs_1.default.renameSyncRetry(timeout)(tempPath, temp_1.default.truncate(filePath));
    }
    tempDisposer();
    tempPath = null;
  } finally {
    if (fd)
      fs_1.default.closeSyncAttempt(fd);
    if (tempPath)
      temp_1.default.purge(tempPath);
  }
};
dist$1.writeFileSync = writeFileSync;
var ajv = { exports: {} };
var core$2 = {};
var validate = {};
var boolSchema = {};
var errors = {};
var codegen = {};
var code$1 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.regexpCode = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
  class _CodeOrName {
  }
  exports._CodeOrName = _CodeOrName;
  exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  class Name extends _CodeOrName {
    constructor(s2) {
      super();
      if (!exports.IDENTIFIER.test(s2))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = s2;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return false;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  exports.Name = Name;
  class _Code extends _CodeOrName {
    constructor(code2) {
      super();
      this._items = typeof code2 === "string" ? [code2] : code2;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return false;
      const item = this._items[0];
      return item === "" || item === '""';
    }
    get str() {
      var _a;
      return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s2, c) => `${s2}${c}`, "");
    }
    get names() {
      var _a;
      return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names2, c) => {
        if (c instanceof Name)
          names2[c.str] = (names2[c.str] || 0) + 1;
        return names2;
      }, {});
    }
  }
  exports._Code = _Code;
  exports.nil = new _Code("");
  function _(strs, ...args) {
    const code2 = [strs[0]];
    let i2 = 0;
    while (i2 < args.length) {
      addCodeArg(code2, args[i2]);
      code2.push(strs[++i2]);
    }
    return new _Code(code2);
  }
  exports._ = _;
  const plus = new _Code("+");
  function str2(strs, ...args) {
    const expr = [safeStringify(strs[0])];
    let i2 = 0;
    while (i2 < args.length) {
      expr.push(plus);
      addCodeArg(expr, args[i2]);
      expr.push(plus, safeStringify(strs[++i2]));
    }
    optimize(expr);
    return new _Code(expr);
  }
  exports.str = str2;
  function addCodeArg(code2, arg) {
    if (arg instanceof _Code)
      code2.push(...arg._items);
    else if (arg instanceof Name)
      code2.push(arg);
    else
      code2.push(interpolate(arg));
  }
  exports.addCodeArg = addCodeArg;
  function optimize(expr) {
    let i2 = 1;
    while (i2 < expr.length - 1) {
      if (expr[i2] === plus) {
        const res = mergeExprItems(expr[i2 - 1], expr[i2 + 1]);
        if (res !== void 0) {
          expr.splice(i2 - 1, 3, res);
          continue;
        }
        expr[i2++] = "+";
      }
      i2++;
    }
  }
  function mergeExprItems(a, b) {
    if (b === '""')
      return a;
    if (a === '""')
      return b;
    if (typeof a == "string") {
      if (b instanceof Name || a[a.length - 1] !== '"')
        return;
      if (typeof b != "string")
        return `${a.slice(0, -1)}${b}"`;
      if (b[0] === '"')
        return a.slice(0, -1) + b.slice(1);
      return;
    }
    if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
      return `"${a}${b.slice(1)}`;
    return;
  }
  function strConcat(c1, c2) {
    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str2`${c1}${c2}`;
  }
  exports.strConcat = strConcat;
  function interpolate(x) {
    return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
  }
  function stringify2(x) {
    return new _Code(safeStringify(x));
  }
  exports.stringify = stringify2;
  function safeStringify(x) {
    return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  exports.safeStringify = safeStringify;
  function getProperty(key) {
    return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
  }
  exports.getProperty = getProperty;
  function regexpCode(rx) {
    return new _Code(rx.toString());
  }
  exports.regexpCode = regexpCode;
})(code$1);
var scope = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
  const code_12 = code$1;
  class ValueError extends Error {
    constructor(name) {
      super(`CodeGen: "code" for ${name} not defined`);
      this.value = name.value;
    }
  }
  var UsedValueState;
  (function(UsedValueState2) {
    UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
    UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
  })(UsedValueState = exports.UsedValueState || (exports.UsedValueState = {}));
  exports.varKinds = {
    const: new code_12.Name("const"),
    let: new code_12.Name("let"),
    var: new code_12.Name("var")
  };
  class Scope {
    constructor({ prefixes, parent } = {}) {
      this._names = {};
      this._prefixes = prefixes;
      this._parent = parent;
    }
    toName(nameOrPrefix) {
      return nameOrPrefix instanceof code_12.Name ? nameOrPrefix : this.name(nameOrPrefix);
    }
    name(prefix) {
      return new code_12.Name(this._newName(prefix));
    }
    _newName(prefix) {
      const ng = this._names[prefix] || this._nameGroup(prefix);
      return `${prefix}${ng.index++}`;
    }
    _nameGroup(prefix) {
      var _a, _b;
      if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
        throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
      }
      return this._names[prefix] = { prefix, index: 0 };
    }
  }
  exports.Scope = Scope;
  class ValueScopeName extends code_12.Name {
    constructor(prefix, nameStr) {
      super(nameStr);
      this.prefix = prefix;
    }
    setValue(value, { property, itemIndex }) {
      this.value = value;
      this.scopePath = code_12._`.${new code_12.Name(property)}[${itemIndex}]`;
    }
  }
  exports.ValueScopeName = ValueScopeName;
  const line = code_12._`\n`;
  class ValueScope extends Scope {
    constructor(opts2) {
      super(opts2);
      this._values = {};
      this._scope = opts2.scope;
      this.opts = __spreadProps(__spreadValues({}, opts2), { _n: opts2.lines ? line : code_12.nil });
    }
    get() {
      return this._scope;
    }
    name(prefix) {
      return new ValueScopeName(prefix, this._newName(prefix));
    }
    value(nameOrPrefix, value) {
      var _a;
      if (value.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const name = this.toName(nameOrPrefix);
      const { prefix } = name;
      const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
      let vs = this._values[prefix];
      if (vs) {
        const _name = vs.get(valueKey);
        if (_name)
          return _name;
      } else {
        vs = this._values[prefix] = new Map();
      }
      vs.set(valueKey, name);
      const s2 = this._scope[prefix] || (this._scope[prefix] = []);
      const itemIndex = s2.length;
      s2[itemIndex] = value.ref;
      name.setValue(value, { property: prefix, itemIndex });
      return name;
    }
    getValue(prefix, keyOrRef) {
      const vs = this._values[prefix];
      if (!vs)
        return;
      return vs.get(keyOrRef);
    }
    scopeRefs(scopeName, values = this._values) {
      return this._reduceValues(values, (name) => {
        if (name.scopePath === void 0)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return code_12._`${scopeName}${name.scopePath}`;
      });
    }
    scopeCode(values = this._values, usedValues, getCode) {
      return this._reduceValues(values, (name) => {
        if (name.value === void 0)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return name.value.code;
      }, usedValues, getCode);
    }
    _reduceValues(values, valueCode, usedValues = {}, getCode) {
      let code2 = code_12.nil;
      for (const prefix in values) {
        const vs = values[prefix];
        if (!vs)
          continue;
        const nameSet = usedValues[prefix] = usedValues[prefix] || new Map();
        vs.forEach((name) => {
          if (nameSet.has(name))
            return;
          nameSet.set(name, UsedValueState.Started);
          let c = valueCode(name);
          if (c) {
            const def2 = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
            code2 = code_12._`${code2}${def2} ${name} = ${c};${this.opts._n}`;
          } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
            code2 = code_12._`${code2}${c}${this.opts._n}`;
          } else {
            throw new ValueError(name);
          }
          nameSet.set(name, UsedValueState.Completed);
        });
      }
      return code2;
    }
  }
  exports.ValueScope = ValueScope;
})(scope);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
  const code_12 = code$1;
  const scope_1 = scope;
  var code_2 = code$1;
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return code_2._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return code_2.str;
  } });
  Object.defineProperty(exports, "strConcat", { enumerable: true, get: function() {
    return code_2.strConcat;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return code_2.nil;
  } });
  Object.defineProperty(exports, "getProperty", { enumerable: true, get: function() {
    return code_2.getProperty;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return code_2.stringify;
  } });
  Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function() {
    return code_2.regexpCode;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return code_2.Name;
  } });
  var scope_2 = scope;
  Object.defineProperty(exports, "Scope", { enumerable: true, get: function() {
    return scope_2.Scope;
  } });
  Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function() {
    return scope_2.ValueScope;
  } });
  Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function() {
    return scope_2.ValueScopeName;
  } });
  Object.defineProperty(exports, "varKinds", { enumerable: true, get: function() {
    return scope_2.varKinds;
  } });
  exports.operators = {
    GT: new code_12._Code(">"),
    GTE: new code_12._Code(">="),
    LT: new code_12._Code("<"),
    LTE: new code_12._Code("<="),
    EQ: new code_12._Code("==="),
    NEQ: new code_12._Code("!=="),
    NOT: new code_12._Code("!"),
    OR: new code_12._Code("||"),
    AND: new code_12._Code("&&"),
    ADD: new code_12._Code("+")
  };
  class Node2 {
    optimizeNodes() {
      return this;
    }
    optimizeNames(_names, _constants) {
      return this;
    }
  }
  class Def extends Node2 {
    constructor(varKind, name, rhs) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.rhs = rhs;
    }
    render({ es5, _n }) {
      const varKind = es5 ? scope_1.varKinds.var : this.varKind;
      const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${varKind} ${this.name}${rhs};` + _n;
    }
    optimizeNames(names2, constants2) {
      if (!names2[this.name.str])
        return;
      if (this.rhs)
        this.rhs = optimizeExpr(this.rhs, names2, constants2);
      return this;
    }
    get names() {
      return this.rhs instanceof code_12._CodeOrName ? this.rhs.names : {};
    }
  }
  class Assign extends Node2 {
    constructor(lhs, rhs, sideEffects) {
      super();
      this.lhs = lhs;
      this.rhs = rhs;
      this.sideEffects = sideEffects;
    }
    render({ _n }) {
      return `${this.lhs} = ${this.rhs};` + _n;
    }
    optimizeNames(names2, constants2) {
      if (this.lhs instanceof code_12.Name && !names2[this.lhs.str] && !this.sideEffects)
        return;
      this.rhs = optimizeExpr(this.rhs, names2, constants2);
      return this;
    }
    get names() {
      const names2 = this.lhs instanceof code_12.Name ? {} : __spreadValues({}, this.lhs.names);
      return addExprNames(names2, this.rhs);
    }
  }
  class AssignOp extends Assign {
    constructor(lhs, op, rhs, sideEffects) {
      super(lhs, rhs, sideEffects);
      this.op = op;
    }
    render({ _n }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
    }
  }
  class Label extends Node2 {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      return `${this.label}:` + _n;
    }
  }
  class Break extends Node2 {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      const label = this.label ? ` ${this.label}` : "";
      return `break${label};` + _n;
    }
  }
  class Throw extends Node2 {
    constructor(error2) {
      super();
      this.error = error2;
    }
    render({ _n }) {
      return `throw ${this.error};` + _n;
    }
    get names() {
      return this.error.names;
    }
  }
  class AnyCode extends Node2 {
    constructor(code2) {
      super();
      this.code = code2;
    }
    render({ _n }) {
      return `${this.code};` + _n;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(names2, constants2) {
      this.code = optimizeExpr(this.code, names2, constants2);
      return this;
    }
    get names() {
      return this.code instanceof code_12._CodeOrName ? this.code.names : {};
    }
  }
  class ParentNode extends Node2 {
    constructor(nodes = []) {
      super();
      this.nodes = nodes;
    }
    render(opts2) {
      return this.nodes.reduce((code2, n) => code2 + n.render(opts2), "");
    }
    optimizeNodes() {
      const { nodes } = this;
      let i2 = nodes.length;
      while (i2--) {
        const n = nodes[i2].optimizeNodes();
        if (Array.isArray(n))
          nodes.splice(i2, 1, ...n);
        else if (n)
          nodes[i2] = n;
        else
          nodes.splice(i2, 1);
      }
      return nodes.length > 0 ? this : void 0;
    }
    optimizeNames(names2, constants2) {
      const { nodes } = this;
      let i2 = nodes.length;
      while (i2--) {
        const n = nodes[i2];
        if (n.optimizeNames(names2, constants2))
          continue;
        subtractNames(names2, n.names);
        nodes.splice(i2, 1);
      }
      return nodes.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((names2, n) => addNames(names2, n.names), {});
    }
  }
  class BlockNode extends ParentNode {
    render(opts2) {
      return "{" + opts2._n + super.render(opts2) + "}" + opts2._n;
    }
  }
  class Root extends ParentNode {
  }
  class Else extends BlockNode {
  }
  Else.kind = "else";
  class If extends BlockNode {
    constructor(condition, nodes) {
      super(nodes);
      this.condition = condition;
    }
    render(opts2) {
      let code2 = `if(${this.condition})` + super.render(opts2);
      if (this.else)
        code2 += "else " + this.else.render(opts2);
      return code2;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const cond = this.condition;
      if (cond === true)
        return this.nodes;
      let e = this.else;
      if (e) {
        const ns = e.optimizeNodes();
        e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
      }
      if (e) {
        if (cond === false)
          return e instanceof If ? e : e.nodes;
        if (this.nodes.length)
          return this;
        return new If(not2(cond), e instanceof If ? [e] : e.nodes);
      }
      if (cond === false || !this.nodes.length)
        return void 0;
      return this;
    }
    optimizeNames(names2, constants2) {
      var _a;
      this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants2);
      if (!(super.optimizeNames(names2, constants2) || this.else))
        return;
      this.condition = optimizeExpr(this.condition, names2, constants2);
      return this;
    }
    get names() {
      const names2 = super.names;
      addExprNames(names2, this.condition);
      if (this.else)
        addNames(names2, this.else.names);
      return names2;
    }
  }
  If.kind = "if";
  class For extends BlockNode {
  }
  For.kind = "for";
  class ForLoop extends For {
    constructor(iteration) {
      super();
      this.iteration = iteration;
    }
    render(opts2) {
      return `for(${this.iteration})` + super.render(opts2);
    }
    optimizeNames(names2, constants2) {
      if (!super.optimizeNames(names2, constants2))
        return;
      this.iteration = optimizeExpr(this.iteration, names2, constants2);
      return this;
    }
    get names() {
      return addNames(super.names, this.iteration.names);
    }
  }
  class ForRange extends For {
    constructor(varKind, name, from, to) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.from = from;
      this.to = to;
    }
    render(opts2) {
      const varKind = opts2.es5 ? scope_1.varKinds.var : this.varKind;
      const { name, from, to } = this;
      return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts2);
    }
    get names() {
      const names2 = addExprNames(super.names, this.from);
      return addExprNames(names2, this.to);
    }
  }
  class ForIter extends For {
    constructor(loop, varKind, name, iterable) {
      super();
      this.loop = loop;
      this.varKind = varKind;
      this.name = name;
      this.iterable = iterable;
    }
    render(opts2) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts2);
    }
    optimizeNames(names2, constants2) {
      if (!super.optimizeNames(names2, constants2))
        return;
      this.iterable = optimizeExpr(this.iterable, names2, constants2);
      return this;
    }
    get names() {
      return addNames(super.names, this.iterable.names);
    }
  }
  class Func extends BlockNode {
    constructor(name, args, async) {
      super();
      this.name = name;
      this.args = args;
      this.async = async;
    }
    render(opts2) {
      const _async = this.async ? "async " : "";
      return `${_async}function ${this.name}(${this.args})` + super.render(opts2);
    }
  }
  Func.kind = "func";
  class Return extends ParentNode {
    render(opts2) {
      return "return " + super.render(opts2);
    }
  }
  Return.kind = "return";
  class Try extends BlockNode {
    render(opts2) {
      let code2 = "try" + super.render(opts2);
      if (this.catch)
        code2 += this.catch.render(opts2);
      if (this.finally)
        code2 += this.finally.render(opts2);
      return code2;
    }
    optimizeNodes() {
      var _a, _b;
      super.optimizeNodes();
      (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
      (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
      return this;
    }
    optimizeNames(names2, constants2) {
      var _a, _b;
      super.optimizeNames(names2, constants2);
      (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants2);
      (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names2, constants2);
      return this;
    }
    get names() {
      const names2 = super.names;
      if (this.catch)
        addNames(names2, this.catch.names);
      if (this.finally)
        addNames(names2, this.finally.names);
      return names2;
    }
  }
  class Catch extends BlockNode {
    constructor(error2) {
      super();
      this.error = error2;
    }
    render(opts2) {
      return `catch(${this.error})` + super.render(opts2);
    }
  }
  Catch.kind = "catch";
  class Finally extends BlockNode {
    render(opts2) {
      return "finally" + super.render(opts2);
    }
  }
  Finally.kind = "finally";
  class CodeGen {
    constructor(extScope, opts2 = {}) {
      this._values = {};
      this._blockStarts = [];
      this._constants = {};
      this.opts = __spreadProps(__spreadValues({}, opts2), { _n: opts2.lines ? "\n" : "" });
      this._extScope = extScope;
      this._scope = new scope_1.Scope({ parent: extScope });
      this._nodes = [new Root()];
    }
    toString() {
      return this._root.render(this.opts);
    }
    name(prefix) {
      return this._scope.name(prefix);
    }
    scopeName(prefix) {
      return this._extScope.name(prefix);
    }
    scopeValue(prefixOrName, value) {
      const name = this._extScope.value(prefixOrName, value);
      const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());
      vs.add(name);
      return name;
    }
    getScopeValue(prefix, keyOrRef) {
      return this._extScope.getValue(prefix, keyOrRef);
    }
    scopeRefs(scopeName) {
      return this._extScope.scopeRefs(scopeName, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(varKind, nameOrPrefix, rhs, constant) {
      const name = this._scope.toName(nameOrPrefix);
      if (rhs !== void 0 && constant)
        this._constants[name.str] = rhs;
      this._leafNode(new Def(varKind, name, rhs));
      return name;
    }
    const(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
    }
    let(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
    }
    var(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
    }
    assign(lhs, rhs, sideEffects) {
      return this._leafNode(new Assign(lhs, rhs, sideEffects));
    }
    add(lhs, rhs) {
      return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
    }
    code(c) {
      if (typeof c == "function")
        c();
      else if (c !== code_12.nil)
        this._leafNode(new AnyCode(c));
      return this;
    }
    object(...keyValues) {
      const code2 = ["{"];
      for (const [key, value] of keyValues) {
        if (code2.length > 1)
          code2.push(",");
        code2.push(key);
        if (key !== value || this.opts.es5) {
          code2.push(":");
          code_12.addCodeArg(code2, value);
        }
      }
      code2.push("}");
      return new code_12._Code(code2);
    }
    if(condition, thenBody, elseBody) {
      this._blockNode(new If(condition));
      if (thenBody && elseBody) {
        this.code(thenBody).else().code(elseBody).endIf();
      } else if (thenBody) {
        this.code(thenBody).endIf();
      } else if (elseBody) {
        throw new Error('CodeGen: "else" body without "then" body');
      }
      return this;
    }
    elseIf(condition) {
      return this._elseNode(new If(condition));
    }
    else() {
      return this._elseNode(new Else());
    }
    endIf() {
      return this._endBlockNode(If, Else);
    }
    _for(node, forBody) {
      this._blockNode(node);
      if (forBody)
        this.code(forBody).endFor();
      return this;
    }
    for(iteration, forBody) {
      return this._for(new ForLoop(iteration), forBody);
    }
    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
    }
    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
      const name = this._scope.toName(nameOrPrefix);
      if (this.opts.es5) {
        const arr = iterable instanceof code_12.Name ? iterable : this.var("_arr", iterable);
        return this.forRange("_i", 0, code_12._`${arr}.length`, (i2) => {
          this.var(name, code_12._`${arr}[${i2}]`);
          forBody(name);
        });
      }
      return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
    }
    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
      if (this.opts.ownProperties) {
        return this.forOf(nameOrPrefix, code_12._`Object.keys(${obj})`, forBody);
      }
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
    }
    endFor() {
      return this._endBlockNode(For);
    }
    label(label) {
      return this._leafNode(new Label(label));
    }
    break(label) {
      return this._leafNode(new Break(label));
    }
    return(value) {
      const node = new Return();
      this._blockNode(node);
      this.code(value);
      if (node.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(Return);
    }
    try(tryBody, catchCode, finallyCode) {
      if (!catchCode && !finallyCode)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const node = new Try();
      this._blockNode(node);
      this.code(tryBody);
      if (catchCode) {
        const error2 = this.name("e");
        this._currNode = node.catch = new Catch(error2);
        catchCode(error2);
      }
      if (finallyCode) {
        this._currNode = node.finally = new Finally();
        this.code(finallyCode);
      }
      return this._endBlockNode(Catch, Finally);
    }
    throw(error2) {
      return this._leafNode(new Throw(error2));
    }
    block(body, nodeCount) {
      this._blockStarts.push(this._nodes.length);
      if (body)
        this.code(body).endBlock(nodeCount);
      return this;
    }
    endBlock(nodeCount) {
      const len = this._blockStarts.pop();
      if (len === void 0)
        throw new Error("CodeGen: not in self-balancing block");
      const toClose = this._nodes.length - len;
      if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
        throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
      }
      this._nodes.length = len;
      return this;
    }
    func(name, args = code_12.nil, async, funcBody) {
      this._blockNode(new Func(name, args, async));
      if (funcBody)
        this.code(funcBody).endFunc();
      return this;
    }
    endFunc() {
      return this._endBlockNode(Func);
    }
    optimize(n = 1) {
      while (n-- > 0) {
        this._root.optimizeNodes();
        this._root.optimizeNames(this._root.names, this._constants);
      }
    }
    _leafNode(node) {
      this._currNode.nodes.push(node);
      return this;
    }
    _blockNode(node) {
      this._currNode.nodes.push(node);
      this._nodes.push(node);
    }
    _endBlockNode(N1, N2) {
      const n = this._currNode;
      if (n instanceof N1 || N2 && n instanceof N2) {
        this._nodes.pop();
        return this;
      }
      throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
    }
    _elseNode(node) {
      const n = this._currNode;
      if (!(n instanceof If)) {
        throw new Error('CodeGen: "else" without "if"');
      }
      this._currNode = n.else = node;
      return this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const ns = this._nodes;
      return ns[ns.length - 1];
    }
    set _currNode(node) {
      const ns = this._nodes;
      ns[ns.length - 1] = node;
    }
  }
  exports.CodeGen = CodeGen;
  function addNames(names2, from) {
    for (const n in from)
      names2[n] = (names2[n] || 0) + (from[n] || 0);
    return names2;
  }
  function addExprNames(names2, from) {
    return from instanceof code_12._CodeOrName ? addNames(names2, from.names) : names2;
  }
  function optimizeExpr(expr, names2, constants2) {
    if (expr instanceof code_12.Name)
      return replaceName(expr);
    if (!canOptimize(expr))
      return expr;
    return new code_12._Code(expr._items.reduce((items2, c) => {
      if (c instanceof code_12.Name)
        c = replaceName(c);
      if (c instanceof code_12._Code)
        items2.push(...c._items);
      else
        items2.push(c);
      return items2;
    }, []));
    function replaceName(n) {
      const c = constants2[n.str];
      if (c === void 0 || names2[n.str] !== 1)
        return n;
      delete names2[n.str];
      return c;
    }
    function canOptimize(e) {
      return e instanceof code_12._Code && e._items.some((c) => c instanceof code_12.Name && names2[c.str] === 1 && constants2[c.str] !== void 0);
    }
  }
  function subtractNames(names2, from) {
    for (const n in from)
      names2[n] = (names2[n] || 0) - (from[n] || 0);
  }
  function not2(x) {
    return typeof x == "boolean" || typeof x == "number" || x === null ? !x : code_12._`!${par(x)}`;
  }
  exports.not = not2;
  const andCode = mappend(exports.operators.AND);
  function and(...args) {
    return args.reduce(andCode);
  }
  exports.and = and;
  const orCode = mappend(exports.operators.OR);
  function or(...args) {
    return args.reduce(orCode);
  }
  exports.or = or;
  function mappend(op) {
    return (x, y2) => x === code_12.nil ? y2 : y2 === code_12.nil ? x : code_12._`${par(x)} ${op} ${par(y2)}`;
  }
  function par(x) {
    return x instanceof code_12.Name ? x : code_12._`(${x})`;
  }
})(codegen);
var util = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
  const codegen_12 = codegen;
  const code_12 = code$1;
  function toHash(arr) {
    const hash = {};
    for (const item of arr)
      hash[item] = true;
    return hash;
  }
  exports.toHash = toHash;
  function alwaysValidSchema(it, schema2) {
    if (typeof schema2 == "boolean")
      return schema2;
    if (Object.keys(schema2).length === 0)
      return true;
    checkUnknownRules(it, schema2);
    return !schemaHasRules(schema2, it.self.RULES.all);
  }
  exports.alwaysValidSchema = alwaysValidSchema;
  function checkUnknownRules(it, schema2 = it.schema) {
    const { opts: opts2, self: self2 } = it;
    if (!opts2.strictSchema)
      return;
    if (typeof schema2 === "boolean")
      return;
    const rules2 = self2.RULES.keywords;
    for (const key in schema2) {
      if (!rules2[key])
        checkStrictMode(it, `unknown keyword: "${key}"`);
    }
  }
  exports.checkUnknownRules = checkUnknownRules;
  function schemaHasRules(schema2, rules2) {
    if (typeof schema2 == "boolean")
      return !schema2;
    for (const key in schema2)
      if (rules2[key])
        return true;
    return false;
  }
  exports.schemaHasRules = schemaHasRules;
  function schemaHasRulesButRef(schema2, RULES) {
    if (typeof schema2 == "boolean")
      return !schema2;
    for (const key in schema2)
      if (key !== "$ref" && RULES.all[key])
        return true;
    return false;
  }
  exports.schemaHasRulesButRef = schemaHasRulesButRef;
  function schemaRefOrVal({ topSchemaRef, schemaPath }, schema2, keyword2, $data) {
    if (!$data) {
      if (typeof schema2 == "number" || typeof schema2 == "boolean")
        return schema2;
      if (typeof schema2 == "string")
        return codegen_12._`${schema2}`;
    }
    return codegen_12._`${topSchemaRef}${schemaPath}${codegen_12.getProperty(keyword2)}`;
  }
  exports.schemaRefOrVal = schemaRefOrVal;
  function unescapeFragment(str2) {
    return unescapeJsonPointer(decodeURIComponent(str2));
  }
  exports.unescapeFragment = unescapeFragment;
  function escapeFragment(str2) {
    return encodeURIComponent(escapeJsonPointer(str2));
  }
  exports.escapeFragment = escapeFragment;
  function escapeJsonPointer(str2) {
    if (typeof str2 == "number")
      return `${str2}`;
    return str2.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  exports.escapeJsonPointer = escapeJsonPointer;
  function unescapeJsonPointer(str2) {
    return str2.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  exports.unescapeJsonPointer = unescapeJsonPointer;
  function eachItem(xs, f) {
    if (Array.isArray(xs)) {
      for (const x of xs)
        f(x);
    } else {
      f(xs);
    }
  }
  exports.eachItem = eachItem;
  function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
    return (gen, from, to, toName) => {
      const res = to === void 0 ? from : to instanceof codegen_12.Name ? (from instanceof codegen_12.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_12.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
      return toName === codegen_12.Name && !(res instanceof codegen_12.Name) ? resultToName(gen, res) : res;
    };
  }
  exports.mergeEvaluated = {
    props: makeMergeEvaluated({
      mergeNames: (gen, from, to) => gen.if(codegen_12._`${to} !== true && ${from} !== undefined`, () => {
        gen.if(codegen_12._`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, codegen_12._`${to} || {}`).code(codegen_12._`Object.assign(${to}, ${from})`));
      }),
      mergeToName: (gen, from, to) => gen.if(codegen_12._`${to} !== true`, () => {
        if (from === true) {
          gen.assign(to, true);
        } else {
          gen.assign(to, codegen_12._`${to} || {}`);
          setEvaluated(gen, to, from);
        }
      }),
      mergeValues: (from, to) => from === true ? true : __spreadValues(__spreadValues({}, from), to),
      resultToName: evaluatedPropsToName
    }),
    items: makeMergeEvaluated({
      mergeNames: (gen, from, to) => gen.if(codegen_12._`${to} !== true && ${from} !== undefined`, () => gen.assign(to, codegen_12._`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
      mergeToName: (gen, from, to) => gen.if(codegen_12._`${to} !== true`, () => gen.assign(to, from === true ? true : codegen_12._`${to} > ${from} ? ${to} : ${from}`)),
      mergeValues: (from, to) => from === true ? true : Math.max(from, to),
      resultToName: (gen, items2) => gen.var("items", items2)
    })
  };
  function evaluatedPropsToName(gen, ps) {
    if (ps === true)
      return gen.var("props", true);
    const props = gen.var("props", codegen_12._`{}`);
    if (ps !== void 0)
      setEvaluated(gen, props, ps);
    return props;
  }
  exports.evaluatedPropsToName = evaluatedPropsToName;
  function setEvaluated(gen, props, ps) {
    Object.keys(ps).forEach((p) => gen.assign(codegen_12._`${props}${codegen_12.getProperty(p)}`, true));
  }
  exports.setEvaluated = setEvaluated;
  const snippets = {};
  function useFunc(gen, f) {
    return gen.scopeValue("func", {
      ref: f,
      code: snippets[f.code] || (snippets[f.code] = new code_12._Code(f.code))
    });
  }
  exports.useFunc = useFunc;
  var Type2;
  (function(Type3) {
    Type3[Type3["Num"] = 0] = "Num";
    Type3[Type3["Str"] = 1] = "Str";
  })(Type2 = exports.Type || (exports.Type = {}));
  function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
    if (dataProp instanceof codegen_12.Name) {
      const isNumber = dataPropType === Type2.Num;
      return jsPropertySyntax ? isNumber ? codegen_12._`"[" + ${dataProp} + "]"` : codegen_12._`"['" + ${dataProp} + "']"` : isNumber ? codegen_12._`"/" + ${dataProp}` : codegen_12._`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return jsPropertySyntax ? codegen_12.getProperty(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
  }
  exports.getErrorPath = getErrorPath;
  function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
    if (!mode)
      return;
    msg = `strict mode: ${msg}`;
    if (mode === true)
      throw new Error(msg);
    it.self.logger.warn(msg);
  }
  exports.checkStrictMode = checkStrictMode;
})(util);
var names$1 = {};
Object.defineProperty(names$1, "__esModule", { value: true });
const codegen_1$t = codegen;
const names = {
  data: new codegen_1$t.Name("data"),
  valCxt: new codegen_1$t.Name("valCxt"),
  instancePath: new codegen_1$t.Name("instancePath"),
  parentData: new codegen_1$t.Name("parentData"),
  parentDataProperty: new codegen_1$t.Name("parentDataProperty"),
  rootData: new codegen_1$t.Name("rootData"),
  dynamicAnchors: new codegen_1$t.Name("dynamicAnchors"),
  vErrors: new codegen_1$t.Name("vErrors"),
  errors: new codegen_1$t.Name("errors"),
  this: new codegen_1$t.Name("this"),
  self: new codegen_1$t.Name("self"),
  scope: new codegen_1$t.Name("scope"),
  json: new codegen_1$t.Name("json"),
  jsonPos: new codegen_1$t.Name("jsonPos"),
  jsonLen: new codegen_1$t.Name("jsonLen"),
  jsonPart: new codegen_1$t.Name("jsonPart")
};
names$1.default = names;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
  const codegen_12 = codegen;
  const util_12 = util;
  const names_12 = names$1;
  exports.keywordError = {
    message: ({ keyword: keyword2 }) => codegen_12.str`must pass "${keyword2}" keyword validation`
  };
  exports.keyword$DataError = {
    message: ({ keyword: keyword2, schemaType }) => schemaType ? codegen_12.str`"${keyword2}" keyword must be ${schemaType} ($data)` : codegen_12.str`"${keyword2}" keyword is invalid ($data)`
  };
  function reportError(cxt, error2 = exports.keywordError, errorPaths, overrideAllErrors) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error2, errorPaths);
    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
      addError(gen, errObj);
    } else {
      returnErrors(it, codegen_12._`[${errObj}]`);
    }
  }
  exports.reportError = reportError;
  function reportExtraError(cxt, error2 = exports.keywordError, errorPaths) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error2, errorPaths);
    addError(gen, errObj);
    if (!(compositeRule || allErrors)) {
      returnErrors(it, names_12.default.vErrors);
    }
  }
  exports.reportExtraError = reportExtraError;
  function resetErrorsCount(gen, errsCount) {
    gen.assign(names_12.default.errors, errsCount);
    gen.if(codegen_12._`${names_12.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign(codegen_12._`${names_12.default.vErrors}.length`, errsCount), () => gen.assign(names_12.default.vErrors, null)));
  }
  exports.resetErrorsCount = resetErrorsCount;
  function extendErrors({ gen, keyword: keyword2, schemaValue, data, errsCount, it }) {
    if (errsCount === void 0)
      throw new Error("ajv implementation error");
    const err = gen.name("err");
    gen.forRange("i", errsCount, names_12.default.errors, (i2) => {
      gen.const(err, codegen_12._`${names_12.default.vErrors}[${i2}]`);
      gen.if(codegen_12._`${err}.instancePath === undefined`, () => gen.assign(codegen_12._`${err}.instancePath`, codegen_12.strConcat(names_12.default.instancePath, it.errorPath)));
      gen.assign(codegen_12._`${err}.schemaPath`, codegen_12.str`${it.errSchemaPath}/${keyword2}`);
      if (it.opts.verbose) {
        gen.assign(codegen_12._`${err}.schema`, schemaValue);
        gen.assign(codegen_12._`${err}.data`, data);
      }
    });
  }
  exports.extendErrors = extendErrors;
  function addError(gen, errObj) {
    const err = gen.const("err", errObj);
    gen.if(codegen_12._`${names_12.default.vErrors} === null`, () => gen.assign(names_12.default.vErrors, codegen_12._`[${err}]`), codegen_12._`${names_12.default.vErrors}.push(${err})`);
    gen.code(codegen_12._`${names_12.default.errors}++`);
  }
  function returnErrors(it, errs) {
    const { gen, validateName, schemaEnv } = it;
    if (schemaEnv.$async) {
      gen.throw(codegen_12._`new ${it.ValidationError}(${errs})`);
    } else {
      gen.assign(codegen_12._`${validateName}.errors`, errs);
      gen.return(false);
    }
  }
  const E = {
    keyword: new codegen_12.Name("keyword"),
    schemaPath: new codegen_12.Name("schemaPath"),
    params: new codegen_12.Name("params"),
    propertyName: new codegen_12.Name("propertyName"),
    message: new codegen_12.Name("message"),
    schema: new codegen_12.Name("schema"),
    parentSchema: new codegen_12.Name("parentSchema")
  };
  function errorObjectCode(cxt, error2, errorPaths) {
    const { createErrors } = cxt.it;
    if (createErrors === false)
      return codegen_12._`{}`;
    return errorObject(cxt, error2, errorPaths);
  }
  function errorObject(cxt, error2, errorPaths = {}) {
    const { gen, it } = cxt;
    const keyValues = [
      errorInstancePath(it, errorPaths),
      errorSchemaPath(cxt, errorPaths)
    ];
    extraErrorProps(cxt, error2, keyValues);
    return gen.object(...keyValues);
  }
  function errorInstancePath({ errorPath }, { instancePath }) {
    const instPath = instancePath ? codegen_12.str`${errorPath}${util_12.getErrorPath(instancePath, util_12.Type.Str)}` : errorPath;
    return [names_12.default.instancePath, codegen_12.strConcat(names_12.default.instancePath, instPath)];
  }
  function errorSchemaPath({ keyword: keyword2, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
    let schPath = parentSchema ? errSchemaPath : codegen_12.str`${errSchemaPath}/${keyword2}`;
    if (schemaPath) {
      schPath = codegen_12.str`${schPath}${util_12.getErrorPath(schemaPath, util_12.Type.Str)}`;
    }
    return [E.schemaPath, schPath];
  }
  function extraErrorProps(cxt, { params, message }, keyValues) {
    const { keyword: keyword2, data, schemaValue, it } = cxt;
    const { opts: opts2, propertyName, topSchemaRef, schemaPath } = it;
    keyValues.push([E.keyword, keyword2], [E.params, typeof params == "function" ? params(cxt) : params || codegen_12._`{}`]);
    if (opts2.messages) {
      keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
    }
    if (opts2.verbose) {
      keyValues.push([E.schema, schemaValue], [E.parentSchema, codegen_12._`${topSchemaRef}${schemaPath}`], [names_12.default.data, data]);
    }
    if (propertyName)
      keyValues.push([E.propertyName, propertyName]);
  }
})(errors);
Object.defineProperty(boolSchema, "__esModule", { value: true });
boolSchema.boolOrEmptySchema = boolSchema.topBoolOrEmptySchema = void 0;
const errors_1$2 = errors;
const codegen_1$s = codegen;
const names_1$6 = names$1;
const boolError = {
  message: "boolean schema is false"
};
function topBoolOrEmptySchema(it) {
  const { gen, schema: schema2, validateName } = it;
  if (schema2 === false) {
    falseSchemaError(it, false);
  } else if (typeof schema2 == "object" && schema2.$async === true) {
    gen.return(names_1$6.default.data);
  } else {
    gen.assign(codegen_1$s._`${validateName}.errors`, null);
    gen.return(true);
  }
}
boolSchema.topBoolOrEmptySchema = topBoolOrEmptySchema;
function boolOrEmptySchema(it, valid2) {
  const { gen, schema: schema2 } = it;
  if (schema2 === false) {
    gen.var(valid2, false);
    falseSchemaError(it);
  } else {
    gen.var(valid2, true);
  }
}
boolSchema.boolOrEmptySchema = boolOrEmptySchema;
function falseSchemaError(it, overrideAllErrors) {
  const { gen, data } = it;
  const cxt = {
    gen,
    keyword: "false schema",
    data,
    schema: false,
    schemaCode: false,
    schemaValue: false,
    params: {},
    it
  };
  errors_1$2.reportError(cxt, boolError, void 0, overrideAllErrors);
}
var dataType = {};
var rules = {};
Object.defineProperty(rules, "__esModule", { value: true });
rules.getRules = rules.isJSONType = void 0;
const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
const jsonTypes = new Set(_jsonTypes);
function isJSONType(x) {
  return typeof x == "string" && jsonTypes.has(x);
}
rules.isJSONType = isJSONType;
function getRules() {
  const groups = {
    number: { type: "number", rules: [] },
    string: { type: "string", rules: [] },
    array: { type: "array", rules: [] },
    object: { type: "object", rules: [] }
  };
  return {
    types: __spreadProps(__spreadValues({}, groups), { integer: true, boolean: true, null: true }),
    rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
    post: { rules: [] },
    all: {},
    keywords: {}
  };
}
rules.getRules = getRules;
var applicability = {};
Object.defineProperty(applicability, "__esModule", { value: true });
applicability.shouldUseRule = applicability.shouldUseGroup = applicability.schemaHasRulesForType = void 0;
function schemaHasRulesForType({ schema: schema2, self: self2 }, type2) {
  const group = self2.RULES.types[type2];
  return group && group !== true && shouldUseGroup(schema2, group);
}
applicability.schemaHasRulesForType = schemaHasRulesForType;
function shouldUseGroup(schema2, group) {
  return group.rules.some((rule) => shouldUseRule(schema2, rule));
}
applicability.shouldUseGroup = shouldUseGroup;
function shouldUseRule(schema2, rule) {
  var _a;
  return schema2[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema2[kwd] !== void 0));
}
applicability.shouldUseRule = shouldUseRule;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
  const rules_1 = rules;
  const applicability_12 = applicability;
  const errors_12 = errors;
  const codegen_12 = codegen;
  const util_12 = util;
  var DataType;
  (function(DataType2) {
    DataType2[DataType2["Correct"] = 0] = "Correct";
    DataType2[DataType2["Wrong"] = 1] = "Wrong";
  })(DataType = exports.DataType || (exports.DataType = {}));
  function getSchemaTypes(schema2) {
    const types2 = getJSONTypes(schema2.type);
    const hasNull = types2.includes("null");
    if (hasNull) {
      if (schema2.nullable === false)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!types2.length && schema2.nullable !== void 0) {
        throw new Error('"nullable" cannot be used without "type"');
      }
      if (schema2.nullable === true)
        types2.push("null");
    }
    return types2;
  }
  exports.getSchemaTypes = getSchemaTypes;
  function getJSONTypes(ts) {
    const types2 = Array.isArray(ts) ? ts : ts ? [ts] : [];
    if (types2.every(rules_1.isJSONType))
      return types2;
    throw new Error("type must be JSONType or JSONType[]: " + types2.join(","));
  }
  exports.getJSONTypes = getJSONTypes;
  function coerceAndCheckDataType(it, types2) {
    const { gen, data, opts: opts2 } = it;
    const coerceTo = coerceToTypes(types2, opts2.coerceTypes);
    const checkTypes = types2.length > 0 && !(coerceTo.length === 0 && types2.length === 1 && applicability_12.schemaHasRulesForType(it, types2[0]));
    if (checkTypes) {
      const wrongType = checkDataTypes(types2, data, opts2.strictNumbers, DataType.Wrong);
      gen.if(wrongType, () => {
        if (coerceTo.length)
          coerceData(it, types2, coerceTo);
        else
          reportTypeError(it);
      });
    }
    return checkTypes;
  }
  exports.coerceAndCheckDataType = coerceAndCheckDataType;
  const COERCIBLE = new Set(["string", "number", "integer", "boolean", "null"]);
  function coerceToTypes(types2, coerceTypes) {
    return coerceTypes ? types2.filter((t2) => COERCIBLE.has(t2) || coerceTypes === "array" && t2 === "array") : [];
  }
  function coerceData(it, types2, coerceTo) {
    const { gen, data, opts: opts2 } = it;
    const dataType2 = gen.let("dataType", codegen_12._`typeof ${data}`);
    const coerced = gen.let("coerced", codegen_12._`undefined`);
    if (opts2.coerceTypes === "array") {
      gen.if(codegen_12._`${dataType2} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, codegen_12._`${data}[0]`).assign(dataType2, codegen_12._`typeof ${data}`).if(checkDataTypes(types2, data, opts2.strictNumbers), () => gen.assign(coerced, data)));
    }
    gen.if(codegen_12._`${coerced} !== undefined`);
    for (const t2 of coerceTo) {
      if (COERCIBLE.has(t2) || t2 === "array" && opts2.coerceTypes === "array") {
        coerceSpecificType(t2);
      }
    }
    gen.else();
    reportTypeError(it);
    gen.endIf();
    gen.if(codegen_12._`${coerced} !== undefined`, () => {
      gen.assign(data, coerced);
      assignParentData(it, coerced);
    });
    function coerceSpecificType(t2) {
      switch (t2) {
        case "string":
          gen.elseIf(codegen_12._`${dataType2} == "number" || ${dataType2} == "boolean"`).assign(coerced, codegen_12._`"" + ${data}`).elseIf(codegen_12._`${data} === null`).assign(coerced, codegen_12._`""`);
          return;
        case "number":
          gen.elseIf(codegen_12._`${dataType2} == "boolean" || ${data} === null
              || (${dataType2} == "string" && ${data} && ${data} == +${data})`).assign(coerced, codegen_12._`+${data}`);
          return;
        case "integer":
          gen.elseIf(codegen_12._`${dataType2} === "boolean" || ${data} === null
              || (${dataType2} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, codegen_12._`+${data}`);
          return;
        case "boolean":
          gen.elseIf(codegen_12._`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf(codegen_12._`${data} === "true" || ${data} === 1`).assign(coerced, true);
          return;
        case "null":
          gen.elseIf(codegen_12._`${data} === "" || ${data} === 0 || ${data} === false`);
          gen.assign(coerced, null);
          return;
        case "array":
          gen.elseIf(codegen_12._`${dataType2} === "string" || ${dataType2} === "number"
              || ${dataType2} === "boolean" || ${data} === null`).assign(coerced, codegen_12._`[${data}]`);
      }
    }
  }
  function assignParentData({ gen, parentData, parentDataProperty }, expr) {
    gen.if(codegen_12._`${parentData} !== undefined`, () => gen.assign(codegen_12._`${parentData}[${parentDataProperty}]`, expr));
  }
  function checkDataType(dataType2, data, strictNums, correct = DataType.Correct) {
    const EQ = correct === DataType.Correct ? codegen_12.operators.EQ : codegen_12.operators.NEQ;
    let cond;
    switch (dataType2) {
      case "null":
        return codegen_12._`${data} ${EQ} null`;
      case "array":
        cond = codegen_12._`Array.isArray(${data})`;
        break;
      case "object":
        cond = codegen_12._`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
        break;
      case "integer":
        cond = numCond(codegen_12._`!(${data} % 1) && !isNaN(${data})`);
        break;
      case "number":
        cond = numCond();
        break;
      default:
        return codegen_12._`typeof ${data} ${EQ} ${dataType2}`;
    }
    return correct === DataType.Correct ? cond : codegen_12.not(cond);
    function numCond(_cond = codegen_12.nil) {
      return codegen_12.and(codegen_12._`typeof ${data} == "number"`, _cond, strictNums ? codegen_12._`isFinite(${data})` : codegen_12.nil);
    }
  }
  exports.checkDataType = checkDataType;
  function checkDataTypes(dataTypes, data, strictNums, correct) {
    if (dataTypes.length === 1) {
      return checkDataType(dataTypes[0], data, strictNums, correct);
    }
    let cond;
    const types2 = util_12.toHash(dataTypes);
    if (types2.array && types2.object) {
      const notObj = codegen_12._`typeof ${data} != "object"`;
      cond = types2.null ? notObj : codegen_12._`!${data} || ${notObj}`;
      delete types2.null;
      delete types2.array;
      delete types2.object;
    } else {
      cond = codegen_12.nil;
    }
    if (types2.number)
      delete types2.integer;
    for (const t2 in types2)
      cond = codegen_12.and(cond, checkDataType(t2, data, strictNums, correct));
    return cond;
  }
  exports.checkDataTypes = checkDataTypes;
  const typeError = {
    message: ({ schema: schema2 }) => `must be ${schema2}`,
    params: ({ schema: schema2, schemaValue }) => typeof schema2 == "string" ? codegen_12._`{type: ${schema2}}` : codegen_12._`{type: ${schemaValue}}`
  };
  function reportTypeError(it) {
    const cxt = getTypeErrorContext(it);
    errors_12.reportError(cxt, typeError);
  }
  exports.reportTypeError = reportTypeError;
  function getTypeErrorContext(it) {
    const { gen, data, schema: schema2 } = it;
    const schemaCode = util_12.schemaRefOrVal(it, schema2, "type");
    return {
      gen,
      keyword: "type",
      data,
      schema: schema2.type,
      schemaCode,
      schemaValue: schemaCode,
      parentSchema: schema2,
      params: {},
      it
    };
  }
})(dataType);
var defaults = {};
Object.defineProperty(defaults, "__esModule", { value: true });
defaults.assignDefaults = void 0;
const codegen_1$r = codegen;
const util_1$o = util;
function assignDefaults(it, ty) {
  const { properties: properties2, items: items2 } = it.schema;
  if (ty === "object" && properties2) {
    for (const key in properties2) {
      assignDefault(it, key, properties2[key].default);
    }
  } else if (ty === "array" && Array.isArray(items2)) {
    items2.forEach((sch, i2) => assignDefault(it, i2, sch.default));
  }
}
defaults.assignDefaults = assignDefaults;
function assignDefault(it, prop, defaultValue) {
  const { gen, compositeRule, data, opts: opts2 } = it;
  if (defaultValue === void 0)
    return;
  const childData = codegen_1$r._`${data}${codegen_1$r.getProperty(prop)}`;
  if (compositeRule) {
    util_1$o.checkStrictMode(it, `default is ignored for: ${childData}`);
    return;
  }
  let condition = codegen_1$r._`${childData} === undefined`;
  if (opts2.useDefaults === "empty") {
    condition = codegen_1$r._`${condition} || ${childData} === null || ${childData} === ""`;
  }
  gen.if(condition, codegen_1$r._`${childData} = ${codegen_1$r.stringify(defaultValue)}`);
}
var keyword = {};
var code = {};
Object.defineProperty(code, "__esModule", { value: true });
code.validateUnion = code.validateArray = code.usePattern = code.callValidateCode = code.schemaProperties = code.allSchemaProperties = code.noPropertyInData = code.propertyInData = code.isOwnProperty = code.hasPropFunc = code.reportMissingProp = code.checkMissingProp = code.checkReportMissingProp = void 0;
const codegen_1$q = codegen;
const util_1$n = util;
const names_1$5 = names$1;
function checkReportMissingProp(cxt, prop) {
  const { gen, data, it } = cxt;
  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
    cxt.setParams({ missingProperty: codegen_1$q._`${prop}` }, true);
    cxt.error();
  });
}
code.checkReportMissingProp = checkReportMissingProp;
function checkMissingProp({ gen, data, it: { opts: opts2 } }, properties2, missing) {
  return codegen_1$q.or(...properties2.map((prop) => codegen_1$q.and(noPropertyInData(gen, data, prop, opts2.ownProperties), codegen_1$q._`${missing} = ${prop}`)));
}
code.checkMissingProp = checkMissingProp;
function reportMissingProp(cxt, missing) {
  cxt.setParams({ missingProperty: missing }, true);
  cxt.error();
}
code.reportMissingProp = reportMissingProp;
function hasPropFunc(gen) {
  return gen.scopeValue("func", {
    ref: Object.prototype.hasOwnProperty,
    code: codegen_1$q._`Object.prototype.hasOwnProperty`
  });
}
code.hasPropFunc = hasPropFunc;
function isOwnProperty(gen, data, property) {
  return codegen_1$q._`${hasPropFunc(gen)}.call(${data}, ${property})`;
}
code.isOwnProperty = isOwnProperty;
function propertyInData(gen, data, property, ownProperties) {
  const cond = codegen_1$q._`${data}${codegen_1$q.getProperty(property)} !== undefined`;
  return ownProperties ? codegen_1$q._`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
}
code.propertyInData = propertyInData;
function noPropertyInData(gen, data, property, ownProperties) {
  const cond = codegen_1$q._`${data}${codegen_1$q.getProperty(property)} === undefined`;
  return ownProperties ? codegen_1$q.or(cond, codegen_1$q.not(isOwnProperty(gen, data, property))) : cond;
}
code.noPropertyInData = noPropertyInData;
function allSchemaProperties(schemaMap) {
  return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
}
code.allSchemaProperties = allSchemaProperties;
function schemaProperties(it, schemaMap) {
  return allSchemaProperties(schemaMap).filter((p) => !util_1$n.alwaysValidSchema(it, schemaMap[p]));
}
code.schemaProperties = schemaProperties;
function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
  const dataAndSchema = passSchema ? codegen_1$q._`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
  const valCxt = [
    [names_1$5.default.instancePath, codegen_1$q.strConcat(names_1$5.default.instancePath, errorPath)],
    [names_1$5.default.parentData, it.parentData],
    [names_1$5.default.parentDataProperty, it.parentDataProperty],
    [names_1$5.default.rootData, names_1$5.default.rootData]
  ];
  if (it.opts.dynamicRef)
    valCxt.push([names_1$5.default.dynamicAnchors, names_1$5.default.dynamicAnchors]);
  const args = codegen_1$q._`${dataAndSchema}, ${gen.object(...valCxt)}`;
  return context !== codegen_1$q.nil ? codegen_1$q._`${func}.call(${context}, ${args})` : codegen_1$q._`${func}(${args})`;
}
code.callValidateCode = callValidateCode;
function usePattern({ gen, it: { opts: opts2 } }, pattern2) {
  const u2 = opts2.unicodeRegExp ? "u" : "";
  return gen.scopeValue("pattern", {
    key: pattern2,
    ref: new RegExp(pattern2, u2),
    code: codegen_1$q._`new RegExp(${pattern2}, ${u2})`
  });
}
code.usePattern = usePattern;
function validateArray(cxt) {
  const { gen, data, keyword: keyword2, it } = cxt;
  const valid2 = gen.name("valid");
  if (it.allErrors) {
    const validArr = gen.let("valid", true);
    validateItems(() => gen.assign(validArr, false));
    return validArr;
  }
  gen.var(valid2, true);
  validateItems(() => gen.break());
  return valid2;
  function validateItems(notValid) {
    const len = gen.const("len", codegen_1$q._`${data}.length`);
    gen.forRange("i", 0, len, (i2) => {
      cxt.subschema({
        keyword: keyword2,
        dataProp: i2,
        dataPropType: util_1$n.Type.Num
      }, valid2);
      gen.if(codegen_1$q.not(valid2), notValid);
    });
  }
}
code.validateArray = validateArray;
function validateUnion(cxt) {
  const { gen, schema: schema2, keyword: keyword2, it } = cxt;
  if (!Array.isArray(schema2))
    throw new Error("ajv implementation error");
  const alwaysValid = schema2.some((sch) => util_1$n.alwaysValidSchema(it, sch));
  if (alwaysValid && !it.opts.unevaluated)
    return;
  const valid2 = gen.let("valid", false);
  const schValid = gen.name("_valid");
  gen.block(() => schema2.forEach((_sch, i2) => {
    const schCxt = cxt.subschema({
      keyword: keyword2,
      schemaProp: i2,
      compositeRule: true
    }, schValid);
    gen.assign(valid2, codegen_1$q._`${valid2} || ${schValid}`);
    const merged = cxt.mergeValidEvaluated(schCxt, schValid);
    if (!merged)
      gen.if(codegen_1$q.not(valid2));
  }));
  cxt.result(valid2, () => cxt.reset(), () => cxt.error(true));
}
code.validateUnion = validateUnion;
Object.defineProperty(keyword, "__esModule", { value: true });
keyword.validateKeywordUsage = keyword.validSchemaType = keyword.funcKeywordCode = keyword.macroKeywordCode = void 0;
const codegen_1$p = codegen;
const names_1$4 = names$1;
const code_1$9 = code;
const errors_1$1 = errors;
function macroKeywordCode(cxt, def2) {
  const { gen, keyword: keyword2, schema: schema2, parentSchema, it } = cxt;
  const macroSchema = def2.macro.call(it.self, schema2, parentSchema, it);
  const schemaRef = useKeyword(gen, keyword2, macroSchema);
  if (it.opts.validateSchema !== false)
    it.self.validateSchema(macroSchema, true);
  const valid2 = gen.name("valid");
  cxt.subschema({
    schema: macroSchema,
    schemaPath: codegen_1$p.nil,
    errSchemaPath: `${it.errSchemaPath}/${keyword2}`,
    topSchemaRef: schemaRef,
    compositeRule: true
  }, valid2);
  cxt.pass(valid2, () => cxt.error(true));
}
keyword.macroKeywordCode = macroKeywordCode;
function funcKeywordCode(cxt, def2) {
  var _a;
  const { gen, keyword: keyword2, schema: schema2, parentSchema, $data, it } = cxt;
  checkAsyncKeyword(it, def2);
  const validate2 = !$data && def2.compile ? def2.compile.call(it.self, schema2, parentSchema, it) : def2.validate;
  const validateRef = useKeyword(gen, keyword2, validate2);
  const valid2 = gen.let("valid");
  cxt.block$data(valid2, validateKeyword);
  cxt.ok((_a = def2.valid) !== null && _a !== void 0 ? _a : valid2);
  function validateKeyword() {
    if (def2.errors === false) {
      assignValid();
      if (def2.modifying)
        modifyData(cxt);
      reportErrs(() => cxt.error());
    } else {
      const ruleErrs = def2.async ? validateAsync() : validateSync();
      if (def2.modifying)
        modifyData(cxt);
      reportErrs(() => addErrs(cxt, ruleErrs));
    }
  }
  function validateAsync() {
    const ruleErrs = gen.let("ruleErrs", null);
    gen.try(() => assignValid(codegen_1$p._`await `), (e) => gen.assign(valid2, false).if(codegen_1$p._`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, codegen_1$p._`${e}.errors`), () => gen.throw(e)));
    return ruleErrs;
  }
  function validateSync() {
    const validateErrs = codegen_1$p._`${validateRef}.errors`;
    gen.assign(validateErrs, null);
    assignValid(codegen_1$p.nil);
    return validateErrs;
  }
  function assignValid(_await = def2.async ? codegen_1$p._`await ` : codegen_1$p.nil) {
    const passCxt = it.opts.passContext ? names_1$4.default.this : names_1$4.default.self;
    const passSchema = !("compile" in def2 && !$data || def2.schema === false);
    gen.assign(valid2, codegen_1$p._`${_await}${code_1$9.callValidateCode(cxt, validateRef, passCxt, passSchema)}`, def2.modifying);
  }
  function reportErrs(errors2) {
    var _a2;
    gen.if(codegen_1$p.not((_a2 = def2.valid) !== null && _a2 !== void 0 ? _a2 : valid2), errors2);
  }
}
keyword.funcKeywordCode = funcKeywordCode;
function modifyData(cxt) {
  const { gen, data, it } = cxt;
  gen.if(it.parentData, () => gen.assign(data, codegen_1$p._`${it.parentData}[${it.parentDataProperty}]`));
}
function addErrs(cxt, errs) {
  const { gen } = cxt;
  gen.if(codegen_1$p._`Array.isArray(${errs})`, () => {
    gen.assign(names_1$4.default.vErrors, codegen_1$p._`${names_1$4.default.vErrors} === null ? ${errs} : ${names_1$4.default.vErrors}.concat(${errs})`).assign(names_1$4.default.errors, codegen_1$p._`${names_1$4.default.vErrors}.length`);
    errors_1$1.extendErrors(cxt);
  }, () => cxt.error());
}
function checkAsyncKeyword({ schemaEnv }, def2) {
  if (def2.async && !schemaEnv.$async)
    throw new Error("async keyword in sync schema");
}
function useKeyword(gen, keyword2, result) {
  if (result === void 0)
    throw new Error(`keyword "${keyword2}" failed to compile`);
  return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: codegen_1$p.stringify(result) });
}
function validSchemaType(schema2, schemaType, allowUndefined = false) {
  return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema2) : st === "object" ? schema2 && typeof schema2 == "object" && !Array.isArray(schema2) : typeof schema2 == st || allowUndefined && typeof schema2 == "undefined");
}
keyword.validSchemaType = validSchemaType;
function validateKeywordUsage({ schema: schema2, opts: opts2, self: self2, errSchemaPath }, def2, keyword2) {
  if (Array.isArray(def2.keyword) ? !def2.keyword.includes(keyword2) : def2.keyword !== keyword2) {
    throw new Error("ajv implementation error");
  }
  const deps = def2.dependencies;
  if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema2, kwd))) {
    throw new Error(`parent schema must have dependencies of ${keyword2}: ${deps.join(",")}`);
  }
  if (def2.validateSchema) {
    const valid2 = def2.validateSchema(schema2[keyword2]);
    if (!valid2) {
      const msg = `keyword "${keyword2}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def2.validateSchema.errors);
      if (opts2.validateSchema === "log")
        self2.logger.error(msg);
      else
        throw new Error(msg);
    }
  }
}
keyword.validateKeywordUsage = validateKeywordUsage;
var subschema = {};
Object.defineProperty(subschema, "__esModule", { value: true });
subschema.extendSubschemaMode = subschema.extendSubschemaData = subschema.getSubschema = void 0;
const codegen_1$o = codegen;
const util_1$m = util;
function getSubschema(it, { keyword: keyword2, schemaProp, schema: schema2, schemaPath, errSchemaPath, topSchemaRef }) {
  if (keyword2 !== void 0 && schema2 !== void 0) {
    throw new Error('both "keyword" and "schema" passed, only one allowed');
  }
  if (keyword2 !== void 0) {
    const sch = it.schema[keyword2];
    return schemaProp === void 0 ? {
      schema: sch,
      schemaPath: codegen_1$o._`${it.schemaPath}${codegen_1$o.getProperty(keyword2)}`,
      errSchemaPath: `${it.errSchemaPath}/${keyword2}`
    } : {
      schema: sch[schemaProp],
      schemaPath: codegen_1$o._`${it.schemaPath}${codegen_1$o.getProperty(keyword2)}${codegen_1$o.getProperty(schemaProp)}`,
      errSchemaPath: `${it.errSchemaPath}/${keyword2}/${util_1$m.escapeFragment(schemaProp)}`
    };
  }
  if (schema2 !== void 0) {
    if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
      throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
    }
    return {
      schema: schema2,
      schemaPath,
      topSchemaRef,
      errSchemaPath
    };
  }
  throw new Error('either "keyword" or "schema" must be passed');
}
subschema.getSubschema = getSubschema;
function extendSubschemaData(subschema2, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
  if (data !== void 0 && dataProp !== void 0) {
    throw new Error('both "data" and "dataProp" passed, only one allowed');
  }
  const { gen } = it;
  if (dataProp !== void 0) {
    const { errorPath, dataPathArr, opts: opts2 } = it;
    const nextData = gen.let("data", codegen_1$o._`${it.data}${codegen_1$o.getProperty(dataProp)}`, true);
    dataContextProps(nextData);
    subschema2.errorPath = codegen_1$o.str`${errorPath}${util_1$m.getErrorPath(dataProp, dpType, opts2.jsPropertySyntax)}`;
    subschema2.parentDataProperty = codegen_1$o._`${dataProp}`;
    subschema2.dataPathArr = [...dataPathArr, subschema2.parentDataProperty];
  }
  if (data !== void 0) {
    const nextData = data instanceof codegen_1$o.Name ? data : gen.let("data", data, true);
    dataContextProps(nextData);
    if (propertyName !== void 0)
      subschema2.propertyName = propertyName;
  }
  if (dataTypes)
    subschema2.dataTypes = dataTypes;
  function dataContextProps(_nextData) {
    subschema2.data = _nextData;
    subschema2.dataLevel = it.dataLevel + 1;
    subschema2.dataTypes = [];
    it.definedProperties = new Set();
    subschema2.parentData = it.data;
    subschema2.dataNames = [...it.dataNames, _nextData];
  }
}
subschema.extendSubschemaData = extendSubschemaData;
function extendSubschemaMode(subschema2, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
  if (compositeRule !== void 0)
    subschema2.compositeRule = compositeRule;
  if (createErrors !== void 0)
    subschema2.createErrors = createErrors;
  if (allErrors !== void 0)
    subschema2.allErrors = allErrors;
  subschema2.jtdDiscriminator = jtdDiscriminator;
  subschema2.jtdMetadata = jtdMetadata;
}
subschema.extendSubschemaMode = extendSubschemaMode;
var resolve$1 = {};
var fastDeepEqual = function equal2(a, b) {
  if (a === b)
    return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    if (a.constructor !== b.constructor)
      return false;
    var length, i2, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length)
        return false;
      for (i2 = length; i2-- !== 0; )
        if (!equal2(a[i2], b[i2]))
          return false;
      return true;
    }
    if (a.constructor === RegExp)
      return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf)
      return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString)
      return a.toString() === b.toString();
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length)
      return false;
    for (i2 = length; i2-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b, keys[i2]))
        return false;
    for (i2 = length; i2-- !== 0; ) {
      var key = keys[i2];
      if (!equal2(a[key], b[key]))
        return false;
    }
    return true;
  }
  return a !== a && b !== b;
};
var jsonSchemaTraverse = { exports: {} };
var traverse$1 = jsonSchemaTraverse.exports = function(schema2, opts2, cb) {
  if (typeof opts2 == "function") {
    cb = opts2;
    opts2 = {};
  }
  cb = opts2.cb || cb;
  var pre = typeof cb == "function" ? cb : cb.pre || function() {
  };
  var post = cb.post || function() {
  };
  _traverse(opts2, pre, post, schema2, "", schema2);
};
traverse$1.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true,
  if: true,
  then: true,
  else: true
};
traverse$1.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};
traverse$1.propsKeywords = {
  $defs: true,
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};
traverse$1.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};
function _traverse(opts2, pre, post, schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema2 && typeof schema2 == "object" && !Array.isArray(schema2)) {
    pre(schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema2) {
      var sch = schema2[key];
      if (Array.isArray(sch)) {
        if (key in traverse$1.arrayKeywords) {
          for (var i2 = 0; i2 < sch.length; i2++)
            _traverse(opts2, pre, post, sch[i2], jsonPtr + "/" + key + "/" + i2, rootSchema, jsonPtr, key, schema2, i2);
        }
      } else if (key in traverse$1.propsKeywords) {
        if (sch && typeof sch == "object") {
          for (var prop in sch)
            _traverse(opts2, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema2, prop);
        }
      } else if (key in traverse$1.keywords || opts2.allKeys && !(key in traverse$1.skipKeywords)) {
        _traverse(opts2, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema2);
      }
    }
    post(schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}
function escapeJsonPtr(str2) {
  return str2.replace(/~/g, "~0").replace(/\//g, "~1");
}
var uri_all = { exports: {} };
/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function(module, exports) {
  (function(global2, factory) {
    factory(exports);
  })(commonjsGlobal, function(exports2) {
    function merge2() {
      for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
        sets[_key] = arguments[_key];
      }
      if (sets.length > 1) {
        sets[0] = sets[0].slice(0, -1);
        var xl = sets.length - 1;
        for (var x = 1; x < xl; ++x) {
          sets[x] = sets[x].slice(1, -1);
        }
        sets[xl] = sets[xl].slice(1);
        return sets.join("");
      } else {
        return sets[0];
      }
    }
    function subexp(str2) {
      return "(?:" + str2 + ")";
    }
    function typeOf(o) {
      return o === void 0 ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
    }
    function toUpperCase(str2) {
      return str2.toUpperCase();
    }
    function toArray2(obj) {
      return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
    }
    function assign(target, source2) {
      var obj = target;
      if (source2) {
        for (var key in source2) {
          obj[key] = source2[key];
        }
      }
      return obj;
    }
    function buildExps(isIRI) {
      var ALPHA$$ = "[A-Za-z]", DIGIT$$ = "[0-9]", HEXDIG$$2 = merge2(DIGIT$$, "[A-Fa-f]"), PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge2(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge2(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$);
      subexp(ALPHA$$ + merge2(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*");
      subexp(subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*");
      var DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+");
      subexp("[vV]" + HEXDIG$$2 + "+\\." + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+");
      subexp(subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$)) + "*");
      var PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]"));
      subexp(subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+");
      subexp(subexp(PCHAR$ + "|" + merge2("[\\/\\?]", IPRIVATE$$)) + "*");
      return {
        NOT_SCHEME: new RegExp(merge2("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(merge2("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_HOST: new RegExp(merge2("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_PATH: new RegExp(merge2("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_PATH_NOSCHEME: new RegExp(merge2("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_QUERY: new RegExp(merge2("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
        NOT_FRAGMENT: new RegExp(merge2("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(merge2("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
        OTHER_CHARS: new RegExp(merge2("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
        PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
        IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
      };
    }
    var URI_PROTOCOL = buildExps(false);
    var IRI_PROTOCOL = buildExps(true);
    var slicedToArray = function() {
      function sliceIterator(arr, i2) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i2 && _arr.length === i2)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"])
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      return function(arr, i2) {
        if (Array.isArray(arr)) {
          return arr;
        } else if (Symbol.iterator in Object(arr)) {
          return sliceIterator(arr, i2);
        } else {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
      };
    }();
    var toConsumableArray = function(arr) {
      if (Array.isArray(arr)) {
        for (var i2 = 0, arr2 = Array(arr.length); i2 < arr.length; i2++)
          arr2[i2] = arr[i2];
        return arr2;
      } else {
        return Array.from(arr);
      }
    };
    var maxInt = 2147483647;
    var base = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128;
    var delimiter = "-";
    var regexPunycode = /^xn--/;
    var regexNonASCII = /[^\0-\x7E]/;
    var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    var errors2 = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    var baseMinusTMin = base - tMin;
    var floor = Math.floor;
    var stringFromCharCode = String.fromCharCode;
    function error$12(type2) {
      throw new RangeError(errors2[type2]);
    }
    function map2(array, fn) {
      var result = [];
      var length = array.length;
      while (length--) {
        result[length] = fn(array[length]);
      }
      return result;
    }
    function mapDomain(string, fn) {
      var parts = string.split("@");
      var result = "";
      if (parts.length > 1) {
        result = parts[0] + "@";
        string = parts[1];
      }
      string = string.replace(regexSeparators, ".");
      var labels = string.split(".");
      var encoded = map2(labels, fn).join(".");
      return result + encoded;
    }
    function ucs2decode(string) {
      var output2 = [];
      var counter = 0;
      var length = string.length;
      while (counter < length) {
        var value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          var extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output2.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output2.push(value);
            counter--;
          }
        } else {
          output2.push(value);
        }
      }
      return output2;
    }
    var ucs2encode = function ucs2encode2(array) {
      return String.fromCodePoint.apply(String, toConsumableArray(array));
    };
    var basicToDigit = function basicToDigit2(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base;
    };
    var digitToBasic = function digitToBasic2(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    var adapt = function adapt2(delta, numPoints, firstTime) {
      var k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (; delta > baseMinusTMin * tMax >> 1; k += base) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    var decode = function decode2(input) {
      var output2 = [];
      var inputLength = input.length;
      var i2 = 0;
      var n = initialN;
      var bias = initialBias;
      var basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (var j = 0; j < basic; ++j) {
        if (input.charCodeAt(j) >= 128) {
          error$12("not-basic");
        }
        output2.push(input.charCodeAt(j));
      }
      for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
        var oldi = i2;
        for (var w2 = 1, k = base; ; k += base) {
          if (index >= inputLength) {
            error$12("invalid-input");
          }
          var digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base || digit > floor((maxInt - i2) / w2)) {
            error$12("overflow");
          }
          i2 += digit * w2;
          var t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (digit < t2) {
            break;
          }
          var baseMinusT = base - t2;
          if (w2 > floor(maxInt / baseMinusT)) {
            error$12("overflow");
          }
          w2 *= baseMinusT;
        }
        var out2 = output2.length + 1;
        bias = adapt(i2 - oldi, out2, oldi == 0);
        if (floor(i2 / out2) > maxInt - n) {
          error$12("overflow");
        }
        n += floor(i2 / out2);
        i2 %= out2;
        output2.splice(i2++, 0, n);
      }
      return String.fromCodePoint.apply(String, output2);
    };
    var encode = function encode2(input) {
      var output2 = [];
      input = ucs2decode(input);
      var inputLength = input.length;
      var n = initialN;
      var delta = 0;
      var bias = initialBias;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = void 0;
      try {
        for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _currentValue2 = _step.value;
          if (_currentValue2 < 128) {
            output2.push(stringFromCharCode(_currentValue2));
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      var basicLength = output2.length;
      var handledCPCount = basicLength;
      if (basicLength) {
        output2.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        var m2 = maxInt;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = void 0;
        try {
          for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var currentValue = _step2.value;
            if (currentValue >= n && currentValue < m2) {
              m2 = currentValue;
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
        var handledCPCountPlusOne = handledCPCount + 1;
        if (m2 - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error$12("overflow");
        }
        delta += (m2 - n) * handledCPCountPlusOne;
        n = m2;
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = void 0;
        try {
          for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _currentValue = _step3.value;
            if (_currentValue < n && ++delta > maxInt) {
              error$12("overflow");
            }
            if (_currentValue == n) {
              var q = delta;
              for (var k = base; ; k += base) {
                var t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t2) {
                  break;
                }
                var qMinusT = q - t2;
                var baseMinusT = base - t2;
                output2.push(stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0)));
                q = floor(qMinusT / baseMinusT);
              }
              output2.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
        ++delta;
        ++n;
      }
      return output2.join("");
    };
    var toUnicode = function toUnicode2(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
      });
    };
    var toASCII = function toASCII2(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
      });
    };
    var punycode = {
      "version": "2.1.0",
      "ucs2": {
        "decode": ucs2decode,
        "encode": ucs2encode
      },
      "decode": decode,
      "encode": encode,
      "toASCII": toASCII,
      "toUnicode": toUnicode
    };
    var SCHEMES = {};
    function pctEncChar(chr) {
      var c = chr.charCodeAt(0);
      var e = void 0;
      if (c < 16)
        e = "%0" + c.toString(16).toUpperCase();
      else if (c < 128)
        e = "%" + c.toString(16).toUpperCase();
      else if (c < 2048)
        e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
      else
        e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
      return e;
    }
    function pctDecChars(str2) {
      var newStr = "";
      var i2 = 0;
      var il = str2.length;
      while (i2 < il) {
        var c = parseInt(str2.substr(i2 + 1, 2), 16);
        if (c < 128) {
          newStr += String.fromCharCode(c);
          i2 += 3;
        } else if (c >= 194 && c < 224) {
          if (il - i2 >= 6) {
            var c2 = parseInt(str2.substr(i2 + 4, 2), 16);
            newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
          } else {
            newStr += str2.substr(i2, 6);
          }
          i2 += 6;
        } else if (c >= 224) {
          if (il - i2 >= 9) {
            var _c = parseInt(str2.substr(i2 + 4, 2), 16);
            var c3 = parseInt(str2.substr(i2 + 7, 2), 16);
            newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
          } else {
            newStr += str2.substr(i2, 9);
          }
          i2 += 9;
        } else {
          newStr += str2.substr(i2, 3);
          i2 += 3;
        }
      }
      return newStr;
    }
    function _normalizeComponentEncoding(components, protocol) {
      function decodeUnreserved2(str2) {
        var decStr = pctDecChars(str2);
        return !decStr.match(protocol.UNRESERVED) ? str2 : decStr;
      }
      if (components.scheme)
        components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
      if (components.userinfo !== void 0)
        components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.host !== void 0)
        components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.path !== void 0)
        components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.query !== void 0)
        components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.fragment !== void 0)
        components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      return components;
    }
    function _stripLeadingZeros(str2) {
      return str2.replace(/^0*(.*)/, "$1") || "0";
    }
    function _normalizeIPv4(host, protocol) {
      var matches = host.match(protocol.IPV4ADDRESS) || [];
      var _matches = slicedToArray(matches, 2), address = _matches[1];
      if (address) {
        return address.split(".").map(_stripLeadingZeros).join(".");
      } else {
        return host;
      }
    }
    function _normalizeIPv6(host, protocol) {
      var matches = host.match(protocol.IPV6ADDRESS) || [];
      var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
      if (address) {
        var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
        var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
        var lastFields = last.split(":").map(_stripLeadingZeros);
        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
        var lastFieldsStart = lastFields.length - fieldCount;
        var fields = Array(fieldCount);
        for (var x = 0; x < fieldCount; ++x) {
          fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
        }
        if (isLastFieldIPv4Address) {
          fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
        }
        var allZeroFields = fields.reduce(function(acc, field, index) {
          if (!field || field === "0") {
            var lastLongest = acc[acc.length - 1];
            if (lastLongest && lastLongest.index + lastLongest.length === index) {
              lastLongest.length++;
            } else {
              acc.push({ index, length: 1 });
            }
          }
          return acc;
        }, []);
        var longestZeroFields = allZeroFields.sort(function(a, b) {
          return b.length - a.length;
        })[0];
        var newHost = void 0;
        if (longestZeroFields && longestZeroFields.length > 1) {
          var newFirst = fields.slice(0, longestZeroFields.index);
          var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
          newHost = newFirst.join(":") + "::" + newLast.join(":");
        } else {
          newHost = fields.join(":");
        }
        if (zone) {
          newHost += "%" + zone;
        }
        return newHost;
      } else {
        return host;
      }
    }
    var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
    var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
    function parse2(uriString) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var components = {};
      var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
      if (options.reference === "suffix")
        uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
      var matches = uriString.match(URI_PARSE);
      if (matches) {
        if (NO_MATCH_IS_UNDEFINED) {
          components.scheme = matches[1];
          components.userinfo = matches[3];
          components.host = matches[4];
          components.port = parseInt(matches[5], 10);
          components.path = matches[6] || "";
          components.query = matches[7];
          components.fragment = matches[8];
          if (isNaN(components.port)) {
            components.port = matches[5];
          }
        } else {
          components.scheme = matches[1] || void 0;
          components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
          components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
          components.port = parseInt(matches[5], 10);
          components.path = matches[6] || "";
          components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
          components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
          if (isNaN(components.port)) {
            components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
          }
        }
        if (components.host) {
          components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
        }
        if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
          components.reference = "same-document";
        } else if (components.scheme === void 0) {
          components.reference = "relative";
        } else if (components.fragment === void 0) {
          components.reference = "absolute";
        } else {
          components.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
          components.error = components.error || "URI is not a " + options.reference + " reference.";
        }
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
            try {
              components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
            } catch (e) {
              components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
            }
          }
          _normalizeComponentEncoding(components, URI_PROTOCOL);
        } else {
          _normalizeComponentEncoding(components, protocol);
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(components, options);
        }
      } else {
        components.error = components.error || "URI can not be parsed.";
      }
      return components;
    }
    function _recomposeAuthority(components, options) {
      var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
      var uriTokens = [];
      if (components.userinfo !== void 0) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
      }
      if (components.host !== void 0) {
        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
          return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
        }));
      }
      if (typeof components.port === "number" || typeof components.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(components.port));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    var RDS1 = /^\.\.?\//;
    var RDS2 = /^\/\.(\/|$)/;
    var RDS3 = /^\/\.\.(\/|$)/;
    var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
    function removeDotSegments(input) {
      var output2 = [];
      while (input.length) {
        if (input.match(RDS1)) {
          input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
          input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
          input = input.replace(RDS3, "/");
          output2.pop();
        } else if (input === "." || input === "..") {
          input = "";
        } else {
          var im = input.match(RDS5);
          if (im) {
            var s2 = im[0];
            input = input.slice(s2.length);
            output2.push(s2);
          } else {
            throw new Error("Unexpected dot segment condition");
          }
        }
      }
      return output2.join("");
    }
    function serialize(components) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
      var uriTokens = [];
      var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
      if (schemeHandler && schemeHandler.serialize)
        schemeHandler.serialize(components, options);
      if (components.host) {
        if (protocol.IPV6ADDRESS.test(components.host))
          ;
        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
          try {
            components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
          } catch (e) {
            components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
          }
        }
      }
      _normalizeComponentEncoding(components, protocol);
      if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme);
        uriTokens.push(":");
      }
      var authority = _recomposeAuthority(components, options);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
          uriTokens.push("/");
        }
      }
      if (components.path !== void 0) {
        var s2 = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s2 = removeDotSegments(s2);
        }
        if (authority === void 0) {
          s2 = s2.replace(/^\/\//, "/%2F");
        }
        uriTokens.push(s2);
      }
      if (components.query !== void 0) {
        uriTokens.push("?");
        uriTokens.push(components.query);
      }
      if (components.fragment !== void 0) {
        uriTokens.push("#");
        uriTokens.push(components.fragment);
      }
      return uriTokens.join("");
    }
    function resolveComponents(base2, relative) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var skipNormalization = arguments[3];
      var target = {};
      if (!skipNormalization) {
        base2 = parse2(serialize(base2, options), options);
        relative = parse2(serialize(relative, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (!relative.path) {
            target.path = base2.path;
            if (relative.query !== void 0) {
              target.query = relative.query;
            } else {
              target.query = base2.query;
            }
          } else {
            if (relative.path.charAt(0) === "/") {
              target.path = removeDotSegments(relative.path);
            } else {
              if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                target.path = "/" + relative.path;
              } else if (!base2.path) {
                target.path = relative.path;
              } else {
                target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative.query;
          }
          target.userinfo = base2.userinfo;
          target.host = base2.host;
          target.port = base2.port;
        }
        target.scheme = base2.scheme;
      }
      target.fragment = relative.fragment;
      return target;
    }
    function resolve2(baseURI, relativeURI, options) {
      var schemelessOptions = assign({ scheme: "null" }, options);
      return serialize(resolveComponents(parse2(baseURI, schemelessOptions), parse2(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
    }
    function normalize(uri, options) {
      if (typeof uri === "string") {
        uri = serialize(parse2(uri, options), options);
      } else if (typeOf(uri) === "object") {
        uri = parse2(serialize(uri, options), options);
      }
      return uri;
    }
    function equal3(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = serialize(parse2(uriA, options), options);
      } else if (typeOf(uriA) === "object") {
        uriA = serialize(uriA, options);
      }
      if (typeof uriB === "string") {
        uriB = serialize(parse2(uriB, options), options);
      } else if (typeOf(uriB) === "object") {
        uriB = serialize(uriB, options);
      }
      return uriA === uriB;
    }
    function escapeComponent(str2, options) {
      return str2 && str2.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
    }
    function unescapeComponent(str2, options) {
      return str2 && str2.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
    }
    var handler = {
      scheme: "http",
      domainHost: true,
      parse: function parse3(components, options) {
        if (!components.host) {
          components.error = components.error || "HTTP URIs must have a host.";
        }
        return components;
      },
      serialize: function serialize2(components, options) {
        var secure = String(components.scheme).toLowerCase() === "https";
        if (components.port === (secure ? 443 : 80) || components.port === "") {
          components.port = void 0;
        }
        if (!components.path) {
          components.path = "/";
        }
        return components;
      }
    };
    var handler$1 = {
      scheme: "https",
      domainHost: handler.domainHost,
      parse: handler.parse,
      serialize: handler.serialize
    };
    function isSecure(wsComponents) {
      return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
    }
    var handler$2 = {
      scheme: "ws",
      domainHost: true,
      parse: function parse3(components, options) {
        var wsComponents = components;
        wsComponents.secure = isSecure(wsComponents);
        wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
        wsComponents.path = void 0;
        wsComponents.query = void 0;
        return wsComponents;
      },
      serialize: function serialize2(wsComponents, options) {
        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
          wsComponents.port = void 0;
        }
        if (typeof wsComponents.secure === "boolean") {
          wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
          wsComponents.secure = void 0;
        }
        if (wsComponents.resourceName) {
          var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path2 = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
          wsComponents.path = path2 && path2 !== "/" ? path2 : void 0;
          wsComponents.query = query;
          wsComponents.resourceName = void 0;
        }
        wsComponents.fragment = void 0;
        return wsComponents;
      }
    };
    var handler$3 = {
      scheme: "wss",
      domainHost: handler$2.domainHost,
      parse: handler$2.parse,
      serialize: handler$2.serialize
    };
    var O = {};
    var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]";
    var HEXDIG$$ = "[0-9A-Fa-f]";
    var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
    var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
    var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
    var VCHAR$$ = merge2(QTEXT$$, '[\\"\\\\]');
    var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
    var UNRESERVED = new RegExp(UNRESERVED$$, "g");
    var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
    var NOT_LOCAL_PART = new RegExp(merge2("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
    var NOT_HFNAME = new RegExp(merge2("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
    var NOT_HFVALUE = NOT_HFNAME;
    function decodeUnreserved(str2) {
      var decStr = pctDecChars(str2);
      return !decStr.match(UNRESERVED) ? str2 : decStr;
    }
    var handler$4 = {
      scheme: "mailto",
      parse: function parse$$1(components, options) {
        var mailtoComponents = components;
        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
        mailtoComponents.path = void 0;
        if (mailtoComponents.query) {
          var unknownHeaders = false;
          var headers = {};
          var hfields = mailtoComponents.query.split("&");
          for (var x = 0, xl = hfields.length; x < xl; ++x) {
            var hfield = hfields[x].split("=");
            switch (hfield[0]) {
              case "to":
                var toAddrs = hfield[1].split(",");
                for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                  to.push(toAddrs[_x]);
                }
                break;
              case "subject":
                mailtoComponents.subject = unescapeComponent(hfield[1], options);
                break;
              case "body":
                mailtoComponents.body = unescapeComponent(hfield[1], options);
                break;
              default:
                unknownHeaders = true;
                headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                break;
            }
          }
          if (unknownHeaders)
            mailtoComponents.headers = headers;
        }
        mailtoComponents.query = void 0;
        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
          var addr = to[_x2].split("@");
          addr[0] = unescapeComponent(addr[0]);
          if (!options.unicodeSupport) {
            try {
              addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
            } catch (e) {
              mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
            }
          } else {
            addr[1] = unescapeComponent(addr[1], options).toLowerCase();
          }
          to[_x2] = addr.join("@");
        }
        return mailtoComponents;
      },
      serialize: function serialize$$1(mailtoComponents, options) {
        var components = mailtoComponents;
        var to = toArray2(mailtoComponents.to);
        if (to) {
          for (var x = 0, xl = to.length; x < xl; ++x) {
            var toAddr = String(to[x]);
            var atIdx = toAddr.lastIndexOf("@");
            var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
            var domain = toAddr.slice(atIdx + 1);
            try {
              domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
            } catch (e) {
              components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
            }
            to[x] = localPart + "@" + domain;
          }
          components.path = to.join(",");
        }
        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
        if (mailtoComponents.subject)
          headers["subject"] = mailtoComponents.subject;
        if (mailtoComponents.body)
          headers["body"] = mailtoComponents.body;
        var fields = [];
        for (var name in headers) {
          if (headers[name] !== O[name]) {
            fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
          }
        }
        if (fields.length) {
          components.query = fields.join("&");
        }
        return components;
      }
    };
    var URN_PARSE = /^([^\:]+)\:(.*)/;
    var handler$5 = {
      scheme: "urn",
      parse: function parse$$1(components, options) {
        var matches = components.path && components.path.match(URN_PARSE);
        var urnComponents = components;
        if (matches) {
          var scheme = options.scheme || urnComponents.scheme || "urn";
          var nid = matches[1].toLowerCase();
          var nss = matches[2];
          var urnScheme = scheme + ":" + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          urnComponents.nid = nid;
          urnComponents.nss = nss;
          urnComponents.path = void 0;
          if (schemeHandler) {
            urnComponents = schemeHandler.parse(urnComponents, options);
          }
        } else {
          urnComponents.error = urnComponents.error || "URN can not be parsed.";
        }
        return urnComponents;
      },
      serialize: function serialize$$1(urnComponents, options) {
        var scheme = options.scheme || urnComponents.scheme || "urn";
        var nid = urnComponents.nid;
        var urnScheme = scheme + ":" + (options.nid || nid);
        var schemeHandler = SCHEMES[urnScheme];
        if (schemeHandler) {
          urnComponents = schemeHandler.serialize(urnComponents, options);
        }
        var uriComponents = urnComponents;
        var nss = urnComponents.nss;
        uriComponents.path = (nid || options.nid) + ":" + nss;
        return uriComponents;
      }
    };
    var UUID2 = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
    var handler$6 = {
      scheme: "urn:uuid",
      parse: function parse3(urnComponents, options) {
        var uuidComponents = urnComponents;
        uuidComponents.uuid = uuidComponents.nss;
        uuidComponents.nss = void 0;
        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID2))) {
          uuidComponents.error = uuidComponents.error || "UUID is not valid.";
        }
        return uuidComponents;
      },
      serialize: function serialize2(uuidComponents, options) {
        var urnComponents = uuidComponents;
        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
        return urnComponents;
      }
    };
    SCHEMES[handler.scheme] = handler;
    SCHEMES[handler$1.scheme] = handler$1;
    SCHEMES[handler$2.scheme] = handler$2;
    SCHEMES[handler$3.scheme] = handler$3;
    SCHEMES[handler$4.scheme] = handler$4;
    SCHEMES[handler$5.scheme] = handler$5;
    SCHEMES[handler$6.scheme] = handler$6;
    exports2.SCHEMES = SCHEMES;
    exports2.pctEncChar = pctEncChar;
    exports2.pctDecChars = pctDecChars;
    exports2.parse = parse2;
    exports2.removeDotSegments = removeDotSegments;
    exports2.serialize = serialize;
    exports2.resolveComponents = resolveComponents;
    exports2.resolve = resolve2;
    exports2.normalize = normalize;
    exports2.equal = equal3;
    exports2.escapeComponent = escapeComponent;
    exports2.unescapeComponent = unescapeComponent;
    Object.defineProperty(exports2, "__esModule", { value: true });
  });
})(uri_all, uri_all.exports);
Object.defineProperty(resolve$1, "__esModule", { value: true });
resolve$1.getSchemaRefs = resolve$1.resolveUrl = resolve$1.normalizeId = resolve$1._getFullPath = resolve$1.getFullPath = resolve$1.inlineRef = void 0;
const util_1$l = util;
const equal$2 = fastDeepEqual;
const traverse = jsonSchemaTraverse.exports;
const URI$1 = uri_all.exports;
const SIMPLE_INLINED = new Set([
  "type",
  "format",
  "pattern",
  "maxLength",
  "minLength",
  "maxProperties",
  "minProperties",
  "maxItems",
  "minItems",
  "maximum",
  "minimum",
  "uniqueItems",
  "multipleOf",
  "required",
  "enum",
  "const"
]);
function inlineRef(schema2, limit2 = true) {
  if (typeof schema2 == "boolean")
    return true;
  if (limit2 === true)
    return !hasRef(schema2);
  if (!limit2)
    return false;
  return countKeys(schema2) <= limit2;
}
resolve$1.inlineRef = inlineRef;
const REF_KEYWORDS = new Set([
  "$ref",
  "$recursiveRef",
  "$recursiveAnchor",
  "$dynamicRef",
  "$dynamicAnchor"
]);
function hasRef(schema2) {
  for (const key in schema2) {
    if (REF_KEYWORDS.has(key))
      return true;
    const sch = schema2[key];
    if (Array.isArray(sch) && sch.some(hasRef))
      return true;
    if (typeof sch == "object" && hasRef(sch))
      return true;
  }
  return false;
}
function countKeys(schema2) {
  let count = 0;
  for (const key in schema2) {
    if (key === "$ref")
      return Infinity;
    count++;
    if (SIMPLE_INLINED.has(key))
      continue;
    if (typeof schema2[key] == "object") {
      util_1$l.eachItem(schema2[key], (sch) => count += countKeys(sch));
    }
    if (count === Infinity)
      return Infinity;
  }
  return count;
}
function getFullPath(id2 = "", normalize) {
  if (normalize !== false)
    id2 = normalizeId(id2);
  const p = URI$1.parse(id2);
  return _getFullPath(p);
}
resolve$1.getFullPath = getFullPath;
function _getFullPath(p) {
  return URI$1.serialize(p).split("#")[0] + "#";
}
resolve$1._getFullPath = _getFullPath;
const TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id2) {
  return id2 ? id2.replace(TRAILING_SLASH_HASH, "") : "";
}
resolve$1.normalizeId = normalizeId;
function resolveUrl(baseId, id2) {
  id2 = normalizeId(id2);
  return URI$1.resolve(baseId, id2);
}
resolve$1.resolveUrl = resolveUrl;
const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
function getSchemaRefs(schema2) {
  if (typeof schema2 == "boolean")
    return {};
  const { schemaId } = this.opts;
  const schId = normalizeId(schema2[schemaId]);
  const baseIds = { "": schId };
  const pathPrefix = getFullPath(schId, false);
  const localRefs = {};
  const schemaRefs = new Set();
  traverse(schema2, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
    if (parentJsonPtr === void 0)
      return;
    const fullPath = pathPrefix + jsonPtr;
    let baseId = baseIds[parentJsonPtr];
    if (typeof sch[schemaId] == "string")
      baseId = addRef.call(this, sch[schemaId]);
    addAnchor.call(this, sch.$anchor);
    addAnchor.call(this, sch.$dynamicAnchor);
    baseIds[jsonPtr] = baseId;
    function addRef(ref2) {
      ref2 = normalizeId(baseId ? URI$1.resolve(baseId, ref2) : ref2);
      if (schemaRefs.has(ref2))
        throw ambiguos(ref2);
      schemaRefs.add(ref2);
      let schOrRef = this.refs[ref2];
      if (typeof schOrRef == "string")
        schOrRef = this.refs[schOrRef];
      if (typeof schOrRef == "object") {
        checkAmbiguosRef(sch, schOrRef.schema, ref2);
      } else if (ref2 !== normalizeId(fullPath)) {
        if (ref2[0] === "#") {
          checkAmbiguosRef(sch, localRefs[ref2], ref2);
          localRefs[ref2] = sch;
        } else {
          this.refs[ref2] = fullPath;
        }
      }
      return ref2;
    }
    function addAnchor(anchor) {
      if (typeof anchor == "string") {
        if (!ANCHOR.test(anchor))
          throw new Error(`invalid anchor "${anchor}"`);
        addRef.call(this, `#${anchor}`);
      }
    }
  });
  return localRefs;
  function checkAmbiguosRef(sch1, sch2, ref2) {
    if (sch2 !== void 0 && !equal$2(sch1, sch2))
      throw ambiguos(ref2);
  }
  function ambiguos(ref2) {
    return new Error(`reference "${ref2}" resolves to more than one schema`);
  }
}
resolve$1.getSchemaRefs = getSchemaRefs;
Object.defineProperty(validate, "__esModule", { value: true });
validate.getData = validate.KeywordCxt = validate.validateFunctionCode = void 0;
const boolSchema_1 = boolSchema;
const dataType_1$1 = dataType;
const applicability_1 = applicability;
const dataType_2 = dataType;
const defaults_1 = defaults;
const keyword_1 = keyword;
const subschema_1 = subschema;
const codegen_1$n = codegen;
const names_1$3 = names$1;
const resolve_1$2 = resolve$1;
const util_1$k = util;
const errors_1 = errors;
function validateFunctionCode(it) {
  if (isSchemaObj(it)) {
    checkKeywords(it);
    if (schemaCxtHasRules(it)) {
      topSchemaObjCode(it);
      return;
    }
  }
  validateFunction(it, () => boolSchema_1.topBoolOrEmptySchema(it));
}
validate.validateFunctionCode = validateFunctionCode;
function validateFunction({ gen, validateName, schema: schema2, schemaEnv, opts: opts2 }, body) {
  if (opts2.code.es5) {
    gen.func(validateName, codegen_1$n._`${names_1$3.default.data}, ${names_1$3.default.valCxt}`, schemaEnv.$async, () => {
      gen.code(codegen_1$n._`"use strict"; ${funcSourceUrl(schema2, opts2)}`);
      destructureValCxtES5(gen, opts2);
      gen.code(body);
    });
  } else {
    gen.func(validateName, codegen_1$n._`${names_1$3.default.data}, ${destructureValCxt(opts2)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema2, opts2)).code(body));
  }
}
function destructureValCxt(opts2) {
  return codegen_1$n._`{${names_1$3.default.instancePath}="", ${names_1$3.default.parentData}, ${names_1$3.default.parentDataProperty}, ${names_1$3.default.rootData}=${names_1$3.default.data}${opts2.dynamicRef ? codegen_1$n._`, ${names_1$3.default.dynamicAnchors}={}` : codegen_1$n.nil}}={}`;
}
function destructureValCxtES5(gen, opts2) {
  gen.if(names_1$3.default.valCxt, () => {
    gen.var(names_1$3.default.instancePath, codegen_1$n._`${names_1$3.default.valCxt}.${names_1$3.default.instancePath}`);
    gen.var(names_1$3.default.parentData, codegen_1$n._`${names_1$3.default.valCxt}.${names_1$3.default.parentData}`);
    gen.var(names_1$3.default.parentDataProperty, codegen_1$n._`${names_1$3.default.valCxt}.${names_1$3.default.parentDataProperty}`);
    gen.var(names_1$3.default.rootData, codegen_1$n._`${names_1$3.default.valCxt}.${names_1$3.default.rootData}`);
    if (opts2.dynamicRef)
      gen.var(names_1$3.default.dynamicAnchors, codegen_1$n._`${names_1$3.default.valCxt}.${names_1$3.default.dynamicAnchors}`);
  }, () => {
    gen.var(names_1$3.default.instancePath, codegen_1$n._`""`);
    gen.var(names_1$3.default.parentData, codegen_1$n._`undefined`);
    gen.var(names_1$3.default.parentDataProperty, codegen_1$n._`undefined`);
    gen.var(names_1$3.default.rootData, names_1$3.default.data);
    if (opts2.dynamicRef)
      gen.var(names_1$3.default.dynamicAnchors, codegen_1$n._`{}`);
  });
}
function topSchemaObjCode(it) {
  const { schema: schema2, opts: opts2, gen } = it;
  validateFunction(it, () => {
    if (opts2.$comment && schema2.$comment)
      commentKeyword(it);
    checkNoDefault(it);
    gen.let(names_1$3.default.vErrors, null);
    gen.let(names_1$3.default.errors, 0);
    if (opts2.unevaluated)
      resetEvaluated(it);
    typeAndKeywords(it);
    returnResults(it);
  });
  return;
}
function resetEvaluated(it) {
  const { gen, validateName } = it;
  it.evaluated = gen.const("evaluated", codegen_1$n._`${validateName}.evaluated`);
  gen.if(codegen_1$n._`${it.evaluated}.dynamicProps`, () => gen.assign(codegen_1$n._`${it.evaluated}.props`, codegen_1$n._`undefined`));
  gen.if(codegen_1$n._`${it.evaluated}.dynamicItems`, () => gen.assign(codegen_1$n._`${it.evaluated}.items`, codegen_1$n._`undefined`));
}
function funcSourceUrl(schema2, opts2) {
  const schId = typeof schema2 == "object" && schema2[opts2.schemaId];
  return schId && (opts2.code.source || opts2.code.process) ? codegen_1$n._`/*# sourceURL=${schId} */` : codegen_1$n.nil;
}
function subschemaCode(it, valid2) {
  if (isSchemaObj(it)) {
    checkKeywords(it);
    if (schemaCxtHasRules(it)) {
      subSchemaObjCode(it, valid2);
      return;
    }
  }
  boolSchema_1.boolOrEmptySchema(it, valid2);
}
function schemaCxtHasRules({ schema: schema2, self: self2 }) {
  if (typeof schema2 == "boolean")
    return !schema2;
  for (const key in schema2)
    if (self2.RULES.all[key])
      return true;
  return false;
}
function isSchemaObj(it) {
  return typeof it.schema != "boolean";
}
function subSchemaObjCode(it, valid2) {
  const { schema: schema2, gen, opts: opts2 } = it;
  if (opts2.$comment && schema2.$comment)
    commentKeyword(it);
  updateContext(it);
  checkAsyncSchema(it);
  const errsCount = gen.const("_errs", names_1$3.default.errors);
  typeAndKeywords(it, errsCount);
  gen.var(valid2, codegen_1$n._`${errsCount} === ${names_1$3.default.errors}`);
}
function checkKeywords(it) {
  util_1$k.checkUnknownRules(it);
  checkRefsAndKeywords(it);
}
function typeAndKeywords(it, errsCount) {
  if (it.opts.jtd)
    return schemaKeywords(it, [], false, errsCount);
  const types2 = dataType_1$1.getSchemaTypes(it.schema);
  const checkedTypes = dataType_1$1.coerceAndCheckDataType(it, types2);
  schemaKeywords(it, types2, !checkedTypes, errsCount);
}
function checkRefsAndKeywords(it) {
  const { schema: schema2, errSchemaPath, opts: opts2, self: self2 } = it;
  if (schema2.$ref && opts2.ignoreKeywordsWithRef && util_1$k.schemaHasRulesButRef(schema2, self2.RULES)) {
    self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
  }
}
function checkNoDefault(it) {
  const { schema: schema2, opts: opts2 } = it;
  if (schema2.default !== void 0 && opts2.useDefaults && opts2.strictSchema) {
    util_1$k.checkStrictMode(it, "default is ignored in the schema root");
  }
}
function updateContext(it) {
  const schId = it.schema[it.opts.schemaId];
  if (schId)
    it.baseId = resolve_1$2.resolveUrl(it.baseId, schId);
}
function checkAsyncSchema(it) {
  if (it.schema.$async && !it.schemaEnv.$async)
    throw new Error("async schema in sync schema");
}
function commentKeyword({ gen, schemaEnv, schema: schema2, errSchemaPath, opts: opts2 }) {
  const msg = schema2.$comment;
  if (opts2.$comment === true) {
    gen.code(codegen_1$n._`${names_1$3.default.self}.logger.log(${msg})`);
  } else if (typeof opts2.$comment == "function") {
    const schemaPath = codegen_1$n.str`${errSchemaPath}/$comment`;
    const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
    gen.code(codegen_1$n._`${names_1$3.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
  }
}
function returnResults(it) {
  const { gen, schemaEnv, validateName, ValidationError: ValidationError2, opts: opts2 } = it;
  if (schemaEnv.$async) {
    gen.if(codegen_1$n._`${names_1$3.default.errors} === 0`, () => gen.return(names_1$3.default.data), () => gen.throw(codegen_1$n._`new ${ValidationError2}(${names_1$3.default.vErrors})`));
  } else {
    gen.assign(codegen_1$n._`${validateName}.errors`, names_1$3.default.vErrors);
    if (opts2.unevaluated)
      assignEvaluated(it);
    gen.return(codegen_1$n._`${names_1$3.default.errors} === 0`);
  }
}
function assignEvaluated({ gen, evaluated, props, items: items2 }) {
  if (props instanceof codegen_1$n.Name)
    gen.assign(codegen_1$n._`${evaluated}.props`, props);
  if (items2 instanceof codegen_1$n.Name)
    gen.assign(codegen_1$n._`${evaluated}.items`, items2);
}
function schemaKeywords(it, types2, typeErrors, errsCount) {
  const { gen, schema: schema2, data, allErrors, opts: opts2, self: self2 } = it;
  const { RULES } = self2;
  if (schema2.$ref && (opts2.ignoreKeywordsWithRef || !util_1$k.schemaHasRulesButRef(schema2, RULES))) {
    gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
    return;
  }
  if (!opts2.jtd)
    checkStrictTypes(it, types2);
  gen.block(() => {
    for (const group of RULES.rules)
      groupKeywords(group);
    groupKeywords(RULES.post);
  });
  function groupKeywords(group) {
    if (!applicability_1.shouldUseGroup(schema2, group))
      return;
    if (group.type) {
      gen.if(dataType_2.checkDataType(group.type, data, opts2.strictNumbers));
      iterateKeywords(it, group);
      if (types2.length === 1 && types2[0] === group.type && typeErrors) {
        gen.else();
        dataType_2.reportTypeError(it);
      }
      gen.endIf();
    } else {
      iterateKeywords(it, group);
    }
    if (!allErrors)
      gen.if(codegen_1$n._`${names_1$3.default.errors} === ${errsCount || 0}`);
  }
}
function iterateKeywords(it, group) {
  const { gen, schema: schema2, opts: { useDefaults } } = it;
  if (useDefaults)
    defaults_1.assignDefaults(it, group.type);
  gen.block(() => {
    for (const rule of group.rules) {
      if (applicability_1.shouldUseRule(schema2, rule)) {
        keywordCode(it, rule.keyword, rule.definition, group.type);
      }
    }
  });
}
function checkStrictTypes(it, types2) {
  if (it.schemaEnv.meta || !it.opts.strictTypes)
    return;
  checkContextTypes(it, types2);
  if (!it.opts.allowUnionTypes)
    checkMultipleTypes(it, types2);
  checkKeywordTypes(it, it.dataTypes);
}
function checkContextTypes(it, types2) {
  if (!types2.length)
    return;
  if (!it.dataTypes.length) {
    it.dataTypes = types2;
    return;
  }
  types2.forEach((t2) => {
    if (!includesType(it.dataTypes, t2)) {
      strictTypesError(it, `type "${t2}" not allowed by context "${it.dataTypes.join(",")}"`);
    }
  });
  it.dataTypes = it.dataTypes.filter((t2) => includesType(types2, t2));
}
function checkMultipleTypes(it, ts) {
  if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
    strictTypesError(it, "use allowUnionTypes to allow union type keyword");
  }
}
function checkKeywordTypes(it, ts) {
  const rules2 = it.self.RULES.all;
  for (const keyword2 in rules2) {
    const rule = rules2[keyword2];
    if (typeof rule == "object" && applicability_1.shouldUseRule(it.schema, rule)) {
      const { type: type2 } = rule.definition;
      if (type2.length && !type2.some((t2) => hasApplicableType(ts, t2))) {
        strictTypesError(it, `missing type "${type2.join(",")}" for keyword "${keyword2}"`);
      }
    }
  }
}
function hasApplicableType(schTs, kwdT) {
  return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
}
function includesType(ts, t2) {
  return ts.includes(t2) || t2 === "integer" && ts.includes("number");
}
function strictTypesError(it, msg) {
  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
  msg += ` at "${schemaPath}" (strictTypes)`;
  util_1$k.checkStrictMode(it, msg, it.opts.strictTypes);
}
class KeywordCxt {
  constructor(it, def2, keyword2) {
    keyword_1.validateKeywordUsage(it, def2, keyword2);
    this.gen = it.gen;
    this.allErrors = it.allErrors;
    this.keyword = keyword2;
    this.data = it.data;
    this.schema = it.schema[keyword2];
    this.$data = def2.$data && it.opts.$data && this.schema && this.schema.$data;
    this.schemaValue = util_1$k.schemaRefOrVal(it, this.schema, keyword2, this.$data);
    this.schemaType = def2.schemaType;
    this.parentSchema = it.schema;
    this.params = {};
    this.it = it;
    this.def = def2;
    if (this.$data) {
      this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
    } else {
      this.schemaCode = this.schemaValue;
      if (!keyword_1.validSchemaType(this.schema, def2.schemaType, def2.allowUndefined)) {
        throw new Error(`${keyword2} value must be ${JSON.stringify(def2.schemaType)}`);
      }
    }
    if ("code" in def2 ? def2.trackErrors : def2.errors !== false) {
      this.errsCount = it.gen.const("_errs", names_1$3.default.errors);
    }
  }
  result(condition, successAction, failAction) {
    this.failResult(codegen_1$n.not(condition), successAction, failAction);
  }
  failResult(condition, successAction, failAction) {
    this.gen.if(condition);
    if (failAction)
      failAction();
    else
      this.error();
    if (successAction) {
      this.gen.else();
      successAction();
      if (this.allErrors)
        this.gen.endIf();
    } else {
      if (this.allErrors)
        this.gen.endIf();
      else
        this.gen.else();
    }
  }
  pass(condition, failAction) {
    this.failResult(codegen_1$n.not(condition), void 0, failAction);
  }
  fail(condition) {
    if (condition === void 0) {
      this.error();
      if (!this.allErrors)
        this.gen.if(false);
      return;
    }
    this.gen.if(condition);
    this.error();
    if (this.allErrors)
      this.gen.endIf();
    else
      this.gen.else();
  }
  fail$data(condition) {
    if (!this.$data)
      return this.fail(condition);
    const { schemaCode } = this;
    this.fail(codegen_1$n._`${schemaCode} !== undefined && (${codegen_1$n.or(this.invalid$data(), condition)})`);
  }
  error(append, errorParams, errorPaths) {
    if (errorParams) {
      this.setParams(errorParams);
      this._error(append, errorPaths);
      this.setParams({});
      return;
    }
    this._error(append, errorPaths);
  }
  _error(append, errorPaths) {
    (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
  }
  $dataError() {
    errors_1.reportError(this, this.def.$dataError || errors_1.keyword$DataError);
  }
  reset() {
    if (this.errsCount === void 0)
      throw new Error('add "trackErrors" to keyword definition');
    errors_1.resetErrorsCount(this.gen, this.errsCount);
  }
  ok(cond) {
    if (!this.allErrors)
      this.gen.if(cond);
  }
  setParams(obj, assign) {
    if (assign)
      Object.assign(this.params, obj);
    else
      this.params = obj;
  }
  block$data(valid2, codeBlock, $dataValid = codegen_1$n.nil) {
    this.gen.block(() => {
      this.check$data(valid2, $dataValid);
      codeBlock();
    });
  }
  check$data(valid2 = codegen_1$n.nil, $dataValid = codegen_1$n.nil) {
    if (!this.$data)
      return;
    const { gen, schemaCode, schemaType, def: def2 } = this;
    gen.if(codegen_1$n.or(codegen_1$n._`${schemaCode} === undefined`, $dataValid));
    if (valid2 !== codegen_1$n.nil)
      gen.assign(valid2, true);
    if (schemaType.length || def2.validateSchema) {
      gen.elseIf(this.invalid$data());
      this.$dataError();
      if (valid2 !== codegen_1$n.nil)
        gen.assign(valid2, false);
    }
    gen.else();
  }
  invalid$data() {
    const { gen, schemaCode, schemaType, def: def2, it } = this;
    return codegen_1$n.or(wrong$DataType(), invalid$DataSchema());
    function wrong$DataType() {
      if (schemaType.length) {
        if (!(schemaCode instanceof codegen_1$n.Name))
          throw new Error("ajv implementation error");
        const st = Array.isArray(schemaType) ? schemaType : [schemaType];
        return codegen_1$n._`${dataType_2.checkDataTypes(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
      }
      return codegen_1$n.nil;
    }
    function invalid$DataSchema() {
      if (def2.validateSchema) {
        const validateSchemaRef = gen.scopeValue("validate$data", { ref: def2.validateSchema });
        return codegen_1$n._`!${validateSchemaRef}(${schemaCode})`;
      }
      return codegen_1$n.nil;
    }
  }
  subschema(appl, valid2) {
    const subschema2 = subschema_1.getSubschema(this.it, appl);
    subschema_1.extendSubschemaData(subschema2, this.it, appl);
    subschema_1.extendSubschemaMode(subschema2, appl);
    const nextContext = __spreadProps(__spreadValues(__spreadValues({}, this.it), subschema2), { items: void 0, props: void 0 });
    subschemaCode(nextContext, valid2);
    return nextContext;
  }
  mergeEvaluated(schemaCxt, toName) {
    const { it, gen } = this;
    if (!it.opts.unevaluated)
      return;
    if (it.props !== true && schemaCxt.props !== void 0) {
      it.props = util_1$k.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
    }
    if (it.items !== true && schemaCxt.items !== void 0) {
      it.items = util_1$k.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
    }
  }
  mergeValidEvaluated(schemaCxt, valid2) {
    const { it, gen } = this;
    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
      gen.if(valid2, () => this.mergeEvaluated(schemaCxt, codegen_1$n.Name));
      return true;
    }
  }
}
validate.KeywordCxt = KeywordCxt;
function keywordCode(it, keyword2, def2, ruleType) {
  const cxt = new KeywordCxt(it, def2, keyword2);
  if ("code" in def2) {
    def2.code(cxt, ruleType);
  } else if (cxt.$data && def2.validate) {
    keyword_1.funcKeywordCode(cxt, def2);
  } else if ("macro" in def2) {
    keyword_1.macroKeywordCode(cxt, def2);
  } else if (def2.compile || def2.validate) {
    keyword_1.funcKeywordCode(cxt, def2);
  }
}
const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, { dataLevel, dataNames, dataPathArr }) {
  let jsonPointer;
  let data;
  if ($data === "")
    return names_1$3.default.rootData;
  if ($data[0] === "/") {
    if (!JSON_POINTER.test($data))
      throw new Error(`Invalid JSON-pointer: ${$data}`);
    jsonPointer = $data;
    data = names_1$3.default.rootData;
  } else {
    const matches = RELATIVE_JSON_POINTER.exec($data);
    if (!matches)
      throw new Error(`Invalid JSON-pointer: ${$data}`);
    const up = +matches[1];
    jsonPointer = matches[2];
    if (jsonPointer === "#") {
      if (up >= dataLevel)
        throw new Error(errorMsg("property/index", up));
      return dataPathArr[dataLevel - up];
    }
    if (up > dataLevel)
      throw new Error(errorMsg("data", up));
    data = dataNames[dataLevel - up];
    if (!jsonPointer)
      return data;
  }
  let expr = data;
  const segments = jsonPointer.split("/");
  for (const segment of segments) {
    if (segment) {
      data = codegen_1$n._`${data}${codegen_1$n.getProperty(util_1$k.unescapeJsonPointer(segment))}`;
      expr = codegen_1$n._`${expr} && ${data}`;
    }
  }
  return expr;
  function errorMsg(pointerType, up) {
    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
  }
}
validate.getData = getData;
var validation_error = {};
Object.defineProperty(validation_error, "__esModule", { value: true });
class ValidationError extends Error {
  constructor(errors2) {
    super("validation failed");
    this.errors = errors2;
    this.ajv = this.validation = true;
  }
}
validation_error.default = ValidationError;
var ref_error = {};
Object.defineProperty(ref_error, "__esModule", { value: true });
const resolve_1$1 = resolve$1;
class MissingRefError extends Error {
  constructor(baseId, ref2, msg) {
    super(msg || `can't resolve reference ${ref2} from id ${baseId}`);
    this.missingRef = resolve_1$1.resolveUrl(baseId, ref2);
    this.missingSchema = resolve_1$1.normalizeId(resolve_1$1.getFullPath(this.missingRef));
  }
}
ref_error.default = MissingRefError;
var compile = {};
Object.defineProperty(compile, "__esModule", { value: true });
compile.resolveSchema = compile.getCompilingSchema = compile.resolveRef = compile.compileSchema = compile.SchemaEnv = void 0;
const codegen_1$m = codegen;
const validation_error_1 = validation_error;
const names_1$2 = names$1;
const resolve_1 = resolve$1;
const util_1$j = util;
const validate_1$1 = validate;
const URI = uri_all.exports;
class SchemaEnv {
  constructor(env2) {
    var _a;
    this.refs = {};
    this.dynamicAnchors = {};
    let schema2;
    if (typeof env2.schema == "object")
      schema2 = env2.schema;
    this.schema = env2.schema;
    this.schemaId = env2.schemaId;
    this.root = env2.root || this;
    this.baseId = (_a = env2.baseId) !== null && _a !== void 0 ? _a : resolve_1.normalizeId(schema2 === null || schema2 === void 0 ? void 0 : schema2[env2.schemaId || "$id"]);
    this.schemaPath = env2.schemaPath;
    this.localRefs = env2.localRefs;
    this.meta = env2.meta;
    this.$async = schema2 === null || schema2 === void 0 ? void 0 : schema2.$async;
    this.refs = {};
  }
}
compile.SchemaEnv = SchemaEnv;
function compileSchema(sch) {
  const _sch = getCompilingSchema.call(this, sch);
  if (_sch)
    return _sch;
  const rootId = resolve_1.getFullPath(sch.root.baseId);
  const { es5, lines } = this.opts.code;
  const { ownProperties } = this.opts;
  const gen = new codegen_1$m.CodeGen(this.scope, { es5, lines, ownProperties });
  let _ValidationError;
  if (sch.$async) {
    _ValidationError = gen.scopeValue("Error", {
      ref: validation_error_1.default,
      code: codegen_1$m._`require("ajv/dist/runtime/validation_error").default`
    });
  }
  const validateName = gen.scopeName("validate");
  sch.validateName = validateName;
  const schemaCxt = {
    gen,
    allErrors: this.opts.allErrors,
    data: names_1$2.default.data,
    parentData: names_1$2.default.parentData,
    parentDataProperty: names_1$2.default.parentDataProperty,
    dataNames: [names_1$2.default.data],
    dataPathArr: [codegen_1$m.nil],
    dataLevel: 0,
    dataTypes: [],
    definedProperties: new Set(),
    topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: codegen_1$m.stringify(sch.schema) } : { ref: sch.schema }),
    validateName,
    ValidationError: _ValidationError,
    schema: sch.schema,
    schemaEnv: sch,
    rootId,
    baseId: sch.baseId || rootId,
    schemaPath: codegen_1$m.nil,
    errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
    errorPath: codegen_1$m._`""`,
    opts: this.opts,
    self: this
  };
  let sourceCode;
  try {
    this._compilations.add(sch);
    validate_1$1.validateFunctionCode(schemaCxt);
    gen.optimize(this.opts.code.optimize);
    const validateCode = gen.toString();
    sourceCode = `${gen.scopeRefs(names_1$2.default.scope)}return ${validateCode}`;
    if (this.opts.code.process)
      sourceCode = this.opts.code.process(sourceCode, sch);
    const makeValidate = new Function(`${names_1$2.default.self}`, `${names_1$2.default.scope}`, sourceCode);
    const validate2 = makeValidate(this, this.scope.get());
    this.scope.value(validateName, { ref: validate2 });
    validate2.errors = null;
    validate2.schema = sch.schema;
    validate2.schemaEnv = sch;
    if (sch.$async)
      validate2.$async = true;
    if (this.opts.code.source === true) {
      validate2.source = { validateName, validateCode, scopeValues: gen._values };
    }
    if (this.opts.unevaluated) {
      const { props, items: items2 } = schemaCxt;
      validate2.evaluated = {
        props: props instanceof codegen_1$m.Name ? void 0 : props,
        items: items2 instanceof codegen_1$m.Name ? void 0 : items2,
        dynamicProps: props instanceof codegen_1$m.Name,
        dynamicItems: items2 instanceof codegen_1$m.Name
      };
      if (validate2.source)
        validate2.source.evaluated = codegen_1$m.stringify(validate2.evaluated);
    }
    sch.validate = validate2;
    return sch;
  } catch (e) {
    delete sch.validate;
    delete sch.validateName;
    if (sourceCode)
      this.logger.error("Error compiling schema, function code:", sourceCode);
    throw e;
  } finally {
    this._compilations.delete(sch);
  }
}
compile.compileSchema = compileSchema;
function resolveRef(root2, baseId, ref2) {
  var _a;
  ref2 = resolve_1.resolveUrl(baseId, ref2);
  const schOrFunc = root2.refs[ref2];
  if (schOrFunc)
    return schOrFunc;
  let _sch = resolve.call(this, root2, ref2);
  if (_sch === void 0) {
    const schema2 = (_a = root2.localRefs) === null || _a === void 0 ? void 0 : _a[ref2];
    const { schemaId } = this.opts;
    if (schema2)
      _sch = new SchemaEnv({ schema: schema2, schemaId, root: root2, baseId });
  }
  if (_sch === void 0)
    return;
  return root2.refs[ref2] = inlineOrCompile.call(this, _sch);
}
compile.resolveRef = resolveRef;
function inlineOrCompile(sch) {
  if (resolve_1.inlineRef(sch.schema, this.opts.inlineRefs))
    return sch.schema;
  return sch.validate ? sch : compileSchema.call(this, sch);
}
function getCompilingSchema(schEnv) {
  for (const sch of this._compilations) {
    if (sameSchemaEnv(sch, schEnv))
      return sch;
  }
}
compile.getCompilingSchema = getCompilingSchema;
function sameSchemaEnv(s1, s2) {
  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
}
function resolve(root2, ref2) {
  let sch;
  while (typeof (sch = this.refs[ref2]) == "string")
    ref2 = sch;
  return sch || this.schemas[ref2] || resolveSchema.call(this, root2, ref2);
}
function resolveSchema(root2, ref2) {
  const p = URI.parse(ref2);
  const refPath = resolve_1._getFullPath(p);
  let baseId = resolve_1.getFullPath(root2.baseId);
  if (Object.keys(root2.schema).length > 0 && refPath === baseId) {
    return getJsonPointer.call(this, p, root2);
  }
  const id2 = resolve_1.normalizeId(refPath);
  const schOrRef = this.refs[id2] || this.schemas[id2];
  if (typeof schOrRef == "string") {
    const sch = resolveSchema.call(this, root2, schOrRef);
    if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
      return;
    return getJsonPointer.call(this, p, sch);
  }
  if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
    return;
  if (!schOrRef.validate)
    compileSchema.call(this, schOrRef);
  if (id2 === resolve_1.normalizeId(ref2)) {
    const { schema: schema2 } = schOrRef;
    const { schemaId } = this.opts;
    const schId = schema2[schemaId];
    if (schId)
      baseId = resolve_1.resolveUrl(baseId, schId);
    return new SchemaEnv({ schema: schema2, schemaId, root: root2, baseId });
  }
  return getJsonPointer.call(this, p, schOrRef);
}
compile.resolveSchema = resolveSchema;
const PREVENT_SCOPE_CHANGE = new Set([
  "properties",
  "patternProperties",
  "enum",
  "dependencies",
  "definitions"
]);
function getJsonPointer(parsedRef, { baseId, schema: schema2, root: root2 }) {
  var _a;
  if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
    return;
  for (const part of parsedRef.fragment.slice(1).split("/")) {
    if (typeof schema2 == "boolean")
      return;
    schema2 = schema2[util_1$j.unescapeFragment(part)];
    if (schema2 === void 0)
      return;
    const schId = typeof schema2 == "object" && schema2[this.opts.schemaId];
    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
      baseId = resolve_1.resolveUrl(baseId, schId);
    }
  }
  let env2;
  if (typeof schema2 != "boolean" && schema2.$ref && !util_1$j.schemaHasRulesButRef(schema2, this.RULES)) {
    const $ref = resolve_1.resolveUrl(baseId, schema2.$ref);
    env2 = resolveSchema.call(this, root2, $ref);
  }
  const { schemaId } = this.opts;
  env2 = env2 || new SchemaEnv({ schema: schema2, schemaId, root: root2, baseId });
  if (env2.schema !== env2.root.schema)
    return env2;
  return void 0;
}
const $id$1 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
const description = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
const type$1 = "object";
const required$1 = [
  "$data"
];
const properties$2 = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
};
const additionalProperties$1 = false;
var require$$9 = {
  $id: $id$1,
  description,
  type: type$1,
  required: required$1,
  properties: properties$2,
  additionalProperties: additionalProperties$1
};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
  var validate_12 = validate;
  Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
    return validate_12.KeywordCxt;
  } });
  var codegen_12 = codegen;
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return codegen_12._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return codegen_12.str;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return codegen_12.stringify;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return codegen_12.nil;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return codegen_12.Name;
  } });
  Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
    return codegen_12.CodeGen;
  } });
  const validation_error_12 = validation_error;
  const ref_error_12 = ref_error;
  const rules_1 = rules;
  const compile_12 = compile;
  const codegen_2 = codegen;
  const resolve_12 = resolve$1;
  const dataType_12 = dataType;
  const util_12 = util;
  const $dataRefSchema = require$$9;
  const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
  const EXT_SCOPE_NAMES = new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]);
  const removedOptions = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  };
  const deprecatedOptions = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  };
  const MAX_EXPRESSION = 200;
  function requiredOptions(o) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
    const s2 = o.strict;
    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
    const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
    return {
      strictSchema: (_c = (_b = o.strictSchema) !== null && _b !== void 0 ? _b : s2) !== null && _c !== void 0 ? _c : true,
      strictNumbers: (_e = (_d = o.strictNumbers) !== null && _d !== void 0 ? _d : s2) !== null && _e !== void 0 ? _e : true,
      strictTypes: (_g = (_f = o.strictTypes) !== null && _f !== void 0 ? _f : s2) !== null && _g !== void 0 ? _g : "log",
      strictTuples: (_j = (_h = o.strictTuples) !== null && _h !== void 0 ? _h : s2) !== null && _j !== void 0 ? _j : "log",
      strictRequired: (_l = (_k = o.strictRequired) !== null && _k !== void 0 ? _k : s2) !== null && _l !== void 0 ? _l : false,
      code: o.code ? __spreadProps(__spreadValues({}, o.code), { optimize }) : { optimize },
      loopRequired: (_m = o.loopRequired) !== null && _m !== void 0 ? _m : MAX_EXPRESSION,
      loopEnum: (_o = o.loopEnum) !== null && _o !== void 0 ? _o : MAX_EXPRESSION,
      meta: (_p = o.meta) !== null && _p !== void 0 ? _p : true,
      messages: (_q = o.messages) !== null && _q !== void 0 ? _q : true,
      inlineRefs: (_r = o.inlineRefs) !== null && _r !== void 0 ? _r : true,
      schemaId: (_s = o.schemaId) !== null && _s !== void 0 ? _s : "$id",
      addUsedSchema: (_t = o.addUsedSchema) !== null && _t !== void 0 ? _t : true,
      validateSchema: (_u = o.validateSchema) !== null && _u !== void 0 ? _u : true,
      validateFormats: (_v = o.validateFormats) !== null && _v !== void 0 ? _v : true,
      unicodeRegExp: (_w = o.unicodeRegExp) !== null && _w !== void 0 ? _w : true,
      int32range: (_x = o.int32range) !== null && _x !== void 0 ? _x : true
    };
  }
  class Ajv {
    constructor(opts2 = {}) {
      this.schemas = {};
      this.refs = {};
      this.formats = {};
      this._compilations = new Set();
      this._loading = {};
      this._cache = new Map();
      opts2 = this.opts = __spreadValues(__spreadValues({}, opts2), requiredOptions(opts2));
      const { es5, lines } = this.opts.code;
      this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
      this.logger = getLogger(opts2.logger);
      const formatOpt = opts2.validateFormats;
      opts2.validateFormats = false;
      this.RULES = rules_1.getRules();
      checkOptions.call(this, removedOptions, opts2, "NOT SUPPORTED");
      checkOptions.call(this, deprecatedOptions, opts2, "DEPRECATED", "warn");
      this._metaOpts = getMetaSchemaOptions.call(this);
      if (opts2.formats)
        addInitialFormats.call(this);
      this._addVocabularies();
      this._addDefaultMetaSchema();
      if (opts2.keywords)
        addInitialKeywords.call(this, opts2.keywords);
      if (typeof opts2.meta == "object")
        this.addMetaSchema(opts2.meta);
      addInitialSchemas.call(this);
      opts2.validateFormats = formatOpt;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data, meta, schemaId } = this.opts;
      let _dataRefSchema = $dataRefSchema;
      if (schemaId === "id") {
        _dataRefSchema = __spreadValues({}, $dataRefSchema);
        _dataRefSchema.id = _dataRefSchema.$id;
        delete _dataRefSchema.$id;
      }
      if (meta && $data)
        this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
    }
    defaultMeta() {
      const { meta, schemaId } = this.opts;
      return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
    }
    validate(schemaKeyRef, data) {
      let v;
      if (typeof schemaKeyRef == "string") {
        v = this.getSchema(schemaKeyRef);
        if (!v)
          throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
      } else {
        v = this.compile(schemaKeyRef);
      }
      const valid2 = v(data);
      if (!("$async" in v))
        this.errors = v.errors;
      return valid2;
    }
    compile(schema2, _meta) {
      const sch = this._addSchema(schema2, _meta);
      return sch.validate || this._compileSchemaEnv(sch);
    }
    compileAsync(schema2, meta) {
      if (typeof this.opts.loadSchema != "function") {
        throw new Error("options.loadSchema should be a function");
      }
      const { loadSchema } = this.opts;
      return runCompileAsync.call(this, schema2, meta);
      async function runCompileAsync(_schema, _meta) {
        await loadMetaSchema.call(this, _schema.$schema);
        const sch = this._addSchema(_schema, _meta);
        return sch.validate || _compileAsync.call(this, sch);
      }
      async function loadMetaSchema($ref) {
        if ($ref && !this.getSchema($ref)) {
          await runCompileAsync.call(this, { $ref }, true);
        }
      }
      async function _compileAsync(sch) {
        try {
          return this._compileSchemaEnv(sch);
        } catch (e) {
          if (!(e instanceof ref_error_12.default))
            throw e;
          checkLoaded.call(this, e);
          await loadMissingSchema.call(this, e.missingSchema);
          return _compileAsync.call(this, sch);
        }
      }
      function checkLoaded({ missingSchema: ref2, missingRef }) {
        if (this.refs[ref2]) {
          throw new Error(`AnySchema ${ref2} is loaded but ${missingRef} cannot be resolved`);
        }
      }
      async function loadMissingSchema(ref2) {
        const _schema = await _loadSchema.call(this, ref2);
        if (!this.refs[ref2])
          await loadMetaSchema.call(this, _schema.$schema);
        if (!this.refs[ref2])
          this.addSchema(_schema, ref2, meta);
      }
      async function _loadSchema(ref2) {
        const p = this._loading[ref2];
        if (p)
          return p;
        try {
          return await (this._loading[ref2] = loadSchema(ref2));
        } finally {
          delete this._loading[ref2];
        }
      }
    }
    addSchema(schema2, key, _meta, _validateSchema = this.opts.validateSchema) {
      if (Array.isArray(schema2)) {
        for (const sch of schema2)
          this.addSchema(sch, void 0, _meta, _validateSchema);
        return this;
      }
      let id2;
      if (typeof schema2 === "object") {
        const { schemaId } = this.opts;
        id2 = schema2[schemaId];
        if (id2 !== void 0 && typeof id2 != "string") {
          throw new Error(`schema ${schemaId} must be string`);
        }
      }
      key = resolve_12.normalizeId(key || id2);
      this._checkUnique(key);
      this.schemas[key] = this._addSchema(schema2, _meta, key, _validateSchema, true);
      return this;
    }
    addMetaSchema(schema2, key, _validateSchema = this.opts.validateSchema) {
      this.addSchema(schema2, key, true, _validateSchema);
      return this;
    }
    validateSchema(schema2, throwOrLogError) {
      if (typeof schema2 == "boolean")
        return true;
      let $schema2;
      $schema2 = schema2.$schema;
      if ($schema2 !== void 0 && typeof $schema2 != "string") {
        throw new Error("$schema must be a string");
      }
      $schema2 = $schema2 || this.opts.defaultMeta || this.defaultMeta();
      if (!$schema2) {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
      }
      const valid2 = this.validate($schema2, schema2);
      if (!valid2 && throwOrLogError) {
        const message = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(message);
        else
          throw new Error(message);
      }
      return valid2;
    }
    getSchema(keyRef) {
      let sch;
      while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
        keyRef = sch;
      if (sch === void 0) {
        const { schemaId } = this.opts;
        const root2 = new compile_12.SchemaEnv({ schema: {}, schemaId });
        sch = compile_12.resolveSchema.call(this, root2, keyRef);
        if (!sch)
          return;
        this.refs[keyRef] = sch;
      }
      return sch.validate || this._compileSchemaEnv(sch);
    }
    removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        this._removeAllSchemas(this.schemas, schemaKeyRef);
        this._removeAllSchemas(this.refs, schemaKeyRef);
        return this;
      }
      switch (typeof schemaKeyRef) {
        case "undefined":
          this._removeAllSchemas(this.schemas);
          this._removeAllSchemas(this.refs);
          this._cache.clear();
          return this;
        case "string": {
          const sch = getSchEnv.call(this, schemaKeyRef);
          if (typeof sch == "object")
            this._cache.delete(sch.schema);
          delete this.schemas[schemaKeyRef];
          delete this.refs[schemaKeyRef];
          return this;
        }
        case "object": {
          const cacheKey = schemaKeyRef;
          this._cache.delete(cacheKey);
          let id2 = schemaKeyRef[this.opts.schemaId];
          if (id2) {
            id2 = resolve_12.normalizeId(id2);
            delete this.schemas[id2];
            delete this.refs[id2];
          }
          return this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    addVocabulary(definitions2) {
      for (const def2 of definitions2)
        this.addKeyword(def2);
      return this;
    }
    addKeyword(kwdOrDef, def2) {
      let keyword2;
      if (typeof kwdOrDef == "string") {
        keyword2 = kwdOrDef;
        if (typeof def2 == "object") {
          this.logger.warn("these parameters are deprecated, see docs for addKeyword");
          def2.keyword = keyword2;
        }
      } else if (typeof kwdOrDef == "object" && def2 === void 0) {
        def2 = kwdOrDef;
        keyword2 = def2.keyword;
        if (Array.isArray(keyword2) && !keyword2.length) {
          throw new Error("addKeywords: keyword must be string or non-empty array");
        }
      } else {
        throw new Error("invalid addKeywords parameters");
      }
      checkKeyword.call(this, keyword2, def2);
      if (!def2) {
        util_12.eachItem(keyword2, (kwd) => addRule.call(this, kwd));
        return this;
      }
      keywordMetaschema.call(this, def2);
      const definition = __spreadProps(__spreadValues({}, def2), {
        type: dataType_12.getJSONTypes(def2.type),
        schemaType: dataType_12.getJSONTypes(def2.schemaType)
      });
      util_12.eachItem(keyword2, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t2) => addRule.call(this, k, definition, t2)));
      return this;
    }
    getKeyword(keyword2) {
      const rule = this.RULES.all[keyword2];
      return typeof rule == "object" ? rule.definition : !!rule;
    }
    removeKeyword(keyword2) {
      const { RULES } = this;
      delete RULES.keywords[keyword2];
      delete RULES.all[keyword2];
      for (const group of RULES.rules) {
        const i2 = group.rules.findIndex((rule) => rule.keyword === keyword2);
        if (i2 >= 0)
          group.rules.splice(i2, 1);
      }
      return this;
    }
    addFormat(name, format2) {
      if (typeof format2 == "string")
        format2 = new RegExp(format2);
      this.formats[name] = format2;
      return this;
    }
    errorsText(errors2 = this.errors, { separator = ", ", dataVar = "data" } = {}) {
      if (!errors2 || errors2.length === 0)
        return "No errors";
      return errors2.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
    }
    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
      const rules2 = this.RULES.all;
      metaSchema = JSON.parse(JSON.stringify(metaSchema));
      for (const jsonPointer of keywordsJsonPointers) {
        const segments = jsonPointer.split("/").slice(1);
        let keywords = metaSchema;
        for (const seg of segments)
          keywords = keywords[seg];
        for (const key in rules2) {
          const rule = rules2[key];
          if (typeof rule != "object")
            continue;
          const { $data } = rule.definition;
          const schema2 = keywords[key];
          if ($data && schema2)
            keywords[key] = schemaOrData(schema2);
        }
      }
      return metaSchema;
    }
    _removeAllSchemas(schemas, regex) {
      for (const keyRef in schemas) {
        const sch = schemas[keyRef];
        if (!regex || regex.test(keyRef)) {
          if (typeof sch == "string") {
            delete schemas[keyRef];
          } else if (sch && !sch.meta) {
            this._cache.delete(sch.schema);
            delete schemas[keyRef];
          }
        }
      }
    }
    _addSchema(schema2, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
      let id2;
      const { schemaId } = this.opts;
      if (typeof schema2 == "object") {
        id2 = schema2[schemaId];
      } else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        else if (typeof schema2 != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let sch = this._cache.get(schema2);
      if (sch !== void 0)
        return sch;
      const localRefs = resolve_12.getSchemaRefs.call(this, schema2);
      baseId = resolve_12.normalizeId(id2 || baseId);
      sch = new compile_12.SchemaEnv({ schema: schema2, schemaId, meta, baseId, localRefs });
      this._cache.set(sch.schema, sch);
      if (addSchema && !baseId.startsWith("#")) {
        if (baseId)
          this._checkUnique(baseId);
        this.refs[baseId] = sch;
      }
      if (validateSchema)
        this.validateSchema(schema2, true);
      return sch;
    }
    _checkUnique(id2) {
      if (this.schemas[id2] || this.refs[id2]) {
        throw new Error(`schema with key or id "${id2}" already exists`);
      }
    }
    _compileSchemaEnv(sch) {
      if (sch.meta)
        this._compileMetaSchema(sch);
      else
        compile_12.compileSchema.call(this, sch);
      if (!sch.validate)
        throw new Error("ajv implementation error");
      return sch.validate;
    }
    _compileMetaSchema(sch) {
      const currentOpts = this.opts;
      this.opts = this._metaOpts;
      try {
        compile_12.compileSchema.call(this, sch);
      } finally {
        this.opts = currentOpts;
      }
    }
  }
  exports.default = Ajv;
  Ajv.ValidationError = validation_error_12.default;
  Ajv.MissingRefError = ref_error_12.default;
  function checkOptions(checkOpts, options, msg, log = "error") {
    for (const key in checkOpts) {
      const opt = key;
      if (opt in options)
        this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
    }
  }
  function getSchEnv(keyRef) {
    keyRef = resolve_12.normalizeId(keyRef);
    return this.schemas[keyRef] || this.refs[keyRef];
  }
  function addInitialSchemas() {
    const optsSchemas = this.opts.schemas;
    if (!optsSchemas)
      return;
    if (Array.isArray(optsSchemas))
      this.addSchema(optsSchemas);
    else
      for (const key in optsSchemas)
        this.addSchema(optsSchemas[key], key);
  }
  function addInitialFormats() {
    for (const name in this.opts.formats) {
      const format2 = this.opts.formats[name];
      if (format2)
        this.addFormat(name, format2);
    }
  }
  function addInitialKeywords(defs) {
    if (Array.isArray(defs)) {
      this.addVocabulary(defs);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const keyword2 in defs) {
      const def2 = defs[keyword2];
      if (!def2.keyword)
        def2.keyword = keyword2;
      this.addKeyword(def2);
    }
  }
  function getMetaSchemaOptions() {
    const metaOpts = __spreadValues({}, this.opts);
    for (const opt of META_IGNORE_OPTIONS)
      delete metaOpts[opt];
    return metaOpts;
  }
  const noLogs = { log() {
  }, warn() {
  }, error() {
  } };
  function getLogger(logger) {
    if (logger === false)
      return noLogs;
    if (logger === void 0)
      return console;
    if (logger.log && logger.warn && logger.error)
      return logger;
    throw new Error("logger must implement log, warn and error methods");
  }
  const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
  function checkKeyword(keyword2, def2) {
    const { RULES } = this;
    util_12.eachItem(keyword2, (kwd) => {
      if (RULES.keywords[kwd])
        throw new Error(`Keyword ${kwd} is already defined`);
      if (!KEYWORD_NAME.test(kwd))
        throw new Error(`Keyword ${kwd} has invalid name`);
    });
    if (!def2)
      return;
    if (def2.$data && !("code" in def2 || "validate" in def2)) {
      throw new Error('$data keyword must have "code" or "validate" function');
    }
  }
  function addRule(keyword2, definition, dataType2) {
    var _a;
    const post = definition === null || definition === void 0 ? void 0 : definition.post;
    if (dataType2 && post)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES } = this;
    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t2 }) => t2 === dataType2);
    if (!ruleGroup) {
      ruleGroup = { type: dataType2, rules: [] };
      RULES.rules.push(ruleGroup);
    }
    RULES.keywords[keyword2] = true;
    if (!definition)
      return;
    const rule = {
      keyword: keyword2,
      definition: __spreadProps(__spreadValues({}, definition), {
        type: dataType_12.getJSONTypes(definition.type),
        schemaType: dataType_12.getJSONTypes(definition.schemaType)
      })
    };
    if (definition.before)
      addBeforeRule.call(this, ruleGroup, rule, definition.before);
    else
      ruleGroup.rules.push(rule);
    RULES.all[keyword2] = rule;
    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
  }
  function addBeforeRule(ruleGroup, rule, before) {
    const i2 = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
    if (i2 >= 0) {
      ruleGroup.rules.splice(i2, 0, rule);
    } else {
      ruleGroup.rules.push(rule);
      this.logger.warn(`rule ${before} is not defined`);
    }
  }
  function keywordMetaschema(def2) {
    let { metaSchema } = def2;
    if (metaSchema === void 0)
      return;
    if (def2.$data && this.opts.$data)
      metaSchema = schemaOrData(metaSchema);
    def2.validateSchema = this.compile(metaSchema, true);
  }
  const $dataRef = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function schemaOrData(schema2) {
    return { anyOf: [schema2, $dataRef] };
  }
})(core$2);
var draft7 = {};
var core$1 = {};
var id = {};
Object.defineProperty(id, "__esModule", { value: true });
const def$s = {
  keyword: "id",
  code() {
    throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  }
};
id.default = def$s;
var ref = {};
Object.defineProperty(ref, "__esModule", { value: true });
ref.callRef = ref.getValidate = void 0;
const ref_error_1 = ref_error;
const code_1$8 = code;
const codegen_1$l = codegen;
const names_1$1 = names$1;
const compile_1 = compile;
const util_1$i = util;
const def$r = {
  keyword: "$ref",
  schemaType: "string",
  code(cxt) {
    const { gen, schema: $ref, it } = cxt;
    const { baseId, schemaEnv: env2, validateName, opts: opts2, self: self2 } = it;
    const { root: root2 } = env2;
    if (($ref === "#" || $ref === "#/") && baseId === root2.baseId)
      return callRootRef();
    const schOrEnv = compile_1.resolveRef.call(self2, root2, baseId, $ref);
    if (schOrEnv === void 0)
      throw new ref_error_1.default(baseId, $ref);
    if (schOrEnv instanceof compile_1.SchemaEnv)
      return callValidate(schOrEnv);
    return inlineRefSchema(schOrEnv);
    function callRootRef() {
      if (env2 === root2)
        return callRef(cxt, validateName, env2, env2.$async);
      const rootName = gen.scopeValue("root", { ref: root2 });
      return callRef(cxt, codegen_1$l._`${rootName}.validate`, root2, root2.$async);
    }
    function callValidate(sch) {
      const v = getValidate(cxt, sch);
      callRef(cxt, v, sch, sch.$async);
    }
    function inlineRefSchema(sch) {
      const schName = gen.scopeValue("schema", opts2.code.source === true ? { ref: sch, code: codegen_1$l.stringify(sch) } : { ref: sch });
      const valid2 = gen.name("valid");
      const schCxt = cxt.subschema({
        schema: sch,
        dataTypes: [],
        schemaPath: codegen_1$l.nil,
        topSchemaRef: schName,
        errSchemaPath: $ref
      }, valid2);
      cxt.mergeEvaluated(schCxt);
      cxt.ok(valid2);
    }
  }
};
function getValidate(cxt, sch) {
  const { gen } = cxt;
  return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : codegen_1$l._`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
}
ref.getValidate = getValidate;
function callRef(cxt, v, sch, $async) {
  const { gen, it } = cxt;
  const { allErrors, schemaEnv: env2, opts: opts2 } = it;
  const passCxt = opts2.passContext ? names_1$1.default.this : codegen_1$l.nil;
  if ($async)
    callAsyncRef();
  else
    callSyncRef();
  function callAsyncRef() {
    if (!env2.$async)
      throw new Error("async schema referenced by sync schema");
    const valid2 = gen.let("valid");
    gen.try(() => {
      gen.code(codegen_1$l._`await ${code_1$8.callValidateCode(cxt, v, passCxt)}`);
      addEvaluatedFrom(v);
      if (!allErrors)
        gen.assign(valid2, true);
    }, (e) => {
      gen.if(codegen_1$l._`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
      addErrorsFrom(e);
      if (!allErrors)
        gen.assign(valid2, false);
    });
    cxt.ok(valid2);
  }
  function callSyncRef() {
    cxt.result(code_1$8.callValidateCode(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
  }
  function addErrorsFrom(source2) {
    const errs = codegen_1$l._`${source2}.errors`;
    gen.assign(names_1$1.default.vErrors, codegen_1$l._`${names_1$1.default.vErrors} === null ? ${errs} : ${names_1$1.default.vErrors}.concat(${errs})`);
    gen.assign(names_1$1.default.errors, codegen_1$l._`${names_1$1.default.vErrors}.length`);
  }
  function addEvaluatedFrom(source2) {
    var _a;
    if (!it.opts.unevaluated)
      return;
    const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
    if (it.props !== true) {
      if (schEvaluated && !schEvaluated.dynamicProps) {
        if (schEvaluated.props !== void 0) {
          it.props = util_1$i.mergeEvaluated.props(gen, schEvaluated.props, it.props);
        }
      } else {
        const props = gen.var("props", codegen_1$l._`${source2}.evaluated.props`);
        it.props = util_1$i.mergeEvaluated.props(gen, props, it.props, codegen_1$l.Name);
      }
    }
    if (it.items !== true) {
      if (schEvaluated && !schEvaluated.dynamicItems) {
        if (schEvaluated.items !== void 0) {
          it.items = util_1$i.mergeEvaluated.items(gen, schEvaluated.items, it.items);
        }
      } else {
        const items2 = gen.var("items", codegen_1$l._`${source2}.evaluated.items`);
        it.items = util_1$i.mergeEvaluated.items(gen, items2, it.items, codegen_1$l.Name);
      }
    }
  }
}
ref.callRef = callRef;
ref.default = def$r;
Object.defineProperty(core$1, "__esModule", { value: true });
const id_1 = id;
const ref_1 = ref;
const core = [
  "$schema",
  "$id",
  "$defs",
  "$vocabulary",
  { keyword: "$comment" },
  "definitions",
  id_1.default,
  ref_1.default
];
core$1.default = core;
var validation$1 = {};
var limitNumber = {};
Object.defineProperty(limitNumber, "__esModule", { value: true });
const codegen_1$k = codegen;
const ops = codegen_1$k.operators;
const KWDs = {
  maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
  minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
  exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
  exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
};
const error$i = {
  message: ({ keyword: keyword2, schemaCode }) => codegen_1$k.str`must be ${KWDs[keyword2].okStr} ${schemaCode}`,
  params: ({ keyword: keyword2, schemaCode }) => codegen_1$k._`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
};
const def$q = {
  keyword: Object.keys(KWDs),
  type: "number",
  schemaType: "number",
  $data: true,
  error: error$i,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    cxt.fail$data(codegen_1$k._`${data} ${KWDs[keyword2].fail} ${schemaCode} || isNaN(${data})`);
  }
};
limitNumber.default = def$q;
var multipleOf = {};
Object.defineProperty(multipleOf, "__esModule", { value: true });
const codegen_1$j = codegen;
const error$h = {
  message: ({ schemaCode }) => codegen_1$j.str`must be multiple of ${schemaCode}`,
  params: ({ schemaCode }) => codegen_1$j._`{multipleOf: ${schemaCode}}`
};
const def$p = {
  keyword: "multipleOf",
  type: "number",
  schemaType: "number",
  $data: true,
  error: error$h,
  code(cxt) {
    const { gen, data, schemaCode, it } = cxt;
    const prec = it.opts.multipleOfPrecision;
    const res = gen.let("res");
    const invalid = prec ? codegen_1$j._`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : codegen_1$j._`${res} !== parseInt(${res})`;
    cxt.fail$data(codegen_1$j._`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
  }
};
multipleOf.default = def$p;
var limitLength = {};
var ucs2length$1 = {};
Object.defineProperty(ucs2length$1, "__esModule", { value: true });
function ucs2length(str2) {
  const len = str2.length;
  let length = 0;
  let pos = 0;
  let value;
  while (pos < len) {
    length++;
    value = str2.charCodeAt(pos++);
    if (value >= 55296 && value <= 56319 && pos < len) {
      value = str2.charCodeAt(pos);
      if ((value & 64512) === 56320)
        pos++;
    }
  }
  return length;
}
ucs2length$1.default = ucs2length;
ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
Object.defineProperty(limitLength, "__esModule", { value: true });
const codegen_1$i = codegen;
const util_1$h = util;
const ucs2length_1 = ucs2length$1;
const error$g = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxLength" ? "more" : "fewer";
    return codegen_1$i.str`must NOT have ${comp} than ${schemaCode} characters`;
  },
  params: ({ schemaCode }) => codegen_1$i._`{limit: ${schemaCode}}`
};
const def$o = {
  keyword: ["maxLength", "minLength"],
  type: "string",
  schemaType: "number",
  $data: true,
  error: error$g,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode, it } = cxt;
    const op = keyword2 === "maxLength" ? codegen_1$i.operators.GT : codegen_1$i.operators.LT;
    const len = it.opts.unicode === false ? codegen_1$i._`${data}.length` : codegen_1$i._`${util_1$h.useFunc(cxt.gen, ucs2length_1.default)}(${data})`;
    cxt.fail$data(codegen_1$i._`${len} ${op} ${schemaCode}`);
  }
};
limitLength.default = def$o;
var pattern = {};
Object.defineProperty(pattern, "__esModule", { value: true });
const code_1$7 = code;
const codegen_1$h = codegen;
const error$f = {
  message: ({ schemaCode }) => codegen_1$h.str`must match pattern "${schemaCode}"`,
  params: ({ schemaCode }) => codegen_1$h._`{pattern: ${schemaCode}}`
};
const def$n = {
  keyword: "pattern",
  type: "string",
  schemaType: "string",
  $data: true,
  error: error$f,
  code(cxt) {
    const { data, $data, schema: schema2, schemaCode, it } = cxt;
    const u2 = it.opts.unicodeRegExp ? "u" : "";
    const regExp = $data ? codegen_1$h._`(new RegExp(${schemaCode}, ${u2}))` : code_1$7.usePattern(cxt, schema2);
    cxt.fail$data(codegen_1$h._`!${regExp}.test(${data})`);
  }
};
pattern.default = def$n;
var limitProperties = {};
Object.defineProperty(limitProperties, "__esModule", { value: true });
const codegen_1$g = codegen;
const error$e = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxProperties" ? "more" : "fewer";
    return codegen_1$g.str`must NOT have ${comp} than ${schemaCode} items`;
  },
  params: ({ schemaCode }) => codegen_1$g._`{limit: ${schemaCode}}`
};
const def$m = {
  keyword: ["maxProperties", "minProperties"],
  type: "object",
  schemaType: "number",
  $data: true,
  error: error$e,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    const op = keyword2 === "maxProperties" ? codegen_1$g.operators.GT : codegen_1$g.operators.LT;
    cxt.fail$data(codegen_1$g._`Object.keys(${data}).length ${op} ${schemaCode}`);
  }
};
limitProperties.default = def$m;
var required = {};
Object.defineProperty(required, "__esModule", { value: true });
const code_1$6 = code;
const codegen_1$f = codegen;
const util_1$g = util;
const error$d = {
  message: ({ params: { missingProperty } }) => codegen_1$f.str`must have required property '${missingProperty}'`,
  params: ({ params: { missingProperty } }) => codegen_1$f._`{missingProperty: ${missingProperty}}`
};
const def$l = {
  keyword: "required",
  type: "object",
  schemaType: "array",
  $data: true,
  error: error$d,
  code(cxt) {
    const { gen, schema: schema2, schemaCode, data, $data, it } = cxt;
    const { opts: opts2 } = it;
    if (!$data && schema2.length === 0)
      return;
    const useLoop = schema2.length >= opts2.loopRequired;
    if (it.allErrors)
      allErrorsMode();
    else
      exitOnErrorMode();
    if (opts2.strictRequired) {
      const props = cxt.parentSchema.properties;
      const { definedProperties } = cxt.it;
      for (const requiredKey of schema2) {
        if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
          const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
          util_1$g.checkStrictMode(it, msg, it.opts.strictRequired);
        }
      }
    }
    function allErrorsMode() {
      if (useLoop || $data) {
        cxt.block$data(codegen_1$f.nil, loopAllRequired);
      } else {
        for (const prop of schema2) {
          code_1$6.checkReportMissingProp(cxt, prop);
        }
      }
    }
    function exitOnErrorMode() {
      const missing = gen.let("missing");
      if (useLoop || $data) {
        const valid2 = gen.let("valid", true);
        cxt.block$data(valid2, () => loopUntilMissing(missing, valid2));
        cxt.ok(valid2);
      } else {
        gen.if(code_1$6.checkMissingProp(cxt, schema2, missing));
        code_1$6.reportMissingProp(cxt, missing);
        gen.else();
      }
    }
    function loopAllRequired() {
      gen.forOf("prop", schemaCode, (prop) => {
        cxt.setParams({ missingProperty: prop });
        gen.if(code_1$6.noPropertyInData(gen, data, prop, opts2.ownProperties), () => cxt.error());
      });
    }
    function loopUntilMissing(missing, valid2) {
      cxt.setParams({ missingProperty: missing });
      gen.forOf(missing, schemaCode, () => {
        gen.assign(valid2, code_1$6.propertyInData(gen, data, missing, opts2.ownProperties));
        gen.if(codegen_1$f.not(valid2), () => {
          cxt.error();
          gen.break();
        });
      }, codegen_1$f.nil);
    }
  }
};
required.default = def$l;
var limitItems = {};
Object.defineProperty(limitItems, "__esModule", { value: true });
const codegen_1$e = codegen;
const error$c = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxItems" ? "more" : "fewer";
    return codegen_1$e.str`must NOT have ${comp} than ${schemaCode} items`;
  },
  params: ({ schemaCode }) => codegen_1$e._`{limit: ${schemaCode}}`
};
const def$k = {
  keyword: ["maxItems", "minItems"],
  type: "array",
  schemaType: "number",
  $data: true,
  error: error$c,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    const op = keyword2 === "maxItems" ? codegen_1$e.operators.GT : codegen_1$e.operators.LT;
    cxt.fail$data(codegen_1$e._`${data}.length ${op} ${schemaCode}`);
  }
};
limitItems.default = def$k;
var uniqueItems = {};
var equal$1 = {};
Object.defineProperty(equal$1, "__esModule", { value: true });
const equal = fastDeepEqual;
equal.code = 'require("ajv/dist/runtime/equal").default';
equal$1.default = equal;
Object.defineProperty(uniqueItems, "__esModule", { value: true });
const dataType_1 = dataType;
const codegen_1$d = codegen;
const util_1$f = util;
const equal_1$2 = equal$1;
const error$b = {
  message: ({ params: { i: i2, j } }) => codegen_1$d.str`must NOT have duplicate items (items ## ${j} and ${i2} are identical)`,
  params: ({ params: { i: i2, j } }) => codegen_1$d._`{i: ${i2}, j: ${j}}`
};
const def$j = {
  keyword: "uniqueItems",
  type: "array",
  schemaType: "boolean",
  $data: true,
  error: error$b,
  code(cxt) {
    const { gen, data, $data, schema: schema2, parentSchema, schemaCode, it } = cxt;
    if (!$data && !schema2)
      return;
    const valid2 = gen.let("valid");
    const itemTypes = parentSchema.items ? dataType_1.getSchemaTypes(parentSchema.items) : [];
    cxt.block$data(valid2, validateUniqueItems, codegen_1$d._`${schemaCode} === false`);
    cxt.ok(valid2);
    function validateUniqueItems() {
      const i2 = gen.let("i", codegen_1$d._`${data}.length`);
      const j = gen.let("j");
      cxt.setParams({ i: i2, j });
      gen.assign(valid2, true);
      gen.if(codegen_1$d._`${i2} > 1`, () => (canOptimize() ? loopN : loopN2)(i2, j));
    }
    function canOptimize() {
      return itemTypes.length > 0 && !itemTypes.some((t2) => t2 === "object" || t2 === "array");
    }
    function loopN(i2, j) {
      const item = gen.name("item");
      const wrongType = dataType_1.checkDataTypes(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
      const indices = gen.const("indices", codegen_1$d._`{}`);
      gen.for(codegen_1$d._`;${i2}--;`, () => {
        gen.let(item, codegen_1$d._`${data}[${i2}]`);
        gen.if(wrongType, codegen_1$d._`continue`);
        if (itemTypes.length > 1)
          gen.if(codegen_1$d._`typeof ${item} == "string"`, codegen_1$d._`${item} += "_"`);
        gen.if(codegen_1$d._`typeof ${indices}[${item}] == "number"`, () => {
          gen.assign(j, codegen_1$d._`${indices}[${item}]`);
          cxt.error();
          gen.assign(valid2, false).break();
        }).code(codegen_1$d._`${indices}[${item}] = ${i2}`);
      });
    }
    function loopN2(i2, j) {
      const eql = util_1$f.useFunc(gen, equal_1$2.default);
      const outer = gen.name("outer");
      gen.label(outer).for(codegen_1$d._`;${i2}--;`, () => gen.for(codegen_1$d._`${j} = ${i2}; ${j}--;`, () => gen.if(codegen_1$d._`${eql}(${data}[${i2}], ${data}[${j}])`, () => {
        cxt.error();
        gen.assign(valid2, false).break(outer);
      })));
    }
  }
};
uniqueItems.default = def$j;
var _const = {};
Object.defineProperty(_const, "__esModule", { value: true });
const codegen_1$c = codegen;
const util_1$e = util;
const equal_1$1 = equal$1;
const error$a = {
  message: "must be equal to constant",
  params: ({ schemaCode }) => codegen_1$c._`{allowedValue: ${schemaCode}}`
};
const def$i = {
  keyword: "const",
  $data: true,
  error: error$a,
  code(cxt) {
    const { gen, data, $data, schemaCode, schema: schema2 } = cxt;
    if ($data || schema2 && typeof schema2 == "object") {
      cxt.fail$data(codegen_1$c._`!${util_1$e.useFunc(gen, equal_1$1.default)}(${data}, ${schemaCode})`);
    } else {
      cxt.fail(codegen_1$c._`${schema2} !== ${data}`);
    }
  }
};
_const.default = def$i;
var _enum = {};
Object.defineProperty(_enum, "__esModule", { value: true });
const codegen_1$b = codegen;
const util_1$d = util;
const equal_1 = equal$1;
const error$9 = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode }) => codegen_1$b._`{allowedValues: ${schemaCode}}`
};
const def$h = {
  keyword: "enum",
  schemaType: "array",
  $data: true,
  error: error$9,
  code(cxt) {
    const { gen, data, $data, schema: schema2, schemaCode, it } = cxt;
    if (!$data && schema2.length === 0)
      throw new Error("enum must have non-empty array");
    const useLoop = schema2.length >= it.opts.loopEnum;
    const eql = util_1$d.useFunc(gen, equal_1.default);
    let valid2;
    if (useLoop || $data) {
      valid2 = gen.let("valid");
      cxt.block$data(valid2, loopEnum);
    } else {
      if (!Array.isArray(schema2))
        throw new Error("ajv implementation error");
      const vSchema = gen.const("vSchema", schemaCode);
      valid2 = codegen_1$b.or(...schema2.map((_x, i2) => equalCode(vSchema, i2)));
    }
    cxt.pass(valid2);
    function loopEnum() {
      gen.assign(valid2, false);
      gen.forOf("v", schemaCode, (v) => gen.if(codegen_1$b._`${eql}(${data}, ${v})`, () => gen.assign(valid2, true).break()));
    }
    function equalCode(vSchema, i2) {
      const sch = schema2[i2];
      return typeof sch === "object" && sch !== null ? codegen_1$b._`${eql}(${data}, ${vSchema}[${i2}])` : codegen_1$b._`${data} === ${sch}`;
    }
  }
};
_enum.default = def$h;
Object.defineProperty(validation$1, "__esModule", { value: true });
const limitNumber_1 = limitNumber;
const multipleOf_1 = multipleOf;
const limitLength_1 = limitLength;
const pattern_1 = pattern;
const limitProperties_1 = limitProperties;
const required_1 = required;
const limitItems_1 = limitItems;
const uniqueItems_1 = uniqueItems;
const const_1 = _const;
const enum_1 = _enum;
const validation = [
  limitNumber_1.default,
  multipleOf_1.default,
  limitLength_1.default,
  pattern_1.default,
  limitProperties_1.default,
  required_1.default,
  limitItems_1.default,
  uniqueItems_1.default,
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  const_1.default,
  enum_1.default
];
validation$1.default = validation;
var applicator = {};
var additionalItems = {};
Object.defineProperty(additionalItems, "__esModule", { value: true });
additionalItems.validateAdditionalItems = void 0;
const codegen_1$a = codegen;
const util_1$c = util;
const error$8 = {
  message: ({ params: { len } }) => codegen_1$a.str`must NOT have more than ${len} items`,
  params: ({ params: { len } }) => codegen_1$a._`{limit: ${len}}`
};
const def$g = {
  keyword: "additionalItems",
  type: "array",
  schemaType: ["boolean", "object"],
  before: "uniqueItems",
  error: error$8,
  code(cxt) {
    const { parentSchema, it } = cxt;
    const { items: items2 } = parentSchema;
    if (!Array.isArray(items2)) {
      util_1$c.checkStrictMode(it, '"additionalItems" is ignored when "items" is not an array of schemas');
      return;
    }
    validateAdditionalItems(cxt, items2);
  }
};
function validateAdditionalItems(cxt, items2) {
  const { gen, schema: schema2, data, keyword: keyword2, it } = cxt;
  it.items = true;
  const len = gen.const("len", codegen_1$a._`${data}.length`);
  if (schema2 === false) {
    cxt.setParams({ len: items2.length });
    cxt.pass(codegen_1$a._`${len} <= ${items2.length}`);
  } else if (typeof schema2 == "object" && !util_1$c.alwaysValidSchema(it, schema2)) {
    const valid2 = gen.var("valid", codegen_1$a._`${len} <= ${items2.length}`);
    gen.if(codegen_1$a.not(valid2), () => validateItems(valid2));
    cxt.ok(valid2);
  }
  function validateItems(valid2) {
    gen.forRange("i", items2.length, len, (i2) => {
      cxt.subschema({ keyword: keyword2, dataProp: i2, dataPropType: util_1$c.Type.Num }, valid2);
      if (!it.allErrors)
        gen.if(codegen_1$a.not(valid2), () => gen.break());
    });
  }
}
additionalItems.validateAdditionalItems = validateAdditionalItems;
additionalItems.default = def$g;
var prefixItems = {};
var items = {};
Object.defineProperty(items, "__esModule", { value: true });
items.validateTuple = void 0;
const codegen_1$9 = codegen;
const util_1$b = util;
const code_1$5 = code;
const def$f = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "array", "boolean"],
  before: "uniqueItems",
  code(cxt) {
    const { schema: schema2, it } = cxt;
    if (Array.isArray(schema2))
      return validateTuple(cxt, "additionalItems", schema2);
    it.items = true;
    if (util_1$b.alwaysValidSchema(it, schema2))
      return;
    cxt.ok(code_1$5.validateArray(cxt));
  }
};
function validateTuple(cxt, extraItems, schArr = cxt.schema) {
  const { gen, parentSchema, data, keyword: keyword2, it } = cxt;
  checkStrictTuple(parentSchema);
  if (it.opts.unevaluated && schArr.length && it.items !== true) {
    it.items = util_1$b.mergeEvaluated.items(gen, schArr.length, it.items);
  }
  const valid2 = gen.name("valid");
  const len = gen.const("len", codegen_1$9._`${data}.length`);
  schArr.forEach((sch, i2) => {
    if (util_1$b.alwaysValidSchema(it, sch))
      return;
    gen.if(codegen_1$9._`${len} > ${i2}`, () => cxt.subschema({
      keyword: keyword2,
      schemaProp: i2,
      dataProp: i2
    }, valid2));
    cxt.ok(valid2);
  });
  function checkStrictTuple(sch) {
    const { opts: opts2, errSchemaPath } = it;
    const l = schArr.length;
    const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
    if (opts2.strictTuples && !fullTuple) {
      const msg = `"${keyword2}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
      util_1$b.checkStrictMode(it, msg, opts2.strictTuples);
    }
  }
}
items.validateTuple = validateTuple;
items.default = def$f;
Object.defineProperty(prefixItems, "__esModule", { value: true });
const items_1$1 = items;
const def$e = {
  keyword: "prefixItems",
  type: "array",
  schemaType: ["array"],
  before: "uniqueItems",
  code: (cxt) => items_1$1.validateTuple(cxt, "items")
};
prefixItems.default = def$e;
var items2020 = {};
Object.defineProperty(items2020, "__esModule", { value: true });
const codegen_1$8 = codegen;
const util_1$a = util;
const code_1$4 = code;
const additionalItems_1$1 = additionalItems;
const error$7 = {
  message: ({ params: { len } }) => codegen_1$8.str`must NOT have more than ${len} items`,
  params: ({ params: { len } }) => codegen_1$8._`{limit: ${len}}`
};
const def$d = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  error: error$7,
  code(cxt) {
    const { schema: schema2, parentSchema, it } = cxt;
    const { prefixItems: prefixItems2 } = parentSchema;
    it.items = true;
    if (util_1$a.alwaysValidSchema(it, schema2))
      return;
    if (prefixItems2)
      additionalItems_1$1.validateAdditionalItems(cxt, prefixItems2);
    else
      cxt.ok(code_1$4.validateArray(cxt));
  }
};
items2020.default = def$d;
var contains = {};
Object.defineProperty(contains, "__esModule", { value: true });
const codegen_1$7 = codegen;
const util_1$9 = util;
const error$6 = {
  message: ({ params: { min, max } }) => max === void 0 ? codegen_1$7.str`must contain at least ${min} valid item(s)` : codegen_1$7.str`must contain at least ${min} and no more than ${max} valid item(s)`,
  params: ({ params: { min, max } }) => max === void 0 ? codegen_1$7._`{minContains: ${min}}` : codegen_1$7._`{minContains: ${min}, maxContains: ${max}}`
};
const def$c = {
  keyword: "contains",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  trackErrors: true,
  error: error$6,
  code(cxt) {
    const { gen, schema: schema2, parentSchema, data, it } = cxt;
    let min;
    let max;
    const { minContains, maxContains } = parentSchema;
    if (it.opts.next) {
      min = minContains === void 0 ? 1 : minContains;
      max = maxContains;
    } else {
      min = 1;
    }
    const len = gen.const("len", codegen_1$7._`${data}.length`);
    cxt.setParams({ min, max });
    if (max === void 0 && min === 0) {
      util_1$9.checkStrictMode(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
      return;
    }
    if (max !== void 0 && min > max) {
      util_1$9.checkStrictMode(it, `"minContains" > "maxContains" is always invalid`);
      cxt.fail();
      return;
    }
    if (util_1$9.alwaysValidSchema(it, schema2)) {
      let cond = codegen_1$7._`${len} >= ${min}`;
      if (max !== void 0)
        cond = codegen_1$7._`${cond} && ${len} <= ${max}`;
      cxt.pass(cond);
      return;
    }
    it.items = true;
    const valid2 = gen.name("valid");
    if (max === void 0 && min === 1) {
      validateItems(valid2, () => gen.if(valid2, () => gen.break()));
    } else {
      gen.let(valid2, false);
      const schValid = gen.name("_valid");
      const count = gen.let("count", 0);
      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
    }
    cxt.result(valid2, () => cxt.reset());
    function validateItems(_valid, block) {
      gen.forRange("i", 0, len, (i2) => {
        cxt.subschema({
          keyword: "contains",
          dataProp: i2,
          dataPropType: util_1$9.Type.Num,
          compositeRule: true
        }, _valid);
        block();
      });
    }
    function checkLimits(count) {
      gen.code(codegen_1$7._`${count}++`);
      if (max === void 0) {
        gen.if(codegen_1$7._`${count} >= ${min}`, () => gen.assign(valid2, true).break());
      } else {
        gen.if(codegen_1$7._`${count} > ${max}`, () => gen.assign(valid2, false).break());
        if (min === 1)
          gen.assign(valid2, true);
        else
          gen.if(codegen_1$7._`${count} >= ${min}`, () => gen.assign(valid2, true));
      }
    }
  }
};
contains.default = def$c;
var dependencies = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
  const codegen_12 = codegen;
  const util_12 = util;
  const code_12 = code;
  exports.error = {
    message: ({ params: { property, depsCount, deps } }) => {
      const property_ies = depsCount === 1 ? "property" : "properties";
      return codegen_12.str`must have ${property_ies} ${deps} when property ${property} is present`;
    },
    params: ({ params: { property, depsCount, deps, missingProperty } }) => codegen_12._`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
  };
  const def2 = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: exports.error,
    code(cxt) {
      const [propDeps, schDeps] = splitDependencies(cxt);
      validatePropertyDeps(cxt, propDeps);
      validateSchemaDeps(cxt, schDeps);
    }
  };
  function splitDependencies({ schema: schema2 }) {
    const propertyDeps = {};
    const schemaDeps = {};
    for (const key in schema2) {
      if (key === "__proto__")
        continue;
      const deps = Array.isArray(schema2[key]) ? propertyDeps : schemaDeps;
      deps[key] = schema2[key];
    }
    return [propertyDeps, schemaDeps];
  }
  function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
    const { gen, data, it } = cxt;
    if (Object.keys(propertyDeps).length === 0)
      return;
    const missing = gen.let("missing");
    for (const prop in propertyDeps) {
      const deps = propertyDeps[prop];
      if (deps.length === 0)
        continue;
      const hasProperty = code_12.propertyInData(gen, data, prop, it.opts.ownProperties);
      cxt.setParams({
        property: prop,
        depsCount: deps.length,
        deps: deps.join(", ")
      });
      if (it.allErrors) {
        gen.if(hasProperty, () => {
          for (const depProp of deps) {
            code_12.checkReportMissingProp(cxt, depProp);
          }
        });
      } else {
        gen.if(codegen_12._`${hasProperty} && (${code_12.checkMissingProp(cxt, deps, missing)})`);
        code_12.reportMissingProp(cxt, missing);
        gen.else();
      }
    }
  }
  exports.validatePropertyDeps = validatePropertyDeps;
  function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
    const { gen, data, keyword: keyword2, it } = cxt;
    const valid2 = gen.name("valid");
    for (const prop in schemaDeps) {
      if (util_12.alwaysValidSchema(it, schemaDeps[prop]))
        continue;
      gen.if(code_12.propertyInData(gen, data, prop, it.opts.ownProperties), () => {
        const schCxt = cxt.subschema({ keyword: keyword2, schemaProp: prop }, valid2);
        cxt.mergeValidEvaluated(schCxt, valid2);
      }, () => gen.var(valid2, true));
      cxt.ok(valid2);
    }
  }
  exports.validateSchemaDeps = validateSchemaDeps;
  exports.default = def2;
})(dependencies);
var propertyNames = {};
Object.defineProperty(propertyNames, "__esModule", { value: true });
const codegen_1$6 = codegen;
const util_1$8 = util;
const error$5 = {
  message: "property name must be valid",
  params: ({ params }) => codegen_1$6._`{propertyName: ${params.propertyName}}`
};
const def$b = {
  keyword: "propertyNames",
  type: "object",
  schemaType: ["object", "boolean"],
  error: error$5,
  code(cxt) {
    const { gen, schema: schema2, data, it } = cxt;
    if (util_1$8.alwaysValidSchema(it, schema2))
      return;
    const valid2 = gen.name("valid");
    gen.forIn("key", data, (key) => {
      cxt.setParams({ propertyName: key });
      cxt.subschema({
        keyword: "propertyNames",
        data: key,
        dataTypes: ["string"],
        propertyName: key,
        compositeRule: true
      }, valid2);
      gen.if(codegen_1$6.not(valid2), () => {
        cxt.error(true);
        if (!it.allErrors)
          gen.break();
      });
    });
    cxt.ok(valid2);
  }
};
propertyNames.default = def$b;
var additionalProperties = {};
Object.defineProperty(additionalProperties, "__esModule", { value: true });
const code_1$3 = code;
const codegen_1$5 = codegen;
const names_1 = names$1;
const util_1$7 = util;
const error$4 = {
  message: "must NOT have additional properties",
  params: ({ params }) => codegen_1$5._`{additionalProperty: ${params.additionalProperty}}`
};
const def$a = {
  keyword: "additionalProperties",
  type: ["object"],
  schemaType: ["boolean", "object"],
  allowUndefined: true,
  trackErrors: true,
  error: error$4,
  code(cxt) {
    const { gen, schema: schema2, parentSchema, data, errsCount, it } = cxt;
    if (!errsCount)
      throw new Error("ajv implementation error");
    const { allErrors, opts: opts2 } = it;
    it.props = true;
    if (opts2.removeAdditional !== "all" && util_1$7.alwaysValidSchema(it, schema2))
      return;
    const props = code_1$3.allSchemaProperties(parentSchema.properties);
    const patProps = code_1$3.allSchemaProperties(parentSchema.patternProperties);
    checkAdditionalProperties();
    cxt.ok(codegen_1$5._`${errsCount} === ${names_1.default.errors}`);
    function checkAdditionalProperties() {
      gen.forIn("key", data, (key) => {
        if (!props.length && !patProps.length)
          additionalPropertyCode(key);
        else
          gen.if(isAdditional(key), () => additionalPropertyCode(key));
      });
    }
    function isAdditional(key) {
      let definedProp;
      if (props.length > 8) {
        const propsSchema = util_1$7.schemaRefOrVal(it, parentSchema.properties, "properties");
        definedProp = code_1$3.isOwnProperty(gen, propsSchema, key);
      } else if (props.length) {
        definedProp = codegen_1$5.or(...props.map((p) => codegen_1$5._`${key} === ${p}`));
      } else {
        definedProp = codegen_1$5.nil;
      }
      if (patProps.length) {
        definedProp = codegen_1$5.or(definedProp, ...patProps.map((p) => codegen_1$5._`${code_1$3.usePattern(cxt, p)}.test(${key})`));
      }
      return codegen_1$5.not(definedProp);
    }
    function deleteAdditional(key) {
      gen.code(codegen_1$5._`delete ${data}[${key}]`);
    }
    function additionalPropertyCode(key) {
      if (opts2.removeAdditional === "all" || opts2.removeAdditional && schema2 === false) {
        deleteAdditional(key);
        return;
      }
      if (schema2 === false) {
        cxt.setParams({ additionalProperty: key });
        cxt.error();
        if (!allErrors)
          gen.break();
        return;
      }
      if (typeof schema2 == "object" && !util_1$7.alwaysValidSchema(it, schema2)) {
        const valid2 = gen.name("valid");
        if (opts2.removeAdditional === "failing") {
          applyAdditionalSchema(key, valid2, false);
          gen.if(codegen_1$5.not(valid2), () => {
            cxt.reset();
            deleteAdditional(key);
          });
        } else {
          applyAdditionalSchema(key, valid2);
          if (!allErrors)
            gen.if(codegen_1$5.not(valid2), () => gen.break());
        }
      }
    }
    function applyAdditionalSchema(key, valid2, errors2) {
      const subschema2 = {
        keyword: "additionalProperties",
        dataProp: key,
        dataPropType: util_1$7.Type.Str
      };
      if (errors2 === false) {
        Object.assign(subschema2, {
          compositeRule: true,
          createErrors: false,
          allErrors: false
        });
      }
      cxt.subschema(subschema2, valid2);
    }
  }
};
additionalProperties.default = def$a;
var properties$1 = {};
Object.defineProperty(properties$1, "__esModule", { value: true });
const validate_1 = validate;
const code_1$2 = code;
const util_1$6 = util;
const additionalProperties_1$1 = additionalProperties;
const def$9 = {
  keyword: "properties",
  type: "object",
  schemaType: "object",
  code(cxt) {
    const { gen, schema: schema2, parentSchema, data, it } = cxt;
    if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
      additionalProperties_1$1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1$1.default, "additionalProperties"));
    }
    const allProps = code_1$2.allSchemaProperties(schema2);
    for (const prop of allProps) {
      it.definedProperties.add(prop);
    }
    if (it.opts.unevaluated && allProps.length && it.props !== true) {
      it.props = util_1$6.mergeEvaluated.props(gen, util_1$6.toHash(allProps), it.props);
    }
    const properties2 = allProps.filter((p) => !util_1$6.alwaysValidSchema(it, schema2[p]));
    if (properties2.length === 0)
      return;
    const valid2 = gen.name("valid");
    for (const prop of properties2) {
      if (hasDefault(prop)) {
        applyPropertySchema(prop);
      } else {
        gen.if(code_1$2.propertyInData(gen, data, prop, it.opts.ownProperties));
        applyPropertySchema(prop);
        if (!it.allErrors)
          gen.else().var(valid2, true);
        gen.endIf();
      }
      cxt.it.definedProperties.add(prop);
      cxt.ok(valid2);
    }
    function hasDefault(prop) {
      return it.opts.useDefaults && !it.compositeRule && schema2[prop].default !== void 0;
    }
    function applyPropertySchema(prop) {
      cxt.subschema({
        keyword: "properties",
        schemaProp: prop,
        dataProp: prop
      }, valid2);
    }
  }
};
properties$1.default = def$9;
var patternProperties = {};
Object.defineProperty(patternProperties, "__esModule", { value: true });
const code_1$1 = code;
const codegen_1$4 = codegen;
const util_1$5 = util;
const util_2 = util;
const def$8 = {
  keyword: "patternProperties",
  type: "object",
  schemaType: "object",
  code(cxt) {
    const { gen, schema: schema2, data, parentSchema, it } = cxt;
    const { opts: opts2 } = it;
    const patterns = code_1$1.allSchemaProperties(schema2);
    const alwaysValidPatterns = patterns.filter((p) => util_1$5.alwaysValidSchema(it, schema2[p]));
    if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
      return;
    }
    const checkProperties = opts2.strictSchema && !opts2.allowMatchingProperties && parentSchema.properties;
    const valid2 = gen.name("valid");
    if (it.props !== true && !(it.props instanceof codegen_1$4.Name)) {
      it.props = util_2.evaluatedPropsToName(gen, it.props);
    }
    const { props } = it;
    validatePatternProperties();
    function validatePatternProperties() {
      for (const pat of patterns) {
        if (checkProperties)
          checkMatchingProperties(pat);
        if (it.allErrors) {
          validateProperties(pat);
        } else {
          gen.var(valid2, true);
          validateProperties(pat);
          gen.if(valid2);
        }
      }
    }
    function checkMatchingProperties(pat) {
      for (const prop in checkProperties) {
        if (new RegExp(pat).test(prop)) {
          util_1$5.checkStrictMode(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
        }
      }
    }
    function validateProperties(pat) {
      gen.forIn("key", data, (key) => {
        gen.if(codegen_1$4._`${code_1$1.usePattern(cxt, pat)}.test(${key})`, () => {
          const alwaysValid = alwaysValidPatterns.includes(pat);
          if (!alwaysValid) {
            cxt.subschema({
              keyword: "patternProperties",
              schemaProp: pat,
              dataProp: key,
              dataPropType: util_2.Type.Str
            }, valid2);
          }
          if (it.opts.unevaluated && props !== true) {
            gen.assign(codegen_1$4._`${props}[${key}]`, true);
          } else if (!alwaysValid && !it.allErrors) {
            gen.if(codegen_1$4.not(valid2), () => gen.break());
          }
        });
      });
    }
  }
};
patternProperties.default = def$8;
var not = {};
Object.defineProperty(not, "__esModule", { value: true });
const util_1$4 = util;
const def$7 = {
  keyword: "not",
  schemaType: ["object", "boolean"],
  trackErrors: true,
  code(cxt) {
    const { gen, schema: schema2, it } = cxt;
    if (util_1$4.alwaysValidSchema(it, schema2)) {
      cxt.fail();
      return;
    }
    const valid2 = gen.name("valid");
    cxt.subschema({
      keyword: "not",
      compositeRule: true,
      createErrors: false,
      allErrors: false
    }, valid2);
    cxt.failResult(valid2, () => cxt.reset(), () => cxt.error());
  },
  error: { message: "must NOT be valid" }
};
not.default = def$7;
var anyOf = {};
Object.defineProperty(anyOf, "__esModule", { value: true });
const code_1 = code;
const def$6 = {
  keyword: "anyOf",
  schemaType: "array",
  trackErrors: true,
  code: code_1.validateUnion,
  error: { message: "must match a schema in anyOf" }
};
anyOf.default = def$6;
var oneOf = {};
Object.defineProperty(oneOf, "__esModule", { value: true });
const codegen_1$3 = codegen;
const util_1$3 = util;
const error$3 = {
  message: "must match exactly one schema in oneOf",
  params: ({ params }) => codegen_1$3._`{passingSchemas: ${params.passing}}`
};
const def$5 = {
  keyword: "oneOf",
  schemaType: "array",
  trackErrors: true,
  error: error$3,
  code(cxt) {
    const { gen, schema: schema2, parentSchema, it } = cxt;
    if (!Array.isArray(schema2))
      throw new Error("ajv implementation error");
    if (it.opts.discriminator && parentSchema.discriminator)
      return;
    const schArr = schema2;
    const valid2 = gen.let("valid", false);
    const passing = gen.let("passing", null);
    const schValid = gen.name("_valid");
    cxt.setParams({ passing });
    gen.block(validateOneOf);
    cxt.result(valid2, () => cxt.reset(), () => cxt.error(true));
    function validateOneOf() {
      schArr.forEach((sch, i2) => {
        let schCxt;
        if (util_1$3.alwaysValidSchema(it, sch)) {
          gen.var(schValid, true);
        } else {
          schCxt = cxt.subschema({
            keyword: "oneOf",
            schemaProp: i2,
            compositeRule: true
          }, schValid);
        }
        if (i2 > 0) {
          gen.if(codegen_1$3._`${schValid} && ${valid2}`).assign(valid2, false).assign(passing, codegen_1$3._`[${passing}, ${i2}]`).else();
        }
        gen.if(schValid, () => {
          gen.assign(valid2, true);
          gen.assign(passing, i2);
          if (schCxt)
            cxt.mergeEvaluated(schCxt, codegen_1$3.Name);
        });
      });
    }
  }
};
oneOf.default = def$5;
var allOf = {};
Object.defineProperty(allOf, "__esModule", { value: true });
const util_1$2 = util;
const def$4 = {
  keyword: "allOf",
  schemaType: "array",
  code(cxt) {
    const { gen, schema: schema2, it } = cxt;
    if (!Array.isArray(schema2))
      throw new Error("ajv implementation error");
    const valid2 = gen.name("valid");
    schema2.forEach((sch, i2) => {
      if (util_1$2.alwaysValidSchema(it, sch))
        return;
      const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i2 }, valid2);
      cxt.ok(valid2);
      cxt.mergeEvaluated(schCxt);
    });
  }
};
allOf.default = def$4;
var _if = {};
Object.defineProperty(_if, "__esModule", { value: true });
const codegen_1$2 = codegen;
const util_1$1 = util;
const error$2 = {
  message: ({ params }) => codegen_1$2.str`must match "${params.ifClause}" schema`,
  params: ({ params }) => codegen_1$2._`{failingKeyword: ${params.ifClause}}`
};
const def$3 = {
  keyword: "if",
  schemaType: ["object", "boolean"],
  trackErrors: true,
  error: error$2,
  code(cxt) {
    const { gen, parentSchema, it } = cxt;
    if (parentSchema.then === void 0 && parentSchema.else === void 0) {
      util_1$1.checkStrictMode(it, '"if" without "then" and "else" is ignored');
    }
    const hasThen = hasSchema(it, "then");
    const hasElse = hasSchema(it, "else");
    if (!hasThen && !hasElse)
      return;
    const valid2 = gen.let("valid", true);
    const schValid = gen.name("_valid");
    validateIf();
    cxt.reset();
    if (hasThen && hasElse) {
      const ifClause = gen.let("ifClause");
      cxt.setParams({ ifClause });
      gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
    } else if (hasThen) {
      gen.if(schValid, validateClause("then"));
    } else {
      gen.if(codegen_1$2.not(schValid), validateClause("else"));
    }
    cxt.pass(valid2, () => cxt.error(true));
    function validateIf() {
      const schCxt = cxt.subschema({
        keyword: "if",
        compositeRule: true,
        createErrors: false,
        allErrors: false
      }, schValid);
      cxt.mergeEvaluated(schCxt);
    }
    function validateClause(keyword2, ifClause) {
      return () => {
        const schCxt = cxt.subschema({ keyword: keyword2 }, schValid);
        gen.assign(valid2, schValid);
        cxt.mergeValidEvaluated(schCxt, valid2);
        if (ifClause)
          gen.assign(ifClause, codegen_1$2._`${keyword2}`);
        else
          cxt.setParams({ ifClause: keyword2 });
      };
    }
  }
};
function hasSchema(it, keyword2) {
  const schema2 = it.schema[keyword2];
  return schema2 !== void 0 && !util_1$1.alwaysValidSchema(it, schema2);
}
_if.default = def$3;
var thenElse = {};
Object.defineProperty(thenElse, "__esModule", { value: true });
const util_1 = util;
const def$2 = {
  keyword: ["then", "else"],
  schemaType: ["object", "boolean"],
  code({ keyword: keyword2, parentSchema, it }) {
    if (parentSchema.if === void 0)
      util_1.checkStrictMode(it, `"${keyword2}" without "if" is ignored`);
  }
};
thenElse.default = def$2;
Object.defineProperty(applicator, "__esModule", { value: true });
const additionalItems_1 = additionalItems;
const prefixItems_1 = prefixItems;
const items_1 = items;
const items2020_1 = items2020;
const contains_1 = contains;
const dependencies_1 = dependencies;
const propertyNames_1 = propertyNames;
const additionalProperties_1 = additionalProperties;
const properties_1 = properties$1;
const patternProperties_1 = patternProperties;
const not_1 = not;
const anyOf_1 = anyOf;
const oneOf_1 = oneOf;
const allOf_1 = allOf;
const if_1 = _if;
const thenElse_1 = thenElse;
function getApplicator(draft2020 = false) {
  const applicator2 = [
    not_1.default,
    anyOf_1.default,
    oneOf_1.default,
    allOf_1.default,
    if_1.default,
    thenElse_1.default,
    propertyNames_1.default,
    additionalProperties_1.default,
    dependencies_1.default,
    properties_1.default,
    patternProperties_1.default
  ];
  if (draft2020)
    applicator2.push(prefixItems_1.default, items2020_1.default);
  else
    applicator2.push(additionalItems_1.default, items_1.default);
  applicator2.push(contains_1.default);
  return applicator2;
}
applicator.default = getApplicator;
var format$2 = {};
var format$1 = {};
Object.defineProperty(format$1, "__esModule", { value: true });
const codegen_1$1 = codegen;
const error$1 = {
  message: ({ schemaCode }) => codegen_1$1.str`must match format "${schemaCode}"`,
  params: ({ schemaCode }) => codegen_1$1._`{format: ${schemaCode}}`
};
const def$1 = {
  keyword: "format",
  type: ["number", "string"],
  schemaType: "string",
  $data: true,
  error: error$1,
  code(cxt, ruleType) {
    const { gen, data, $data, schema: schema2, schemaCode, it } = cxt;
    const { opts: opts2, errSchemaPath, schemaEnv, self: self2 } = it;
    if (!opts2.validateFormats)
      return;
    if ($data)
      validate$DataFormat();
    else
      validateFormat();
    function validate$DataFormat() {
      const fmts = gen.scopeValue("formats", {
        ref: self2.formats,
        code: opts2.code.formats
      });
      const fDef = gen.const("fDef", codegen_1$1._`${fmts}[${schemaCode}]`);
      const fType = gen.let("fType");
      const format2 = gen.let("format");
      gen.if(codegen_1$1._`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, codegen_1$1._`${fDef}.type || "string"`).assign(format2, codegen_1$1._`${fDef}.validate`), () => gen.assign(fType, codegen_1$1._`"string"`).assign(format2, fDef));
      cxt.fail$data(codegen_1$1.or(unknownFmt(), invalidFmt()));
      function unknownFmt() {
        if (opts2.strictSchema === false)
          return codegen_1$1.nil;
        return codegen_1$1._`${schemaCode} && !${format2}`;
      }
      function invalidFmt() {
        const callFormat = schemaEnv.$async ? codegen_1$1._`(${fDef}.async ? await ${format2}(${data}) : ${format2}(${data}))` : codegen_1$1._`${format2}(${data})`;
        const validData = codegen_1$1._`(typeof ${format2} == "function" ? ${callFormat} : ${format2}.test(${data}))`;
        return codegen_1$1._`${format2} && ${format2} !== true && ${fType} === ${ruleType} && !${validData}`;
      }
    }
    function validateFormat() {
      const formatDef = self2.formats[schema2];
      if (!formatDef) {
        unknownFormat();
        return;
      }
      if (formatDef === true)
        return;
      const [fmtType, format2, fmtRef] = getFormat(formatDef);
      if (fmtType === ruleType)
        cxt.pass(validCondition());
      function unknownFormat() {
        if (opts2.strictSchema === false) {
          self2.logger.warn(unknownMsg());
          return;
        }
        throw new Error(unknownMsg());
        function unknownMsg() {
          return `unknown format "${schema2}" ignored in schema at path "${errSchemaPath}"`;
        }
      }
      function getFormat(fmtDef) {
        const code2 = fmtDef instanceof RegExp ? codegen_1$1.regexpCode(fmtDef) : opts2.code.formats ? codegen_1$1._`${opts2.code.formats}${codegen_1$1.getProperty(schema2)}` : void 0;
        const fmt = gen.scopeValue("formats", { key: schema2, ref: fmtDef, code: code2 });
        if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
          return [fmtDef.type || "string", fmtDef.validate, codegen_1$1._`${fmt}.validate`];
        }
        return ["string", fmtDef, fmt];
      }
      function validCondition() {
        if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
          if (!schemaEnv.$async)
            throw new Error("async format in sync schema");
          return codegen_1$1._`await ${fmtRef}(${data})`;
        }
        return typeof format2 == "function" ? codegen_1$1._`${fmtRef}(${data})` : codegen_1$1._`${fmtRef}.test(${data})`;
      }
    }
  }
};
format$1.default = def$1;
Object.defineProperty(format$2, "__esModule", { value: true });
const format_1$1 = format$1;
const format = [format_1$1.default];
format$2.default = format;
var metadata = {};
Object.defineProperty(metadata, "__esModule", { value: true });
metadata.contentVocabulary = metadata.metadataVocabulary = void 0;
metadata.metadataVocabulary = [
  "title",
  "description",
  "default",
  "deprecated",
  "readOnly",
  "writeOnly",
  "examples"
];
metadata.contentVocabulary = [
  "contentMediaType",
  "contentEncoding",
  "contentSchema"
];
Object.defineProperty(draft7, "__esModule", { value: true });
const core_1 = core$1;
const validation_1 = validation$1;
const applicator_1 = applicator;
const format_1 = format$2;
const metadata_1 = metadata;
const draft7Vocabularies = [
  core_1.default,
  validation_1.default,
  applicator_1.default(),
  format_1.default,
  metadata_1.metadataVocabulary,
  metadata_1.contentVocabulary
];
draft7.default = draft7Vocabularies;
var discriminator = {};
var types = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiscrError = void 0;
  (function(DiscrError) {
    DiscrError["Tag"] = "tag";
    DiscrError["Mapping"] = "mapping";
  })(exports.DiscrError || (exports.DiscrError = {}));
})(types);
Object.defineProperty(discriminator, "__esModule", { value: true });
const codegen_1 = codegen;
const types_1 = types;
const error = {
  message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
  params: ({ params: { discrError, tag, tagName } }) => codegen_1._`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
};
const def = {
  keyword: "discriminator",
  type: "object",
  schemaType: "object",
  error,
  code(cxt) {
    const { gen, data, schema: schema2, parentSchema, it } = cxt;
    const { oneOf: oneOf2 } = parentSchema;
    if (!it.opts.discriminator) {
      throw new Error("discriminator: requires discriminator option");
    }
    const tagName = schema2.propertyName;
    if (typeof tagName != "string")
      throw new Error("discriminator: requires propertyName");
    if (schema2.mapping)
      throw new Error("discriminator: mapping is not supported");
    if (!oneOf2)
      throw new Error("discriminator: requires oneOf keyword");
    const valid2 = gen.let("valid", false);
    const tag = gen.const("tag", codegen_1._`${data}${codegen_1.getProperty(tagName)}`);
    gen.if(codegen_1._`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
    cxt.ok(valid2);
    function validateMapping() {
      const mapping = getMapping();
      gen.if(false);
      for (const tagValue in mapping) {
        gen.elseIf(codegen_1._`${tag} === ${tagValue}`);
        gen.assign(valid2, applyTagSchema(mapping[tagValue]));
      }
      gen.else();
      cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
      gen.endIf();
    }
    function applyTagSchema(schemaProp) {
      const _valid = gen.name("valid");
      const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
      cxt.mergeEvaluated(schCxt, codegen_1.Name);
      return _valid;
    }
    function getMapping() {
      var _a;
      const oneOfMapping = {};
      const topRequired = hasRequired(parentSchema);
      let tagRequired = true;
      for (let i2 = 0; i2 < oneOf2.length; i2++) {
        const sch = oneOf2[i2];
        const propSch = (_a = sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
        if (typeof propSch != "object") {
          throw new Error(`discriminator: oneOf schemas must have "properties/${tagName}"`);
        }
        tagRequired = tagRequired && (topRequired || hasRequired(sch));
        addMappings(propSch, i2);
      }
      if (!tagRequired)
        throw new Error(`discriminator: "${tagName}" must be required`);
      return oneOfMapping;
      function hasRequired({ required: required2 }) {
        return Array.isArray(required2) && required2.includes(tagName);
      }
      function addMappings(sch, i2) {
        if (sch.const) {
          addMapping(sch.const, i2);
        } else if (sch.enum) {
          for (const tagValue of sch.enum) {
            addMapping(tagValue, i2);
          }
        } else {
          throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
        }
      }
      function addMapping(tagValue, i2) {
        if (typeof tagValue != "string" || tagValue in oneOfMapping) {
          throw new Error(`discriminator: "${tagName}" values must be unique strings`);
        }
        oneOfMapping[tagValue] = i2;
      }
    }
  }
};
discriminator.default = def;
const $schema = "http://json-schema.org/draft-07/schema#";
const $id = "http://json-schema.org/draft-07/schema#";
const title = "Core schema meta-schema";
const definitions = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/nonNegativeInteger"
      },
      {
        "default": 0
      }
    ]
  },
  simpleTypes: {
    "enum": [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: true,
    "default": []
  }
};
const type = [
  "object",
  "boolean"
];
const properties = {
  $id: {
    type: "string",
    format: "uri-reference"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  $ref: {
    type: "string",
    format: "uri-reference"
  },
  $comment: {
    type: "string"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  "default": true,
  readOnly: {
    type: "boolean",
    "default": false
  },
  examples: {
    type: "array",
    items: true
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    $ref: "#"
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    "default": true
  },
  maxItems: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    "default": false
  },
  contains: {
    $ref: "#"
  },
  maxProperties: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    $ref: "#"
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    propertyNames: {
      format: "regex"
    },
    "default": {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  propertyNames: {
    $ref: "#"
  },
  "const": true,
  "enum": {
    type: "array",
    items: true,
    minItems: 1,
    uniqueItems: true
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: true
      }
    ]
  },
  format: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentEncoding: {
    type: "string"
  },
  "if": {
    $ref: "#"
  },
  then: {
    $ref: "#"
  },
  "else": {
    $ref: "#"
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
};
var require$$3 = {
  $schema,
  $id,
  title,
  definitions,
  type,
  properties,
  "default": true
};
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
  const core_12 = core$2;
  const draft7_1 = draft7;
  const discriminator_1 = discriminator;
  const draft7MetaSchema = require$$3;
  const META_SUPPORT_DATA = ["/properties"];
  const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
  class Ajv extends core_12.default {
    _addVocabularies() {
      super._addVocabularies();
      draft7_1.default.forEach((v) => this.addVocabulary(v));
      if (this.opts.discriminator)
        this.addKeyword(discriminator_1.default);
    }
    _addDefaultMetaSchema() {
      super._addDefaultMetaSchema();
      if (!this.opts.meta)
        return;
      const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
      this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
      this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
    }
  }
  module.exports = exports = Ajv;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = Ajv;
  var validate_12 = validate;
  Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
    return validate_12.KeywordCxt;
  } });
  var codegen_12 = codegen;
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return codegen_12._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return codegen_12.str;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return codegen_12.stringify;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return codegen_12.nil;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return codegen_12.Name;
  } });
  Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
    return codegen_12.CodeGen;
  } });
})(ajv, ajv.exports);
var dist = { exports: {} };
var formats = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatNames = exports.fastFormats = exports.fullFormats = void 0;
  function fmtDef(validate2, compare2) {
    return { validate: validate2, compare: compare2 };
  }
  exports.fullFormats = {
    date: fmtDef(date, compareDate),
    time: fmtDef(time, compareTime),
    "date-time": fmtDef(date_time, compareDateTime),
    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
    uri,
    "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
    regex,
    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    byte,
    int32: { type: "number", validate: validateInt32 },
    int64: { type: "number", validate: validateInt64 },
    float: { type: "number", validate: validateNumber },
    double: { type: "number", validate: validateNumber },
    password: true,
    binary: true
  };
  exports.fastFormats = __spreadProps(__spreadValues({}, exports.fullFormats), {
    date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
    time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareTime),
    "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
  });
  exports.formatNames = Object.keys(exports.fullFormats);
  function isLeapYear(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  }
  const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
  const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function date(str2) {
    const matches = DATE.exec(str2);
    if (!matches)
      return false;
    const year = +matches[1];
    const month = +matches[2];
    const day = +matches[3];
    return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
  }
  function compareDate(d1, d2) {
    if (!(d1 && d2))
      return void 0;
    if (d1 > d2)
      return 1;
    if (d1 < d2)
      return -1;
    return 0;
  }
  const TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
  function time(str2, withTimeZone) {
    const matches = TIME.exec(str2);
    if (!matches)
      return false;
    const hour = +matches[1];
    const minute = +matches[2];
    const second = +matches[3];
    const timeZone = matches[5];
    return (hour <= 23 && minute <= 59 && second <= 59 || hour === 23 && minute === 59 && second === 60) && (!withTimeZone || timeZone !== "");
  }
  function compareTime(t1, t2) {
    if (!(t1 && t2))
      return void 0;
    const a1 = TIME.exec(t1);
    const a2 = TIME.exec(t2);
    if (!(a1 && a2))
      return void 0;
    t1 = a1[1] + a1[2] + a1[3] + (a1[4] || "");
    t2 = a2[1] + a2[2] + a2[3] + (a2[4] || "");
    if (t1 > t2)
      return 1;
    if (t1 < t2)
      return -1;
    return 0;
  }
  const DATE_TIME_SEPARATOR = /t|\s/i;
  function date_time(str2) {
    const dateTime = str2.split(DATE_TIME_SEPARATOR);
    return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1], true);
  }
  function compareDateTime(dt1, dt2) {
    if (!(dt1 && dt2))
      return void 0;
    const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
    const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
    const res = compareDate(d1, d2);
    if (res === void 0)
      return void 0;
    return res || compareTime(t1, t2);
  }
  const NOT_URI_FRAGMENT = /\/|:/;
  const URI2 = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  function uri(str2) {
    return NOT_URI_FRAGMENT.test(str2) && URI2.test(str2);
  }
  const BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
  function byte(str2) {
    BYTE.lastIndex = 0;
    return BYTE.test(str2);
  }
  const MIN_INT32 = -(2 ** 31);
  const MAX_INT32 = 2 ** 31 - 1;
  function validateInt32(value) {
    return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
  }
  function validateInt64(value) {
    return Number.isInteger(value);
  }
  function validateNumber() {
    return true;
  }
  const Z_ANCHOR = /[^\\]\\Z/;
  function regex(str2) {
    if (Z_ANCHOR.test(str2))
      return false;
    try {
      new RegExp(str2);
      return true;
    } catch (e) {
      return false;
    }
  }
})(formats);
var limit = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatLimitDefinition = void 0;
  const ajv_1 = ajv.exports;
  const codegen_12 = codegen;
  const ops2 = codegen_12.operators;
  const KWDs2 = {
    formatMaximum: { okStr: "<=", ok: ops2.LTE, fail: ops2.GT },
    formatMinimum: { okStr: ">=", ok: ops2.GTE, fail: ops2.LT },
    formatExclusiveMaximum: { okStr: "<", ok: ops2.LT, fail: ops2.GTE },
    formatExclusiveMinimum: { okStr: ">", ok: ops2.GT, fail: ops2.LTE }
  };
  const error2 = {
    message: ({ keyword: keyword2, schemaCode }) => codegen_12.str`should be ${KWDs2[keyword2].okStr} ${schemaCode}`,
    params: ({ keyword: keyword2, schemaCode }) => codegen_12._`{comparison: ${KWDs2[keyword2].okStr}, limit: ${schemaCode}}`
  };
  exports.formatLimitDefinition = {
    keyword: Object.keys(KWDs2),
    type: "string",
    schemaType: "string",
    $data: true,
    error: error2,
    code(cxt) {
      const { gen, data, schemaCode, keyword: keyword2, it } = cxt;
      const { opts: opts2, self: self2 } = it;
      if (!opts2.validateFormats)
        return;
      const fCxt = new ajv_1.KeywordCxt(it, self2.RULES.all.format.definition, "format");
      if (fCxt.$data)
        validate$DataFormat();
      else
        validateFormat();
      function validate$DataFormat() {
        const fmts = gen.scopeValue("formats", {
          ref: self2.formats,
          code: opts2.code.formats
        });
        const fmt = gen.const("fmt", codegen_12._`${fmts}[${fCxt.schemaCode}]`);
        cxt.fail$data(codegen_12.or(codegen_12._`typeof ${fmt} != "object"`, codegen_12._`${fmt} instanceof RegExp`, codegen_12._`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
      }
      function validateFormat() {
        const format2 = fCxt.schema;
        const fmtDef = self2.formats[format2];
        if (!fmtDef || fmtDef === true)
          return;
        if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
          throw new Error(`"${keyword2}": format "${format2}" does not define "compare" function`);
        }
        const fmt = gen.scopeValue("formats", {
          key: format2,
          ref: fmtDef,
          code: opts2.code.formats ? codegen_12._`${opts2.code.formats}${codegen_12.getProperty(format2)}` : void 0
        });
        cxt.fail$data(compareCode(fmt));
      }
      function compareCode(fmt) {
        return codegen_12._`${fmt}.compare(${data}, ${schemaCode}) ${KWDs2[keyword2].fail} 0`;
      }
    },
    dependencies: ["format"]
  };
  const formatLimitPlugin = (ajv2) => {
    ajv2.addKeyword(exports.formatLimitDefinition);
    return ajv2;
  };
  exports.default = formatLimitPlugin;
})(limit);
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  const formats_1 = formats;
  const limit_1 = limit;
  const codegen_12 = codegen;
  const fullName = new codegen_12.Name("fullFormats");
  const fastName = new codegen_12.Name("fastFormats");
  const formatsPlugin = (ajv2, opts2 = { keywords: true }) => {
    if (Array.isArray(opts2)) {
      addFormats(ajv2, opts2, formats_1.fullFormats, fullName);
      return ajv2;
    }
    const [formats2, exportName] = opts2.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
    const list = opts2.formats || formats_1.formatNames;
    addFormats(ajv2, list, formats2, exportName);
    if (opts2.keywords)
      limit_1.default(ajv2);
    return ajv2;
  };
  formatsPlugin.get = (name, mode = "full") => {
    const formats2 = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
    const f = formats2[name];
    if (!f)
      throw new Error(`Unknown format "${name}"`);
    return f;
  };
  function addFormats(ajv2, list, fs2, exportName) {
    var _a;
    var _b;
    (_a = (_b = ajv2.opts.code).formats) !== null && _a !== void 0 ? _a : _b.formats = codegen_12._`require("ajv-formats/dist/formats").${exportName}`;
    for (const f of list)
      ajv2.addFormat(f, fs2[f]);
  }
  module.exports = exports = formatsPlugin;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = formatsPlugin;
})(dist, dist.exports);
const copyProperty = (to, from, property, ignoreNonConfigurable) => {
  if (property === "length" || property === "prototype") {
    return;
  }
  if (property === "arguments" || property === "caller") {
    return;
  }
  const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
  const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);
  if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {
    return;
  }
  Object.defineProperty(to, property, fromDescriptor);
};
const canCopyProperty = function(toDescriptor, fromDescriptor) {
  return toDescriptor === void 0 || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
};
const changePrototype = (to, from) => {
  const fromPrototype = Object.getPrototypeOf(from);
  if (fromPrototype === Object.getPrototypeOf(to)) {
    return;
  }
  Object.setPrototypeOf(to, fromPrototype);
};
const wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/
${fromBody}`;
const toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, "toString");
const toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name");
const changeToString = (to, from, name) => {
  const withName = name === "" ? "" : `with ${name.trim()}() `;
  const newToString = wrappedToString.bind(null, withName, from.toString());
  Object.defineProperty(newToString, "name", toStringName);
  Object.defineProperty(to, "toString", __spreadProps(__spreadValues({}, toStringDescriptor), { value: newToString }));
};
const mimicFn$4 = (to, from, { ignoreNonConfigurable = false } = {}) => {
  const { name } = to;
  for (const property of Reflect.ownKeys(from)) {
    copyProperty(to, from, property, ignoreNonConfigurable);
  }
  changePrototype(to, from);
  changeToString(to, from, name);
  return to;
};
var mimicFn_1 = mimicFn$4;
const mimicFn$3 = mimicFn_1;
var debounceFn = (inputFunction, options = {}) => {
  if (typeof inputFunction !== "function") {
    throw new TypeError(`Expected the first argument to be a function, got \`${typeof inputFunction}\``);
  }
  const {
    wait = 0,
    before = false,
    after = true
  } = options;
  if (!before && !after) {
    throw new Error("Both `before` and `after` are false, function wouldn't be called.");
  }
  let timeout;
  let result;
  const debouncedFunction = function(...arguments_) {
    const context = this;
    const later = () => {
      timeout = void 0;
      if (after) {
        result = inputFunction.apply(context, arguments_);
      }
    };
    const shouldCallNow = before && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (shouldCallNow) {
      result = inputFunction.apply(context, arguments_);
    }
    return result;
  };
  mimicFn$3(debouncedFunction, inputFunction);
  debouncedFunction.cancel = () => {
    if (timeout) {
      clearTimeout(timeout);
      timeout = void 0;
    }
  };
  return debouncedFunction;
};
var onetime$1 = { exports: {} };
var mimicFn$2 = { exports: {} };
const mimicFn$1 = (to, from) => {
  for (const prop of Reflect.ownKeys(from)) {
    Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
  }
  return to;
};
mimicFn$2.exports = mimicFn$1;
mimicFn$2.exports.default = mimicFn$1;
const mimicFn = mimicFn$2.exports;
const calledFunctions = new WeakMap();
const onetime = (function_, options = {}) => {
  if (typeof function_ !== "function") {
    throw new TypeError("Expected a function");
  }
  let returnValue;
  let callCount = 0;
  const functionName = function_.displayName || function_.name || "<anonymous>";
  const onetime2 = function(...arguments_) {
    calledFunctions.set(onetime2, ++callCount);
    if (callCount === 1) {
      returnValue = function_.apply(this, arguments_);
      function_ = null;
    } else if (options.throw === true) {
      throw new Error(`Function \`${functionName}\` can only be called once`);
    }
    return returnValue;
  };
  mimicFn(onetime2, function_);
  calledFunctions.set(onetime2, callCount);
  return onetime2;
};
onetime$1.exports = onetime;
onetime$1.exports.default = onetime;
onetime$1.exports.callCount = (function_) => {
  if (!calledFunctions.has(function_)) {
    throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
  }
  return calledFunctions.get(function_);
};
(function(module, exports) {
  var __classPrivateFieldSet = commonjsGlobal && commonjsGlobal.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = commonjsGlobal && commonjsGlobal.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _a, _b;
  var _Conf_validator, _Conf_encryptionKey, _Conf_options, _Conf_defaultValues;
  Object.defineProperty(exports, "__esModule", { value: true });
  const util_12 = require$$4__default["default"];
  const fs2 = require$$0__default$2["default"];
  const path2 = require$$1__default$1["default"];
  const crypto = require$$0__default$4["default"];
  const assert2 = require$$5__default["default"];
  const events_12 = require$$0__default$3["default"];
  const dotProp$1 = dotProp;
  const pkgUp$1 = pkgUp.exports;
  const envPaths2 = envPaths$1.exports;
  const atomically = dist$1;
  const ajv_1 = ajv.exports;
  const ajv_formats_1 = dist.exports;
  const debounceFn$1 = debounceFn;
  const semver2 = semver$1;
  const onetime2 = onetime$1.exports;
  const encryptionAlgorithm = "aes-256-cbc";
  const createPlainObject = () => {
    return Object.create(null);
  };
  const isExist = (data) => {
    return data !== void 0 && data !== null;
  };
  let parentDir = "";
  try {
    delete require.cache[__filename];
    parentDir = path2.dirname((_b = (_a = module.parent) === null || _a === void 0 ? void 0 : _a.filename) !== null && _b !== void 0 ? _b : ".");
  } catch (_c) {
  }
  const checkValueType = (key, value) => {
    const nonJsonTypes = new Set([
      "undefined",
      "symbol",
      "function"
    ]);
    const type2 = typeof value;
    if (nonJsonTypes.has(type2)) {
      throw new TypeError(`Setting a value of type \`${type2}\` for key \`${key}\` is not allowed as it's not supported by JSON`);
    }
  };
  const INTERNAL_KEY = "__internal__";
  const MIGRATION_KEY = `${INTERNAL_KEY}.migrations.version`;
  class Conf2 {
    constructor(partialOptions = {}) {
      var _a2;
      _Conf_validator.set(this, void 0);
      _Conf_encryptionKey.set(this, void 0);
      _Conf_options.set(this, void 0);
      _Conf_defaultValues.set(this, {});
      this._deserialize = (value) => JSON.parse(value);
      this._serialize = (value) => JSON.stringify(value, void 0, "	");
      const options = __spreadValues({
        configName: "config",
        fileExtension: "json",
        projectSuffix: "nodejs",
        clearInvalidConfig: false,
        accessPropertiesByDotNotation: true
      }, partialOptions);
      const getPackageData = onetime2(() => {
        const packagePath = pkgUp$1.sync({ cwd: parentDir });
        const packageData = packagePath && JSON.parse(fs2.readFileSync(packagePath, "utf8"));
        return packageData !== null && packageData !== void 0 ? packageData : {};
      });
      if (!options.cwd) {
        if (!options.projectName) {
          options.projectName = getPackageData().name;
        }
        if (!options.projectName) {
          throw new Error("Project name could not be inferred. Please specify the `projectName` option.");
        }
        options.cwd = envPaths2(options.projectName, { suffix: options.projectSuffix }).config;
      }
      __classPrivateFieldSet(this, _Conf_options, options, "f");
      if (options.schema) {
        if (typeof options.schema !== "object") {
          throw new TypeError("The `schema` option must be an object.");
        }
        const ajv2 = new ajv_1.default({
          allErrors: true,
          useDefaults: true
        });
        ajv_formats_1.default(ajv2);
        const schema2 = {
          type: "object",
          properties: options.schema
        };
        __classPrivateFieldSet(this, _Conf_validator, ajv2.compile(schema2), "f");
        for (const [key, value] of Object.entries(options.schema)) {
          if (value === null || value === void 0 ? void 0 : value.default) {
            __classPrivateFieldGet(this, _Conf_defaultValues, "f")[key] = value.default;
          }
        }
      }
      if (options.defaults) {
        __classPrivateFieldSet(this, _Conf_defaultValues, __spreadValues(__spreadValues({}, __classPrivateFieldGet(this, _Conf_defaultValues, "f")), options.defaults), "f");
      }
      if (options.serialize) {
        this._serialize = options.serialize;
      }
      if (options.deserialize) {
        this._deserialize = options.deserialize;
      }
      this.events = new events_12.EventEmitter();
      __classPrivateFieldSet(this, _Conf_encryptionKey, options.encryptionKey, "f");
      const fileExtension = options.fileExtension ? `.${options.fileExtension}` : "";
      this.path = path2.resolve(options.cwd, `${(_a2 = options.configName) !== null && _a2 !== void 0 ? _a2 : "config"}${fileExtension}`);
      const fileStore = this.store;
      const store2 = Object.assign(createPlainObject(), options.defaults, fileStore);
      this._validate(store2);
      try {
        assert2.deepEqual(fileStore, store2);
      } catch (_b2) {
        this.store = store2;
      }
      if (options.watch) {
        this._watch();
      }
      if (options.migrations) {
        if (!options.projectVersion) {
          options.projectVersion = getPackageData().version;
        }
        if (!options.projectVersion) {
          throw new Error("Project version could not be inferred. Please specify the `projectVersion` option.");
        }
        this._migrate(options.migrations, options.projectVersion);
      }
    }
    get(key, defaultValue) {
      if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        return this._get(key, defaultValue);
      }
      const { store: store2 } = this;
      return key in store2 ? store2[key] : defaultValue;
    }
    set(key, value) {
      if (typeof key !== "string" && typeof key !== "object") {
        throw new TypeError(`Expected \`key\` to be of type \`string\` or \`object\`, got ${typeof key}`);
      }
      if (typeof key !== "object" && value === void 0) {
        throw new TypeError("Use `delete()` to clear values");
      }
      if (this._containsReservedKey(key)) {
        throw new TypeError(`Please don't use the ${INTERNAL_KEY} key, as it's used to manage this module internal operations.`);
      }
      const { store: store2 } = this;
      const set2 = (key2, value2) => {
        checkValueType(key2, value2);
        if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
          dotProp$1.set(store2, key2, value2);
        } else {
          store2[key2] = value2;
        }
      };
      if (typeof key === "object") {
        const object = key;
        for (const [key2, value2] of Object.entries(object)) {
          set2(key2, value2);
        }
      } else {
        set2(key, value);
      }
      this.store = store2;
    }
    has(key) {
      if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        return dotProp$1.has(this.store, key);
      }
      return key in this.store;
    }
    reset(...keys) {
      for (const key of keys) {
        if (isExist(__classPrivateFieldGet(this, _Conf_defaultValues, "f")[key])) {
          this.set(key, __classPrivateFieldGet(this, _Conf_defaultValues, "f")[key]);
        }
      }
    }
    delete(key) {
      const { store: store2 } = this;
      if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        dotProp$1.delete(store2, key);
      } else {
        delete store2[key];
      }
      this.store = store2;
    }
    clear() {
      this.store = createPlainObject();
      for (const key of Object.keys(__classPrivateFieldGet(this, _Conf_defaultValues, "f"))) {
        this.reset(key);
      }
    }
    onDidChange(key, callback) {
      if (typeof key !== "string") {
        throw new TypeError(`Expected \`key\` to be of type \`string\`, got ${typeof key}`);
      }
      if (typeof callback !== "function") {
        throw new TypeError(`Expected \`callback\` to be of type \`function\`, got ${typeof callback}`);
      }
      return this._handleChange(() => this.get(key), callback);
    }
    onDidAnyChange(callback) {
      if (typeof callback !== "function") {
        throw new TypeError(`Expected \`callback\` to be of type \`function\`, got ${typeof callback}`);
      }
      return this._handleChange(() => this.store, callback);
    }
    get size() {
      return Object.keys(this.store).length;
    }
    get store() {
      try {
        const data = fs2.readFileSync(this.path, __classPrivateFieldGet(this, _Conf_encryptionKey, "f") ? null : "utf8");
        const dataString = this._encryptData(data);
        const deserializedData = this._deserialize(dataString);
        this._validate(deserializedData);
        return Object.assign(createPlainObject(), deserializedData);
      } catch (error2) {
        if (error2.code === "ENOENT") {
          this._ensureDirectory();
          return createPlainObject();
        }
        if (__classPrivateFieldGet(this, _Conf_options, "f").clearInvalidConfig && error2.name === "SyntaxError") {
          return createPlainObject();
        }
        throw error2;
      }
    }
    set store(value) {
      this._ensureDirectory();
      this._validate(value);
      this._write(value);
      this.events.emit("change");
    }
    *[(_Conf_validator = new WeakMap(), _Conf_encryptionKey = new WeakMap(), _Conf_options = new WeakMap(), _Conf_defaultValues = new WeakMap(), Symbol.iterator)]() {
      for (const [key, value] of Object.entries(this.store)) {
        yield [key, value];
      }
    }
    _encryptData(data) {
      if (!__classPrivateFieldGet(this, _Conf_encryptionKey, "f")) {
        return data.toString();
      }
      try {
        if (__classPrivateFieldGet(this, _Conf_encryptionKey, "f")) {
          try {
            if (data.slice(16, 17).toString() === ":") {
              const initializationVector = data.slice(0, 16);
              const password = crypto.pbkdf2Sync(__classPrivateFieldGet(this, _Conf_encryptionKey, "f"), initializationVector.toString(), 1e4, 32, "sha512");
              const decipher = crypto.createDecipheriv(encryptionAlgorithm, password, initializationVector);
              data = Buffer.concat([decipher.update(Buffer.from(data.slice(17))), decipher.final()]).toString("utf8");
            } else {
              const decipher = crypto.createDecipher(encryptionAlgorithm, __classPrivateFieldGet(this, _Conf_encryptionKey, "f"));
              data = Buffer.concat([decipher.update(Buffer.from(data)), decipher.final()]).toString("utf8");
            }
          } catch (_a2) {
          }
        }
      } catch (_b2) {
      }
      return data.toString();
    }
    _handleChange(getter, callback) {
      let currentValue = getter();
      const onChange = () => {
        const oldValue = currentValue;
        const newValue = getter();
        if (util_12.isDeepStrictEqual(newValue, oldValue)) {
          return;
        }
        currentValue = newValue;
        callback.call(this, newValue, oldValue);
      };
      this.events.on("change", onChange);
      return () => this.events.removeListener("change", onChange);
    }
    _validate(data) {
      if (!__classPrivateFieldGet(this, _Conf_validator, "f")) {
        return;
      }
      const valid2 = __classPrivateFieldGet(this, _Conf_validator, "f").call(this, data);
      if (valid2 || !__classPrivateFieldGet(this, _Conf_validator, "f").errors) {
        return;
      }
      const errors2 = __classPrivateFieldGet(this, _Conf_validator, "f").errors.map(({ instancePath, message = "" }) => `\`${instancePath.slice(1)}\` ${message}`);
      throw new Error("Config schema violation: " + errors2.join("; "));
    }
    _ensureDirectory() {
      fs2.mkdirSync(path2.dirname(this.path), { recursive: true });
    }
    _write(value) {
      let data = this._serialize(value);
      if (__classPrivateFieldGet(this, _Conf_encryptionKey, "f")) {
        const initializationVector = crypto.randomBytes(16);
        const password = crypto.pbkdf2Sync(__classPrivateFieldGet(this, _Conf_encryptionKey, "f"), initializationVector.toString(), 1e4, 32, "sha512");
        const cipher = crypto.createCipheriv(encryptionAlgorithm, password, initializationVector);
        data = Buffer.concat([initializationVector, Buffer.from(":"), cipher.update(Buffer.from(data)), cipher.final()]);
      }
      {
        try {
          atomically.writeFileSync(this.path, data);
        } catch (error2) {
          if (error2.code === "EXDEV") {
            fs2.writeFileSync(this.path, data);
            return;
          }
          throw error2;
        }
      }
    }
    _watch() {
      this._ensureDirectory();
      if (!fs2.existsSync(this.path)) {
        this._write(createPlainObject());
      }
      if (process.platform === "win32") {
        fs2.watch(this.path, { persistent: false }, debounceFn$1(() => {
          this.events.emit("change");
        }, { wait: 100 }));
      } else {
        fs2.watchFile(this.path, { persistent: false }, debounceFn$1(() => {
          this.events.emit("change");
        }, { wait: 5e3 }));
      }
    }
    _migrate(migrations, versionToMigrate) {
      let previousMigratedVersion = this._get(MIGRATION_KEY, "0.0.0");
      const newerVersions = Object.keys(migrations).filter((candidateVersion) => this._shouldPerformMigration(candidateVersion, previousMigratedVersion, versionToMigrate));
      let storeBackup = __spreadValues({}, this.store);
      for (const version of newerVersions) {
        try {
          const migration = migrations[version];
          migration(this);
          this._set(MIGRATION_KEY, version);
          previousMigratedVersion = version;
          storeBackup = __spreadValues({}, this.store);
        } catch (error2) {
          this.store = storeBackup;
          throw new Error(`Something went wrong during the migration! Changes applied to the store until this failed migration will be restored. ${error2}`);
        }
      }
      if (this._isVersionInRangeFormat(previousMigratedVersion) || !semver2.eq(previousMigratedVersion, versionToMigrate)) {
        this._set(MIGRATION_KEY, versionToMigrate);
      }
    }
    _containsReservedKey(key) {
      if (typeof key === "object") {
        const firsKey = Object.keys(key)[0];
        if (firsKey === INTERNAL_KEY) {
          return true;
        }
      }
      if (typeof key !== "string") {
        return false;
      }
      if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        if (key.startsWith(`${INTERNAL_KEY}.`)) {
          return true;
        }
        return false;
      }
      return false;
    }
    _isVersionInRangeFormat(version) {
      return semver2.clean(version) === null;
    }
    _shouldPerformMigration(candidateVersion, previousMigratedVersion, versionToMigrate) {
      if (this._isVersionInRangeFormat(candidateVersion)) {
        if (previousMigratedVersion !== "0.0.0" && semver2.satisfies(previousMigratedVersion, candidateVersion)) {
          return false;
        }
        return semver2.satisfies(versionToMigrate, candidateVersion);
      }
      if (semver2.lte(candidateVersion, previousMigratedVersion)) {
        return false;
      }
      if (semver2.gt(candidateVersion, versionToMigrate)) {
        return false;
      }
      return true;
    }
    _get(key, defaultValue) {
      return dotProp$1.get(this.store, key, defaultValue);
    }
    _set(key, value) {
      const { store: store2 } = this;
      dotProp$1.set(store2, key, value);
      this.store = store2;
    }
  }
  exports.default = Conf2;
  module.exports = Conf2;
  module.exports.default = Conf2;
})(source, source.exports);
const path = require$$1__default$1["default"];
const { app, ipcMain, ipcRenderer, shell } = require$$1__default["default"];
const Conf = source.exports;
let isInitialized = false;
const initDataListener = () => {
  if (!ipcMain || !app) {
    throw new Error("Electron Store: You need to call `.initRenderer()` from the main process.");
  }
  const appData = {
    defaultCwd: app.getPath("userData"),
    appVersion: app.getVersion()
  };
  if (isInitialized) {
    return appData;
  }
  ipcMain.on("electron-store-get-data", (event) => {
    event.returnValue = appData;
  });
  isInitialized = true;
  return appData;
};
class ElectronStore extends Conf {
  constructor(options) {
    let defaultCwd;
    let appVersion;
    if (ipcRenderer) {
      const appData = ipcRenderer.sendSync("electron-store-get-data");
      if (!appData) {
        throw new Error("Electron Store: You need to call `.initRenderer()` from the main process.");
      }
      ({ defaultCwd, appVersion } = appData);
    } else if (ipcMain && app) {
      ({ defaultCwd, appVersion } = initDataListener());
    }
    options = __spreadValues({
      name: "config"
    }, options);
    if (!options.projectVersion) {
      options.projectVersion = appVersion;
    }
    if (options.cwd) {
      options.cwd = path.isAbsolute(options.cwd) ? options.cwd : path.join(defaultCwd, options.cwd);
    } else {
      options.cwd = defaultCwd;
    }
    options.configName = options.name;
    delete options.name;
    super(options);
  }
  static initRenderer() {
    initDataListener();
  }
  openInEditor() {
    shell.openPath(this.path);
  }
}
var electronStore = ElectronStore;
const schema$1 = {
  notes: {
    type: "object",
    patternProperties: {
      "[A-Za-z0-9_-]": {
        type: "object",
        properties: {
          id: { type: "string", default: "" },
          title: { type: "string", default: "" },
          content: { type: "object", default: { type: "doc", content: [] } },
          labels: { type: "array", default: [] },
          createdAt: { type: "number", default: Date.now() },
          updatedAt: { type: "number", default: Date.now() },
          isBookmarked: { type: "boolean", default: false },
          isArchived: { type: "boolean", default: false },
          lastCursorPosition: { type: "number", default: 0 }
        }
      }
    }
  },
  labels: {
    type: "array"
  }
};
const store$1 = new electronStore({
  schema: schema$1,
  encryptionKey: {}.VITE_ENCRYPT_KEY
});
const schema = {
  dataDir: {
    type: "string",
    default: require$$1.app.getPath("userData")
  }
};
var settings = new electronStore({ name: "settings", schema, encryptionKey: {}.VITE_ENCRYPT_KEY });
var store = {
  data: store$1,
  settings
};
const isSingleInstance = require$$1.app.requestSingleInstanceLock();
if (!isSingleInstance) {
  require$$1.app.quit();
  process.exit(0);
}
require$$1.app.disableHardwareAcceleration();
const env = { "VITE_DEV_SERVER_URL": "http://localhost:3000/", "BASE_URL": "/", "MODE": "development", "DEV": true, "PROD": false };
{
  require$$1.app.whenReady().then(() => Promise.resolve().then(function() {
    return /* @__PURE__ */ _interopNamespace(require("electron-devtools-installer"));
  })).then(({ default: installExtension, VUEJS3_DEVTOOLS }) => installExtension(VUEJS3_DEVTOOLS, {
    loadExtensionOptions: {
      allowFileAccess: true
    }
  })).catch((e) => console.error("Failed install extension:", e));
}
let mainWindow = null;
const createWindow = async () => {
  mainWindow = new require$$1.BrowserWindow({
    show: false,
    width: 950,
    height: 600,
    webPreferences: {
      preload: require$$1$1.join(__dirname, "../../preload/dist/index.cjs"),
      contextIsolation: env.MODE !== "test",
      enableRemoteModule: env.MODE === "test"
    }
  });
  mainWindow.setMenuBarVisibility(false);
  mainWindow.on("ready-to-show", () => {
    mainWindow == null ? void 0 : mainWindow.show();
    {
      mainWindow == null ? void 0 : mainWindow.webContents.openDevTools();
    }
  });
  mainWindow == null ? void 0 : mainWindow.webContents.on("new-window", function(event, url) {
    event.preventDefault();
    if (url.startsWith("note://"))
      return;
    require$$1.shell.openExternal(url);
  });
  const pageUrl = env.VITE_DEV_SERVER_URL;
  await mainWindow.loadURL(pageUrl);
};
require$$1.app.on("second-instance", () => {
  if (mainWindow) {
    if (mainWindow.isMinimized())
      mainWindow.restore();
    mainWindow.focus();
  }
});
require$$1.app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    require$$1.app.quit();
  }
});
require$$1.app.whenReady().then(async () => {
  require$$1.protocol.registerFileProtocol("assets", (request, callback) => {
    const url = request.url.substr(9);
    const dir = store.settings.get("dataDir");
    const imgPath = `${dir}/notes-assets/${url}`;
    callback({ path: require$$1$1.normalize(imgPath) });
  });
  await lib.ensureDir(require$$1$1.join(require$$1.app.getPath("userData"), "notes-assets"));
  await createWindow();
}).catch((e) => console.error("Failed create window:", e));
ipcMain$1.answerRenderer("app:info", () => ({
  name: require$$1.app.getName(),
  version: require$$1.app.getVersion()
}));
ipcMain$1.answerRenderer("dialog:open", (props) => require$$1.dialog.showOpenDialog(props));
ipcMain$1.answerRenderer("dialog:message", (props) => require$$1.dialog.showMessageBox(props));
ipcMain$1.answerRenderer("dialog:save", (props) => require$$1.dialog.showSaveDialog(props));
ipcMain$1.answerRenderer("fs:copy", ({ path: path2, dest }) => lib.copy(path2, dest));
ipcMain$1.answerRenderer("fs:output-json", ({ path: path2, data }) => lib.outputJson(path2, data));
ipcMain$1.answerRenderer("fs:read-json", (path2) => lib.readJson(path2));
ipcMain$1.answerRenderer("fs:ensureDir", (path2) => lib.ensureDir(path2));
ipcMain$1.answerRenderer("fs:pathExists", (path2) => lib.pathExistsSync(path2));
ipcMain$1.answerRenderer("fs:remove", (path2) => lib.remove(path2));
ipcMain$1.answerRenderer("helper:relaunch", (options = {}) => {
  require$$1.app.relaunch(__spreadValues({ args: process.argv.slice(1).concat(["--relaunch"]) }, options));
  require$$1.app.exit(0);
});
ipcMain$1.answerRenderer("helper:get-path", (name) => require$$1.app.getPath(name));
ipcMain$1.answerRenderer("helper:is-dark-theme", () => require$$1.nativeTheme.shouldUseDarkColors);
ipcMain$1.answerRenderer("storage:store", (name) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.store;
});
ipcMain$1.answerRenderer("storage:replace", ({ name, data }) => store[name].store = data);
ipcMain$1.answerRenderer("storage:get", ({ name, key, def: def2 }) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.get(key, def2);
});
ipcMain$1.answerRenderer("storage:set", ({ name, key, value }) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.set(key, value);
});
ipcMain$1.answerRenderer("storage:delete", ({ name, key }) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.delete(key);
});
ipcMain$1.answerRenderer("storage:has", ({ name, key }) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.has(key);
});
ipcMain$1.answerRenderer("storage:clear", (name) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.clear();
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguY2pzIiwic291cmNlcyI6WyIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VyaWFsaXplLWVycm9yL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWJldHRlci1pcGMvc291cmNlL3V0aWwuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tYmV0dGVyLWlwYy9zb3VyY2UvcmVuZGVyZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tYmV0dGVyLWlwYy9zb3VyY2UvbWFpbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1iZXR0ZXItaXBjL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3VuaXZlcnNhbGlmeS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9ncmFjZWZ1bC1mcy9wb2x5ZmlsbHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvbGVnYWN5LXN0cmVhbXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvY2xvbmUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvZ3JhY2VmdWwtZnMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2ZzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9ta2RpcnMvdXRpbHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21rZGlycy9tYWtlLWRpci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvbWtkaXJzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi91dGlsL3V0aW1lcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvdXRpbC9zdGF0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9jb3B5LXN5bmMvY29weS1zeW5jLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9jb3B5LXN5bmMvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3BhdGgtZXhpc3RzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9jb3B5L2NvcHkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2NvcHkvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3JlbW92ZS9yaW1yYWYuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3JlbW92ZS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW1wdHkvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9maWxlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbnN1cmUvbGluay5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW5zdXJlL3N5bWxpbmstcGF0aHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9zeW1saW5rLXR5cGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9zeW1saW5rLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbnN1cmUvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvanNvbmZpbGUvdXRpbHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvanNvbmZpbGUvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2pzb24vanNvbmZpbGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL291dHB1dC9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvanNvbi9vdXRwdXQtanNvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvanNvbi9vdXRwdXQtanNvbi1zeW5jLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9qc29uL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9tb3ZlLXN5bmMvbW92ZS1zeW5jLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9tb3ZlLXN5bmMvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21vdmUvbW92ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvbW92ZS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvYnVpbGRlci11dGlsLXJ1bnRpbWUvb3V0L0NhbmNlbGxhdGlvblRva2VuLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9jb21tb24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvYnVpbGRlci11dGlsLXJ1bnRpbWUvb3V0L1Byb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm0uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvYnVpbGRlci11dGlsLXJ1bnRpbWUvb3V0L2h0dHBFeGVjdXRvci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9idWlsZGVyLXV0aWwtcnVudGltZS9vdXQvcHVibGlzaE9wdGlvbnMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvYnVpbGRlci11dGlsLXJ1bnRpbWUvb3V0L3JmYzIyNTNQYXJzZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvYnVpbGRlci11dGlsLXJ1bnRpbWUvb3V0L3V1aWQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2F4L2xpYi9zYXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvYnVpbGRlci11dGlsLXJ1bnRpbWUvb3V0L3htbC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9idWlsZGVyLXV0aWwtcnVudGltZS9vdXQvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvY29tbW9uLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2V4Y2VwdGlvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9zbmlwcGV0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL3R5cGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvc2NoZW1hLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL3R5cGUvc3RyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL3R5cGUvc2VxLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL3R5cGUvbWFwLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL3NjaGVtYS9mYWlsc2FmZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi90eXBlL251bGwuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvdHlwZS9ib29sLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL3R5cGUvaW50LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL3R5cGUvZmxvYXQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvc2NoZW1hL2pzb24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvc2NoZW1hL2NvcmUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvdHlwZS90aW1lc3RhbXAuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvdHlwZS9tZXJnZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi90eXBlL2JpbmFyeS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi90eXBlL29tYXAuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvdHlwZS9wYWlycy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi90eXBlL3NldC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9zY2hlbWEvZGVmYXVsdC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9sb2FkZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvZHVtcGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbGF6eS12YWwvb3V0L21haW4uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2NvbnN0YW50cy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvZGVidWcuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL3JlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9wYXJzZS1vcHRpb25zLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9pZGVudGlmaWVycy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvY2xhc3Nlcy9zZW12ZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9wYXJzZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3ZhbGlkLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY2xlYW4uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9pbmMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb21wYXJlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZXEuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9kaWZmLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbWFqb3IuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9taW5vci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3BhdGNoLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcHJlcmVsZWFzZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3Jjb21wYXJlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29tcGFyZS1sb29zZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvbXBhcmUtYnVpbGQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9zb3J0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcnNvcnQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9ndC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2x0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbmVxLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZ3RlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbHRlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY21wLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29lcmNlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3lhbGxpc3QvaXRlcmF0b3IuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMveWFsbGlzdC95YWxsaXN0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xydS1jYWNoZS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvY2xhc3Nlcy9yYW5nZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvY2xhc3Nlcy9jb21wYXJhdG9yLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvc2F0aXNmaWVzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvdG8tY29tcGFyYXRvcnMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9tYXgtc2F0aXNmeWluZy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL21pbi1zYXRpc2Z5aW5nLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvbWluLXZlcnNpb24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy92YWxpZC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL291dHNpZGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9ndHIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9sdHIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9pbnRlcnNlY3RzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvc2ltcGxpZnkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9zdWJzZXQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC5pc2VxdWFsL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L0Rvd25sb2FkZWRVcGRhdGVIZWxwZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvQXBwQWRhcHRlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9FbGVjdHJvbkFwcEFkYXB0ZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvZWxlY3Ryb25IdHRwRXhlY3V0b3IuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLmVzY2FwZXJlZ2V4cC9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC91dGlsLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L3Byb3ZpZGVycy9Qcm92aWRlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9wcm92aWRlcnMvR2VuZXJpY1Byb3ZpZGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2J1aWxkZXItdXRpbC1ydW50aW1lL291dC9iaW50cmF5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L3Byb3ZpZGVycy9CaW50cmF5UHJvdmlkZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvcHJvdmlkZXJzL0dpdEh1YlByb3ZpZGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L3Byb3ZpZGVycy9LZXlnZW5Qcm92aWRlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9wcm92aWRlcnMvUHJpdmF0ZUdpdEh1YlByb3ZpZGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L3Byb3ZpZGVyRmFjdG9yeS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9BcHBVcGRhdGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L0Jhc2VVcGRhdGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L2RpZmZlcmVudGlhbERvd25sb2FkZXIvZG93bmxvYWRQbGFuQnVpbGRlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9kaWZmZXJlbnRpYWxEb3dubG9hZGVyL0RhdGFTcGxpdHRlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9kaWZmZXJlbnRpYWxEb3dubG9hZGVyL211bHRpcGxlUmFuZ2VEb3dubG9hZGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L2RpZmZlcmVudGlhbERvd25sb2FkZXIvUHJvZ3Jlc3NEaWZmZXJlbnRpYWxEb3dubG9hZENhbGxiYWNrVHJhbnNmb3JtLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L2RpZmZlcmVudGlhbERvd25sb2FkZXIvRGlmZmVyZW50aWFsRG93bmxvYWRlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9kaWZmZXJlbnRpYWxEb3dubG9hZGVyL0ZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvQXBwSW1hZ2VVcGRhdGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L01hY1VwZGF0ZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvZGlmZmVyZW50aWFsRG93bmxvYWRlci9HZW5lcmljRGlmZmVyZW50aWFsRG93bmxvYWRlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC93aW5kb3dzRXhlY3V0YWJsZUNvZGVTaWduYXR1cmVWZXJpZmllci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9Oc2lzVXBkYXRlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9tYWluLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2lzLW9iai9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kb3QtcHJvcC9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9wYXRoLWV4aXN0cy9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9wLXRyeS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9wLWxpbWl0L2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3AtbG9jYXRlL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvY2F0ZS1wYXRoL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZpbmQtdXAvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcGtnLXVwL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Vudi1wYXRocy9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hdG9taWNhbGx5L2Rpc3QvY29uc3RzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2F0b21pY2FsbHkvZGlzdC91dGlscy9hdHRlbXB0aWZ5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2F0b21pY2FsbHkvZGlzdC91dGlscy9mc19oYW5kbGVycy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hdG9taWNhbGx5L2Rpc3QvdXRpbHMvcmV0cnlpZnlfcXVldWUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L3V0aWxzL3JldHJ5aWZ5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2F0b21pY2FsbHkvZGlzdC91dGlscy9mcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hdG9taWNhbGx5L2Rpc3QvdXRpbHMvbGFuZy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hdG9taWNhbGx5L2Rpc3QvdXRpbHMvc2NoZWR1bGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2F0b21pY2FsbHkvZGlzdC91dGlscy90ZW1wLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2F0b21pY2FsbHkvZGlzdC9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL2NvZGVnZW4vY29kZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL2NvZGVnZW4vc2NvcGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9jb2RlZ2VuL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdXRpbC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL25hbWVzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvZXJyb3JzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGUvYm9vbFNjaGVtYS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3J1bGVzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGUvYXBwbGljYWJpbGl0eS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL2RhdGFUeXBlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGUvZGVmYXVsdHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2NvZGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9rZXl3b3JkLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGUvc3Vic2NoZW1hLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Zhc3QtZGVlcC1lcXVhbC9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS10cmF2ZXJzZS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy91cmktanMvZGlzdC9lczUvdXJpLmFsbC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3Jlc29sdmUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3IuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9yZWZfZXJyb3IuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb3JlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9jb3JlL2lkLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9jb3JlL3JlZi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvY29yZS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9saW1pdE51bWJlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9tdWx0aXBsZU9mLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3J1bnRpbWUvdWNzMmxlbmd0aC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9saW1pdExlbmd0aC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9wYXR0ZXJuLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2xpbWl0UHJvcGVydGllcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9yZXF1aXJlZC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9saW1pdEl0ZW1zLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3J1bnRpbWUvZXF1YWwuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vdW5pcXVlSXRlbXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vY29uc3QuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vZW51bS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9hZGRpdGlvbmFsSXRlbXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaXRlbXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcHJlZml4SXRlbXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaXRlbXMyMDIwLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2NvbnRhaW5zLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2RlcGVuZGVuY2llcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9wcm9wZXJ0eU5hbWVzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2FkZGl0aW9uYWxQcm9wZXJ0aWVzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL3Byb3BlcnRpZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcGF0dGVyblByb3BlcnRpZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3Ivbm90LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2FueU9mLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL29uZU9mLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2FsbE9mLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2lmLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL3RoZW5FbHNlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9mb3JtYXQvZm9ybWF0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9mb3JtYXQvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL21ldGFkYXRhLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9kcmFmdDcuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2Rpc2NyaW1pbmF0b3IvdHlwZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2Rpc2NyaW1pbmF0b3IvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvYWp2LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi1mb3JtYXRzL2Rpc3QvZm9ybWF0cy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYtZm9ybWF0cy9kaXN0L2xpbWl0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi1mb3JtYXRzL2Rpc3QvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGVib3VuY2UtZm4vbm9kZV9tb2R1bGVzL21pbWljLWZuL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RlYm91bmNlLWZuL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL21pbWljLWZuL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29uZXRpbWUvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9kaXN0L3NvdXJjZS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1zdG9yZS9pbmRleC5qcyIsIi4uL3NyYy9zdG9yZS9tb2R1bGVzL2RhdGEuc3RvcmUuanMiLCIuLi9zcmMvc3RvcmUvbW9kdWxlcy9zZXR0aW5ncy5zdG9yZS5qcyIsIi4uL3NyYy9zdG9yZS9pbmRleC5qcyIsIi4uL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNsYXNzIE5vbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXHRjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG5cdFx0c3VwZXIoTm9uRXJyb3IuX3ByZXBhcmVTdXBlck1lc3NhZ2UobWVzc2FnZSkpO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbmFtZScsIHtcblx0XHRcdHZhbHVlOiAnTm9uRXJyb3InLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0d3JpdGFibGU6IHRydWVcblx0XHR9KTtcblxuXHRcdGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuXHRcdFx0RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgTm9uRXJyb3IpO1xuXHRcdH1cblx0fVxuXG5cdHN0YXRpYyBfcHJlcGFyZVN1cGVyTWVzc2FnZShtZXNzYWdlKSB7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeShtZXNzYWdlKTtcblx0XHR9IGNhdGNoIHtcblx0XHRcdHJldHVybiBTdHJpbmcobWVzc2FnZSk7XG5cdFx0fVxuXHR9XG59XG5cbmNvbnN0IGNvbW1vblByb3BlcnRpZXMgPSBbXG5cdHtwcm9wZXJ0eTogJ25hbWUnLCBlbnVtZXJhYmxlOiBmYWxzZX0sXG5cdHtwcm9wZXJ0eTogJ21lc3NhZ2UnLCBlbnVtZXJhYmxlOiBmYWxzZX0sXG5cdHtwcm9wZXJ0eTogJ3N0YWNrJywgZW51bWVyYWJsZTogZmFsc2V9LFxuXHR7cHJvcGVydHk6ICdjb2RlJywgZW51bWVyYWJsZTogdHJ1ZX1cbl07XG5cbmNvbnN0IGlzQ2FsbGVkID0gU3ltYm9sKCcudG9KU09OIGNhbGxlZCcpO1xuXG5jb25zdCB0b0pTT04gPSBmcm9tID0+IHtcblx0ZnJvbVtpc0NhbGxlZF0gPSB0cnVlO1xuXHRjb25zdCBqc29uID0gZnJvbS50b0pTT04oKTtcblx0ZGVsZXRlIGZyb21baXNDYWxsZWRdO1xuXHRyZXR1cm4ganNvbjtcbn07XG5cbmNvbnN0IGRlc3Ryb3lDaXJjdWxhciA9ICh7XG5cdGZyb20sXG5cdHNlZW4sXG5cdHRvXyxcblx0Zm9yY2VFbnVtZXJhYmxlLFxuXHRtYXhEZXB0aCxcblx0ZGVwdGhcbn0pID0+IHtcblx0Y29uc3QgdG8gPSB0b18gfHwgKEFycmF5LmlzQXJyYXkoZnJvbSkgPyBbXSA6IHt9KTtcblxuXHRzZWVuLnB1c2goZnJvbSk7XG5cblx0aWYgKGRlcHRoID49IG1heERlcHRoKSB7XG5cdFx0cmV0dXJuIHRvO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBmcm9tLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJyAmJiBmcm9tW2lzQ2FsbGVkXSAhPT0gdHJ1ZSkge1xuXHRcdHJldHVybiB0b0pTT04oZnJvbSk7XG5cdH1cblxuXHRmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhmcm9tKSkge1xuXHRcdGlmICh0eXBlb2YgQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcblx0XHRcdHRvW2tleV0gPSAnW29iamVjdCBCdWZmZXJdJztcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuXHRcdFx0dG9ba2V5XSA9IHZhbHVlO1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0aWYgKCFzZWVuLmluY2x1ZGVzKGZyb21ba2V5XSkpIHtcblx0XHRcdGRlcHRoKys7XG5cblx0XHRcdHRvW2tleV0gPSBkZXN0cm95Q2lyY3VsYXIoe1xuXHRcdFx0XHRmcm9tOiBmcm9tW2tleV0sXG5cdFx0XHRcdHNlZW46IHNlZW4uc2xpY2UoKSxcblx0XHRcdFx0Zm9yY2VFbnVtZXJhYmxlLFxuXHRcdFx0XHRtYXhEZXB0aCxcblx0XHRcdFx0ZGVwdGhcblx0XHRcdH0pO1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0dG9ba2V5XSA9ICdbQ2lyY3VsYXJdJztcblx0fVxuXG5cdGZvciAoY29uc3Qge3Byb3BlcnR5LCBlbnVtZXJhYmxlfSBvZiBjb21tb25Qcm9wZXJ0aWVzKSB7XG5cdFx0aWYgKHR5cGVvZiBmcm9tW3Byb3BlcnR5XSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0bywgcHJvcGVydHksIHtcblx0XHRcdFx0dmFsdWU6IGZyb21bcHJvcGVydHldLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiBmb3JjZUVudW1lcmFibGUgPyB0cnVlIDogZW51bWVyYWJsZSxcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcblxuY29uc3Qgc2VyaWFsaXplRXJyb3IgPSAodmFsdWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuXHRjb25zdCB7bWF4RGVwdGggPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFl9ID0gb3B0aW9ucztcblxuXHRpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuXHRcdHJldHVybiBkZXN0cm95Q2lyY3VsYXIoe1xuXHRcdFx0ZnJvbTogdmFsdWUsXG5cdFx0XHRzZWVuOiBbXSxcblx0XHRcdGZvcmNlRW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdG1heERlcHRoLFxuXHRcdFx0ZGVwdGg6IDBcblx0XHR9KTtcblx0fVxuXG5cdC8vIFBlb3BsZSBzb21ldGltZXMgdGhyb3cgdGhpbmdzIGJlc2lkZXMgRXJyb3Igb2JqZWN0c+KAplxuXHRpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0Ly8gYEpTT04uc3RyaW5naWZ5KClgIGRpc2NhcmRzIGZ1bmN0aW9ucy4gV2UgZG8gdG9vLCB1bmxlc3MgYSBmdW5jdGlvbiBpcyB0aHJvd24gZGlyZWN0bHkuXG5cdFx0cmV0dXJuIGBbRnVuY3Rpb246ICR7KHZhbHVlLm5hbWUgfHwgJ2Fub255bW91cycpfV1gO1xuXHR9XG5cblx0cmV0dXJuIHZhbHVlO1xufTtcblxuY29uc3QgZGVzZXJpYWxpemVFcnJvciA9ICh2YWx1ZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG5cdGNvbnN0IHttYXhEZXB0aCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWX0gPSBvcHRpb25zO1xuXG5cdGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cblx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0Y29uc3QgbmV3RXJyb3IgPSBuZXcgRXJyb3IoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSB1bmljb3JuL2Vycm9yLW1lc3NhZ2Vcblx0XHRkZXN0cm95Q2lyY3VsYXIoe1xuXHRcdFx0ZnJvbTogdmFsdWUsXG5cdFx0XHRzZWVuOiBbXSxcblx0XHRcdHRvXzogbmV3RXJyb3IsXG5cdFx0XHRtYXhEZXB0aCxcblx0XHRcdGRlcHRoOiAwXG5cdFx0fSk7XG5cdFx0cmV0dXJuIG5ld0Vycm9yO1xuXHR9XG5cblx0cmV0dXJuIG5ldyBOb25FcnJvcih2YWx1ZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0c2VyaWFsaXplRXJyb3IsXG5cdGRlc2VyaWFsaXplRXJyb3Jcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGdldFVuaXF1ZUlkID0gKCkgPT4gYCR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpfWA7XG5cbmNvbnN0IGdldFNlbmRDaGFubmVsID0gY2hhbm5lbCA9PiBgJWJldHRlci1pcGMtc2VuZC1jaGFubmVsLSR7Y2hhbm5lbH1gO1xuY29uc3QgZ2V0UmVuZGVyZXJTZW5kQ2hhbm5lbCA9IGNoYW5uZWwgPT4gYCViZXR0ZXItaXBjLXNlbmQtY2hhbm5lbC0ke2NoYW5uZWx9YDtcblxubW9kdWxlLmV4cG9ydHMuY3VycmVudFdpbmRvd0NoYW5uZWwgPSAnJWJldHRlci1pcGMtY3VycmVudC13aW5kb3cnO1xuXG5tb2R1bGUuZXhwb3J0cy5nZXRTZW5kQ2hhbm5lbCA9IGdldFNlbmRDaGFubmVsO1xubW9kdWxlLmV4cG9ydHMuZ2V0UmVuZGVyZXJTZW5kQ2hhbm5lbCA9IGdldFJlbmRlcmVyU2VuZENoYW5uZWw7XG5cbm1vZHVsZS5leHBvcnRzLmdldFJlc3BvbnNlQ2hhbm5lbHMgPSBjaGFubmVsID0+IHtcblx0Y29uc3QgaWQgPSBnZXRVbmlxdWVJZCgpO1xuXHRyZXR1cm4ge1xuXHRcdHNlbmRDaGFubmVsOiBnZXRTZW5kQ2hhbm5lbChjaGFubmVsKSxcblx0XHRkYXRhQ2hhbm5lbDogYCViZXR0ZXItaXBjLXJlc3BvbnNlLWRhdGEtY2hhbm5lbC0ke2NoYW5uZWx9LSR7aWR9YCxcblx0XHRlcnJvckNoYW5uZWw6IGAlYmV0dGVyLWlwYy1yZXNwb25zZS1lcnJvci1jaGFubmVsLSR7Y2hhbm5lbH0tJHtpZH1gXG5cdH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5nZXRSZW5kZXJlclJlc3BvbnNlQ2hhbm5lbHMgPSBjaGFubmVsID0+IHtcblx0Y29uc3QgaWQgPSBnZXRVbmlxdWVJZCgpO1xuXHRyZXR1cm4ge1xuXHRcdHNlbmRDaGFubmVsOiBnZXRSZW5kZXJlclNlbmRDaGFubmVsKGNoYW5uZWwpLFxuXHRcdGRhdGFDaGFubmVsOiBgJWJldHRlci1pcGMtcmVzcG9uc2UtZGF0YS1jaGFubmVsLSR7Y2hhbm5lbH0tJHtpZH1gLFxuXHRcdGVycm9yQ2hhbm5lbDogYCViZXR0ZXItaXBjLXJlc3BvbnNlLWVycm9yLWNoYW5uZWwtJHtjaGFubmVsfS0ke2lkfWBcblx0fTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBlbGVjdHJvbiA9IHJlcXVpcmUoJ2VsZWN0cm9uJyk7XG5jb25zdCB7c2VyaWFsaXplRXJyb3IsIGRlc2VyaWFsaXplRXJyb3J9ID0gcmVxdWlyZSgnc2VyaWFsaXplLWVycm9yJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsLmpzJyk7XG5cbmNvbnN0IHtpcGNSZW5kZXJlcn0gPSBlbGVjdHJvbjtcbmNvbnN0IGlwYyA9IE9iamVjdC5jcmVhdGUoaXBjUmVuZGVyZXIgfHwge30pO1xuXG5pcGMuY2FsbE1haW4gPSAoY2hhbm5lbCwgZGF0YSkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRjb25zdCB7c2VuZENoYW5uZWwsIGRhdGFDaGFubmVsLCBlcnJvckNoYW5uZWx9ID0gdXRpbC5nZXRSZXNwb25zZUNoYW5uZWxzKGNoYW5uZWwpO1xuXG5cdGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG5cdFx0aXBjUmVuZGVyZXIub2ZmKGRhdGFDaGFubmVsLCBvbkRhdGEpO1xuXHRcdGlwY1JlbmRlcmVyLm9mZihlcnJvckNoYW5uZWwsIG9uRXJyb3IpO1xuXHR9O1xuXG5cdGNvbnN0IG9uRGF0YSA9IChfZXZlbnQsIHJlc3VsdCkgPT4ge1xuXHRcdGNsZWFudXAoKTtcblx0XHRyZXNvbHZlKHJlc3VsdCk7XG5cdH07XG5cblx0Y29uc3Qgb25FcnJvciA9IChfZXZlbnQsIGVycm9yKSA9PiB7XG5cdFx0Y2xlYW51cCgpO1xuXHRcdHJlamVjdChkZXNlcmlhbGl6ZUVycm9yKGVycm9yKSk7XG5cdH07XG5cblx0aXBjUmVuZGVyZXIub25jZShkYXRhQ2hhbm5lbCwgb25EYXRhKTtcblx0aXBjUmVuZGVyZXIub25jZShlcnJvckNoYW5uZWwsIG9uRXJyb3IpO1xuXG5cdGNvbnN0IGNvbXBsZXRlRGF0YSA9IHtcblx0XHRkYXRhQ2hhbm5lbCxcblx0XHRlcnJvckNoYW5uZWwsXG5cdFx0dXNlckRhdGE6IGRhdGFcblx0fTtcblxuXHRpcGNSZW5kZXJlci5zZW5kKHNlbmRDaGFubmVsLCBjb21wbGV0ZURhdGEpO1xufSk7XG5cbmlwYy5hbnN3ZXJNYWluID0gKGNoYW5uZWwsIGNhbGxiYWNrKSA9PiB7XG5cdGNvbnN0IHNlbmRDaGFubmVsID0gdXRpbC5nZXRSZW5kZXJlclNlbmRDaGFubmVsKGNoYW5uZWwpO1xuXG5cdGNvbnN0IGxpc3RlbmVyID0gYXN5bmMgKF9ldmVudCwgZGF0YSkgPT4ge1xuXHRcdGNvbnN0IHtkYXRhQ2hhbm5lbCwgZXJyb3JDaGFubmVsLCB1c2VyRGF0YX0gPSBkYXRhO1xuXG5cdFx0dHJ5IHtcblx0XHRcdGlwY1JlbmRlcmVyLnNlbmQoZGF0YUNoYW5uZWwsIGF3YWl0IGNhbGxiYWNrKHVzZXJEYXRhKSk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlwY1JlbmRlcmVyLnNlbmQoZXJyb3JDaGFubmVsLCBzZXJpYWxpemVFcnJvcihlcnJvcikpO1xuXHRcdH1cblx0fTtcblxuXHRpcGNSZW5kZXJlci5vbihzZW5kQ2hhbm5lbCwgbGlzdGVuZXIpO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aXBjUmVuZGVyZXIub2ZmKHNlbmRDaGFubmVsLCBsaXN0ZW5lcik7XG5cdH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlwYztcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IGVsZWN0cm9uID0gcmVxdWlyZSgnZWxlY3Ryb24nKTtcbmNvbnN0IHtzZXJpYWxpemVFcnJvciwgZGVzZXJpYWxpemVFcnJvcn0gPSByZXF1aXJlKCdzZXJpYWxpemUtZXJyb3InKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwuanMnKTtcblxuY29uc3Qge2lwY01haW4sIEJyb3dzZXJXaW5kb3d9ID0gZWxlY3Ryb247XG5jb25zdCBpcGMgPSBPYmplY3QuY3JlYXRlKGlwY01haW4gfHwge30pO1xuXG5pcGMuY2FsbFJlbmRlcmVyID0gKGJyb3dzZXJXaW5kb3csIGNoYW5uZWwsIGRhdGEpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0aWYgKCFicm93c2VyV2luZG93KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdCcm93c2VyIHdpbmRvdyByZXF1aXJlZCcpO1xuXHR9XG5cblx0Y29uc3Qge3NlbmRDaGFubmVsLCBkYXRhQ2hhbm5lbCwgZXJyb3JDaGFubmVsfSA9IHV0aWwuZ2V0UmVuZGVyZXJSZXNwb25zZUNoYW5uZWxzKGNoYW5uZWwpO1xuXG5cdGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG5cdFx0aXBjTWFpbi5vZmYoZGF0YUNoYW5uZWwsIG9uRGF0YSk7XG5cdFx0aXBjTWFpbi5vZmYoZXJyb3JDaGFubmVsLCBvbkVycm9yKTtcblx0fTtcblxuXHRjb25zdCBvbkRhdGEgPSAoZXZlbnQsIHJlc3VsdCkgPT4ge1xuXHRcdGNvbnN0IHdpbmRvdyA9IEJyb3dzZXJXaW5kb3cuZnJvbVdlYkNvbnRlbnRzKGV2ZW50LnNlbmRlcik7XG5cdFx0aWYgKHdpbmRvdy5pZCA9PT0gYnJvd3NlcldpbmRvdy5pZCkge1xuXHRcdFx0Y2xlYW51cCgpO1xuXHRcdFx0cmVzb2x2ZShyZXN1bHQpO1xuXHRcdH1cblx0fTtcblxuXHRjb25zdCBvbkVycm9yID0gKGV2ZW50LCBlcnJvcikgPT4ge1xuXHRcdGNvbnN0IHdpbmRvdyA9IEJyb3dzZXJXaW5kb3cuZnJvbVdlYkNvbnRlbnRzKGV2ZW50LnNlbmRlcik7XG5cdFx0aWYgKHdpbmRvdy5pZCA9PT0gYnJvd3NlcldpbmRvdy5pZCkge1xuXHRcdFx0Y2xlYW51cCgpO1xuXHRcdFx0cmVqZWN0KGRlc2VyaWFsaXplRXJyb3IoZXJyb3IpKTtcblx0XHR9XG5cdH07XG5cblx0aXBjTWFpbi5vbihkYXRhQ2hhbm5lbCwgb25EYXRhKTtcblx0aXBjTWFpbi5vbihlcnJvckNoYW5uZWwsIG9uRXJyb3IpO1xuXG5cdGNvbnN0IGNvbXBsZXRlRGF0YSA9IHtcblx0XHRkYXRhQ2hhbm5lbCxcblx0XHRlcnJvckNoYW5uZWwsXG5cdFx0dXNlckRhdGE6IGRhdGFcblx0fTtcblxuXHRpZiAoYnJvd3NlcldpbmRvdy53ZWJDb250ZW50cykge1xuXHRcdGJyb3dzZXJXaW5kb3cud2ViQ29udGVudHMuc2VuZChzZW5kQ2hhbm5lbCwgY29tcGxldGVEYXRhKTtcblx0fVxufSk7XG5cbmlwYy5jYWxsRm9jdXNlZFJlbmRlcmVyID0gYXN5bmMgKC4uLmFyZ3MpID0+IHtcblx0Y29uc3QgZm9jdXNlZFdpbmRvdyA9IEJyb3dzZXJXaW5kb3cuZ2V0Rm9jdXNlZFdpbmRvdygpO1xuXHRpZiAoIWZvY3VzZWRXaW5kb3cpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ05vIGJyb3dzZXIgd2luZG93IGluIGZvY3VzJyk7XG5cdH1cblxuXHRyZXR1cm4gaXBjLmNhbGxSZW5kZXJlcihmb2N1c2VkV2luZG93LCAuLi5hcmdzKTtcbn07XG5cbmlwYy5hbnN3ZXJSZW5kZXJlciA9IChicm93c2VyV2luZG93T3JDaGFubmVsLCBjaGFubmVsT3JDYWxsYmFjaywgY2FsbGJhY2tPck5vdGhpbmcpID0+IHtcblx0bGV0IHdpbmRvdztcblx0bGV0IGNoYW5uZWw7XG5cdGxldCBjYWxsYmFjaztcblxuXHRpZiAoY2FsbGJhY2tPck5vdGhpbmcgPT09IHVuZGVmaW5lZCkge1xuXHRcdGNoYW5uZWwgPSBicm93c2VyV2luZG93T3JDaGFubmVsO1xuXHRcdGNhbGxiYWNrID0gY2hhbm5lbE9yQ2FsbGJhY2s7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93ID0gYnJvd3NlcldpbmRvd09yQ2hhbm5lbDtcblx0XHRjaGFubmVsID0gY2hhbm5lbE9yQ2FsbGJhY2s7XG5cdFx0Y2FsbGJhY2sgPSBjYWxsYmFja09yTm90aGluZztcblxuXHRcdGlmICghd2luZG93KSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Jyb3dzZXIgd2luZG93IHJlcXVpcmVkJyk7XG5cdFx0fVxuXHR9XG5cblx0Y29uc3Qgc2VuZENoYW5uZWwgPSB1dGlsLmdldFNlbmRDaGFubmVsKGNoYW5uZWwpO1xuXG5cdGNvbnN0IGxpc3RlbmVyID0gYXN5bmMgKGV2ZW50LCBkYXRhKSA9PiB7XG5cdFx0Y29uc3QgYnJvd3NlcldpbmRvdyA9IEJyb3dzZXJXaW5kb3cuZnJvbVdlYkNvbnRlbnRzKGV2ZW50LnNlbmRlcik7XG5cblx0XHRpZiAod2luZG93ICYmIHdpbmRvdy5pZCAhPT0gYnJvd3NlcldpbmRvdy5pZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IHNlbmQgPSAoY2hhbm5lbCwgZGF0YSkgPT4ge1xuXHRcdFx0aWYgKCEoYnJvd3NlcldpbmRvdyAmJiBicm93c2VyV2luZG93LmlzRGVzdHJveWVkKCkpKSB7XG5cdFx0XHRcdGV2ZW50LnNlbmRlci5zZW5kKGNoYW5uZWwsIGRhdGEpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRjb25zdCB7ZGF0YUNoYW5uZWwsIGVycm9yQ2hhbm5lbCwgdXNlckRhdGF9ID0gZGF0YTtcblxuXHRcdHRyeSB7XG5cdFx0XHRzZW5kKGRhdGFDaGFubmVsLCBhd2FpdCBjYWxsYmFjayh1c2VyRGF0YSwgYnJvd3NlcldpbmRvdykpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRzZW5kKGVycm9yQ2hhbm5lbCwgc2VyaWFsaXplRXJyb3IoZXJyb3IpKTtcblx0XHR9XG5cdH07XG5cblx0aXBjTWFpbi5vbihzZW5kQ2hhbm5lbCwgbGlzdGVuZXIpO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aXBjTWFpbi5vZmYoc2VuZENoYW5uZWwsIGxpc3RlbmVyKTtcblx0fTtcbn07XG5cbmlwYy5zZW5kVG9SZW5kZXJlcnMgPSAoY2hhbm5lbCwgZGF0YSkgPT4ge1xuXHRmb3IgKGNvbnN0IGJyb3dzZXJXaW5kb3cgb2YgQnJvd3NlcldpbmRvdy5nZXRBbGxXaW5kb3dzKCkpIHtcblx0XHRpZiAoYnJvd3NlcldpbmRvdy53ZWJDb250ZW50cykge1xuXHRcdFx0YnJvd3NlcldpbmRvdy53ZWJDb250ZW50cy5zZW5kKGNoYW5uZWwsIGRhdGEpO1xuXHRcdH1cblx0fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpcGM7XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcblx0bW9kdWxlLmV4cG9ydHMuaXBjUmVuZGVyZXIgPSByZXF1aXJlKCcuL3NvdXJjZS9yZW5kZXJlci5qcycpO1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMuaXBjTWFpbiA9IHJlcXVpcmUoJy4vc291cmNlL21haW4uanMnKTtcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmZyb21DYWxsYmFjayA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicpIGZuLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBmbi5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgLi4uYXJncyxcbiAgICAgICAgICAoZXJyLCByZXMpID0+IChlcnIgIT0gbnVsbCkgPyByZWplY3QoZXJyKSA6IHJlc29sdmUocmVzKVxuICAgICAgICApXG4gICAgICB9KVxuICAgIH1cbiAgfSwgJ25hbWUnLCB7IHZhbHVlOiBmbi5uYW1lIH0pXG59XG5cbmV4cG9ydHMuZnJvbVByb21pc2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmdW5jdGlvbiAoLi4uYXJncykge1xuICAgIGNvbnN0IGNiID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdXG4gICAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgZWxzZSBmbi5hcHBseSh0aGlzLCBhcmdzLnNsaWNlKDAsIC0xKSkudGhlbihyID0+IGNiKG51bGwsIHIpLCBjYilcbiAgfSwgJ25hbWUnLCB7IHZhbHVlOiBmbi5uYW1lIH0pXG59XG4iLCJ2YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnY29uc3RhbnRzJylcblxudmFyIG9yaWdDd2QgPSBwcm9jZXNzLmN3ZFxudmFyIGN3ZCA9IG51bGxcblxudmFyIHBsYXRmb3JtID0gcHJvY2Vzcy5lbnYuR1JBQ0VGVUxfRlNfUExBVEZPUk0gfHwgcHJvY2Vzcy5wbGF0Zm9ybVxuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIWN3ZClcbiAgICBjd2QgPSBvcmlnQ3dkLmNhbGwocHJvY2VzcylcbiAgcmV0dXJuIGN3ZFxufVxudHJ5IHtcbiAgcHJvY2Vzcy5jd2QoKVxufSBjYXRjaCAoZXIpIHt9XG5cbi8vIFRoaXMgY2hlY2sgaXMgbmVlZGVkIHVudGlsIG5vZGUuanMgMTIgaXMgcmVxdWlyZWRcbmlmICh0eXBlb2YgcHJvY2Vzcy5jaGRpciA9PT0gJ2Z1bmN0aW9uJykge1xuICB2YXIgY2hkaXIgPSBwcm9jZXNzLmNoZGlyXG4gIHByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZCkge1xuICAgIGN3ZCA9IG51bGxcbiAgICBjaGRpci5jYWxsKHByb2Nlc3MsIGQpXG4gIH1cbiAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikgT2JqZWN0LnNldFByb3RvdHlwZU9mKHByb2Nlc3MuY2hkaXIsIGNoZGlyKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGNoXG5cbmZ1bmN0aW9uIHBhdGNoIChmcykge1xuICAvLyAocmUtKWltcGxlbWVudCBzb21lIHRoaW5ncyB0aGF0IGFyZSBrbm93biBidXN0ZWQgb3IgbWlzc2luZy5cblxuICAvLyBsY2htb2QsIGJyb2tlbiBwcmlvciB0byAwLjYuMlxuICAvLyBiYWNrLXBvcnQgdGhlIGZpeCBoZXJlLlxuICBpZiAoY29uc3RhbnRzLmhhc093blByb3BlcnR5KCdPX1NZTUxJTksnKSAmJlxuICAgICAgcHJvY2Vzcy52ZXJzaW9uLm1hdGNoKC9edjBcXC42XFwuWzAtMl18XnYwXFwuNVxcLi8pKSB7XG4gICAgcGF0Y2hMY2htb2QoZnMpXG4gIH1cblxuICAvLyBsdXRpbWVzIGltcGxlbWVudGF0aW9uLCBvciBuby1vcFxuICBpZiAoIWZzLmx1dGltZXMpIHtcbiAgICBwYXRjaEx1dGltZXMoZnMpXG4gIH1cblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vaXNhYWNzL25vZGUtZ3JhY2VmdWwtZnMvaXNzdWVzLzRcbiAgLy8gQ2hvd24gc2hvdWxkIG5vdCBmYWlsIG9uIGVpbnZhbCBvciBlcGVybSBpZiBub24tcm9vdC5cbiAgLy8gSXQgc2hvdWxkIG5vdCBmYWlsIG9uIGVub3N5cyBldmVyLCBhcyB0aGlzIGp1c3QgaW5kaWNhdGVzXG4gIC8vIHRoYXQgYSBmcyBkb2Vzbid0IHN1cHBvcnQgdGhlIGludGVuZGVkIG9wZXJhdGlvbi5cblxuICBmcy5jaG93biA9IGNob3duRml4KGZzLmNob3duKVxuICBmcy5mY2hvd24gPSBjaG93bkZpeChmcy5mY2hvd24pXG4gIGZzLmxjaG93biA9IGNob3duRml4KGZzLmxjaG93bilcblxuICBmcy5jaG1vZCA9IGNobW9kRml4KGZzLmNobW9kKVxuICBmcy5mY2htb2QgPSBjaG1vZEZpeChmcy5mY2htb2QpXG4gIGZzLmxjaG1vZCA9IGNobW9kRml4KGZzLmxjaG1vZClcblxuICBmcy5jaG93blN5bmMgPSBjaG93bkZpeFN5bmMoZnMuY2hvd25TeW5jKVxuICBmcy5mY2hvd25TeW5jID0gY2hvd25GaXhTeW5jKGZzLmZjaG93blN5bmMpXG4gIGZzLmxjaG93blN5bmMgPSBjaG93bkZpeFN5bmMoZnMubGNob3duU3luYylcblxuICBmcy5jaG1vZFN5bmMgPSBjaG1vZEZpeFN5bmMoZnMuY2htb2RTeW5jKVxuICBmcy5mY2htb2RTeW5jID0gY2htb2RGaXhTeW5jKGZzLmZjaG1vZFN5bmMpXG4gIGZzLmxjaG1vZFN5bmMgPSBjaG1vZEZpeFN5bmMoZnMubGNobW9kU3luYylcblxuICBmcy5zdGF0ID0gc3RhdEZpeChmcy5zdGF0KVxuICBmcy5mc3RhdCA9IHN0YXRGaXgoZnMuZnN0YXQpXG4gIGZzLmxzdGF0ID0gc3RhdEZpeChmcy5sc3RhdClcblxuICBmcy5zdGF0U3luYyA9IHN0YXRGaXhTeW5jKGZzLnN0YXRTeW5jKVxuICBmcy5mc3RhdFN5bmMgPSBzdGF0Rml4U3luYyhmcy5mc3RhdFN5bmMpXG4gIGZzLmxzdGF0U3luYyA9IHN0YXRGaXhTeW5jKGZzLmxzdGF0U3luYylcblxuICAvLyBpZiBsY2htb2QvbGNob3duIGRvIG5vdCBleGlzdCwgdGhlbiBtYWtlIHRoZW0gbm8tb3BzXG4gIGlmICghZnMubGNobW9kKSB7XG4gICAgZnMubGNobW9kID0gZnVuY3Rpb24gKHBhdGgsIG1vZGUsIGNiKSB7XG4gICAgICBpZiAoY2IpIHByb2Nlc3MubmV4dFRpY2soY2IpXG4gICAgfVxuICAgIGZzLmxjaG1vZFN5bmMgPSBmdW5jdGlvbiAoKSB7fVxuICB9XG4gIGlmICghZnMubGNob3duKSB7XG4gICAgZnMubGNob3duID0gZnVuY3Rpb24gKHBhdGgsIHVpZCwgZ2lkLCBjYikge1xuICAgICAgaWYgKGNiKSBwcm9jZXNzLm5leHRUaWNrKGNiKVxuICAgIH1cbiAgICBmcy5sY2hvd25TeW5jID0gZnVuY3Rpb24gKCkge31cbiAgfVxuXG4gIC8vIG9uIFdpbmRvd3MsIEEvViBzb2Z0d2FyZSBjYW4gbG9jayB0aGUgZGlyZWN0b3J5LCBjYXVzaW5nIHRoaXNcbiAgLy8gdG8gZmFpbCB3aXRoIGFuIEVBQ0NFUyBvciBFUEVSTSBpZiB0aGUgZGlyZWN0b3J5IGNvbnRhaW5zIG5ld2x5XG4gIC8vIGNyZWF0ZWQgZmlsZXMuICBUcnkgYWdhaW4gb24gZmFpbHVyZSwgZm9yIHVwIHRvIDYwIHNlY29uZHMuXG5cbiAgLy8gU2V0IHRoZSB0aW1lb3V0IHRoaXMgbG9uZyBiZWNhdXNlIHNvbWUgV2luZG93cyBBbnRpLVZpcnVzLCBzdWNoIGFzIFBhcml0eVxuICAvLyBiaXQ5LCBtYXkgbG9jayBmaWxlcyBmb3IgdXAgdG8gYSBtaW51dGUsIGNhdXNpbmcgbnBtIHBhY2thZ2UgaW5zdGFsbFxuICAvLyBmYWlsdXJlcy4gQWxzbywgdGFrZSBjYXJlIHRvIHlpZWxkIHRoZSBzY2hlZHVsZXIuIFdpbmRvd3Mgc2NoZWR1bGluZyBnaXZlc1xuICAvLyBDUFUgdG8gYSBidXN5IGxvb3BpbmcgcHJvY2Vzcywgd2hpY2ggY2FuIGNhdXNlIHRoZSBwcm9ncmFtIGNhdXNpbmcgdGhlIGxvY2tcbiAgLy8gY29udGVudGlvbiB0byBiZSBzdGFydmVkIG9mIENQVSBieSBub2RlLCBzbyB0aGUgY29udGVudGlvbiBkb2Vzbid0IHJlc29sdmUuXG4gIGlmIChwbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiKSB7XG4gICAgZnMucmVuYW1lID0gKGZ1bmN0aW9uIChmcyRyZW5hbWUpIHsgcmV0dXJuIGZ1bmN0aW9uIChmcm9tLCB0bywgY2IpIHtcbiAgICAgIHZhciBzdGFydCA9IERhdGUubm93KClcbiAgICAgIHZhciBiYWNrb2ZmID0gMDtcbiAgICAgIGZzJHJlbmFtZShmcm9tLCB0bywgZnVuY3Rpb24gQ0IgKGVyKSB7XG4gICAgICAgIGlmIChlclxuICAgICAgICAgICAgJiYgKGVyLmNvZGUgPT09IFwiRUFDQ0VTXCIgfHwgZXIuY29kZSA9PT0gXCJFUEVSTVwiKVxuICAgICAgICAgICAgJiYgRGF0ZS5ub3coKSAtIHN0YXJ0IDwgNjAwMDApIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZnMuc3RhdCh0bywgZnVuY3Rpb24gKHN0YXRlciwgc3QpIHtcbiAgICAgICAgICAgICAgaWYgKHN0YXRlciAmJiBzdGF0ZXIuY29kZSA9PT0gXCJFTk9FTlRcIilcbiAgICAgICAgICAgICAgICBmcyRyZW5hbWUoZnJvbSwgdG8sIENCKTtcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNiKGVyKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9LCBiYWNrb2ZmKVxuICAgICAgICAgIGlmIChiYWNrb2ZmIDwgMTAwKVxuICAgICAgICAgICAgYmFja29mZiArPSAxMDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNiKSBjYihlcilcbiAgICAgIH0pXG4gICAgfX0pKGZzLnJlbmFtZSlcbiAgfVxuXG4gIC8vIGlmIHJlYWQoKSByZXR1cm5zIEVBR0FJTiwgdGhlbiBqdXN0IHRyeSBpdCBhZ2Fpbi5cbiAgZnMucmVhZCA9IChmdW5jdGlvbiAoZnMkcmVhZCkge1xuICAgIGZ1bmN0aW9uIHJlYWQgKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FsbGJhY2tfKSB7XG4gICAgICB2YXIgY2FsbGJhY2tcbiAgICAgIGlmIChjYWxsYmFja18gJiYgdHlwZW9mIGNhbGxiYWNrXyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgZWFnQ291bnRlciA9IDBcbiAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoZXIsIF8sIF9fKSB7XG4gICAgICAgICAgaWYgKGVyICYmIGVyLmNvZGUgPT09ICdFQUdBSU4nICYmIGVhZ0NvdW50ZXIgPCAxMCkge1xuICAgICAgICAgICAgZWFnQ291bnRlciArK1xuICAgICAgICAgICAgcmV0dXJuIGZzJHJlYWQuY2FsbChmcywgZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaylcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2tfLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZzJHJlYWQuY2FsbChmcywgZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaylcbiAgICB9XG5cbiAgICAvLyBUaGlzIGVuc3VyZXMgYHV0aWwucHJvbWlzaWZ5YCB3b3JrcyBhcyBpdCBkb2VzIGZvciBuYXRpdmUgYGZzLnJlYWRgLlxuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIE9iamVjdC5zZXRQcm90b3R5cGVPZihyZWFkLCBmcyRyZWFkKVxuICAgIHJldHVybiByZWFkXG4gIH0pKGZzLnJlYWQpXG5cbiAgZnMucmVhZFN5bmMgPSAoZnVuY3Rpb24gKGZzJHJlYWRTeW5jKSB7IHJldHVybiBmdW5jdGlvbiAoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKSB7XG4gICAgdmFyIGVhZ0NvdW50ZXIgPSAwXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmcyRyZWFkU3luYy5jYWxsKGZzLCBmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICBpZiAoZXIuY29kZSA9PT0gJ0VBR0FJTicgJiYgZWFnQ291bnRlciA8IDEwKSB7XG4gICAgICAgICAgZWFnQ291bnRlciArK1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJcbiAgICAgIH1cbiAgICB9XG4gIH19KShmcy5yZWFkU3luYylcblxuICBmdW5jdGlvbiBwYXRjaExjaG1vZCAoZnMpIHtcbiAgICBmcy5sY2htb2QgPSBmdW5jdGlvbiAocGF0aCwgbW9kZSwgY2FsbGJhY2spIHtcbiAgICAgIGZzLm9wZW4oIHBhdGhcbiAgICAgICAgICAgICAsIGNvbnN0YW50cy5PX1dST05MWSB8IGNvbnN0YW50cy5PX1NZTUxJTktcbiAgICAgICAgICAgICAsIG1vZGVcbiAgICAgICAgICAgICAsIGZ1bmN0aW9uIChlcnIsIGZkKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVycilcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICAvLyBwcmVmZXIgdG8gcmV0dXJuIHRoZSBjaG1vZCBlcnJvciwgaWYgb25lIG9jY3VycyxcbiAgICAgICAgLy8gYnV0IHN0aWxsIHRyeSB0byBjbG9zZSwgYW5kIHJlcG9ydCBjbG9zaW5nIGVycm9ycyBpZiB0aGV5IG9jY3VyLlxuICAgICAgICBmcy5mY2htb2QoZmQsIG1vZGUsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBmcy5jbG9zZShmZCwgZnVuY3Rpb24oZXJyMikge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhlcnIgfHwgZXJyMilcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBmcy5sY2htb2RTeW5jID0gZnVuY3Rpb24gKHBhdGgsIG1vZGUpIHtcbiAgICAgIHZhciBmZCA9IGZzLm9wZW5TeW5jKHBhdGgsIGNvbnN0YW50cy5PX1dST05MWSB8IGNvbnN0YW50cy5PX1NZTUxJTkssIG1vZGUpXG5cbiAgICAgIC8vIHByZWZlciB0byByZXR1cm4gdGhlIGNobW9kIGVycm9yLCBpZiBvbmUgb2NjdXJzLFxuICAgICAgLy8gYnV0IHN0aWxsIHRyeSB0byBjbG9zZSwgYW5kIHJlcG9ydCBjbG9zaW5nIGVycm9ycyBpZiB0aGV5IG9jY3VyLlxuICAgICAgdmFyIHRocmV3ID0gdHJ1ZVxuICAgICAgdmFyIHJldFxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0ID0gZnMuZmNobW9kU3luYyhmZCwgbW9kZSlcbiAgICAgICAgdGhyZXcgPSBmYWxzZVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHRocmV3KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZzLmNsb3NlU3luYyhmZClcbiAgICAgICAgICB9IGNhdGNoIChlcikge31cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmcy5jbG9zZVN5bmMoZmQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXRcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXRjaEx1dGltZXMgKGZzKSB7XG4gICAgaWYgKGNvbnN0YW50cy5oYXNPd25Qcm9wZXJ0eShcIk9fU1lNTElOS1wiKSkge1xuICAgICAgZnMubHV0aW1lcyA9IGZ1bmN0aW9uIChwYXRoLCBhdCwgbXQsIGNiKSB7XG4gICAgICAgIGZzLm9wZW4ocGF0aCwgY29uc3RhbnRzLk9fU1lNTElOSywgZnVuY3Rpb24gKGVyLCBmZCkge1xuICAgICAgICAgIGlmIChlcikge1xuICAgICAgICAgICAgaWYgKGNiKSBjYihlcilcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICBmcy5mdXRpbWVzKGZkLCBhdCwgbXQsIGZ1bmN0aW9uIChlcikge1xuICAgICAgICAgICAgZnMuY2xvc2UoZmQsIGZ1bmN0aW9uIChlcjIpIHtcbiAgICAgICAgICAgICAgaWYgKGNiKSBjYihlciB8fCBlcjIpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGZzLmx1dGltZXNTeW5jID0gZnVuY3Rpb24gKHBhdGgsIGF0LCBtdCkge1xuICAgICAgICB2YXIgZmQgPSBmcy5vcGVuU3luYyhwYXRoLCBjb25zdGFudHMuT19TWU1MSU5LKVxuICAgICAgICB2YXIgcmV0XG4gICAgICAgIHZhciB0aHJldyA9IHRydWVcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXQgPSBmcy5mdXRpbWVzU3luYyhmZCwgYXQsIG10KVxuICAgICAgICAgIHRocmV3ID0gZmFsc2VcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAodGhyZXcpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZzLmNsb3NlU3luYyhmZClcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVyKSB7fVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcy5jbG9zZVN5bmMoZmQpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXRcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBmcy5sdXRpbWVzID0gZnVuY3Rpb24gKF9hLCBfYiwgX2MsIGNiKSB7IGlmIChjYikgcHJvY2Vzcy5uZXh0VGljayhjYikgfVxuICAgICAgZnMubHV0aW1lc1N5bmMgPSBmdW5jdGlvbiAoKSB7fVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNobW9kRml4IChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBtb2RlLCBjYikge1xuICAgICAgcmV0dXJuIG9yaWcuY2FsbChmcywgdGFyZ2V0LCBtb2RlLCBmdW5jdGlvbiAoZXIpIHtcbiAgICAgICAgaWYgKGNob3duRXJPayhlcikpIGVyID0gbnVsbFxuICAgICAgICBpZiAoY2IpIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2htb2RGaXhTeW5jIChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBtb2RlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIG1vZGUpXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICBpZiAoIWNob3duRXJPayhlcikpIHRocm93IGVyXG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICBmdW5jdGlvbiBjaG93bkZpeCAob3JpZykge1xuICAgIGlmICghb3JpZykgcmV0dXJuIG9yaWdcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgdWlkLCBnaWQsIGNiKSB7XG4gICAgICByZXR1cm4gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIHVpZCwgZ2lkLCBmdW5jdGlvbiAoZXIpIHtcbiAgICAgICAgaWYgKGNob3duRXJPayhlcikpIGVyID0gbnVsbFxuICAgICAgICBpZiAoY2IpIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hvd25GaXhTeW5jIChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCB1aWQsIGdpZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG9yaWcuY2FsbChmcywgdGFyZ2V0LCB1aWQsIGdpZClcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIGlmICghY2hvd25Fck9rKGVyKSkgdGhyb3cgZXJcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdGF0Rml4IChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIC8vIE9sZGVyIHZlcnNpb25zIG9mIE5vZGUgZXJyb25lb3VzbHkgcmV0dXJuZWQgc2lnbmVkIGludGVnZXJzIGZvclxuICAgIC8vIHVpZCArIGdpZC5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucywgY2IpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYiA9IG9wdGlvbnNcbiAgICAgICAgb3B0aW9ucyA9IG51bGxcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNhbGxiYWNrIChlciwgc3RhdHMpIHtcbiAgICAgICAgaWYgKHN0YXRzKSB7XG4gICAgICAgICAgaWYgKHN0YXRzLnVpZCA8IDApIHN0YXRzLnVpZCArPSAweDEwMDAwMDAwMFxuICAgICAgICAgIGlmIChzdGF0cy5naWQgPCAwKSBzdGF0cy5naWQgKz0gMHgxMDAwMDAwMDBcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2IpIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zID8gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgICAgICA6IG9yaWcuY2FsbChmcywgdGFyZ2V0LCBjYWxsYmFjaylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdGF0Rml4U3luYyAob3JpZykge1xuICAgIGlmICghb3JpZykgcmV0dXJuIG9yaWdcbiAgICAvLyBPbGRlciB2ZXJzaW9ucyBvZiBOb2RlIGVycm9uZW91c2x5IHJldHVybmVkIHNpZ25lZCBpbnRlZ2VycyBmb3JcbiAgICAvLyB1aWQgKyBnaWQuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzdGF0cyA9IG9wdGlvbnMgPyBvcmlnLmNhbGwoZnMsIHRhcmdldCwgb3B0aW9ucylcbiAgICAgICAgOiBvcmlnLmNhbGwoZnMsIHRhcmdldClcbiAgICAgIGlmIChzdGF0cy51aWQgPCAwKSBzdGF0cy51aWQgKz0gMHgxMDAwMDAwMDBcbiAgICAgIGlmIChzdGF0cy5naWQgPCAwKSBzdGF0cy5naWQgKz0gMHgxMDAwMDAwMDBcbiAgICAgIHJldHVybiBzdGF0cztcbiAgICB9XG4gIH1cblxuICAvLyBFTk9TWVMgbWVhbnMgdGhhdCB0aGUgZnMgZG9lc24ndCBzdXBwb3J0IHRoZSBvcC4gSnVzdCBpZ25vcmVcbiAgLy8gdGhhdCwgYmVjYXVzZSBpdCBkb2Vzbid0IG1hdHRlci5cbiAgLy9cbiAgLy8gaWYgdGhlcmUncyBubyBnZXR1aWQsIG9yIGlmIGdldHVpZCgpIGlzIHNvbWV0aGluZyBvdGhlclxuICAvLyB0aGFuIDAsIGFuZCB0aGUgZXJyb3IgaXMgRUlOVkFMIG9yIEVQRVJNLCB0aGVuIGp1c3QgaWdub3JlXG4gIC8vIGl0LlxuICAvL1xuICAvLyBUaGlzIHNwZWNpZmljIGNhc2UgaXMgYSBzaWxlbnQgZmFpbHVyZSBpbiBjcCwgaW5zdGFsbCwgdGFyLFxuICAvLyBhbmQgbW9zdCBvdGhlciB1bml4IHRvb2xzIHRoYXQgbWFuYWdlIHBlcm1pc3Npb25zLlxuICAvL1xuICAvLyBXaGVuIHJ1bm5pbmcgYXMgcm9vdCwgb3IgaWYgb3RoZXIgdHlwZXMgb2YgZXJyb3JzIGFyZVxuICAvLyBlbmNvdW50ZXJlZCwgdGhlbiBpdCdzIHN0cmljdC5cbiAgZnVuY3Rpb24gY2hvd25Fck9rIChlcikge1xuICAgIGlmICghZXIpXG4gICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgaWYgKGVyLmNvZGUgPT09IFwiRU5PU1lTXCIpXG4gICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgdmFyIG5vbnJvb3QgPSAhcHJvY2Vzcy5nZXR1aWQgfHwgcHJvY2Vzcy5nZXR1aWQoKSAhPT0gMFxuICAgIGlmIChub25yb290KSB7XG4gICAgICBpZiAoZXIuY29kZSA9PT0gXCJFSU5WQUxcIiB8fCBlci5jb2RlID09PSBcIkVQRVJNXCIpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cbiIsInZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKS5TdHJlYW1cblxubW9kdWxlLmV4cG9ydHMgPSBsZWdhY3lcblxuZnVuY3Rpb24gbGVnYWN5IChmcykge1xuICByZXR1cm4ge1xuICAgIFJlYWRTdHJlYW06IFJlYWRTdHJlYW0sXG4gICAgV3JpdGVTdHJlYW06IFdyaXRlU3RyZWFtXG4gIH1cblxuICBmdW5jdGlvbiBSZWFkU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRTdHJlYW0pKSByZXR1cm4gbmV3IFJlYWRTdHJlYW0ocGF0aCwgb3B0aW9ucyk7XG5cbiAgICBTdHJlYW0uY2FsbCh0aGlzKTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5mZCA9IG51bGw7XG4gICAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuZmxhZ3MgPSAncic7XG4gICAgdGhpcy5tb2RlID0gNDM4OyAvKj0wNjY2Ki9cbiAgICB0aGlzLmJ1ZmZlclNpemUgPSA2NCAqIDEwMjQ7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIE1peGluIG9wdGlvbnMgaW50byB0aGlzXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmVuY29kaW5nKSB0aGlzLnNldEVuY29kaW5nKHRoaXMuZW5jb2RpbmcpO1xuXG4gICAgaWYgKHRoaXMuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCdudW1iZXInICE9PSB0eXBlb2YgdGhpcy5zdGFydCkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ3N0YXJ0IG11c3QgYmUgYSBOdW1iZXInKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZW5kID0gSW5maW5pdHk7XG4gICAgICB9IGVsc2UgaWYgKCdudW1iZXInICE9PSB0eXBlb2YgdGhpcy5lbmQpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdlbmQgbXVzdCBiZSBhIE51bWJlcicpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zdGFydCA+IHRoaXMuZW5kKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3RhcnQgbXVzdCBiZSA8PSBlbmQnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wb3MgPSB0aGlzLnN0YXJ0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZkICE9PSBudWxsKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLl9yZWFkKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmcy5vcGVuKHRoaXMucGF0aCwgdGhpcy5mbGFncywgdGhpcy5tb2RlLCBmdW5jdGlvbiAoZXJyLCBmZCkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgc2VsZi5yZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNlbGYuZmQgPSBmZDtcbiAgICAgIHNlbGYuZW1pdCgnb3BlbicsIGZkKTtcbiAgICAgIHNlbGYuX3JlYWQoKTtcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gV3JpdGVTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV3JpdGVTdHJlYW0pKSByZXR1cm4gbmV3IFdyaXRlU3RyZWFtKHBhdGgsIG9wdGlvbnMpO1xuXG4gICAgU3RyZWFtLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMuZmQgPSBudWxsO1xuICAgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gICAgdGhpcy5mbGFncyA9ICd3JztcbiAgICB0aGlzLmVuY29kaW5nID0gJ2JpbmFyeSc7XG4gICAgdGhpcy5tb2RlID0gNDM4OyAvKj0wNjY2Ki9cbiAgICB0aGlzLmJ5dGVzV3JpdHRlbiA9IDA7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIE1peGluIG9wdGlvbnMgaW50byB0aGlzXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICgnbnVtYmVyJyAhPT0gdHlwZW9mIHRoaXMuc3RhcnQpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdzdGFydCBtdXN0IGJlIGEgTnVtYmVyJyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdGFydCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdGFydCBtdXN0IGJlID49IHplcm8nKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wb3MgPSB0aGlzLnN0YXJ0O1xuICAgIH1cblxuICAgIHRoaXMuYnVzeSA9IGZhbHNlO1xuICAgIHRoaXMuX3F1ZXVlID0gW107XG5cbiAgICBpZiAodGhpcy5mZCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fb3BlbiA9IGZzLm9wZW47XG4gICAgICB0aGlzLl9xdWV1ZS5wdXNoKFt0aGlzLl9vcGVuLCB0aGlzLnBhdGgsIHRoaXMuZmxhZ3MsIHRoaXMubW9kZSwgdW5kZWZpbmVkXSk7XG4gICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVxuXG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqLl9fcHJvdG9fX1xufVxuXG5mdW5jdGlvbiBjbG9uZSAob2JqKSB7XG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpXG4gICAgcmV0dXJuIG9ialxuXG4gIGlmIChvYmogaW5zdGFuY2VvZiBPYmplY3QpXG4gICAgdmFyIGNvcHkgPSB7IF9fcHJvdG9fXzogZ2V0UHJvdG90eXBlT2Yob2JqKSB9XG4gIGVsc2VcbiAgICB2YXIgY29weSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb3B5LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpKVxuICB9KVxuXG4gIHJldHVybiBjb3B5XG59XG4iLCJ2YXIgZnMgPSByZXF1aXJlKCdmcycpXG52YXIgcG9seWZpbGxzID0gcmVxdWlyZSgnLi9wb2x5ZmlsbHMuanMnKVxudmFyIGxlZ2FjeSA9IHJlcXVpcmUoJy4vbGVnYWN5LXN0cmVhbXMuanMnKVxudmFyIGNsb25lID0gcmVxdWlyZSgnLi9jbG9uZS5qcycpXG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gbm9kZSAwLnggcG9seWZpbGwgKi9cbnZhciBncmFjZWZ1bFF1ZXVlXG52YXIgcHJldmlvdXNTeW1ib2xcblxuLyogaXN0YW5idWwgaWdub3JlIGVsc2UgLSBub2RlIDAueCBwb2x5ZmlsbCAqL1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5mb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgZ3JhY2VmdWxRdWV1ZSA9IFN5bWJvbC5mb3IoJ2dyYWNlZnVsLWZzLnF1ZXVlJylcbiAgLy8gVGhpcyBpcyB1c2VkIGluIHRlc3RpbmcgYnkgZnV0dXJlIHZlcnNpb25zXG4gIHByZXZpb3VzU3ltYm9sID0gU3ltYm9sLmZvcignZ3JhY2VmdWwtZnMucHJldmlvdXMnKVxufSBlbHNlIHtcbiAgZ3JhY2VmdWxRdWV1ZSA9ICdfX19ncmFjZWZ1bC1mcy5xdWV1ZSdcbiAgcHJldmlvdXNTeW1ib2wgPSAnX19fZ3JhY2VmdWwtZnMucHJldmlvdXMnXG59XG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cblxuZnVuY3Rpb24gcHVibGlzaFF1ZXVlKGNvbnRleHQsIHF1ZXVlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb250ZXh0LCBncmFjZWZ1bFF1ZXVlLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBxdWV1ZVxuICAgIH1cbiAgfSlcbn1cblxudmFyIGRlYnVnID0gbm9vcFxuaWYgKHV0aWwuZGVidWdsb2cpXG4gIGRlYnVnID0gdXRpbC5kZWJ1Z2xvZygnZ2ZzNCcpXG5lbHNlIGlmICgvXFxiZ2ZzNFxcYi9pLnRlc3QocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJykpXG4gIGRlYnVnID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG0gPSB1dGlsLmZvcm1hdC5hcHBseSh1dGlsLCBhcmd1bWVudHMpXG4gICAgbSA9ICdHRlM0OiAnICsgbS5zcGxpdCgvXFxuLykuam9pbignXFxuR0ZTNDogJylcbiAgICBjb25zb2xlLmVycm9yKG0pXG4gIH1cblxuLy8gT25jZSB0aW1lIGluaXRpYWxpemF0aW9uXG5pZiAoIWZzW2dyYWNlZnVsUXVldWVdKSB7XG4gIC8vIFRoaXMgcXVldWUgY2FuIGJlIHNoYXJlZCBieSBtdWx0aXBsZSBsb2FkZWQgaW5zdGFuY2VzXG4gIHZhciBxdWV1ZSA9IGdsb2JhbFtncmFjZWZ1bFF1ZXVlXSB8fCBbXVxuICBwdWJsaXNoUXVldWUoZnMsIHF1ZXVlKVxuXG4gIC8vIFBhdGNoIGZzLmNsb3NlL2Nsb3NlU3luYyB0byBzaGFyZWQgcXVldWUgdmVyc2lvbiwgYmVjYXVzZSB3ZSBuZWVkXG4gIC8vIHRvIHJldHJ5KCkgd2hlbmV2ZXIgYSBjbG9zZSBoYXBwZW5zICphbnl3aGVyZSogaW4gdGhlIHByb2dyYW0uXG4gIC8vIFRoaXMgaXMgZXNzZW50aWFsIHdoZW4gbXVsdGlwbGUgZ3JhY2VmdWwtZnMgaW5zdGFuY2VzIGFyZVxuICAvLyBpbiBwbGF5IGF0IHRoZSBzYW1lIHRpbWUuXG4gIGZzLmNsb3NlID0gKGZ1bmN0aW9uIChmcyRjbG9zZSkge1xuICAgIGZ1bmN0aW9uIGNsb3NlIChmZCwgY2IpIHtcbiAgICAgIHJldHVybiBmcyRjbG9zZS5jYWxsKGZzLCBmZCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIHVzZXMgdGhlIGdyYWNlZnVsLWZzIHNoYXJlZCBxdWV1ZVxuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgIHJlc2V0UXVldWUoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICB9KVxuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbG9zZSwgcHJldmlvdXNTeW1ib2wsIHtcbiAgICAgIHZhbHVlOiBmcyRjbG9zZVxuICAgIH0pXG4gICAgcmV0dXJuIGNsb3NlXG4gIH0pKGZzLmNsb3NlKVxuXG4gIGZzLmNsb3NlU3luYyA9IChmdW5jdGlvbiAoZnMkY2xvc2VTeW5jKSB7XG4gICAgZnVuY3Rpb24gY2xvc2VTeW5jIChmZCkge1xuICAgICAgLy8gVGhpcyBmdW5jdGlvbiB1c2VzIHRoZSBncmFjZWZ1bC1mcyBzaGFyZWQgcXVldWVcbiAgICAgIGZzJGNsb3NlU3luYy5hcHBseShmcywgYXJndW1lbnRzKVxuICAgICAgcmVzZXRRdWV1ZSgpXG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsb3NlU3luYywgcHJldmlvdXNTeW1ib2wsIHtcbiAgICAgIHZhbHVlOiBmcyRjbG9zZVN5bmNcbiAgICB9KVxuICAgIHJldHVybiBjbG9zZVN5bmNcbiAgfSkoZnMuY2xvc2VTeW5jKVxuXG4gIGlmICgvXFxiZ2ZzNFxcYi9pLnRlc3QocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJykpIHtcbiAgICBwcm9jZXNzLm9uKCdleGl0JywgZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1Zyhmc1tncmFjZWZ1bFF1ZXVlXSlcbiAgICAgIHJlcXVpcmUoJ2Fzc2VydCcpLmVxdWFsKGZzW2dyYWNlZnVsUXVldWVdLmxlbmd0aCwgMClcbiAgICB9KVxuICB9XG59XG5cbmlmICghZ2xvYmFsW2dyYWNlZnVsUXVldWVdKSB7XG4gIHB1Ymxpc2hRdWV1ZShnbG9iYWwsIGZzW2dyYWNlZnVsUXVldWVdKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaChjbG9uZShmcykpXG5pZiAocHJvY2Vzcy5lbnYuVEVTVF9HUkFDRUZVTF9GU19HTE9CQUxfUEFUQ0ggJiYgIWZzLl9fcGF0Y2hlZCkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gcGF0Y2goZnMpXG4gICAgZnMuX19wYXRjaGVkID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcGF0Y2ggKGZzKSB7XG4gIC8vIEV2ZXJ5dGhpbmcgdGhhdCByZWZlcmVuY2VzIHRoZSBvcGVuKCkgZnVuY3Rpb24gbmVlZHMgdG8gYmUgaW4gaGVyZVxuICBwb2x5ZmlsbHMoZnMpXG4gIGZzLmdyYWNlZnVsaWZ5ID0gcGF0Y2hcblxuICBmcy5jcmVhdGVSZWFkU3RyZWFtID0gY3JlYXRlUmVhZFN0cmVhbVxuICBmcy5jcmVhdGVXcml0ZVN0cmVhbSA9IGNyZWF0ZVdyaXRlU3RyZWFtXG4gIHZhciBmcyRyZWFkRmlsZSA9IGZzLnJlYWRGaWxlXG4gIGZzLnJlYWRGaWxlID0gcmVhZEZpbGVcbiAgZnVuY3Rpb24gcmVhZEZpbGUgKHBhdGgsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBvcHRpb25zLCBvcHRpb25zID0gbnVsbFxuXG4gICAgcmV0dXJuIGdvJHJlYWRGaWxlKHBhdGgsIG9wdGlvbnMsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kcmVhZEZpbGUgKHBhdGgsIG9wdGlvbnMsIGNiLCBzdGFydFRpbWUpIHtcbiAgICAgIHJldHVybiBmcyRyZWFkRmlsZShwYXRoLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgJiYgKGVyci5jb2RlID09PSAnRU1GSUxFJyB8fCBlcnIuY29kZSA9PT0gJ0VORklMRScpKVxuICAgICAgICAgIGVucXVldWUoW2dvJHJlYWRGaWxlLCBbcGF0aCwgb3B0aW9ucywgY2JdLCBlcnIsIHN0YXJ0VGltZSB8fCBEYXRlLm5vdygpLCBEYXRlLm5vdygpXSlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICB2YXIgZnMkd3JpdGVGaWxlID0gZnMud3JpdGVGaWxlXG4gIGZzLndyaXRlRmlsZSA9IHdyaXRlRmlsZVxuICBmdW5jdGlvbiB3cml0ZUZpbGUgKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBvcHRpb25zLCBvcHRpb25zID0gbnVsbFxuXG4gICAgcmV0dXJuIGdvJHdyaXRlRmlsZShwYXRoLCBkYXRhLCBvcHRpb25zLCBjYilcblxuICAgIGZ1bmN0aW9uIGdvJHdyaXRlRmlsZSAocGF0aCwgZGF0YSwgb3B0aW9ucywgY2IsIHN0YXJ0VGltZSkge1xuICAgICAgcmV0dXJuIGZzJHdyaXRlRmlsZShwYXRoLCBkYXRhLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgJiYgKGVyci5jb2RlID09PSAnRU1GSUxFJyB8fCBlcnIuY29kZSA9PT0gJ0VORklMRScpKVxuICAgICAgICAgIGVucXVldWUoW2dvJHdyaXRlRmlsZSwgW3BhdGgsIGRhdGEsIG9wdGlvbnMsIGNiXSwgZXJyLCBzdGFydFRpbWUgfHwgRGF0ZS5ub3coKSwgRGF0ZS5ub3coKV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgdmFyIGZzJGFwcGVuZEZpbGUgPSBmcy5hcHBlbmRGaWxlXG4gIGlmIChmcyRhcHBlbmRGaWxlKVxuICAgIGZzLmFwcGVuZEZpbGUgPSBhcHBlbmRGaWxlXG4gIGZ1bmN0aW9uIGFwcGVuZEZpbGUgKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBvcHRpb25zLCBvcHRpb25zID0gbnVsbFxuXG4gICAgcmV0dXJuIGdvJGFwcGVuZEZpbGUocGF0aCwgZGF0YSwgb3B0aW9ucywgY2IpXG5cbiAgICBmdW5jdGlvbiBnbyRhcHBlbmRGaWxlIChwYXRoLCBkYXRhLCBvcHRpb25zLCBjYiwgc3RhcnRUaW1lKSB7XG4gICAgICByZXR1cm4gZnMkYXBwZW5kRmlsZShwYXRoLCBkYXRhLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgJiYgKGVyci5jb2RlID09PSAnRU1GSUxFJyB8fCBlcnIuY29kZSA9PT0gJ0VORklMRScpKVxuICAgICAgICAgIGVucXVldWUoW2dvJGFwcGVuZEZpbGUsIFtwYXRoLCBkYXRhLCBvcHRpb25zLCBjYl0sIGVyciwgc3RhcnRUaW1lIHx8IERhdGUubm93KCksIERhdGUubm93KCldKVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHZhciBmcyRjb3B5RmlsZSA9IGZzLmNvcHlGaWxlXG4gIGlmIChmcyRjb3B5RmlsZSlcbiAgICBmcy5jb3B5RmlsZSA9IGNvcHlGaWxlXG4gIGZ1bmN0aW9uIGNvcHlGaWxlIChzcmMsIGRlc3QsIGZsYWdzLCBjYikge1xuICAgIGlmICh0eXBlb2YgZmxhZ3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gZmxhZ3NcbiAgICAgIGZsYWdzID0gMFxuICAgIH1cbiAgICByZXR1cm4gZ28kY29weUZpbGUoc3JjLCBkZXN0LCBmbGFncywgY2IpXG5cbiAgICBmdW5jdGlvbiBnbyRjb3B5RmlsZSAoc3JjLCBkZXN0LCBmbGFncywgY2IsIHN0YXJ0VGltZSkge1xuICAgICAgcmV0dXJuIGZzJGNvcHlGaWxlKHNyYywgZGVzdCwgZmxhZ3MsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgICAgZW5xdWV1ZShbZ28kY29weUZpbGUsIFtzcmMsIGRlc3QsIGZsYWdzLCBjYl0sIGVyciwgc3RhcnRUaW1lIHx8IERhdGUubm93KCksIERhdGUubm93KCldKVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHZhciBmcyRyZWFkZGlyID0gZnMucmVhZGRpclxuICBmcy5yZWFkZGlyID0gcmVhZGRpclxuICBmdW5jdGlvbiByZWFkZGlyIChwYXRoLCBvcHRpb25zLCBjYikge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNiID0gb3B0aW9ucywgb3B0aW9ucyA9IG51bGxcblxuICAgIHJldHVybiBnbyRyZWFkZGlyKHBhdGgsIG9wdGlvbnMsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kcmVhZGRpciAocGF0aCwgb3B0aW9ucywgY2IsIHN0YXJ0VGltZSkge1xuICAgICAgcmV0dXJuIGZzJHJlYWRkaXIocGF0aCwgb3B0aW9ucywgZnVuY3Rpb24gKGVyciwgZmlsZXMpIHtcbiAgICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgICAgZW5xdWV1ZShbZ28kcmVhZGRpciwgW3BhdGgsIG9wdGlvbnMsIGNiXSwgZXJyLCBzdGFydFRpbWUgfHwgRGF0ZS5ub3coKSwgRGF0ZS5ub3coKV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChmaWxlcyAmJiBmaWxlcy5zb3J0KVxuICAgICAgICAgICAgZmlsZXMuc29ydCgpXG5cbiAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgY2IuY2FsbCh0aGlzLCBlcnIsIGZpbGVzKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9jZXNzLnZlcnNpb24uc3Vic3RyKDAsIDQpID09PSAndjAuOCcpIHtcbiAgICB2YXIgbGVnU3RyZWFtcyA9IGxlZ2FjeShmcylcbiAgICBSZWFkU3RyZWFtID0gbGVnU3RyZWFtcy5SZWFkU3RyZWFtXG4gICAgV3JpdGVTdHJlYW0gPSBsZWdTdHJlYW1zLldyaXRlU3RyZWFtXG4gIH1cblxuICB2YXIgZnMkUmVhZFN0cmVhbSA9IGZzLlJlYWRTdHJlYW1cbiAgaWYgKGZzJFJlYWRTdHJlYW0pIHtcbiAgICBSZWFkU3RyZWFtLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZnMkUmVhZFN0cmVhbS5wcm90b3R5cGUpXG4gICAgUmVhZFN0cmVhbS5wcm90b3R5cGUub3BlbiA9IFJlYWRTdHJlYW0kb3BlblxuICB9XG5cbiAgdmFyIGZzJFdyaXRlU3RyZWFtID0gZnMuV3JpdGVTdHJlYW1cbiAgaWYgKGZzJFdyaXRlU3RyZWFtKSB7XG4gICAgV3JpdGVTdHJlYW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShmcyRXcml0ZVN0cmVhbS5wcm90b3R5cGUpXG4gICAgV3JpdGVTdHJlYW0ucHJvdG90eXBlLm9wZW4gPSBXcml0ZVN0cmVhbSRvcGVuXG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnMsICdSZWFkU3RyZWFtJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFJlYWRTdHJlYW1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgUmVhZFN0cmVhbSA9IHZhbFxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZzLCAnV3JpdGVTdHJlYW0nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gV3JpdGVTdHJlYW1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgV3JpdGVTdHJlYW0gPSB2YWxcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pXG5cbiAgLy8gbGVnYWN5IG5hbWVzXG4gIHZhciBGaWxlUmVhZFN0cmVhbSA9IFJlYWRTdHJlYW1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZzLCAnRmlsZVJlYWRTdHJlYW0nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gRmlsZVJlYWRTdHJlYW1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgRmlsZVJlYWRTdHJlYW0gPSB2YWxcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pXG4gIHZhciBGaWxlV3JpdGVTdHJlYW0gPSBXcml0ZVN0cmVhbVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnMsICdGaWxlV3JpdGVTdHJlYW0nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gRmlsZVdyaXRlU3RyZWFtXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIEZpbGVXcml0ZVN0cmVhbSA9IHZhbFxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcblxuICBmdW5jdGlvbiBSZWFkU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBSZWFkU3RyZWFtKVxuICAgICAgcmV0dXJuIGZzJFJlYWRTdHJlYW0uYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdGhpc1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBSZWFkU3RyZWFtLmFwcGx5KE9iamVjdC5jcmVhdGUoUmVhZFN0cmVhbS5wcm90b3R5cGUpLCBhcmd1bWVudHMpXG4gIH1cblxuICBmdW5jdGlvbiBSZWFkU3RyZWFtJG9wZW4gKCkge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIG9wZW4odGhhdC5wYXRoLCB0aGF0LmZsYWdzLCB0aGF0Lm1vZGUsIGZ1bmN0aW9uIChlcnIsIGZkKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGlmICh0aGF0LmF1dG9DbG9zZSlcbiAgICAgICAgICB0aGF0LmRlc3Ryb3koKVxuXG4gICAgICAgIHRoYXQuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGF0LmZkID0gZmRcbiAgICAgICAgdGhhdC5lbWl0KCdvcGVuJywgZmQpXG4gICAgICAgIHRoYXQucmVhZCgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIFdyaXRlU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBXcml0ZVN0cmVhbSlcbiAgICAgIHJldHVybiBmcyRXcml0ZVN0cmVhbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0aGlzXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIFdyaXRlU3RyZWFtLmFwcGx5KE9iamVjdC5jcmVhdGUoV3JpdGVTdHJlYW0ucHJvdG90eXBlKSwgYXJndW1lbnRzKVxuICB9XG5cbiAgZnVuY3Rpb24gV3JpdGVTdHJlYW0kb3BlbiAoKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgb3Blbih0aGF0LnBhdGgsIHRoYXQuZmxhZ3MsIHRoYXQubW9kZSwgZnVuY3Rpb24gKGVyciwgZmQpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhhdC5kZXN0cm95KClcbiAgICAgICAgdGhhdC5lbWl0KCdlcnJvcicsIGVycilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoYXQuZmQgPSBmZFxuICAgICAgICB0aGF0LmVtaXQoJ29wZW4nLCBmZClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUmVhZFN0cmVhbSAocGF0aCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgZnMuUmVhZFN0cmVhbShwYXRoLCBvcHRpb25zKVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlV3JpdGVTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IGZzLldyaXRlU3RyZWFtKHBhdGgsIG9wdGlvbnMpXG4gIH1cblxuICB2YXIgZnMkb3BlbiA9IGZzLm9wZW5cbiAgZnMub3BlbiA9IG9wZW5cbiAgZnVuY3Rpb24gb3BlbiAocGF0aCwgZmxhZ3MsIG1vZGUsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBtb2RlID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBtb2RlLCBtb2RlID0gbnVsbFxuXG4gICAgcmV0dXJuIGdvJG9wZW4ocGF0aCwgZmxhZ3MsIG1vZGUsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kb3BlbiAocGF0aCwgZmxhZ3MsIG1vZGUsIGNiLCBzdGFydFRpbWUpIHtcbiAgICAgIHJldHVybiBmcyRvcGVuKHBhdGgsIGZsYWdzLCBtb2RlLCBmdW5jdGlvbiAoZXJyLCBmZCkge1xuICAgICAgICBpZiAoZXJyICYmIChlcnIuY29kZSA9PT0gJ0VNRklMRScgfHwgZXJyLmNvZGUgPT09ICdFTkZJTEUnKSlcbiAgICAgICAgICBlbnF1ZXVlKFtnbyRvcGVuLCBbcGF0aCwgZmxhZ3MsIG1vZGUsIGNiXSwgZXJyLCBzdGFydFRpbWUgfHwgRGF0ZS5ub3coKSwgRGF0ZS5ub3coKV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZzXG59XG5cbmZ1bmN0aW9uIGVucXVldWUgKGVsZW0pIHtcbiAgZGVidWcoJ0VOUVVFVUUnLCBlbGVtWzBdLm5hbWUsIGVsZW1bMV0pXG4gIGZzW2dyYWNlZnVsUXVldWVdLnB1c2goZWxlbSlcbiAgcmV0cnkoKVxufVxuXG4vLyBrZWVwIHRyYWNrIG9mIHRoZSB0aW1lb3V0IGJldHdlZW4gcmV0cnkoKSBjYWxsc1xudmFyIHJldHJ5VGltZXJcblxuLy8gcmVzZXQgdGhlIHN0YXJ0VGltZSBhbmQgbGFzdFRpbWUgdG8gbm93XG4vLyB0aGlzIHJlc2V0cyB0aGUgc3RhcnQgb2YgdGhlIDYwIHNlY29uZCBvdmVyYWxsIHRpbWVvdXQgYXMgd2VsbCBhcyB0aGVcbi8vIGRlbGF5IGJldHdlZW4gYXR0ZW1wdHMgc28gdGhhdCB3ZSdsbCByZXRyeSB0aGVzZSBqb2JzIHNvb25lclxuZnVuY3Rpb24gcmVzZXRRdWV1ZSAoKSB7XG4gIHZhciBub3cgPSBEYXRlLm5vdygpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZnNbZ3JhY2VmdWxRdWV1ZV0ubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBlbnRyaWVzIHRoYXQgYXJlIG9ubHkgYSBsZW5ndGggb2YgMiBhcmUgZnJvbSBhbiBvbGRlciB2ZXJzaW9uLCBkb24ndFxuICAgIC8vIGJvdGhlciBtb2RpZnlpbmcgdGhvc2Ugc2luY2UgdGhleSdsbCBiZSByZXRyaWVkIGFueXdheS5cbiAgICBpZiAoZnNbZ3JhY2VmdWxRdWV1ZV1baV0ubGVuZ3RoID4gMikge1xuICAgICAgZnNbZ3JhY2VmdWxRdWV1ZV1baV1bM10gPSBub3cgLy8gc3RhcnRUaW1lXG4gICAgICBmc1tncmFjZWZ1bFF1ZXVlXVtpXVs0XSA9IG5vdyAvLyBsYXN0VGltZVxuICAgIH1cbiAgfVxuICAvLyBjYWxsIHJldHJ5IHRvIG1ha2Ugc3VyZSB3ZSdyZSBhY3RpdmVseSBwcm9jZXNzaW5nIHRoZSBxdWV1ZVxuICByZXRyeSgpXG59XG5cbmZ1bmN0aW9uIHJldHJ5ICgpIHtcbiAgLy8gY2xlYXIgdGhlIHRpbWVyIGFuZCByZW1vdmUgaXQgdG8gaGVscCBwcmV2ZW50IHVuaW50ZW5kZWQgY29uY3VycmVuY3lcbiAgY2xlYXJUaW1lb3V0KHJldHJ5VGltZXIpXG4gIHJldHJ5VGltZXIgPSB1bmRlZmluZWRcblxuICBpZiAoZnNbZ3JhY2VmdWxRdWV1ZV0ubGVuZ3RoID09PSAwKVxuICAgIHJldHVyblxuXG4gIHZhciBlbGVtID0gZnNbZ3JhY2VmdWxRdWV1ZV0uc2hpZnQoKVxuICB2YXIgZm4gPSBlbGVtWzBdXG4gIHZhciBhcmdzID0gZWxlbVsxXVxuICAvLyB0aGVzZSBpdGVtcyBtYXkgYmUgdW5zZXQgaWYgdGhleSB3ZXJlIGFkZGVkIGJ5IGFuIG9sZGVyIGdyYWNlZnVsLWZzXG4gIHZhciBlcnIgPSBlbGVtWzJdXG4gIHZhciBzdGFydFRpbWUgPSBlbGVtWzNdXG4gIHZhciBsYXN0VGltZSA9IGVsZW1bNF1cblxuICAvLyBpZiB3ZSBkb24ndCBoYXZlIGEgc3RhcnRUaW1lIHdlIGhhdmUgbm8gd2F5IG9mIGtub3dpbmcgaWYgd2UndmUgd2FpdGVkXG4gIC8vIGxvbmcgZW5vdWdoLCBzbyBnbyBhaGVhZCBhbmQgcmV0cnkgdGhpcyBpdGVtIG5vd1xuICBpZiAoc3RhcnRUaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICBkZWJ1ZygnUkVUUlknLCBmbi5uYW1lLCBhcmdzKVxuICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpXG4gIH0gZWxzZSBpZiAoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSA+PSA2MDAwMCkge1xuICAgIC8vIGl0J3MgYmVlbiBtb3JlIHRoYW4gNjAgc2Vjb25kcyB0b3RhbCwgYmFpbCBub3dcbiAgICBkZWJ1ZygnVElNRU9VVCcsIGZuLm5hbWUsIGFyZ3MpXG4gICAgdmFyIGNiID0gYXJncy5wb3AoKVxuICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYi5jYWxsKG51bGwsIGVycilcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgYW1vdW50IG9mIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBhdHRlbXB0IGFuZCByaWdodCBub3dcbiAgICB2YXIgc2luY2VBdHRlbXB0ID0gRGF0ZS5ub3coKSAtIGxhc3RUaW1lXG4gICAgLy8gdGhlIGFtb3VudCBvZiB0aW1lIGJldHdlZW4gd2hlbiB3ZSBmaXJzdCB0cmllZCwgYW5kIHdoZW4gd2UgbGFzdCB0cmllZFxuICAgIC8vIHJvdW5kZWQgdXAgdG8gYXQgbGVhc3QgMVxuICAgIHZhciBzaW5jZVN0YXJ0ID0gTWF0aC5tYXgobGFzdFRpbWUgLSBzdGFydFRpbWUsIDEpXG4gICAgLy8gYmFja29mZi4gd2FpdCBsb25nZXIgdGhhbiB0aGUgdG90YWwgdGltZSB3ZSd2ZSBiZWVuIHJldHJ5aW5nLCBidXQgb25seVxuICAgIC8vIHVwIHRvIGEgbWF4aW11bSBvZiAxMDBtc1xuICAgIHZhciBkZXNpcmVkRGVsYXkgPSBNYXRoLm1pbihzaW5jZVN0YXJ0ICogMS4yLCAxMDApXG4gICAgLy8gaXQncyBiZWVuIGxvbmcgZW5vdWdoIHNpbmNlIHRoZSBsYXN0IHJldHJ5LCBkbyBpdCBhZ2FpblxuICAgIGlmIChzaW5jZUF0dGVtcHQgPj0gZGVzaXJlZERlbGF5KSB7XG4gICAgICBkZWJ1ZygnUkVUUlknLCBmbi5uYW1lLCBhcmdzKVxuICAgICAgZm4uYXBwbHkobnVsbCwgYXJncy5jb25jYXQoW3N0YXJ0VGltZV0pKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiB3ZSBjYW4ndCBkbyB0aGlzIGpvYiB5ZXQsIHB1c2ggaXQgdG8gdGhlIGVuZCBvZiB0aGUgcXVldWVcbiAgICAgIC8vIGFuZCBsZXQgdGhlIG5leHQgaXRlcmF0aW9uIGNoZWNrIGFnYWluXG4gICAgICBmc1tncmFjZWZ1bFF1ZXVlXS5wdXNoKGVsZW0pXG4gICAgfVxuICB9XG5cbiAgLy8gc2NoZWR1bGUgb3VyIG5leHQgcnVuIGlmIG9uZSBpc24ndCBhbHJlYWR5IHNjaGVkdWxlZFxuICBpZiAocmV0cnlUaW1lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0cnlUaW1lciA9IHNldFRpbWVvdXQocmV0cnksIDApXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuLy8gVGhpcyBpcyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL25vcm1hbGl6ZS9telxuLy8gQ29weXJpZ2h0IChjKSAyMDE0LTIwMTYgSm9uYXRoYW4gT25nIG1lQGpvbmdsZWJlcnJ5LmNvbSBhbmQgQ29udHJpYnV0b3JzXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcblxuY29uc3QgYXBpID0gW1xuICAnYWNjZXNzJyxcbiAgJ2FwcGVuZEZpbGUnLFxuICAnY2htb2QnLFxuICAnY2hvd24nLFxuICAnY2xvc2UnLFxuICAnY29weUZpbGUnLFxuICAnZmNobW9kJyxcbiAgJ2ZjaG93bicsXG4gICdmZGF0YXN5bmMnLFxuICAnZnN0YXQnLFxuICAnZnN5bmMnLFxuICAnZnRydW5jYXRlJyxcbiAgJ2Z1dGltZXMnLFxuICAnbGNobW9kJyxcbiAgJ2xjaG93bicsXG4gICdsaW5rJyxcbiAgJ2xzdGF0JyxcbiAgJ21rZGlyJyxcbiAgJ21rZHRlbXAnLFxuICAnb3BlbicsXG4gICdvcGVuZGlyJyxcbiAgJ3JlYWRkaXInLFxuICAncmVhZEZpbGUnLFxuICAncmVhZGxpbmsnLFxuICAncmVhbHBhdGgnLFxuICAncmVuYW1lJyxcbiAgJ3JtJyxcbiAgJ3JtZGlyJyxcbiAgJ3N0YXQnLFxuICAnc3ltbGluaycsXG4gICd0cnVuY2F0ZScsXG4gICd1bmxpbmsnLFxuICAndXRpbWVzJyxcbiAgJ3dyaXRlRmlsZSdcbl0uZmlsdGVyKGtleSA9PiB7XG4gIC8vIFNvbWUgY29tbWFuZHMgYXJlIG5vdCBhdmFpbGFibGUgb24gc29tZSBzeXN0ZW1zLiBFeDpcbiAgLy8gZnMub3BlbmRpciB3YXMgYWRkZWQgaW4gTm9kZS5qcyB2MTIuMTIuMFxuICAvLyBmcy5ybSB3YXMgYWRkZWQgaW4gTm9kZS5qcyB2MTQuMTQuMFxuICAvLyBmcy5sY2hvd24gaXMgbm90IGF2YWlsYWJsZSBvbiBhdCBsZWFzdCBzb21lIExpbnV4XG4gIHJldHVybiB0eXBlb2YgZnNba2V5XSA9PT0gJ2Z1bmN0aW9uJ1xufSlcblxuLy8gRXhwb3J0IGNsb25lZCBmczpcbk9iamVjdC5hc3NpZ24oZXhwb3J0cywgZnMpXG5cbi8vIFVuaXZlcnNhbGlmeSBhc3luYyBtZXRob2RzOlxuYXBpLmZvckVhY2gobWV0aG9kID0+IHtcbiAgZXhwb3J0c1ttZXRob2RdID0gdShmc1ttZXRob2RdKVxufSlcbmV4cG9ydHMucmVhbHBhdGgubmF0aXZlID0gdShmcy5yZWFscGF0aC5uYXRpdmUpXG5cbi8vIFdlIGRpZmZlciBmcm9tIG16L2ZzIGluIHRoYXQgd2Ugc3RpbGwgc2hpcCB0aGUgb2xkLCBicm9rZW4sIGZzLmV4aXN0cygpXG4vLyBzaW5jZSB3ZSBhcmUgYSBkcm9wLWluIHJlcGxhY2VtZW50IGZvciB0aGUgbmF0aXZlIG1vZHVsZVxuZXhwb3J0cy5leGlzdHMgPSBmdW5jdGlvbiAoZmlsZW5hbWUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZnMuZXhpc3RzKGZpbGVuYW1lLCBjYWxsYmFjaylcbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgcmV0dXJuIGZzLmV4aXN0cyhmaWxlbmFtZSwgcmVzb2x2ZSlcbiAgfSlcbn1cblxuLy8gZnMucmVhZCgpLCBmcy53cml0ZSgpLCAmIGZzLndyaXRldigpIG5lZWQgc3BlY2lhbCB0cmVhdG1lbnQgZHVlIHRvIG11bHRpcGxlIGNhbGxiYWNrIGFyZ3NcblxuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmcy5yZWFkKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FsbGJhY2spXG4gIH1cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBmcy5yZWFkKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgKGVyciwgYnl0ZXNSZWFkLCBidWZmZXIpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgcmVzb2x2ZSh7IGJ5dGVzUmVhZCwgYnVmZmVyIH0pXG4gICAgfSlcbiAgfSlcbn1cblxuLy8gRnVuY3Rpb24gc2lnbmF0dXJlIGNhbiBiZVxuLy8gZnMud3JpdGUoZmQsIGJ1ZmZlclssIG9mZnNldFssIGxlbmd0aFssIHBvc2l0aW9uXV1dLCBjYWxsYmFjaylcbi8vIE9SXG4vLyBmcy53cml0ZShmZCwgc3RyaW5nWywgcG9zaXRpb25bLCBlbmNvZGluZ11dLCBjYWxsYmFjaylcbi8vIFdlIG5lZWQgdG8gaGFuZGxlIGJvdGggY2FzZXMsIHNvIHdlIHVzZSAuLi5hcmdzXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGZkLCBidWZmZXIsIC4uLmFyZ3MpIHtcbiAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZnMud3JpdGUoZmQsIGJ1ZmZlciwgLi4uYXJncylcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZnMud3JpdGUoZmQsIGJ1ZmZlciwgLi4uYXJncywgKGVyciwgYnl0ZXNXcml0dGVuLCBidWZmZXIpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgcmVzb2x2ZSh7IGJ5dGVzV3JpdHRlbiwgYnVmZmVyIH0pXG4gICAgfSlcbiAgfSlcbn1cblxuLy8gZnMud3JpdGV2IG9ubHkgYXZhaWxhYmxlIGluIE5vZGUgdjEyLjkuMCtcbmlmICh0eXBlb2YgZnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIEZ1bmN0aW9uIHNpZ25hdHVyZSBpc1xuICAvLyBzLndyaXRldihmZCwgYnVmZmVyc1ssIHBvc2l0aW9uXSwgY2FsbGJhY2spXG4gIC8vIFdlIG5lZWQgdG8gaGFuZGxlIHRoZSBvcHRpb25hbCBhcmcsIHNvIHdlIHVzZSAuLi5hcmdzXG4gIGV4cG9ydHMud3JpdGV2ID0gZnVuY3Rpb24gKGZkLCBidWZmZXJzLCAuLi5hcmdzKSB7XG4gICAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBmcy53cml0ZXYoZmQsIGJ1ZmZlcnMsIC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGZzLndyaXRldihmZCwgYnVmZmVycywgLi4uYXJncywgKGVyciwgYnl0ZXNXcml0dGVuLCBidWZmZXJzKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgICByZXNvbHZlKHsgYnl0ZXNXcml0dGVuLCBidWZmZXJzIH0pXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cbiIsIi8vIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL21ha2UtZGlyXG4vLyBDb3B5cmlnaHQgKGMpIFNpbmRyZSBTb3JodXMgPHNpbmRyZXNvcmh1c0BnbWFpbC5jb20+IChzaW5kcmVzb3JodXMuY29tKVxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4ndXNlIHN0cmljdCdcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy84OTg3XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbGlidXYvbGlidXYvcHVsbC8xMDg4XG5tb2R1bGUuZXhwb3J0cy5jaGVja1BhdGggPSBmdW5jdGlvbiBjaGVja1BhdGggKHB0aCkge1xuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgIGNvbnN0IHBhdGhIYXNJbnZhbGlkV2luQ2hhcmFjdGVycyA9IC9bPD46XCJ8PypdLy50ZXN0KHB0aC5yZXBsYWNlKHBhdGgucGFyc2UocHRoKS5yb290LCAnJykpXG5cbiAgICBpZiAocGF0aEhhc0ludmFsaWRXaW5DaGFyYWN0ZXJzKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgUGF0aCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnM6ICR7cHRofWApXG4gICAgICBlcnJvci5jb2RlID0gJ0VJTlZBTCdcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcbmNvbnN0IGZzID0gcmVxdWlyZSgnLi4vZnMnKVxuY29uc3QgeyBjaGVja1BhdGggfSA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuXG5jb25zdCBnZXRNb2RlID0gb3B0aW9ucyA9PiB7XG4gIGNvbnN0IGRlZmF1bHRzID0geyBtb2RlOiAwbzc3NyB9XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpIHJldHVybiBvcHRpb25zXG4gIHJldHVybiAoeyAuLi5kZWZhdWx0cywgLi4ub3B0aW9ucyB9KS5tb2RlXG59XG5cbm1vZHVsZS5leHBvcnRzLm1ha2VEaXIgPSBhc3luYyAoZGlyLCBvcHRpb25zKSA9PiB7XG4gIGNoZWNrUGF0aChkaXIpXG5cbiAgcmV0dXJuIGZzLm1rZGlyKGRpciwge1xuICAgIG1vZGU6IGdldE1vZGUob3B0aW9ucyksXG4gICAgcmVjdXJzaXZlOiB0cnVlXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzLm1ha2VEaXJTeW5jID0gKGRpciwgb3B0aW9ucykgPT4ge1xuICBjaGVja1BhdGgoZGlyKVxuXG4gIHJldHVybiBmcy5ta2RpclN5bmMoZGlyLCB7XG4gICAgbW9kZTogZ2V0TW9kZShvcHRpb25zKSxcbiAgICByZWN1cnNpdmU6IHRydWVcbiAgfSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21Qcm9taXNlXG5jb25zdCB7IG1ha2VEaXI6IF9tYWtlRGlyLCBtYWtlRGlyU3luYyB9ID0gcmVxdWlyZSgnLi9tYWtlLWRpcicpXG5jb25zdCBtYWtlRGlyID0gdShfbWFrZURpcilcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG1rZGlyczogbWFrZURpcixcbiAgbWtkaXJzU3luYzogbWFrZURpclN5bmMsXG4gIC8vIGFsaWFzXG4gIG1rZGlycDogbWFrZURpcixcbiAgbWtkaXJwU3luYzogbWFrZURpclN5bmMsXG4gIGVuc3VyZURpcjogbWFrZURpcixcbiAgZW5zdXJlRGlyU3luYzogbWFrZURpclN5bmNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcblxuZnVuY3Rpb24gdXRpbWVzTWlsbGlzIChwYXRoLCBhdGltZSwgbXRpbWUsIGNhbGxiYWNrKSB7XG4gIC8vIGlmICghSEFTX01JTExJU19SRVMpIHJldHVybiBmcy51dGltZXMocGF0aCwgYXRpbWUsIG10aW1lLCBjYWxsYmFjaylcbiAgZnMub3BlbihwYXRoLCAncisnLCAoZXJyLCBmZCkgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgZnMuZnV0aW1lcyhmZCwgYXRpbWUsIG10aW1lLCBmdXRpbWVzRXJyID0+IHtcbiAgICAgIGZzLmNsb3NlKGZkLCBjbG9zZUVyciA9PiB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZnV0aW1lc0VyciB8fCBjbG9zZUVycilcbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gdXRpbWVzTWlsbGlzU3luYyAocGF0aCwgYXRpbWUsIG10aW1lKSB7XG4gIGNvbnN0IGZkID0gZnMub3BlblN5bmMocGF0aCwgJ3IrJylcbiAgZnMuZnV0aW1lc1N5bmMoZmQsIGF0aW1lLCBtdGltZSlcbiAgcmV0dXJuIGZzLmNsb3NlU3luYyhmZClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHV0aW1lc01pbGxpcyxcbiAgdXRpbWVzTWlsbGlzU3luY1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnLi4vZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxuXG5mdW5jdGlvbiBnZXRTdGF0cyAoc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGNvbnN0IHN0YXRGdW5jID0gb3B0cy5kZXJlZmVyZW5jZVxuICAgID8gKGZpbGUpID0+IGZzLnN0YXQoZmlsZSwgeyBiaWdpbnQ6IHRydWUgfSlcbiAgICA6IChmaWxlKSA9PiBmcy5sc3RhdChmaWxlLCB7IGJpZ2ludDogdHJ1ZSB9KVxuICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgIHN0YXRGdW5jKHNyYyksXG4gICAgc3RhdEZ1bmMoZGVzdCkuY2F0Y2goZXJyID0+IHtcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHJldHVybiBudWxsXG4gICAgICB0aHJvdyBlcnJcbiAgICB9KVxuICBdKS50aGVuKChbc3JjU3RhdCwgZGVzdFN0YXRdKSA9PiAoeyBzcmNTdGF0LCBkZXN0U3RhdCB9KSlcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdHNTeW5jIChzcmMsIGRlc3QsIG9wdHMpIHtcbiAgbGV0IGRlc3RTdGF0XG4gIGNvbnN0IHN0YXRGdW5jID0gb3B0cy5kZXJlZmVyZW5jZVxuICAgID8gKGZpbGUpID0+IGZzLnN0YXRTeW5jKGZpbGUsIHsgYmlnaW50OiB0cnVlIH0pXG4gICAgOiAoZmlsZSkgPT4gZnMubHN0YXRTeW5jKGZpbGUsIHsgYmlnaW50OiB0cnVlIH0pXG4gIGNvbnN0IHNyY1N0YXQgPSBzdGF0RnVuYyhzcmMpXG4gIHRyeSB7XG4gICAgZGVzdFN0YXQgPSBzdGF0RnVuYyhkZXN0KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyLmNvZGUgPT09ICdFTk9FTlQnKSByZXR1cm4geyBzcmNTdGF0LCBkZXN0U3RhdDogbnVsbCB9XG4gICAgdGhyb3cgZXJyXG4gIH1cbiAgcmV0dXJuIHsgc3JjU3RhdCwgZGVzdFN0YXQgfVxufVxuXG5mdW5jdGlvbiBjaGVja1BhdGhzIChzcmMsIGRlc3QsIGZ1bmNOYW1lLCBvcHRzLCBjYikge1xuICB1dGlsLmNhbGxiYWNraWZ5KGdldFN0YXRzKShzcmMsIGRlc3QsIG9wdHMsIChlcnIsIHN0YXRzKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBjb25zdCB7IHNyY1N0YXQsIGRlc3RTdGF0IH0gPSBzdGF0c1xuXG4gICAgaWYgKGRlc3RTdGF0KSB7XG4gICAgICBpZiAoYXJlSWRlbnRpY2FsKHNyY1N0YXQsIGRlc3RTdGF0KSkge1xuICAgICAgICBjb25zdCBzcmNCYXNlTmFtZSA9IHBhdGguYmFzZW5hbWUoc3JjKVxuICAgICAgICBjb25zdCBkZXN0QmFzZU5hbWUgPSBwYXRoLmJhc2VuYW1lKGRlc3QpXG4gICAgICAgIGlmIChmdW5jTmFtZSA9PT0gJ21vdmUnICYmXG4gICAgICAgICAgc3JjQmFzZU5hbWUgIT09IGRlc3RCYXNlTmFtZSAmJlxuICAgICAgICAgIHNyY0Jhc2VOYW1lLnRvTG93ZXJDYXNlKCkgPT09IGRlc3RCYXNlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKG51bGwsIHsgc3JjU3RhdCwgZGVzdFN0YXQsIGlzQ2hhbmdpbmdDYXNlOiB0cnVlIH0pXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignU291cmNlIGFuZCBkZXN0aW5hdGlvbiBtdXN0IG5vdCBiZSB0aGUgc2FtZS4nKSlcbiAgICAgIH1cbiAgICAgIGlmIChzcmNTdGF0LmlzRGlyZWN0b3J5KCkgJiYgIWRlc3RTdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcihgQ2Fubm90IG92ZXJ3cml0ZSBub24tZGlyZWN0b3J5ICcke2Rlc3R9JyB3aXRoIGRpcmVjdG9yeSAnJHtzcmN9Jy5gKSlcbiAgICAgIH1cbiAgICAgIGlmICghc3JjU3RhdC5pc0RpcmVjdG9yeSgpICYmIGRlc3RTdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcihgQ2Fubm90IG92ZXJ3cml0ZSBkaXJlY3RvcnkgJyR7ZGVzdH0nIHdpdGggbm9uLWRpcmVjdG9yeSAnJHtzcmN9Jy5gKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3JjU3RhdC5pc0RpcmVjdG9yeSgpICYmIGlzU3JjU3ViZGlyKHNyYywgZGVzdCkpIHtcbiAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoZXJyTXNnKHNyYywgZGVzdCwgZnVuY05hbWUpKSlcbiAgICB9XG4gICAgcmV0dXJuIGNiKG51bGwsIHsgc3JjU3RhdCwgZGVzdFN0YXQgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gY2hlY2tQYXRoc1N5bmMgKHNyYywgZGVzdCwgZnVuY05hbWUsIG9wdHMpIHtcbiAgY29uc3QgeyBzcmNTdGF0LCBkZXN0U3RhdCB9ID0gZ2V0U3RhdHNTeW5jKHNyYywgZGVzdCwgb3B0cylcblxuICBpZiAoZGVzdFN0YXQpIHtcbiAgICBpZiAoYXJlSWRlbnRpY2FsKHNyY1N0YXQsIGRlc3RTdGF0KSkge1xuICAgICAgY29uc3Qgc3JjQmFzZU5hbWUgPSBwYXRoLmJhc2VuYW1lKHNyYylcbiAgICAgIGNvbnN0IGRlc3RCYXNlTmFtZSA9IHBhdGguYmFzZW5hbWUoZGVzdClcbiAgICAgIGlmIChmdW5jTmFtZSA9PT0gJ21vdmUnICYmXG4gICAgICAgIHNyY0Jhc2VOYW1lICE9PSBkZXN0QmFzZU5hbWUgJiZcbiAgICAgICAgc3JjQmFzZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gZGVzdEJhc2VOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgcmV0dXJuIHsgc3JjU3RhdCwgZGVzdFN0YXQsIGlzQ2hhbmdpbmdDYXNlOiB0cnVlIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignU291cmNlIGFuZCBkZXN0aW5hdGlvbiBtdXN0IG5vdCBiZSB0aGUgc2FtZS4nKVxuICAgIH1cbiAgICBpZiAoc3JjU3RhdC5pc0RpcmVjdG9yeSgpICYmICFkZXN0U3RhdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBvdmVyd3JpdGUgbm9uLWRpcmVjdG9yeSAnJHtkZXN0fScgd2l0aCBkaXJlY3RvcnkgJyR7c3JjfScuYClcbiAgICB9XG4gICAgaWYgKCFzcmNTdGF0LmlzRGlyZWN0b3J5KCkgJiYgZGVzdFN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgb3ZlcndyaXRlIGRpcmVjdG9yeSAnJHtkZXN0fScgd2l0aCBub24tZGlyZWN0b3J5ICcke3NyY30nLmApXG4gICAgfVxuICB9XG5cbiAgaWYgKHNyY1N0YXQuaXNEaXJlY3RvcnkoKSAmJiBpc1NyY1N1YmRpcihzcmMsIGRlc3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyhzcmMsIGRlc3QsIGZ1bmNOYW1lKSlcbiAgfVxuICByZXR1cm4geyBzcmNTdGF0LCBkZXN0U3RhdCB9XG59XG5cbi8vIHJlY3Vyc2l2ZWx5IGNoZWNrIGlmIGRlc3QgcGFyZW50IGlzIGEgc3ViZGlyZWN0b3J5IG9mIHNyYy5cbi8vIEl0IHdvcmtzIGZvciBhbGwgZmlsZSB0eXBlcyBpbmNsdWRpbmcgc3ltbGlua3Mgc2luY2UgaXRcbi8vIGNoZWNrcyB0aGUgc3JjIGFuZCBkZXN0IGlub2Rlcy4gSXQgc3RhcnRzIGZyb20gdGhlIGRlZXBlc3Rcbi8vIHBhcmVudCBhbmQgc3RvcHMgb25jZSBpdCByZWFjaGVzIHRoZSBzcmMgcGFyZW50IG9yIHRoZSByb290IHBhdGguXG5mdW5jdGlvbiBjaGVja1BhcmVudFBhdGhzIChzcmMsIHNyY1N0YXQsIGRlc3QsIGZ1bmNOYW1lLCBjYikge1xuICBjb25zdCBzcmNQYXJlbnQgPSBwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKHNyYykpXG4gIGNvbnN0IGRlc3RQYXJlbnQgPSBwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKGRlc3QpKVxuICBpZiAoZGVzdFBhcmVudCA9PT0gc3JjUGFyZW50IHx8IGRlc3RQYXJlbnQgPT09IHBhdGgucGFyc2UoZGVzdFBhcmVudCkucm9vdCkgcmV0dXJuIGNiKClcbiAgZnMuc3RhdChkZXN0UGFyZW50LCB7IGJpZ2ludDogdHJ1ZSB9LCAoZXJyLCBkZXN0U3RhdCkgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHJldHVybiBjYigpXG4gICAgICByZXR1cm4gY2IoZXJyKVxuICAgIH1cbiAgICBpZiAoYXJlSWRlbnRpY2FsKHNyY1N0YXQsIGRlc3RTdGF0KSkge1xuICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcihlcnJNc2coc3JjLCBkZXN0LCBmdW5jTmFtZSkpKVxuICAgIH1cbiAgICByZXR1cm4gY2hlY2tQYXJlbnRQYXRocyhzcmMsIHNyY1N0YXQsIGRlc3RQYXJlbnQsIGZ1bmNOYW1lLCBjYilcbiAgfSlcbn1cblxuZnVuY3Rpb24gY2hlY2tQYXJlbnRQYXRoc1N5bmMgKHNyYywgc3JjU3RhdCwgZGVzdCwgZnVuY05hbWUpIHtcbiAgY29uc3Qgc3JjUGFyZW50ID0gcGF0aC5yZXNvbHZlKHBhdGguZGlybmFtZShzcmMpKVxuICBjb25zdCBkZXN0UGFyZW50ID0gcGF0aC5yZXNvbHZlKHBhdGguZGlybmFtZShkZXN0KSlcbiAgaWYgKGRlc3RQYXJlbnQgPT09IHNyY1BhcmVudCB8fCBkZXN0UGFyZW50ID09PSBwYXRoLnBhcnNlKGRlc3RQYXJlbnQpLnJvb3QpIHJldHVyblxuICBsZXQgZGVzdFN0YXRcbiAgdHJ5IHtcbiAgICBkZXN0U3RhdCA9IGZzLnN0YXRTeW5jKGRlc3RQYXJlbnQsIHsgYmlnaW50OiB0cnVlIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHJldHVyblxuICAgIHRocm93IGVyclxuICB9XG4gIGlmIChhcmVJZGVudGljYWwoc3JjU3RhdCwgZGVzdFN0YXQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyhzcmMsIGRlc3QsIGZ1bmNOYW1lKSlcbiAgfVxuICByZXR1cm4gY2hlY2tQYXJlbnRQYXRoc1N5bmMoc3JjLCBzcmNTdGF0LCBkZXN0UGFyZW50LCBmdW5jTmFtZSlcbn1cblxuZnVuY3Rpb24gYXJlSWRlbnRpY2FsIChzcmNTdGF0LCBkZXN0U3RhdCkge1xuICByZXR1cm4gZGVzdFN0YXQuaW5vICYmIGRlc3RTdGF0LmRldiAmJiBkZXN0U3RhdC5pbm8gPT09IHNyY1N0YXQuaW5vICYmIGRlc3RTdGF0LmRldiA9PT0gc3JjU3RhdC5kZXZcbn1cblxuLy8gcmV0dXJuIHRydWUgaWYgZGVzdCBpcyBhIHN1YmRpciBvZiBzcmMsIG90aGVyd2lzZSBmYWxzZS5cbi8vIEl0IG9ubHkgY2hlY2tzIHRoZSBwYXRoIHN0cmluZ3MuXG5mdW5jdGlvbiBpc1NyY1N1YmRpciAoc3JjLCBkZXN0KSB7XG4gIGNvbnN0IHNyY0FyciA9IHBhdGgucmVzb2x2ZShzcmMpLnNwbGl0KHBhdGguc2VwKS5maWx0ZXIoaSA9PiBpKVxuICBjb25zdCBkZXN0QXJyID0gcGF0aC5yZXNvbHZlKGRlc3QpLnNwbGl0KHBhdGguc2VwKS5maWx0ZXIoaSA9PiBpKVxuICByZXR1cm4gc3JjQXJyLnJlZHVjZSgoYWNjLCBjdXIsIGkpID0+IGFjYyAmJiBkZXN0QXJyW2ldID09PSBjdXIsIHRydWUpXG59XG5cbmZ1bmN0aW9uIGVyck1zZyAoc3JjLCBkZXN0LCBmdW5jTmFtZSkge1xuICByZXR1cm4gYENhbm5vdCAke2Z1bmNOYW1lfSAnJHtzcmN9JyB0byBhIHN1YmRpcmVjdG9yeSBvZiBpdHNlbGYsICcke2Rlc3R9Jy5gXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjaGVja1BhdGhzLFxuICBjaGVja1BhdGhzU3luYyxcbiAgY2hlY2tQYXJlbnRQYXRocyxcbiAgY2hlY2tQYXJlbnRQYXRoc1N5bmMsXG4gIGlzU3JjU3ViZGlyLFxuICBhcmVJZGVudGljYWxcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IG1rZGlyc1N5bmMgPSByZXF1aXJlKCcuLi9ta2RpcnMnKS5ta2RpcnNTeW5jXG5jb25zdCB1dGltZXNNaWxsaXNTeW5jID0gcmVxdWlyZSgnLi4vdXRpbC91dGltZXMnKS51dGltZXNNaWxsaXNTeW5jXG5jb25zdCBzdGF0ID0gcmVxdWlyZSgnLi4vdXRpbC9zdGF0JylcblxuZnVuY3Rpb24gY29weVN5bmMgKHNyYywgZGVzdCwgb3B0cykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRzID0geyBmaWx0ZXI6IG9wdHMgfVxuICB9XG5cbiAgb3B0cyA9IG9wdHMgfHwge31cbiAgb3B0cy5jbG9iYmVyID0gJ2Nsb2JiZXInIGluIG9wdHMgPyAhIW9wdHMuY2xvYmJlciA6IHRydWUgLy8gZGVmYXVsdCB0byB0cnVlIGZvciBub3dcbiAgb3B0cy5vdmVyd3JpdGUgPSAnb3ZlcndyaXRlJyBpbiBvcHRzID8gISFvcHRzLm92ZXJ3cml0ZSA6IG9wdHMuY2xvYmJlciAvLyBvdmVyd3JpdGUgZmFsbHMgYmFjayB0byBjbG9iYmVyXG5cbiAgLy8gV2FybiBhYm91dCB1c2luZyBwcmVzZXJ2ZVRpbWVzdGFtcHMgb24gMzItYml0IG5vZGVcbiAgaWYgKG9wdHMucHJlc2VydmVUaW1lc3RhbXBzICYmIHByb2Nlc3MuYXJjaCA9PT0gJ2lhMzInKSB7XG4gICAgY29uc29sZS53YXJuKGBmcy1leHRyYTogVXNpbmcgdGhlIHByZXNlcnZlVGltZXN0YW1wcyBvcHRpb24gaW4gMzItYml0IG5vZGUgaXMgbm90IHJlY29tbWVuZGVkO1xcblxuICAgIHNlZSBodHRwczovL2dpdGh1Yi5jb20vanByaWNoYXJkc29uL25vZGUtZnMtZXh0cmEvaXNzdWVzLzI2OWApXG4gIH1cblxuICBjb25zdCB7IHNyY1N0YXQsIGRlc3RTdGF0IH0gPSBzdGF0LmNoZWNrUGF0aHNTeW5jKHNyYywgZGVzdCwgJ2NvcHknLCBvcHRzKVxuICBzdGF0LmNoZWNrUGFyZW50UGF0aHNTeW5jKHNyYywgc3JjU3RhdCwgZGVzdCwgJ2NvcHknKVxuICByZXR1cm4gaGFuZGxlRmlsdGVyQW5kQ29weShkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxufVxuXG5mdW5jdGlvbiBoYW5kbGVGaWx0ZXJBbmRDb3B5IChkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGlmIChvcHRzLmZpbHRlciAmJiAhb3B0cy5maWx0ZXIoc3JjLCBkZXN0KSkgcmV0dXJuXG4gIGNvbnN0IGRlc3RQYXJlbnQgPSBwYXRoLmRpcm5hbWUoZGVzdClcbiAgaWYgKCFmcy5leGlzdHNTeW5jKGRlc3RQYXJlbnQpKSBta2RpcnNTeW5jKGRlc3RQYXJlbnQpXG4gIHJldHVybiBnZXRTdGF0cyhkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxufVxuXG5mdW5jdGlvbiBzdGFydENvcHkgKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgaWYgKG9wdHMuZmlsdGVyICYmICFvcHRzLmZpbHRlcihzcmMsIGRlc3QpKSByZXR1cm5cbiAgcmV0dXJuIGdldFN0YXRzKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG59XG5cbmZ1bmN0aW9uIGdldFN0YXRzIChkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGNvbnN0IHN0YXRTeW5jID0gb3B0cy5kZXJlZmVyZW5jZSA/IGZzLnN0YXRTeW5jIDogZnMubHN0YXRTeW5jXG4gIGNvbnN0IHNyY1N0YXQgPSBzdGF0U3luYyhzcmMpXG5cbiAgaWYgKHNyY1N0YXQuaXNEaXJlY3RvcnkoKSkgcmV0dXJuIG9uRGlyKHNyY1N0YXQsIGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG4gIGVsc2UgaWYgKHNyY1N0YXQuaXNGaWxlKCkgfHxcbiAgICAgICAgICAgc3JjU3RhdC5pc0NoYXJhY3RlckRldmljZSgpIHx8XG4gICAgICAgICAgIHNyY1N0YXQuaXNCbG9ja0RldmljZSgpKSByZXR1cm4gb25GaWxlKHNyY1N0YXQsIGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG4gIGVsc2UgaWYgKHNyY1N0YXQuaXNTeW1ib2xpY0xpbmsoKSkgcmV0dXJuIG9uTGluayhkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxuICBlbHNlIGlmIChzcmNTdGF0LmlzU29ja2V0KCkpIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvcHkgYSBzb2NrZXQgZmlsZTogJHtzcmN9YClcbiAgZWxzZSBpZiAoc3JjU3RhdC5pc0ZJRk8oKSkgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY29weSBhIEZJRk8gcGlwZTogJHtzcmN9YClcbiAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGZpbGU6ICR7c3JjfWApXG59XG5cbmZ1bmN0aW9uIG9uRmlsZSAoc3JjU3RhdCwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBpZiAoIWRlc3RTdGF0KSByZXR1cm4gY29weUZpbGUoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxuICByZXR1cm4gbWF5Q29weUZpbGUoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxufVxuXG5mdW5jdGlvbiBtYXlDb3B5RmlsZSAoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGlmIChvcHRzLm92ZXJ3cml0ZSkge1xuICAgIGZzLnVubGlua1N5bmMoZGVzdClcbiAgICByZXR1cm4gY29weUZpbGUoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxuICB9IGVsc2UgaWYgKG9wdHMuZXJyb3JPbkV4aXN0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAnJHtkZXN0fScgYWxyZWFkeSBleGlzdHNgKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvcHlGaWxlIChzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgZnMuY29weUZpbGVTeW5jKHNyYywgZGVzdClcbiAgaWYgKG9wdHMucHJlc2VydmVUaW1lc3RhbXBzKSBoYW5kbGVUaW1lc3RhbXBzKHNyY1N0YXQubW9kZSwgc3JjLCBkZXN0KVxuICByZXR1cm4gc2V0RGVzdE1vZGUoZGVzdCwgc3JjU3RhdC5tb2RlKVxufVxuXG5mdW5jdGlvbiBoYW5kbGVUaW1lc3RhbXBzIChzcmNNb2RlLCBzcmMsIGRlc3QpIHtcbiAgLy8gTWFrZSBzdXJlIHRoZSBmaWxlIGlzIHdyaXRhYmxlIGJlZm9yZSBzZXR0aW5nIHRoZSB0aW1lc3RhbXBcbiAgLy8gb3RoZXJ3aXNlIG9wZW4gZmFpbHMgd2l0aCBFUEVSTSB3aGVuIGludm9rZWQgd2l0aCAncisnXG4gIC8vICh0aHJvdWdoIHV0aW1lcyBjYWxsKVxuICBpZiAoZmlsZUlzTm90V3JpdGFibGUoc3JjTW9kZSkpIG1ha2VGaWxlV3JpdGFibGUoZGVzdCwgc3JjTW9kZSlcbiAgcmV0dXJuIHNldERlc3RUaW1lc3RhbXBzKHNyYywgZGVzdClcbn1cblxuZnVuY3Rpb24gZmlsZUlzTm90V3JpdGFibGUgKHNyY01vZGUpIHtcbiAgcmV0dXJuIChzcmNNb2RlICYgMG8yMDApID09PSAwXG59XG5cbmZ1bmN0aW9uIG1ha2VGaWxlV3JpdGFibGUgKGRlc3QsIHNyY01vZGUpIHtcbiAgcmV0dXJuIHNldERlc3RNb2RlKGRlc3QsIHNyY01vZGUgfCAwbzIwMClcbn1cblxuZnVuY3Rpb24gc2V0RGVzdE1vZGUgKGRlc3QsIHNyY01vZGUpIHtcbiAgcmV0dXJuIGZzLmNobW9kU3luYyhkZXN0LCBzcmNNb2RlKVxufVxuXG5mdW5jdGlvbiBzZXREZXN0VGltZXN0YW1wcyAoc3JjLCBkZXN0KSB7XG4gIC8vIFRoZSBpbml0aWFsIHNyY1N0YXQuYXRpbWUgY2Fubm90IGJlIHRydXN0ZWRcbiAgLy8gYmVjYXVzZSBpdCBpcyBtb2RpZmllZCBieSB0aGUgcmVhZCgyKSBzeXN0ZW0gY2FsbFxuICAvLyAoU2VlIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZnMuaHRtbCNmc19zdGF0X3RpbWVfdmFsdWVzKVxuICBjb25zdCB1cGRhdGVkU3JjU3RhdCA9IGZzLnN0YXRTeW5jKHNyYylcbiAgcmV0dXJuIHV0aW1lc01pbGxpc1N5bmMoZGVzdCwgdXBkYXRlZFNyY1N0YXQuYXRpbWUsIHVwZGF0ZWRTcmNTdGF0Lm10aW1lKVxufVxuXG5mdW5jdGlvbiBvbkRpciAoc3JjU3RhdCwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBpZiAoIWRlc3RTdGF0KSByZXR1cm4gbWtEaXJBbmRDb3B5KHNyY1N0YXQubW9kZSwgc3JjLCBkZXN0LCBvcHRzKVxuICByZXR1cm4gY29weURpcihzcmMsIGRlc3QsIG9wdHMpXG59XG5cbmZ1bmN0aW9uIG1rRGlyQW5kQ29weSAoc3JjTW9kZSwgc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGZzLm1rZGlyU3luYyhkZXN0KVxuICBjb3B5RGlyKHNyYywgZGVzdCwgb3B0cylcbiAgcmV0dXJuIHNldERlc3RNb2RlKGRlc3QsIHNyY01vZGUpXG59XG5cbmZ1bmN0aW9uIGNvcHlEaXIgKHNyYywgZGVzdCwgb3B0cykge1xuICBmcy5yZWFkZGlyU3luYyhzcmMpLmZvckVhY2goaXRlbSA9PiBjb3B5RGlySXRlbShpdGVtLCBzcmMsIGRlc3QsIG9wdHMpKVxufVxuXG5mdW5jdGlvbiBjb3B5RGlySXRlbSAoaXRlbSwgc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGNvbnN0IHNyY0l0ZW0gPSBwYXRoLmpvaW4oc3JjLCBpdGVtKVxuICBjb25zdCBkZXN0SXRlbSA9IHBhdGguam9pbihkZXN0LCBpdGVtKVxuICBjb25zdCB7IGRlc3RTdGF0IH0gPSBzdGF0LmNoZWNrUGF0aHNTeW5jKHNyY0l0ZW0sIGRlc3RJdGVtLCAnY29weScsIG9wdHMpXG4gIHJldHVybiBzdGFydENvcHkoZGVzdFN0YXQsIHNyY0l0ZW0sIGRlc3RJdGVtLCBvcHRzKVxufVxuXG5mdW5jdGlvbiBvbkxpbmsgKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgbGV0IHJlc29sdmVkU3JjID0gZnMucmVhZGxpbmtTeW5jKHNyYylcbiAgaWYgKG9wdHMuZGVyZWZlcmVuY2UpIHtcbiAgICByZXNvbHZlZFNyYyA9IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCByZXNvbHZlZFNyYylcbiAgfVxuXG4gIGlmICghZGVzdFN0YXQpIHtcbiAgICByZXR1cm4gZnMuc3ltbGlua1N5bmMocmVzb2x2ZWRTcmMsIGRlc3QpXG4gIH0gZWxzZSB7XG4gICAgbGV0IHJlc29sdmVkRGVzdFxuICAgIHRyeSB7XG4gICAgICByZXNvbHZlZERlc3QgPSBmcy5yZWFkbGlua1N5bmMoZGVzdClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIGRlc3QgZXhpc3RzIGFuZCBpcyBhIHJlZ3VsYXIgZmlsZSBvciBkaXJlY3RvcnksXG4gICAgICAvLyBXaW5kb3dzIG1heSB0aHJvdyBVTktOT1dOIGVycm9yLiBJZiBkZXN0IGFscmVhZHkgZXhpc3RzLFxuICAgICAgLy8gZnMgdGhyb3dzIGVycm9yIGFueXdheSwgc28gbm8gbmVlZCB0byBndWFyZCBhZ2FpbnN0IGl0IGhlcmUuXG4gICAgICBpZiAoZXJyLmNvZGUgPT09ICdFSU5WQUwnIHx8IGVyci5jb2RlID09PSAnVU5LTk9XTicpIHJldHVybiBmcy5zeW1saW5rU3luYyhyZXNvbHZlZFNyYywgZGVzdClcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgICBpZiAob3B0cy5kZXJlZmVyZW5jZSkge1xuICAgICAgcmVzb2x2ZWREZXN0ID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksIHJlc29sdmVkRGVzdClcbiAgICB9XG4gICAgaWYgKHN0YXQuaXNTcmNTdWJkaXIocmVzb2x2ZWRTcmMsIHJlc29sdmVkRGVzdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvcHkgJyR7cmVzb2x2ZWRTcmN9JyB0byBhIHN1YmRpcmVjdG9yeSBvZiBpdHNlbGYsICcke3Jlc29sdmVkRGVzdH0nLmApXG4gICAgfVxuXG4gICAgLy8gcHJldmVudCBjb3B5IGlmIHNyYyBpcyBhIHN1YmRpciBvZiBkZXN0IHNpbmNlIHVubGlua2luZ1xuICAgIC8vIGRlc3QgaW4gdGhpcyBjYXNlIHdvdWxkIHJlc3VsdCBpbiByZW1vdmluZyBzcmMgY29udGVudHNcbiAgICAvLyBhbmQgdGhlcmVmb3JlIGEgYnJva2VuIHN5bWxpbmsgd291bGQgYmUgY3JlYXRlZC5cbiAgICBpZiAoZnMuc3RhdFN5bmMoZGVzdCkuaXNEaXJlY3RvcnkoKSAmJiBzdGF0LmlzU3JjU3ViZGlyKHJlc29sdmVkRGVzdCwgcmVzb2x2ZWRTcmMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBvdmVyd3JpdGUgJyR7cmVzb2x2ZWREZXN0fScgd2l0aCAnJHtyZXNvbHZlZFNyY30nLmApXG4gICAgfVxuICAgIHJldHVybiBjb3B5TGluayhyZXNvbHZlZFNyYywgZGVzdClcbiAgfVxufVxuXG5mdW5jdGlvbiBjb3B5TGluayAocmVzb2x2ZWRTcmMsIGRlc3QpIHtcbiAgZnMudW5saW5rU3luYyhkZXN0KVxuICByZXR1cm4gZnMuc3ltbGlua1N5bmMocmVzb2x2ZWRTcmMsIGRlc3QpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVN5bmNcbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29weVN5bmM6IHJlcXVpcmUoJy4vY29weS1zeW5jJylcbn1cbiIsIid1c2Ugc3RyaWN0J1xuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21Qcm9taXNlXG5jb25zdCBmcyA9IHJlcXVpcmUoJy4uL2ZzJylcblxuZnVuY3Rpb24gcGF0aEV4aXN0cyAocGF0aCkge1xuICByZXR1cm4gZnMuYWNjZXNzKHBhdGgpLnRoZW4oKCkgPT4gdHJ1ZSkuY2F0Y2goKCkgPT4gZmFsc2UpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBwYXRoRXhpc3RzOiB1KHBhdGhFeGlzdHMpLFxuICBwYXRoRXhpc3RzU3luYzogZnMuZXhpc3RzU3luY1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgbWtkaXJzID0gcmVxdWlyZSgnLi4vbWtkaXJzJykubWtkaXJzXG5jb25zdCBwYXRoRXhpc3RzID0gcmVxdWlyZSgnLi4vcGF0aC1leGlzdHMnKS5wYXRoRXhpc3RzXG5jb25zdCB1dGltZXNNaWxsaXMgPSByZXF1aXJlKCcuLi91dGlsL3V0aW1lcycpLnV0aW1lc01pbGxpc1xuY29uc3Qgc3RhdCA9IHJlcXVpcmUoJy4uL3V0aWwvc3RhdCcpXG5cbmZ1bmN0aW9uIGNvcHkgKHNyYywgZGVzdCwgb3B0cywgY2IpIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nICYmICFjYikge1xuICAgIGNiID0gb3B0c1xuICAgIG9wdHMgPSB7fVxuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0cyA9IHsgZmlsdGVyOiBvcHRzIH1cbiAgfVxuXG4gIGNiID0gY2IgfHwgZnVuY3Rpb24gKCkge31cbiAgb3B0cyA9IG9wdHMgfHwge31cblxuICBvcHRzLmNsb2JiZXIgPSAnY2xvYmJlcicgaW4gb3B0cyA/ICEhb3B0cy5jbG9iYmVyIDogdHJ1ZSAvLyBkZWZhdWx0IHRvIHRydWUgZm9yIG5vd1xuICBvcHRzLm92ZXJ3cml0ZSA9ICdvdmVyd3JpdGUnIGluIG9wdHMgPyAhIW9wdHMub3ZlcndyaXRlIDogb3B0cy5jbG9iYmVyIC8vIG92ZXJ3cml0ZSBmYWxscyBiYWNrIHRvIGNsb2JiZXJcblxuICAvLyBXYXJuIGFib3V0IHVzaW5nIHByZXNlcnZlVGltZXN0YW1wcyBvbiAzMi1iaXQgbm9kZVxuICBpZiAob3B0cy5wcmVzZXJ2ZVRpbWVzdGFtcHMgJiYgcHJvY2Vzcy5hcmNoID09PSAnaWEzMicpIHtcbiAgICBjb25zb2xlLndhcm4oYGZzLWV4dHJhOiBVc2luZyB0aGUgcHJlc2VydmVUaW1lc3RhbXBzIG9wdGlvbiBpbiAzMi1iaXQgbm9kZSBpcyBub3QgcmVjb21tZW5kZWQ7XFxuXG4gICAgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcHJpY2hhcmRzb24vbm9kZS1mcy1leHRyYS9pc3N1ZXMvMjY5YClcbiAgfVxuXG4gIHN0YXQuY2hlY2tQYXRocyhzcmMsIGRlc3QsICdjb3B5Jywgb3B0cywgKGVyciwgc3RhdHMpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGNvbnN0IHsgc3JjU3RhdCwgZGVzdFN0YXQgfSA9IHN0YXRzXG4gICAgc3RhdC5jaGVja1BhcmVudFBhdGhzKHNyYywgc3JjU3RhdCwgZGVzdCwgJ2NvcHknLCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIGlmIChvcHRzLmZpbHRlcikgcmV0dXJuIGhhbmRsZUZpbHRlcihjaGVja1BhcmVudERpciwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gICAgICByZXR1cm4gY2hlY2tQYXJlbnREaXIoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gY2hlY2tQYXJlbnREaXIgKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGNvbnN0IGRlc3RQYXJlbnQgPSBwYXRoLmRpcm5hbWUoZGVzdClcbiAgcGF0aEV4aXN0cyhkZXN0UGFyZW50LCAoZXJyLCBkaXJFeGlzdHMpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGlmIChkaXJFeGlzdHMpIHJldHVybiBnZXRTdGF0cyhkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgICBta2RpcnMoZGVzdFBhcmVudCwgZXJyID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICByZXR1cm4gZ2V0U3RhdHMoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gaGFuZGxlRmlsdGVyIChvbkluY2x1ZGUsIGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIFByb21pc2UucmVzb2x2ZShvcHRzLmZpbHRlcihzcmMsIGRlc3QpKS50aGVuKGluY2x1ZGUgPT4ge1xuICAgIGlmIChpbmNsdWRlKSByZXR1cm4gb25JbmNsdWRlKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgIHJldHVybiBjYigpXG4gIH0sIGVycm9yID0+IGNiKGVycm9yKSlcbn1cblxuZnVuY3Rpb24gc3RhcnRDb3B5IChkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBpZiAob3B0cy5maWx0ZXIpIHJldHVybiBoYW5kbGVGaWx0ZXIoZ2V0U3RhdHMsIGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICByZXR1cm4gZ2V0U3RhdHMoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG59XG5cbmZ1bmN0aW9uIGdldFN0YXRzIChkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBjb25zdCBzdGF0ID0gb3B0cy5kZXJlZmVyZW5jZSA/IGZzLnN0YXQgOiBmcy5sc3RhdFxuICBzdGF0KHNyYywgKGVyciwgc3JjU3RhdCkgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG5cbiAgICBpZiAoc3JjU3RhdC5pc0RpcmVjdG9yeSgpKSByZXR1cm4gb25EaXIoc3JjU3RhdCwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gICAgZWxzZSBpZiAoc3JjU3RhdC5pc0ZpbGUoKSB8fFxuICAgICAgICAgICAgIHNyY1N0YXQuaXNDaGFyYWN0ZXJEZXZpY2UoKSB8fFxuICAgICAgICAgICAgIHNyY1N0YXQuaXNCbG9ja0RldmljZSgpKSByZXR1cm4gb25GaWxlKHNyY1N0YXQsIGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgIGVsc2UgaWYgKHNyY1N0YXQuaXNTeW1ib2xpY0xpbmsoKSkgcmV0dXJuIG9uTGluayhkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgICBlbHNlIGlmIChzcmNTdGF0LmlzU29ja2V0KCkpIHJldHVybiBjYihuZXcgRXJyb3IoYENhbm5vdCBjb3B5IGEgc29ja2V0IGZpbGU6ICR7c3JjfWApKVxuICAgIGVsc2UgaWYgKHNyY1N0YXQuaXNGSUZPKCkpIHJldHVybiBjYihuZXcgRXJyb3IoYENhbm5vdCBjb3B5IGEgRklGTyBwaXBlOiAke3NyY31gKSlcbiAgICByZXR1cm4gY2IobmV3IEVycm9yKGBVbmtub3duIGZpbGU6ICR7c3JjfWApKVxuICB9KVxufVxuXG5mdW5jdGlvbiBvbkZpbGUgKHNyY1N0YXQsIGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGlmICghZGVzdFN0YXQpIHJldHVybiBjb3B5RmlsZShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICByZXR1cm4gbWF5Q29weUZpbGUoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbn1cblxuZnVuY3Rpb24gbWF5Q29weUZpbGUgKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpIHtcbiAgaWYgKG9wdHMub3ZlcndyaXRlKSB7XG4gICAgZnMudW5saW5rKGRlc3QsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgcmV0dXJuIGNvcHlGaWxlKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gICAgfSlcbiAgfSBlbHNlIGlmIChvcHRzLmVycm9yT25FeGlzdCkge1xuICAgIHJldHVybiBjYihuZXcgRXJyb3IoYCcke2Rlc3R9JyBhbHJlYWR5IGV4aXN0c2ApKVxuICB9IGVsc2UgcmV0dXJuIGNiKClcbn1cblxuZnVuY3Rpb24gY29weUZpbGUgKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpIHtcbiAgZnMuY29weUZpbGUoc3JjLCBkZXN0LCBlcnIgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgaWYgKG9wdHMucHJlc2VydmVUaW1lc3RhbXBzKSByZXR1cm4gaGFuZGxlVGltZXN0YW1wc0FuZE1vZGUoc3JjU3RhdC5tb2RlLCBzcmMsIGRlc3QsIGNiKVxuICAgIHJldHVybiBzZXREZXN0TW9kZShkZXN0LCBzcmNTdGF0Lm1vZGUsIGNiKVxuICB9KVxufVxuXG5mdW5jdGlvbiBoYW5kbGVUaW1lc3RhbXBzQW5kTW9kZSAoc3JjTW9kZSwgc3JjLCBkZXN0LCBjYikge1xuICAvLyBNYWtlIHN1cmUgdGhlIGZpbGUgaXMgd3JpdGFibGUgYmVmb3JlIHNldHRpbmcgdGhlIHRpbWVzdGFtcFxuICAvLyBvdGhlcndpc2Ugb3BlbiBmYWlscyB3aXRoIEVQRVJNIHdoZW4gaW52b2tlZCB3aXRoICdyKydcbiAgLy8gKHRocm91Z2ggdXRpbWVzIGNhbGwpXG4gIGlmIChmaWxlSXNOb3RXcml0YWJsZShzcmNNb2RlKSkge1xuICAgIHJldHVybiBtYWtlRmlsZVdyaXRhYmxlKGRlc3QsIHNyY01vZGUsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgcmV0dXJuIHNldERlc3RUaW1lc3RhbXBzQW5kTW9kZShzcmNNb2RlLCBzcmMsIGRlc3QsIGNiKVxuICAgIH0pXG4gIH1cbiAgcmV0dXJuIHNldERlc3RUaW1lc3RhbXBzQW5kTW9kZShzcmNNb2RlLCBzcmMsIGRlc3QsIGNiKVxufVxuXG5mdW5jdGlvbiBmaWxlSXNOb3RXcml0YWJsZSAoc3JjTW9kZSkge1xuICByZXR1cm4gKHNyY01vZGUgJiAwbzIwMCkgPT09IDBcbn1cblxuZnVuY3Rpb24gbWFrZUZpbGVXcml0YWJsZSAoZGVzdCwgc3JjTW9kZSwgY2IpIHtcbiAgcmV0dXJuIHNldERlc3RNb2RlKGRlc3QsIHNyY01vZGUgfCAwbzIwMCwgY2IpXG59XG5cbmZ1bmN0aW9uIHNldERlc3RUaW1lc3RhbXBzQW5kTW9kZSAoc3JjTW9kZSwgc3JjLCBkZXN0LCBjYikge1xuICBzZXREZXN0VGltZXN0YW1wcyhzcmMsIGRlc3QsIGVyciA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICByZXR1cm4gc2V0RGVzdE1vZGUoZGVzdCwgc3JjTW9kZSwgY2IpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHNldERlc3RNb2RlIChkZXN0LCBzcmNNb2RlLCBjYikge1xuICByZXR1cm4gZnMuY2htb2QoZGVzdCwgc3JjTW9kZSwgY2IpXG59XG5cbmZ1bmN0aW9uIHNldERlc3RUaW1lc3RhbXBzIChzcmMsIGRlc3QsIGNiKSB7XG4gIC8vIFRoZSBpbml0aWFsIHNyY1N0YXQuYXRpbWUgY2Fubm90IGJlIHRydXN0ZWRcbiAgLy8gYmVjYXVzZSBpdCBpcyBtb2RpZmllZCBieSB0aGUgcmVhZCgyKSBzeXN0ZW0gY2FsbFxuICAvLyAoU2VlIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZnMuaHRtbCNmc19zdGF0X3RpbWVfdmFsdWVzKVxuICBmcy5zdGF0KHNyYywgKGVyciwgdXBkYXRlZFNyY1N0YXQpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIHJldHVybiB1dGltZXNNaWxsaXMoZGVzdCwgdXBkYXRlZFNyY1N0YXQuYXRpbWUsIHVwZGF0ZWRTcmNTdGF0Lm10aW1lLCBjYilcbiAgfSlcbn1cblxuZnVuY3Rpb24gb25EaXIgKHNyY1N0YXQsIGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGlmICghZGVzdFN0YXQpIHJldHVybiBta0RpckFuZENvcHkoc3JjU3RhdC5tb2RlLCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICByZXR1cm4gY29weURpcihzcmMsIGRlc3QsIG9wdHMsIGNiKVxufVxuXG5mdW5jdGlvbiBta0RpckFuZENvcHkgKHNyY01vZGUsIHNyYywgZGVzdCwgb3B0cywgY2IpIHtcbiAgZnMubWtkaXIoZGVzdCwgZXJyID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGNvcHlEaXIoc3JjLCBkZXN0LCBvcHRzLCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIHJldHVybiBzZXREZXN0TW9kZShkZXN0LCBzcmNNb2RlLCBjYilcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBjb3B5RGlyIChzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGZzLnJlYWRkaXIoc3JjLCAoZXJyLCBpdGVtcykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgcmV0dXJuIGNvcHlEaXJJdGVtcyhpdGVtcywgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgfSlcbn1cblxuZnVuY3Rpb24gY29weURpckl0ZW1zIChpdGVtcywgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBjb25zdCBpdGVtID0gaXRlbXMucG9wKClcbiAgaWYgKCFpdGVtKSByZXR1cm4gY2IoKVxuICByZXR1cm4gY29weURpckl0ZW0oaXRlbXMsIGl0ZW0sIHNyYywgZGVzdCwgb3B0cywgY2IpXG59XG5cbmZ1bmN0aW9uIGNvcHlEaXJJdGVtIChpdGVtcywgaXRlbSwgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBjb25zdCBzcmNJdGVtID0gcGF0aC5qb2luKHNyYywgaXRlbSlcbiAgY29uc3QgZGVzdEl0ZW0gPSBwYXRoLmpvaW4oZGVzdCwgaXRlbSlcbiAgc3RhdC5jaGVja1BhdGhzKHNyY0l0ZW0sIGRlc3RJdGVtLCAnY29weScsIG9wdHMsIChlcnIsIHN0YXRzKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBjb25zdCB7IGRlc3RTdGF0IH0gPSBzdGF0c1xuICAgIHN0YXJ0Q29weShkZXN0U3RhdCwgc3JjSXRlbSwgZGVzdEl0ZW0sIG9wdHMsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgcmV0dXJuIGNvcHlEaXJJdGVtcyhpdGVtcywgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBvbkxpbmsgKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGZzLnJlYWRsaW5rKHNyYywgKGVyciwgcmVzb2x2ZWRTcmMpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGlmIChvcHRzLmRlcmVmZXJlbmNlKSB7XG4gICAgICByZXNvbHZlZFNyYyA9IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCByZXNvbHZlZFNyYylcbiAgICB9XG5cbiAgICBpZiAoIWRlc3RTdGF0KSB7XG4gICAgICByZXR1cm4gZnMuc3ltbGluayhyZXNvbHZlZFNyYywgZGVzdCwgY2IpXG4gICAgfSBlbHNlIHtcbiAgICAgIGZzLnJlYWRsaW5rKGRlc3QsIChlcnIsIHJlc29sdmVkRGVzdCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgLy8gZGVzdCBleGlzdHMgYW5kIGlzIGEgcmVndWxhciBmaWxlIG9yIGRpcmVjdG9yeSxcbiAgICAgICAgICAvLyBXaW5kb3dzIG1heSB0aHJvdyBVTktOT1dOIGVycm9yLiBJZiBkZXN0IGFscmVhZHkgZXhpc3RzLFxuICAgICAgICAgIC8vIGZzIHRocm93cyBlcnJvciBhbnl3YXksIHNvIG5vIG5lZWQgdG8gZ3VhcmQgYWdhaW5zdCBpdCBoZXJlLlxuICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VJTlZBTCcgfHwgZXJyLmNvZGUgPT09ICdVTktOT1dOJykgcmV0dXJuIGZzLnN5bWxpbmsocmVzb2x2ZWRTcmMsIGRlc3QsIGNiKVxuICAgICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuZGVyZWZlcmVuY2UpIHtcbiAgICAgICAgICByZXNvbHZlZERlc3QgPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgcmVzb2x2ZWREZXN0KVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0LmlzU3JjU3ViZGlyKHJlc29sdmVkU3JjLCByZXNvbHZlZERlc3QpKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcihgQ2Fubm90IGNvcHkgJyR7cmVzb2x2ZWRTcmN9JyB0byBhIHN1YmRpcmVjdG9yeSBvZiBpdHNlbGYsICcke3Jlc29sdmVkRGVzdH0nLmApKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZG8gbm90IGNvcHkgaWYgc3JjIGlzIGEgc3ViZGlyIG9mIGRlc3Qgc2luY2UgdW5saW5raW5nXG4gICAgICAgIC8vIGRlc3QgaW4gdGhpcyBjYXNlIHdvdWxkIHJlc3VsdCBpbiByZW1vdmluZyBzcmMgY29udGVudHNcbiAgICAgICAgLy8gYW5kIHRoZXJlZm9yZSBhIGJyb2tlbiBzeW1saW5rIHdvdWxkIGJlIGNyZWF0ZWQuXG4gICAgICAgIGlmIChkZXN0U3RhdC5pc0RpcmVjdG9yeSgpICYmIHN0YXQuaXNTcmNTdWJkaXIocmVzb2x2ZWREZXN0LCByZXNvbHZlZFNyYykpIHtcbiAgICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKGBDYW5ub3Qgb3ZlcndyaXRlICcke3Jlc29sdmVkRGVzdH0nIHdpdGggJyR7cmVzb2x2ZWRTcmN9Jy5gKSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29weUxpbmsocmVzb2x2ZWRTcmMsIGRlc3QsIGNiKVxuICAgICAgfSlcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNvcHlMaW5rIChyZXNvbHZlZFNyYywgZGVzdCwgY2IpIHtcbiAgZnMudW5saW5rKGRlc3QsIGVyciA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICByZXR1cm4gZnMuc3ltbGluayhyZXNvbHZlZFNyYywgZGVzdCwgY2IpXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tQ2FsbGJhY2tcbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb3B5OiB1KHJlcXVpcmUoJy4vY29weScpKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcblxuY29uc3QgaXNXaW5kb3dzID0gKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpXG5cbmZ1bmN0aW9uIGRlZmF1bHRzIChvcHRpb25zKSB7XG4gIGNvbnN0IG1ldGhvZHMgPSBbXG4gICAgJ3VubGluaycsXG4gICAgJ2NobW9kJyxcbiAgICAnc3RhdCcsXG4gICAgJ2xzdGF0JyxcbiAgICAncm1kaXInLFxuICAgICdyZWFkZGlyJ1xuICBdXG4gIG1ldGhvZHMuZm9yRWFjaChtID0+IHtcbiAgICBvcHRpb25zW21dID0gb3B0aW9uc1ttXSB8fCBmc1ttXVxuICAgIG0gPSBtICsgJ1N5bmMnXG4gICAgb3B0aW9uc1ttXSA9IG9wdGlvbnNbbV0gfHwgZnNbbV1cbiAgfSlcblxuICBvcHRpb25zLm1heEJ1c3lUcmllcyA9IG9wdGlvbnMubWF4QnVzeVRyaWVzIHx8IDNcbn1cblxuZnVuY3Rpb24gcmltcmFmIChwLCBvcHRpb25zLCBjYikge1xuICBsZXQgYnVzeVRyaWVzID0gMFxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gb3B0aW9uc1xuICAgIG9wdGlvbnMgPSB7fVxuICB9XG5cbiAgYXNzZXJ0KHAsICdyaW1yYWY6IG1pc3NpbmcgcGF0aCcpXG4gIGFzc2VydC5zdHJpY3RFcXVhbCh0eXBlb2YgcCwgJ3N0cmluZycsICdyaW1yYWY6IHBhdGggc2hvdWxkIGJlIGEgc3RyaW5nJylcbiAgYXNzZXJ0LnN0cmljdEVxdWFsKHR5cGVvZiBjYiwgJ2Z1bmN0aW9uJywgJ3JpbXJhZjogY2FsbGJhY2sgZnVuY3Rpb24gcmVxdWlyZWQnKVxuICBhc3NlcnQob3B0aW9ucywgJ3JpbXJhZjogaW52YWxpZCBvcHRpb25zIGFyZ3VtZW50IHByb3ZpZGVkJylcbiAgYXNzZXJ0LnN0cmljdEVxdWFsKHR5cGVvZiBvcHRpb25zLCAnb2JqZWN0JywgJ3JpbXJhZjogb3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0JylcblxuICBkZWZhdWx0cyhvcHRpb25zKVxuXG4gIHJpbXJhZl8ocCwgb3B0aW9ucywgZnVuY3Rpb24gQ0IgKGVyKSB7XG4gICAgaWYgKGVyKSB7XG4gICAgICBpZiAoKGVyLmNvZGUgPT09ICdFQlVTWScgfHwgZXIuY29kZSA9PT0gJ0VOT1RFTVBUWScgfHwgZXIuY29kZSA9PT0gJ0VQRVJNJykgJiZcbiAgICAgICAgICBidXN5VHJpZXMgPCBvcHRpb25zLm1heEJ1c3lUcmllcykge1xuICAgICAgICBidXN5VHJpZXMrK1xuICAgICAgICBjb25zdCB0aW1lID0gYnVzeVRyaWVzICogMTAwXG4gICAgICAgIC8vIHRyeSBhZ2Fpbiwgd2l0aCB0aGUgc2FtZSBleGFjdCBjYWxsYmFjayBhcyB0aGlzIG9uZS5cbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoKCkgPT4gcmltcmFmXyhwLCBvcHRpb25zLCBDQiksIHRpbWUpXG4gICAgICB9XG5cbiAgICAgIC8vIGFscmVhZHkgZ29uZVxuICAgICAgaWYgKGVyLmNvZGUgPT09ICdFTk9FTlQnKSBlciA9IG51bGxcbiAgICB9XG5cbiAgICBjYihlcilcbiAgfSlcbn1cblxuLy8gVHdvIHBvc3NpYmxlIHN0cmF0ZWdpZXMuXG4vLyAxLiBBc3N1bWUgaXQncyBhIGZpbGUuICB1bmxpbmsgaXQsIHRoZW4gZG8gdGhlIGRpciBzdHVmZiBvbiBFUEVSTSBvciBFSVNESVJcbi8vIDIuIEFzc3VtZSBpdCdzIGEgZGlyZWN0b3J5LiAgcmVhZGRpciwgdGhlbiBkbyB0aGUgZmlsZSBzdHVmZiBvbiBFTk9URElSXG4vL1xuLy8gQm90aCByZXN1bHQgaW4gYW4gZXh0cmEgc3lzY2FsbCB3aGVuIHlvdSBndWVzcyB3cm9uZy4gIEhvd2V2ZXIsIHRoZXJlXG4vLyBhcmUgbGlrZWx5IGZhciBtb3JlIG5vcm1hbCBmaWxlcyBpbiB0aGUgd29ybGQgdGhhbiBkaXJlY3Rvcmllcy4gIFRoaXNcbi8vIGlzIGJhc2VkIG9uIHRoZSBhc3N1bXB0aW9uIHRoYXQgYSB0aGUgYXZlcmFnZSBudW1iZXIgb2YgZmlsZXMgcGVyXG4vLyBkaXJlY3RvcnkgaXMgPj0gMS5cbi8vXG4vLyBJZiBhbnlvbmUgZXZlciBjb21wbGFpbnMgYWJvdXQgdGhpcywgdGhlbiBJIGd1ZXNzIHRoZSBzdHJhdGVneSBjb3VsZFxuLy8gYmUgbWFkZSBjb25maWd1cmFibGUgc29tZWhvdy4gIEJ1dCB1bnRpbCB0aGVuLCBZQUdOSS5cbmZ1bmN0aW9uIHJpbXJhZl8gKHAsIG9wdGlvbnMsIGNiKSB7XG4gIGFzc2VydChwKVxuICBhc3NlcnQob3B0aW9ucylcbiAgYXNzZXJ0KHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcblxuICAvLyBzdW5vcyBsZXRzIHRoZSByb290IHVzZXIgdW5saW5rIGRpcmVjdG9yaWVzLCB3aGljaCBpcy4uLiB3ZWlyZC5cbiAgLy8gc28gd2UgaGF2ZSB0byBsc3RhdCBoZXJlIGFuZCBtYWtlIHN1cmUgaXQncyBub3QgYSBkaXIuXG4gIG9wdGlvbnMubHN0YXQocCwgKGVyLCBzdCkgPT4ge1xuICAgIGlmIChlciAmJiBlci5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgcmV0dXJuIGNiKG51bGwpXG4gICAgfVxuXG4gICAgLy8gV2luZG93cyBjYW4gRVBFUk0gb24gc3RhdC4gIExpZmUgaXMgc3VmZmVyaW5nLlxuICAgIGlmIChlciAmJiBlci5jb2RlID09PSAnRVBFUk0nICYmIGlzV2luZG93cykge1xuICAgICAgcmV0dXJuIGZpeFdpbkVQRVJNKHAsIG9wdGlvbnMsIGVyLCBjYilcbiAgICB9XG5cbiAgICBpZiAoc3QgJiYgc3QuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgcmV0dXJuIHJtZGlyKHAsIG9wdGlvbnMsIGVyLCBjYilcbiAgICB9XG5cbiAgICBvcHRpb25zLnVubGluayhwLCBlciA9PiB7XG4gICAgICBpZiAoZXIpIHtcbiAgICAgICAgaWYgKGVyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKG51bGwpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVyLmNvZGUgPT09ICdFUEVSTScpIHtcbiAgICAgICAgICByZXR1cm4gKGlzV2luZG93cylcbiAgICAgICAgICAgID8gZml4V2luRVBFUk0ocCwgb3B0aW9ucywgZXIsIGNiKVxuICAgICAgICAgICAgOiBybWRpcihwLCBvcHRpb25zLCBlciwgY2IpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVyLmNvZGUgPT09ICdFSVNESVInKSB7XG4gICAgICAgICAgcmV0dXJuIHJtZGlyKHAsIG9wdGlvbnMsIGVyLCBjYilcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNiKGVyKVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGZpeFdpbkVQRVJNIChwLCBvcHRpb25zLCBlciwgY2IpIHtcbiAgYXNzZXJ0KHApXG4gIGFzc2VydChvcHRpb25zKVxuICBhc3NlcnQodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuXG4gIG9wdGlvbnMuY2htb2QocCwgMG82NjYsIGVyMiA9PiB7XG4gICAgaWYgKGVyMikge1xuICAgICAgY2IoZXIyLmNvZGUgPT09ICdFTk9FTlQnID8gbnVsbCA6IGVyKVxuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLnN0YXQocCwgKGVyMywgc3RhdHMpID0+IHtcbiAgICAgICAgaWYgKGVyMykge1xuICAgICAgICAgIGNiKGVyMy5jb2RlID09PSAnRU5PRU5UJyA/IG51bGwgOiBlcilcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgcm1kaXIocCwgb3B0aW9ucywgZXIsIGNiKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMudW5saW5rKHAsIGNiKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gZml4V2luRVBFUk1TeW5jIChwLCBvcHRpb25zLCBlcikge1xuICBsZXQgc3RhdHNcblxuICBhc3NlcnQocClcbiAgYXNzZXJ0KG9wdGlvbnMpXG5cbiAgdHJ5IHtcbiAgICBvcHRpb25zLmNobW9kU3luYyhwLCAwbzY2NilcbiAgfSBjYXRjaCAoZXIyKSB7XG4gICAgaWYgKGVyMi5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgcmV0dXJuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVyXG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICBzdGF0cyA9IG9wdGlvbnMuc3RhdFN5bmMocClcbiAgfSBjYXRjaCAoZXIzKSB7XG4gICAgaWYgKGVyMy5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgcmV0dXJuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVyXG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICBybWRpclN5bmMocCwgb3B0aW9ucywgZXIpXG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy51bmxpbmtTeW5jKHApXG4gIH1cbn1cblxuZnVuY3Rpb24gcm1kaXIgKHAsIG9wdGlvbnMsIG9yaWdpbmFsRXIsIGNiKSB7XG4gIGFzc2VydChwKVxuICBhc3NlcnQob3B0aW9ucylcbiAgYXNzZXJ0KHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcblxuICAvLyB0cnkgdG8gcm1kaXIgZmlyc3QsIGFuZCBvbmx5IHJlYWRkaXIgb24gRU5PVEVNUFRZIG9yIEVFWElTVCAoU3VuT1MpXG4gIC8vIGlmIHdlIGd1ZXNzZWQgd3JvbmcsIGFuZCBpdCdzIG5vdCBhIGRpcmVjdG9yeSwgdGhlblxuICAvLyByYWlzZSB0aGUgb3JpZ2luYWwgZXJyb3IuXG4gIG9wdGlvbnMucm1kaXIocCwgZXIgPT4ge1xuICAgIGlmIChlciAmJiAoZXIuY29kZSA9PT0gJ0VOT1RFTVBUWScgfHwgZXIuY29kZSA9PT0gJ0VFWElTVCcgfHwgZXIuY29kZSA9PT0gJ0VQRVJNJykpIHtcbiAgICAgIHJta2lkcyhwLCBvcHRpb25zLCBjYilcbiAgICB9IGVsc2UgaWYgKGVyICYmIGVyLmNvZGUgPT09ICdFTk9URElSJykge1xuICAgICAgY2Iob3JpZ2luYWxFcilcbiAgICB9IGVsc2Uge1xuICAgICAgY2IoZXIpXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBybWtpZHMgKHAsIG9wdGlvbnMsIGNiKSB7XG4gIGFzc2VydChwKVxuICBhc3NlcnQob3B0aW9ucylcbiAgYXNzZXJ0KHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcblxuICBvcHRpb25zLnJlYWRkaXIocCwgKGVyLCBmaWxlcykgPT4ge1xuICAgIGlmIChlcikgcmV0dXJuIGNiKGVyKVxuXG4gICAgbGV0IG4gPSBmaWxlcy5sZW5ndGhcbiAgICBsZXQgZXJyU3RhdGVcblxuICAgIGlmIChuID09PSAwKSByZXR1cm4gb3B0aW9ucy5ybWRpcihwLCBjYilcblxuICAgIGZpbGVzLmZvckVhY2goZiA9PiB7XG4gICAgICByaW1yYWYocGF0aC5qb2luKHAsIGYpLCBvcHRpb25zLCBlciA9PiB7XG4gICAgICAgIGlmIChlcnJTdGF0ZSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmIChlcikgcmV0dXJuIGNiKGVyclN0YXRlID0gZXIpXG4gICAgICAgIGlmICgtLW4gPT09IDApIHtcbiAgICAgICAgICBvcHRpb25zLnJtZGlyKHAsIGNiKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG59XG5cbi8vIHRoaXMgbG9va3Mgc2ltcGxlciwgYW5kIGlzIHN0cmljdGx5ICpmYXN0ZXIqLCBidXQgd2lsbFxuLy8gdGllIHVwIHRoZSBKYXZhU2NyaXB0IHRocmVhZCBhbmQgZmFpbCBvbiBleGNlc3NpdmVseVxuLy8gZGVlcCBkaXJlY3RvcnkgdHJlZXMuXG5mdW5jdGlvbiByaW1yYWZTeW5jIChwLCBvcHRpb25zKSB7XG4gIGxldCBzdFxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIGRlZmF1bHRzKG9wdGlvbnMpXG5cbiAgYXNzZXJ0KHAsICdyaW1yYWY6IG1pc3NpbmcgcGF0aCcpXG4gIGFzc2VydC5zdHJpY3RFcXVhbCh0eXBlb2YgcCwgJ3N0cmluZycsICdyaW1yYWY6IHBhdGggc2hvdWxkIGJlIGEgc3RyaW5nJylcbiAgYXNzZXJ0KG9wdGlvbnMsICdyaW1yYWY6IG1pc3Npbmcgb3B0aW9ucycpXG4gIGFzc2VydC5zdHJpY3RFcXVhbCh0eXBlb2Ygb3B0aW9ucywgJ29iamVjdCcsICdyaW1yYWY6IG9wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCcpXG5cbiAgdHJ5IHtcbiAgICBzdCA9IG9wdGlvbnMubHN0YXRTeW5jKHApXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgaWYgKGVyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBXaW5kb3dzIGNhbiBFUEVSTSBvbiBzdGF0LiAgTGlmZSBpcyBzdWZmZXJpbmcuXG4gICAgaWYgKGVyLmNvZGUgPT09ICdFUEVSTScgJiYgaXNXaW5kb3dzKSB7XG4gICAgICBmaXhXaW5FUEVSTVN5bmMocCwgb3B0aW9ucywgZXIpXG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBzdW5vcyBsZXRzIHRoZSByb290IHVzZXIgdW5saW5rIGRpcmVjdG9yaWVzLCB3aGljaCBpcy4uLiB3ZWlyZC5cbiAgICBpZiAoc3QgJiYgc3QuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgcm1kaXJTeW5jKHAsIG9wdGlvbnMsIG51bGwpXG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMudW5saW5rU3luYyhwKVxuICAgIH1cbiAgfSBjYXRjaCAoZXIpIHtcbiAgICBpZiAoZXIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSBpZiAoZXIuY29kZSA9PT0gJ0VQRVJNJykge1xuICAgICAgcmV0dXJuIGlzV2luZG93cyA/IGZpeFdpbkVQRVJNU3luYyhwLCBvcHRpb25zLCBlcikgOiBybWRpclN5bmMocCwgb3B0aW9ucywgZXIpXG4gICAgfSBlbHNlIGlmIChlci5jb2RlICE9PSAnRUlTRElSJykge1xuICAgICAgdGhyb3cgZXJcbiAgICB9XG4gICAgcm1kaXJTeW5jKHAsIG9wdGlvbnMsIGVyKVxuICB9XG59XG5cbmZ1bmN0aW9uIHJtZGlyU3luYyAocCwgb3B0aW9ucywgb3JpZ2luYWxFcikge1xuICBhc3NlcnQocClcbiAgYXNzZXJ0KG9wdGlvbnMpXG5cbiAgdHJ5IHtcbiAgICBvcHRpb25zLnJtZGlyU3luYyhwKVxuICB9IGNhdGNoIChlcikge1xuICAgIGlmIChlci5jb2RlID09PSAnRU5PVERJUicpIHtcbiAgICAgIHRocm93IG9yaWdpbmFsRXJcbiAgICB9IGVsc2UgaWYgKGVyLmNvZGUgPT09ICdFTk9URU1QVFknIHx8IGVyLmNvZGUgPT09ICdFRVhJU1QnIHx8IGVyLmNvZGUgPT09ICdFUEVSTScpIHtcbiAgICAgIHJta2lkc1N5bmMocCwgb3B0aW9ucylcbiAgICB9IGVsc2UgaWYgKGVyLmNvZGUgIT09ICdFTk9FTlQnKSB7XG4gICAgICB0aHJvdyBlclxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBybWtpZHNTeW5jIChwLCBvcHRpb25zKSB7XG4gIGFzc2VydChwKVxuICBhc3NlcnQob3B0aW9ucylcbiAgb3B0aW9ucy5yZWFkZGlyU3luYyhwKS5mb3JFYWNoKGYgPT4gcmltcmFmU3luYyhwYXRoLmpvaW4ocCwgZiksIG9wdGlvbnMpKVxuXG4gIGlmIChpc1dpbmRvd3MpIHtcbiAgICAvLyBXZSBvbmx5IGVuZCB1cCBoZXJlIG9uY2Ugd2UgZ290IEVOT1RFTVBUWSBhdCBsZWFzdCBvbmNlLCBhbmRcbiAgICAvLyBhdCB0aGlzIHBvaW50LCB3ZSBhcmUgZ3VhcmFudGVlZCB0byBoYXZlIHJlbW92ZWQgYWxsIHRoZSBraWRzLlxuICAgIC8vIFNvLCB3ZSBrbm93IHRoYXQgaXQgd29uJ3QgYmUgRU5PRU5UIG9yIEVOT1RESVIgb3IgYW55dGhpbmcgZWxzZS5cbiAgICAvLyB0cnkgcmVhbGx5IGhhcmQgdG8gZGVsZXRlIHN0dWZmIG9uIHdpbmRvd3MsIGJlY2F1c2UgaXQgaGFzIGFcbiAgICAvLyBQUk9GT1VORExZIGFubm95aW5nIGhhYml0IG9mIG5vdCBjbG9zaW5nIGhhbmRsZXMgcHJvbXB0bHkgd2hlblxuICAgIC8vIGZpbGVzIGFyZSBkZWxldGVkLCByZXN1bHRpbmcgaW4gc3B1cmlvdXMgRU5PVEVNUFRZIGVycm9ycy5cbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpXG4gICAgZG8ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0ID0gb3B0aW9ucy5ybWRpclN5bmMocCwgb3B0aW9ucylcbiAgICAgICAgcmV0dXJuIHJldFxuICAgICAgfSBjYXRjaCB7fVxuICAgIH0gd2hpbGUgKERhdGUubm93KCkgLSBzdGFydFRpbWUgPCA1MDApIC8vIGdpdmUgdXAgYWZ0ZXIgNTAwbXNcbiAgfSBlbHNlIHtcbiAgICBjb25zdCByZXQgPSBvcHRpb25zLnJtZGlyU3luYyhwLCBvcHRpb25zKVxuICAgIHJldHVybiByZXRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJpbXJhZlxucmltcmFmLnN5bmMgPSByaW1yYWZTeW5jXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5jb25zdCByaW1yYWYgPSByZXF1aXJlKCcuL3JpbXJhZicpXG5cbmZ1bmN0aW9uIHJlbW92ZSAocGF0aCwgY2FsbGJhY2spIHtcbiAgLy8gTm9kZSAxNC4xNC4wK1xuICBpZiAoZnMucm0pIHJldHVybiBmcy5ybShwYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSwgZm9yY2U6IHRydWUgfSwgY2FsbGJhY2spXG4gIHJpbXJhZihwYXRoLCBjYWxsYmFjaylcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3luYyAocGF0aCkge1xuICAvLyBOb2RlIDE0LjE0LjArXG4gIGlmIChmcy5ybVN5bmMpIHJldHVybiBmcy5ybVN5bmMocGF0aCwgeyByZWN1cnNpdmU6IHRydWUsIGZvcmNlOiB0cnVlIH0pXG4gIHJpbXJhZi5zeW5jKHBhdGgpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICByZW1vdmU6IHUocmVtb3ZlKSxcbiAgcmVtb3ZlU3luY1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tUHJvbWlzZVxuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBta2RpciA9IHJlcXVpcmUoJy4uL21rZGlycycpXG5jb25zdCByZW1vdmUgPSByZXF1aXJlKCcuLi9yZW1vdmUnKVxuXG5jb25zdCBlbXB0eURpciA9IHUoYXN5bmMgZnVuY3Rpb24gZW1wdHlEaXIgKGRpcikge1xuICBsZXQgaXRlbXNcbiAgdHJ5IHtcbiAgICBpdGVtcyA9IGF3YWl0IGZzLnJlYWRkaXIoZGlyKVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbWtkaXIubWtkaXJzKGRpcilcbiAgfVxuXG4gIHJldHVybiBQcm9taXNlLmFsbChpdGVtcy5tYXAoaXRlbSA9PiByZW1vdmUucmVtb3ZlKHBhdGguam9pbihkaXIsIGl0ZW0pKSkpXG59KVxuXG5mdW5jdGlvbiBlbXB0eURpclN5bmMgKGRpcikge1xuICBsZXQgaXRlbXNcbiAgdHJ5IHtcbiAgICBpdGVtcyA9IGZzLnJlYWRkaXJTeW5jKGRpcilcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIG1rZGlyLm1rZGlyc1N5bmMoZGlyKVxuICB9XG5cbiAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICBpdGVtID0gcGF0aC5qb2luKGRpciwgaXRlbSlcbiAgICByZW1vdmUucmVtb3ZlU3luYyhpdGVtKVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZW1wdHlEaXJTeW5jLFxuICBlbXB0eWRpclN5bmM6IGVtcHR5RGlyU3luYyxcbiAgZW1wdHlEaXIsXG4gIGVtcHR5ZGlyOiBlbXB0eURpclxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tQ2FsbGJhY2tcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuY29uc3QgbWtkaXIgPSByZXF1aXJlKCcuLi9ta2RpcnMnKVxuXG5mdW5jdGlvbiBjcmVhdGVGaWxlIChmaWxlLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBtYWtlRmlsZSAoKSB7XG4gICAgZnMud3JpdGVGaWxlKGZpbGUsICcnLCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9KVxuICB9XG5cbiAgZnMuc3RhdChmaWxlLCAoZXJyLCBzdGF0cykgPT4geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGhhbmRsZS1jYWxsYmFjay1lcnJcbiAgICBpZiAoIWVyciAmJiBzdGF0cy5pc0ZpbGUoKSkgcmV0dXJuIGNhbGxiYWNrKClcbiAgICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZmlsZSlcbiAgICBmcy5zdGF0KGRpciwgKGVyciwgc3RhdHMpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgLy8gaWYgdGhlIGRpcmVjdG9yeSBkb2Vzbid0IGV4aXN0LCBtYWtlIGl0XG4gICAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgICByZXR1cm4gbWtkaXIubWtkaXJzKGRpciwgZXJyID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgICBtYWtlRmlsZSgpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdHMuaXNEaXJlY3RvcnkoKSkgbWFrZUZpbGUoKVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHBhcmVudCBpcyBub3QgYSBkaXJlY3RvcnlcbiAgICAgICAgLy8gVGhpcyBpcyBqdXN0IHRvIGNhdXNlIGFuIGludGVybmFsIEVOT1RESVIgZXJyb3IgdG8gYmUgdGhyb3duXG4gICAgICAgIGZzLnJlYWRkaXIoZGlyLCBlcnIgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmlsZVN5bmMgKGZpbGUpIHtcbiAgbGV0IHN0YXRzXG4gIHRyeSB7XG4gICAgc3RhdHMgPSBmcy5zdGF0U3luYyhmaWxlKVxuICB9IGNhdGNoIHt9XG4gIGlmIChzdGF0cyAmJiBzdGF0cy5pc0ZpbGUoKSkgcmV0dXJuXG5cbiAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGZpbGUpXG4gIHRyeSB7XG4gICAgaWYgKCFmcy5zdGF0U3luYyhkaXIpLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIC8vIHBhcmVudCBpcyBub3QgYSBkaXJlY3RvcnlcbiAgICAgIC8vIFRoaXMgaXMganVzdCB0byBjYXVzZSBhbiBpbnRlcm5hbCBFTk9URElSIGVycm9yIHRvIGJlIHRocm93blxuICAgICAgZnMucmVhZGRpclN5bmMoZGlyKVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gSWYgdGhlIHN0YXQgY2FsbCBhYm92ZSBmYWlsZWQgYmVjYXVzZSB0aGUgZGlyZWN0b3J5IGRvZXNuJ3QgZXhpc3QsIGNyZWF0ZSBpdFxuICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgPT09ICdFTk9FTlQnKSBta2Rpci5ta2RpcnNTeW5jKGRpcilcbiAgICBlbHNlIHRocm93IGVyclxuICB9XG5cbiAgZnMud3JpdGVGaWxlU3luYyhmaWxlLCAnJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZUZpbGU6IHUoY3JlYXRlRmlsZSksXG4gIGNyZWF0ZUZpbGVTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21DYWxsYmFja1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBta2RpciA9IHJlcXVpcmUoJy4uL21rZGlycycpXG5jb25zdCBwYXRoRXhpc3RzID0gcmVxdWlyZSgnLi4vcGF0aC1leGlzdHMnKS5wYXRoRXhpc3RzXG5jb25zdCB7IGFyZUlkZW50aWNhbCB9ID0gcmVxdWlyZSgnLi4vdXRpbC9zdGF0JylcblxuZnVuY3Rpb24gY3JlYXRlTGluayAoc3JjcGF0aCwgZHN0cGF0aCwgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gbWFrZUxpbmsgKHNyY3BhdGgsIGRzdHBhdGgpIHtcbiAgICBmcy5saW5rKHNyY3BhdGgsIGRzdHBhdGgsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgY2FsbGJhY2sobnVsbClcbiAgICB9KVxuICB9XG5cbiAgZnMubHN0YXQoZHN0cGF0aCwgKF8sIGRzdFN0YXQpID0+IHtcbiAgICBmcy5sc3RhdChzcmNwYXRoLCAoZXJyLCBzcmNTdGF0KSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGVyci5tZXNzYWdlID0gZXJyLm1lc3NhZ2UucmVwbGFjZSgnbHN0YXQnLCAnZW5zdXJlTGluaycpXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG4gICAgICBpZiAoZHN0U3RhdCAmJiBhcmVJZGVudGljYWwoc3JjU3RhdCwgZHN0U3RhdCkpIHJldHVybiBjYWxsYmFjayhudWxsKVxuXG4gICAgICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZHN0cGF0aClcbiAgICAgIHBhdGhFeGlzdHMoZGlyLCAoZXJyLCBkaXJFeGlzdHMpID0+IHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgaWYgKGRpckV4aXN0cykgcmV0dXJuIG1ha2VMaW5rKHNyY3BhdGgsIGRzdHBhdGgpXG4gICAgICAgIG1rZGlyLm1rZGlycyhkaXIsIGVyciA9PiB7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgICBtYWtlTGluayhzcmNwYXRoLCBkc3RwYXRoKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rU3luYyAoc3JjcGF0aCwgZHN0cGF0aCkge1xuICBsZXQgZHN0U3RhdFxuICB0cnkge1xuICAgIGRzdFN0YXQgPSBmcy5sc3RhdFN5bmMoZHN0cGF0aClcbiAgfSBjYXRjaCB7fVxuXG4gIHRyeSB7XG4gICAgY29uc3Qgc3JjU3RhdCA9IGZzLmxzdGF0U3luYyhzcmNwYXRoKVxuICAgIGlmIChkc3RTdGF0ICYmIGFyZUlkZW50aWNhbChzcmNTdGF0LCBkc3RTdGF0KSkgcmV0dXJuXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5tZXNzYWdlID0gZXJyLm1lc3NhZ2UucmVwbGFjZSgnbHN0YXQnLCAnZW5zdXJlTGluaycpXG4gICAgdGhyb3cgZXJyXG4gIH1cblxuICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZHN0cGF0aClcbiAgY29uc3QgZGlyRXhpc3RzID0gZnMuZXhpc3RzU3luYyhkaXIpXG4gIGlmIChkaXJFeGlzdHMpIHJldHVybiBmcy5saW5rU3luYyhzcmNwYXRoLCBkc3RwYXRoKVxuICBta2Rpci5ta2RpcnNTeW5jKGRpcilcblxuICByZXR1cm4gZnMubGlua1N5bmMoc3JjcGF0aCwgZHN0cGF0aClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZUxpbms6IHUoY3JlYXRlTGluayksXG4gIGNyZWF0ZUxpbmtTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBwYXRoRXhpc3RzID0gcmVxdWlyZSgnLi4vcGF0aC1leGlzdHMnKS5wYXRoRXhpc3RzXG5cbi8qKlxuICogRnVuY3Rpb24gdGhhdCByZXR1cm5zIHR3byB0eXBlcyBvZiBwYXRocywgb25lIHJlbGF0aXZlIHRvIHN5bWxpbmssIGFuZCBvbmVcbiAqIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5LiBDaGVja3MgaWYgcGF0aCBpcyBhYnNvbHV0ZSBvclxuICogcmVsYXRpdmUuIElmIHRoZSBwYXRoIGlzIHJlbGF0aXZlLCB0aGlzIGZ1bmN0aW9uIGNoZWNrcyBpZiB0aGUgcGF0aCBpc1xuICogcmVsYXRpdmUgdG8gc3ltbGluayBvciByZWxhdGl2ZSB0byBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5LiBUaGlzIGlzIGFuXG4gKiBpbml0aWF0aXZlIHRvIGZpbmQgYSBzbWFydGVyIGBzcmNwYXRoYCB0byBzdXBwbHkgd2hlbiBidWlsZGluZyBzeW1saW5rcy5cbiAqIFRoaXMgYWxsb3dzIHlvdSB0byBkZXRlcm1pbmUgd2hpY2ggcGF0aCB0byB1c2Ugb3V0IG9mIG9uZSBvZiB0aHJlZSBwb3NzaWJsZVxuICogdHlwZXMgb2Ygc291cmNlIHBhdGhzLiBUaGUgZmlyc3QgaXMgYW4gYWJzb2x1dGUgcGF0aC4gVGhpcyBpcyBkZXRlY3RlZCBieVxuICogYHBhdGguaXNBYnNvbHV0ZSgpYC4gV2hlbiBhbiBhYnNvbHV0ZSBwYXRoIGlzIHByb3ZpZGVkLCBpdCBpcyBjaGVja2VkIHRvXG4gKiBzZWUgaWYgaXQgZXhpc3RzLiBJZiBpdCBkb2VzIGl0J3MgdXNlZCwgaWYgbm90IGFuIGVycm9yIGlzIHJldHVybmVkXG4gKiAoY2FsbGJhY2spLyB0aHJvd24gKHN5bmMpLiBUaGUgb3RoZXIgdHdvIG9wdGlvbnMgZm9yIGBzcmNwYXRoYCBhcmUgYVxuICogcmVsYXRpdmUgdXJsLiBCeSBkZWZhdWx0IE5vZGUncyBgZnMuc3ltbGlua2Agd29ya3MgYnkgY3JlYXRpbmcgYSBzeW1saW5rXG4gKiB1c2luZyBgZHN0cGF0aGAgYW5kIGV4cGVjdHMgdGhlIGBzcmNwYXRoYCB0byBiZSByZWxhdGl2ZSB0byB0aGUgbmV3bHlcbiAqIGNyZWF0ZWQgc3ltbGluay4gSWYgeW91IHByb3ZpZGUgYSBgc3JjcGF0aGAgdGhhdCBkb2VzIG5vdCBleGlzdCBvbiB0aGUgZmlsZVxuICogc3lzdGVtIGl0IHJlc3VsdHMgaW4gYSBicm9rZW4gc3ltbGluay4gVG8gbWluaW1pemUgdGhpcywgdGhlIGZ1bmN0aW9uXG4gKiBjaGVja3MgdG8gc2VlIGlmIHRoZSAncmVsYXRpdmUgdG8gc3ltbGluaycgc291cmNlIGZpbGUgZXhpc3RzLCBhbmQgaWYgaXRcbiAqIGRvZXMgaXQgd2lsbCB1c2UgaXQuIElmIGl0IGRvZXMgbm90LCBpdCBjaGVja3MgaWYgdGhlcmUncyBhIGZpbGUgdGhhdFxuICogZXhpc3RzIHRoYXQgaXMgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnksIGlmIGRvZXMgaXRzIHVzZWQuXG4gKiBUaGlzIHByZXNlcnZlcyB0aGUgZXhwZWN0YXRpb25zIG9mIHRoZSBvcmlnaW5hbCBmcy5zeW1saW5rIHNwZWMgYW5kIGFkZHNcbiAqIHRoZSBhYmlsaXR5IHRvIHBhc3MgaW4gYHJlbGF0aXZlIHRvIGN1cnJlbnQgd29ya2luZyBkaXJlY290cnlgIHBhdGhzLlxuICovXG5cbmZ1bmN0aW9uIHN5bWxpbmtQYXRocyAoc3JjcGF0aCwgZHN0cGF0aCwgY2FsbGJhY2spIHtcbiAgaWYgKHBhdGguaXNBYnNvbHV0ZShzcmNwYXRoKSkge1xuICAgIHJldHVybiBmcy5sc3RhdChzcmNwYXRoLCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGVyci5tZXNzYWdlID0gZXJyLm1lc3NhZ2UucmVwbGFjZSgnbHN0YXQnLCAnZW5zdXJlU3ltbGluaycpXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwge1xuICAgICAgICB0b0N3ZDogc3JjcGF0aCxcbiAgICAgICAgdG9Ec3Q6IHNyY3BhdGhcbiAgICAgIH0pXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBkc3RkaXIgPSBwYXRoLmRpcm5hbWUoZHN0cGF0aClcbiAgICBjb25zdCByZWxhdGl2ZVRvRHN0ID0gcGF0aC5qb2luKGRzdGRpciwgc3JjcGF0aClcbiAgICByZXR1cm4gcGF0aEV4aXN0cyhyZWxhdGl2ZVRvRHN0LCAoZXJyLCBleGlzdHMpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICBpZiAoZXhpc3RzKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgICAgdG9Dd2Q6IHJlbGF0aXZlVG9Ec3QsXG4gICAgICAgICAgdG9Ec3Q6IHNyY3BhdGhcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmcy5sc3RhdChzcmNwYXRoLCAoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBlcnIubWVzc2FnZS5yZXBsYWNlKCdsc3RhdCcsICdlbnN1cmVTeW1saW5rJylcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgICAgICB0b0N3ZDogc3JjcGF0aCxcbiAgICAgICAgICAgIHRvRHN0OiBwYXRoLnJlbGF0aXZlKGRzdGRpciwgc3JjcGF0aClcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gc3ltbGlua1BhdGhzU3luYyAoc3JjcGF0aCwgZHN0cGF0aCkge1xuICBsZXQgZXhpc3RzXG4gIGlmIChwYXRoLmlzQWJzb2x1dGUoc3JjcGF0aCkpIHtcbiAgICBleGlzdHMgPSBmcy5leGlzdHNTeW5jKHNyY3BhdGgpXG4gICAgaWYgKCFleGlzdHMpIHRocm93IG5ldyBFcnJvcignYWJzb2x1dGUgc3JjcGF0aCBkb2VzIG5vdCBleGlzdCcpXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvQ3dkOiBzcmNwYXRoLFxuICAgICAgdG9Ec3Q6IHNyY3BhdGhcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZHN0ZGlyID0gcGF0aC5kaXJuYW1lKGRzdHBhdGgpXG4gICAgY29uc3QgcmVsYXRpdmVUb0RzdCA9IHBhdGguam9pbihkc3RkaXIsIHNyY3BhdGgpXG4gICAgZXhpc3RzID0gZnMuZXhpc3RzU3luYyhyZWxhdGl2ZVRvRHN0KVxuICAgIGlmIChleGlzdHMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvQ3dkOiByZWxhdGl2ZVRvRHN0LFxuICAgICAgICB0b0RzdDogc3JjcGF0aFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdHMgPSBmcy5leGlzdHNTeW5jKHNyY3BhdGgpXG4gICAgICBpZiAoIWV4aXN0cykgdGhyb3cgbmV3IEVycm9yKCdyZWxhdGl2ZSBzcmNwYXRoIGRvZXMgbm90IGV4aXN0JylcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvQ3dkOiBzcmNwYXRoLFxuICAgICAgICB0b0RzdDogcGF0aC5yZWxhdGl2ZShkc3RkaXIsIHNyY3BhdGgpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzeW1saW5rUGF0aHMsXG4gIHN5bWxpbmtQYXRoc1N5bmNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcblxuZnVuY3Rpb24gc3ltbGlua1R5cGUgKHNyY3BhdGgsIHR5cGUsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSA/IHR5cGUgOiBjYWxsYmFja1xuICB0eXBlID0gKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSA/IGZhbHNlIDogdHlwZVxuICBpZiAodHlwZSkgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHR5cGUpXG4gIGZzLmxzdGF0KHNyY3BhdGgsIChlcnIsIHN0YXRzKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKG51bGwsICdmaWxlJylcbiAgICB0eXBlID0gKHN0YXRzICYmIHN0YXRzLmlzRGlyZWN0b3J5KCkpID8gJ2RpcicgOiAnZmlsZSdcbiAgICBjYWxsYmFjayhudWxsLCB0eXBlKVxuICB9KVxufVxuXG5mdW5jdGlvbiBzeW1saW5rVHlwZVN5bmMgKHNyY3BhdGgsIHR5cGUpIHtcbiAgbGV0IHN0YXRzXG5cbiAgaWYgKHR5cGUpIHJldHVybiB0eXBlXG4gIHRyeSB7XG4gICAgc3RhdHMgPSBmcy5sc3RhdFN5bmMoc3JjcGF0aClcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICdmaWxlJ1xuICB9XG4gIHJldHVybiAoc3RhdHMgJiYgc3RhdHMuaXNEaXJlY3RvcnkoKSkgPyAnZGlyJyA6ICdmaWxlJ1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3ltbGlua1R5cGUsXG4gIHN5bWxpbmtUeXBlU3luY1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tQ2FsbGJhY2tcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IGZzID0gcmVxdWlyZSgnLi4vZnMnKVxuY29uc3QgX21rZGlycyA9IHJlcXVpcmUoJy4uL21rZGlycycpXG5jb25zdCBta2RpcnMgPSBfbWtkaXJzLm1rZGlyc1xuY29uc3QgbWtkaXJzU3luYyA9IF9ta2RpcnMubWtkaXJzU3luY1xuXG5jb25zdCBfc3ltbGlua1BhdGhzID0gcmVxdWlyZSgnLi9zeW1saW5rLXBhdGhzJylcbmNvbnN0IHN5bWxpbmtQYXRocyA9IF9zeW1saW5rUGF0aHMuc3ltbGlua1BhdGhzXG5jb25zdCBzeW1saW5rUGF0aHNTeW5jID0gX3N5bWxpbmtQYXRocy5zeW1saW5rUGF0aHNTeW5jXG5cbmNvbnN0IF9zeW1saW5rVHlwZSA9IHJlcXVpcmUoJy4vc3ltbGluay10eXBlJylcbmNvbnN0IHN5bWxpbmtUeXBlID0gX3N5bWxpbmtUeXBlLnN5bWxpbmtUeXBlXG5jb25zdCBzeW1saW5rVHlwZVN5bmMgPSBfc3ltbGlua1R5cGUuc3ltbGlua1R5cGVTeW5jXG5cbmNvbnN0IHBhdGhFeGlzdHMgPSByZXF1aXJlKCcuLi9wYXRoLWV4aXN0cycpLnBhdGhFeGlzdHNcblxuY29uc3QgeyBhcmVJZGVudGljYWwgfSA9IHJlcXVpcmUoJy4uL3V0aWwvc3RhdCcpXG5cbmZ1bmN0aW9uIGNyZWF0ZVN5bWxpbmsgKHNyY3BhdGgsIGRzdHBhdGgsIHR5cGUsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSA/IHR5cGUgOiBjYWxsYmFja1xuICB0eXBlID0gKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSA/IGZhbHNlIDogdHlwZVxuXG4gIGZzLmxzdGF0KGRzdHBhdGgsIChlcnIsIHN0YXRzKSA9PiB7XG4gICAgaWYgKCFlcnIgJiYgc3RhdHMuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICBmcy5zdGF0KHNyY3BhdGgpLFxuICAgICAgICBmcy5zdGF0KGRzdHBhdGgpXG4gICAgICBdKS50aGVuKChbc3JjU3RhdCwgZHN0U3RhdF0pID0+IHtcbiAgICAgICAgaWYgKGFyZUlkZW50aWNhbChzcmNTdGF0LCBkc3RTdGF0KSkgcmV0dXJuIGNhbGxiYWNrKG51bGwpXG4gICAgICAgIF9jcmVhdGVTeW1saW5rKHNyY3BhdGgsIGRzdHBhdGgsIHR5cGUsIGNhbGxiYWNrKVxuICAgICAgfSlcbiAgICB9IGVsc2UgX2NyZWF0ZVN5bWxpbmsoc3JjcGF0aCwgZHN0cGF0aCwgdHlwZSwgY2FsbGJhY2spXG4gIH0pXG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVTeW1saW5rIChzcmNwYXRoLCBkc3RwYXRoLCB0eXBlLCBjYWxsYmFjaykge1xuICBzeW1saW5rUGF0aHMoc3JjcGF0aCwgZHN0cGF0aCwgKGVyciwgcmVsYXRpdmUpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgIHNyY3BhdGggPSByZWxhdGl2ZS50b0RzdFxuICAgIHN5bWxpbmtUeXBlKHJlbGF0aXZlLnRvQ3dkLCB0eXBlLCAoZXJyLCB0eXBlKSA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGRzdHBhdGgpXG4gICAgICBwYXRoRXhpc3RzKGRpciwgKGVyciwgZGlyRXhpc3RzKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIGlmIChkaXJFeGlzdHMpIHJldHVybiBmcy5zeW1saW5rKHNyY3BhdGgsIGRzdHBhdGgsIHR5cGUsIGNhbGxiYWNrKVxuICAgICAgICBta2RpcnMoZGlyLCBlcnIgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgZnMuc3ltbGluayhzcmNwYXRoLCBkc3RwYXRoLCB0eXBlLCBjYWxsYmFjaylcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlU3ltbGlua1N5bmMgKHNyY3BhdGgsIGRzdHBhdGgsIHR5cGUpIHtcbiAgbGV0IHN0YXRzXG4gIHRyeSB7XG4gICAgc3RhdHMgPSBmcy5sc3RhdFN5bmMoZHN0cGF0aClcbiAgfSBjYXRjaCB7fVxuICBpZiAoc3RhdHMgJiYgc3RhdHMuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgIGNvbnN0IHNyY1N0YXQgPSBmcy5zdGF0U3luYyhzcmNwYXRoKVxuICAgIGNvbnN0IGRzdFN0YXQgPSBmcy5zdGF0U3luYyhkc3RwYXRoKVxuICAgIGlmIChhcmVJZGVudGljYWwoc3JjU3RhdCwgZHN0U3RhdCkpIHJldHVyblxuICB9XG5cbiAgY29uc3QgcmVsYXRpdmUgPSBzeW1saW5rUGF0aHNTeW5jKHNyY3BhdGgsIGRzdHBhdGgpXG4gIHNyY3BhdGggPSByZWxhdGl2ZS50b0RzdFxuICB0eXBlID0gc3ltbGlua1R5cGVTeW5jKHJlbGF0aXZlLnRvQ3dkLCB0eXBlKVxuICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZHN0cGF0aClcbiAgY29uc3QgZXhpc3RzID0gZnMuZXhpc3RzU3luYyhkaXIpXG4gIGlmIChleGlzdHMpIHJldHVybiBmcy5zeW1saW5rU3luYyhzcmNwYXRoLCBkc3RwYXRoLCB0eXBlKVxuICBta2RpcnNTeW5jKGRpcilcbiAgcmV0dXJuIGZzLnN5bWxpbmtTeW5jKHNyY3BhdGgsIGRzdHBhdGgsIHR5cGUpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGVTeW1saW5rOiB1KGNyZWF0ZVN5bWxpbmspLFxuICBjcmVhdGVTeW1saW5rU3luY1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZpbGUgPSByZXF1aXJlKCcuL2ZpbGUnKVxuY29uc3QgbGluayA9IHJlcXVpcmUoJy4vbGluaycpXG5jb25zdCBzeW1saW5rID0gcmVxdWlyZSgnLi9zeW1saW5rJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGZpbGVcbiAgY3JlYXRlRmlsZTogZmlsZS5jcmVhdGVGaWxlLFxuICBjcmVhdGVGaWxlU3luYzogZmlsZS5jcmVhdGVGaWxlU3luYyxcbiAgZW5zdXJlRmlsZTogZmlsZS5jcmVhdGVGaWxlLFxuICBlbnN1cmVGaWxlU3luYzogZmlsZS5jcmVhdGVGaWxlU3luYyxcbiAgLy8gbGlua1xuICBjcmVhdGVMaW5rOiBsaW5rLmNyZWF0ZUxpbmssXG4gIGNyZWF0ZUxpbmtTeW5jOiBsaW5rLmNyZWF0ZUxpbmtTeW5jLFxuICBlbnN1cmVMaW5rOiBsaW5rLmNyZWF0ZUxpbmssXG4gIGVuc3VyZUxpbmtTeW5jOiBsaW5rLmNyZWF0ZUxpbmtTeW5jLFxuICAvLyBzeW1saW5rXG4gIGNyZWF0ZVN5bWxpbms6IHN5bWxpbmsuY3JlYXRlU3ltbGluayxcbiAgY3JlYXRlU3ltbGlua1N5bmM6IHN5bWxpbmsuY3JlYXRlU3ltbGlua1N5bmMsXG4gIGVuc3VyZVN5bWxpbms6IHN5bWxpbmsuY3JlYXRlU3ltbGluayxcbiAgZW5zdXJlU3ltbGlua1N5bmM6IHN5bWxpbmsuY3JlYXRlU3ltbGlua1N5bmNcbn1cbiIsImZ1bmN0aW9uIHN0cmluZ2lmeSAob2JqLCB7IEVPTCA9ICdcXG4nLCBmaW5hbEVPTCA9IHRydWUsIHJlcGxhY2VyID0gbnVsbCwgc3BhY2VzIH0gPSB7fSkge1xuICBjb25zdCBFT0YgPSBmaW5hbEVPTCA/IEVPTCA6ICcnXG4gIGNvbnN0IHN0ciA9IEpTT04uc3RyaW5naWZ5KG9iaiwgcmVwbGFjZXIsIHNwYWNlcylcblxuICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcbi9nLCBFT0wpICsgRU9GXG59XG5cbmZ1bmN0aW9uIHN0cmlwQm9tIChjb250ZW50KSB7XG4gIC8vIHdlIGRvIHRoaXMgYmVjYXVzZSBKU09OLnBhcnNlIHdvdWxkIGNvbnZlcnQgaXQgdG8gYSB1dGY4IHN0cmluZyBpZiBlbmNvZGluZyB3YXNuJ3Qgc3BlY2lmaWVkXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoY29udGVudCkpIGNvbnRlbnQgPSBjb250ZW50LnRvU3RyaW5nKCd1dGY4JylcbiAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZSgvXlxcdUZFRkYvLCAnJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IHN0cmluZ2lmeSwgc3RyaXBCb20gfVxuIiwibGV0IF9mc1xudHJ5IHtcbiAgX2ZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxufSBjYXRjaCAoXykge1xuICBfZnMgPSByZXF1aXJlKCdmcycpXG59XG5jb25zdCB1bml2ZXJzYWxpZnkgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKVxuY29uc3QgeyBzdHJpbmdpZnksIHN0cmlwQm9tIH0gPSByZXF1aXJlKCcuL3V0aWxzJylcblxuYXN5bmMgZnVuY3Rpb24gX3JlYWRGaWxlIChmaWxlLCBvcHRpb25zID0ge30pIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSB7IGVuY29kaW5nOiBvcHRpb25zIH1cbiAgfVxuXG4gIGNvbnN0IGZzID0gb3B0aW9ucy5mcyB8fCBfZnNcblxuICBjb25zdCBzaG91bGRUaHJvdyA9ICd0aHJvd3MnIGluIG9wdGlvbnMgPyBvcHRpb25zLnRocm93cyA6IHRydWVcblxuICBsZXQgZGF0YSA9IGF3YWl0IHVuaXZlcnNhbGlmeS5mcm9tQ2FsbGJhY2soZnMucmVhZEZpbGUpKGZpbGUsIG9wdGlvbnMpXG5cbiAgZGF0YSA9IHN0cmlwQm9tKGRhdGEpXG5cbiAgbGV0IG9ialxuICB0cnkge1xuICAgIG9iaiA9IEpTT04ucGFyc2UoZGF0YSwgb3B0aW9ucyA/IG9wdGlvbnMucmV2aXZlciA6IG51bGwpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChzaG91bGRUaHJvdykge1xuICAgICAgZXJyLm1lc3NhZ2UgPSBgJHtmaWxlfTogJHtlcnIubWVzc2FnZX1gXG4gICAgICB0aHJvdyBlcnJcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqXG59XG5cbmNvbnN0IHJlYWRGaWxlID0gdW5pdmVyc2FsaWZ5LmZyb21Qcm9taXNlKF9yZWFkRmlsZSlcblxuZnVuY3Rpb24gcmVhZEZpbGVTeW5jIChmaWxlLCBvcHRpb25zID0ge30pIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSB7IGVuY29kaW5nOiBvcHRpb25zIH1cbiAgfVxuXG4gIGNvbnN0IGZzID0gb3B0aW9ucy5mcyB8fCBfZnNcblxuICBjb25zdCBzaG91bGRUaHJvdyA9ICd0aHJvd3MnIGluIG9wdGlvbnMgPyBvcHRpb25zLnRocm93cyA6IHRydWVcblxuICB0cnkge1xuICAgIGxldCBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKGZpbGUsIG9wdGlvbnMpXG4gICAgY29udGVudCA9IHN0cmlwQm9tKGNvbnRlbnQpXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoY29udGVudCwgb3B0aW9ucy5yZXZpdmVyKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoc2hvdWxkVGhyb3cpIHtcbiAgICAgIGVyci5tZXNzYWdlID0gYCR7ZmlsZX06ICR7ZXJyLm1lc3NhZ2V9YFxuICAgICAgdGhyb3cgZXJyXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIF93cml0ZUZpbGUgKGZpbGUsIG9iaiwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGZzID0gb3B0aW9ucy5mcyB8fCBfZnNcblxuICBjb25zdCBzdHIgPSBzdHJpbmdpZnkob2JqLCBvcHRpb25zKVxuXG4gIGF3YWl0IHVuaXZlcnNhbGlmeS5mcm9tQ2FsbGJhY2soZnMud3JpdGVGaWxlKShmaWxlLCBzdHIsIG9wdGlvbnMpXG59XG5cbmNvbnN0IHdyaXRlRmlsZSA9IHVuaXZlcnNhbGlmeS5mcm9tUHJvbWlzZShfd3JpdGVGaWxlKVxuXG5mdW5jdGlvbiB3cml0ZUZpbGVTeW5jIChmaWxlLCBvYmosIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBmcyA9IG9wdGlvbnMuZnMgfHwgX2ZzXG5cbiAgY29uc3Qgc3RyID0gc3RyaW5naWZ5KG9iaiwgb3B0aW9ucylcbiAgLy8gbm90IHN1cmUgaWYgZnMud3JpdGVGaWxlU3luYyByZXR1cm5zIGFueXRoaW5nLCBidXQganVzdCBpbiBjYXNlXG4gIHJldHVybiBmcy53cml0ZUZpbGVTeW5jKGZpbGUsIHN0ciwgb3B0aW9ucylcbn1cblxuY29uc3QganNvbmZpbGUgPSB7XG4gIHJlYWRGaWxlLFxuICByZWFkRmlsZVN5bmMsXG4gIHdyaXRlRmlsZSxcbiAgd3JpdGVGaWxlU3luY1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGpzb25maWxlXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QganNvbkZpbGUgPSByZXF1aXJlKCdqc29uZmlsZScpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBqc29uZmlsZSBleHBvcnRzXG4gIHJlYWRKc29uOiBqc29uRmlsZS5yZWFkRmlsZSxcbiAgcmVhZEpzb25TeW5jOiBqc29uRmlsZS5yZWFkRmlsZVN5bmMsXG4gIHdyaXRlSnNvbjoganNvbkZpbGUud3JpdGVGaWxlLFxuICB3cml0ZUpzb25TeW5jOiBqc29uRmlsZS53cml0ZUZpbGVTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21DYWxsYmFja1xuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBta2RpciA9IHJlcXVpcmUoJy4uL21rZGlycycpXG5jb25zdCBwYXRoRXhpc3RzID0gcmVxdWlyZSgnLi4vcGF0aC1leGlzdHMnKS5wYXRoRXhpc3RzXG5cbmZ1bmN0aW9uIG91dHB1dEZpbGUgKGZpbGUsIGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZmlsZSlcbiAgcGF0aEV4aXN0cyhkaXIsIChlcnIsIGl0RG9lcykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgaWYgKGl0RG9lcykgcmV0dXJuIGZzLndyaXRlRmlsZShmaWxlLCBkYXRhLCBlbmNvZGluZywgY2FsbGJhY2spXG5cbiAgICBta2Rpci5ta2RpcnMoZGlyLCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcblxuICAgICAgZnMud3JpdGVGaWxlKGZpbGUsIGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjaylcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBvdXRwdXRGaWxlU3luYyAoZmlsZSwgLi4uYXJncykge1xuICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZmlsZSlcbiAgaWYgKGZzLmV4aXN0c1N5bmMoZGlyKSkge1xuICAgIHJldHVybiBmcy53cml0ZUZpbGVTeW5jKGZpbGUsIC4uLmFyZ3MpXG4gIH1cbiAgbWtkaXIubWtkaXJzU3luYyhkaXIpXG4gIGZzLndyaXRlRmlsZVN5bmMoZmlsZSwgLi4uYXJncylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG91dHB1dEZpbGU6IHUob3V0cHV0RmlsZSksXG4gIG91dHB1dEZpbGVTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBzdHJpbmdpZnkgfSA9IHJlcXVpcmUoJ2pzb25maWxlL3V0aWxzJylcbmNvbnN0IHsgb3V0cHV0RmlsZSB9ID0gcmVxdWlyZSgnLi4vb3V0cHV0JylcblxuYXN5bmMgZnVuY3Rpb24gb3V0cHV0SnNvbiAoZmlsZSwgZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHN0ciA9IHN0cmluZ2lmeShkYXRhLCBvcHRpb25zKVxuXG4gIGF3YWl0IG91dHB1dEZpbGUoZmlsZSwgc3RyLCBvcHRpb25zKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG91dHB1dEpzb25cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHN0cmluZ2lmeSB9ID0gcmVxdWlyZSgnanNvbmZpbGUvdXRpbHMnKVxuY29uc3QgeyBvdXRwdXRGaWxlU3luYyB9ID0gcmVxdWlyZSgnLi4vb3V0cHV0JylcblxuZnVuY3Rpb24gb3V0cHV0SnNvblN5bmMgKGZpbGUsIGRhdGEsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc3RyID0gc3RyaW5naWZ5KGRhdGEsIG9wdGlvbnMpXG5cbiAgb3V0cHV0RmlsZVN5bmMoZmlsZSwgc3RyLCBvcHRpb25zKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG91dHB1dEpzb25TeW5jXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21Qcm9taXNlXG5jb25zdCBqc29uRmlsZSA9IHJlcXVpcmUoJy4vanNvbmZpbGUnKVxuXG5qc29uRmlsZS5vdXRwdXRKc29uID0gdShyZXF1aXJlKCcuL291dHB1dC1qc29uJykpXG5qc29uRmlsZS5vdXRwdXRKc29uU3luYyA9IHJlcXVpcmUoJy4vb3V0cHV0LWpzb24tc3luYycpXG4vLyBhbGlhc2VzXG5qc29uRmlsZS5vdXRwdXRKU09OID0ganNvbkZpbGUub3V0cHV0SnNvblxuanNvbkZpbGUub3V0cHV0SlNPTlN5bmMgPSBqc29uRmlsZS5vdXRwdXRKc29uU3luY1xuanNvbkZpbGUud3JpdGVKU09OID0ganNvbkZpbGUud3JpdGVKc29uXG5qc29uRmlsZS53cml0ZUpTT05TeW5jID0ganNvbkZpbGUud3JpdGVKc29uU3luY1xuanNvbkZpbGUucmVhZEpTT04gPSBqc29uRmlsZS5yZWFkSnNvblxuanNvbkZpbGUucmVhZEpTT05TeW5jID0ganNvbkZpbGUucmVhZEpzb25TeW5jXG5cbm1vZHVsZS5leHBvcnRzID0ganNvbkZpbGVcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IGNvcHlTeW5jID0gcmVxdWlyZSgnLi4vY29weS1zeW5jJykuY29weVN5bmNcbmNvbnN0IHJlbW92ZVN5bmMgPSByZXF1aXJlKCcuLi9yZW1vdmUnKS5yZW1vdmVTeW5jXG5jb25zdCBta2RpcnBTeW5jID0gcmVxdWlyZSgnLi4vbWtkaXJzJykubWtkaXJwU3luY1xuY29uc3Qgc3RhdCA9IHJlcXVpcmUoJy4uL3V0aWwvc3RhdCcpXG5cbmZ1bmN0aW9uIG1vdmVTeW5jIChzcmMsIGRlc3QsIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge31cbiAgY29uc3Qgb3ZlcndyaXRlID0gb3B0cy5vdmVyd3JpdGUgfHwgb3B0cy5jbG9iYmVyIHx8IGZhbHNlXG5cbiAgY29uc3QgeyBzcmNTdGF0LCBpc0NoYW5naW5nQ2FzZSA9IGZhbHNlIH0gPSBzdGF0LmNoZWNrUGF0aHNTeW5jKHNyYywgZGVzdCwgJ21vdmUnLCBvcHRzKVxuICBzdGF0LmNoZWNrUGFyZW50UGF0aHNTeW5jKHNyYywgc3JjU3RhdCwgZGVzdCwgJ21vdmUnKVxuICBpZiAoIWlzUGFyZW50Um9vdChkZXN0KSkgbWtkaXJwU3luYyhwYXRoLmRpcm5hbWUoZGVzdCkpXG4gIHJldHVybiBkb1JlbmFtZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSwgaXNDaGFuZ2luZ0Nhc2UpXG59XG5cbmZ1bmN0aW9uIGlzUGFyZW50Um9vdCAoZGVzdCkge1xuICBjb25zdCBwYXJlbnQgPSBwYXRoLmRpcm5hbWUoZGVzdClcbiAgY29uc3QgcGFyc2VkUGF0aCA9IHBhdGgucGFyc2UocGFyZW50KVxuICByZXR1cm4gcGFyc2VkUGF0aC5yb290ID09PSBwYXJlbnRcbn1cblxuZnVuY3Rpb24gZG9SZW5hbWUgKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBpc0NoYW5naW5nQ2FzZSkge1xuICBpZiAoaXNDaGFuZ2luZ0Nhc2UpIHJldHVybiByZW5hbWUoc3JjLCBkZXN0LCBvdmVyd3JpdGUpXG4gIGlmIChvdmVyd3JpdGUpIHtcbiAgICByZW1vdmVTeW5jKGRlc3QpXG4gICAgcmV0dXJuIHJlbmFtZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSlcbiAgfVxuICBpZiAoZnMuZXhpc3RzU3luYyhkZXN0KSkgdGhyb3cgbmV3IEVycm9yKCdkZXN0IGFscmVhZHkgZXhpc3RzLicpXG4gIHJldHVybiByZW5hbWUoc3JjLCBkZXN0LCBvdmVyd3JpdGUpXG59XG5cbmZ1bmN0aW9uIHJlbmFtZSAoc3JjLCBkZXN0LCBvdmVyd3JpdGUpIHtcbiAgdHJ5IHtcbiAgICBmcy5yZW5hbWVTeW5jKHNyYywgZGVzdClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyci5jb2RlICE9PSAnRVhERVYnKSB0aHJvdyBlcnJcbiAgICByZXR1cm4gbW92ZUFjcm9zc0RldmljZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBtb3ZlQWNyb3NzRGV2aWNlIChzcmMsIGRlc3QsIG92ZXJ3cml0ZSkge1xuICBjb25zdCBvcHRzID0ge1xuICAgIG92ZXJ3cml0ZSxcbiAgICBlcnJvck9uRXhpc3Q6IHRydWVcbiAgfVxuICBjb3B5U3luYyhzcmMsIGRlc3QsIG9wdHMpXG4gIHJldHVybiByZW1vdmVTeW5jKHNyYylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtb3ZlU3luY1xuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBtb3ZlU3luYzogcmVxdWlyZSgnLi9tb3ZlLXN5bmMnKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgY29weSA9IHJlcXVpcmUoJy4uL2NvcHknKS5jb3B5XG5jb25zdCByZW1vdmUgPSByZXF1aXJlKCcuLi9yZW1vdmUnKS5yZW1vdmVcbmNvbnN0IG1rZGlycCA9IHJlcXVpcmUoJy4uL21rZGlycycpLm1rZGlycFxuY29uc3QgcGF0aEV4aXN0cyA9IHJlcXVpcmUoJy4uL3BhdGgtZXhpc3RzJykucGF0aEV4aXN0c1xuY29uc3Qgc3RhdCA9IHJlcXVpcmUoJy4uL3V0aWwvc3RhdCcpXG5cbmZ1bmN0aW9uIG1vdmUgKHNyYywgZGVzdCwgb3B0cywgY2IpIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBvcHRzXG4gICAgb3B0cyA9IHt9XG4gIH1cblxuICBjb25zdCBvdmVyd3JpdGUgPSBvcHRzLm92ZXJ3cml0ZSB8fCBvcHRzLmNsb2JiZXIgfHwgZmFsc2VcblxuICBzdGF0LmNoZWNrUGF0aHMoc3JjLCBkZXN0LCAnbW92ZScsIG9wdHMsIChlcnIsIHN0YXRzKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBjb25zdCB7IHNyY1N0YXQsIGlzQ2hhbmdpbmdDYXNlID0gZmFsc2UgfSA9IHN0YXRzXG4gICAgc3RhdC5jaGVja1BhcmVudFBhdGhzKHNyYywgc3JjU3RhdCwgZGVzdCwgJ21vdmUnLCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIGlmIChpc1BhcmVudFJvb3QoZGVzdCkpIHJldHVybiBkb1JlbmFtZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSwgaXNDaGFuZ2luZ0Nhc2UsIGNiKVxuICAgICAgbWtkaXJwKHBhdGguZGlybmFtZShkZXN0KSwgZXJyID0+IHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgICAgcmV0dXJuIGRvUmVuYW1lKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBpc0NoYW5naW5nQ2FzZSwgY2IpXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGlzUGFyZW50Um9vdCAoZGVzdCkge1xuICBjb25zdCBwYXJlbnQgPSBwYXRoLmRpcm5hbWUoZGVzdClcbiAgY29uc3QgcGFyc2VkUGF0aCA9IHBhdGgucGFyc2UocGFyZW50KVxuICByZXR1cm4gcGFyc2VkUGF0aC5yb290ID09PSBwYXJlbnRcbn1cblxuZnVuY3Rpb24gZG9SZW5hbWUgKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBpc0NoYW5naW5nQ2FzZSwgY2IpIHtcbiAgaWYgKGlzQ2hhbmdpbmdDYXNlKSByZXR1cm4gcmVuYW1lKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBjYilcbiAgaWYgKG92ZXJ3cml0ZSkge1xuICAgIHJldHVybiByZW1vdmUoZGVzdCwgZXJyID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICByZXR1cm4gcmVuYW1lKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBjYilcbiAgICB9KVxuICB9XG4gIHBhdGhFeGlzdHMoZGVzdCwgKGVyciwgZGVzdEV4aXN0cykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgaWYgKGRlc3RFeGlzdHMpIHJldHVybiBjYihuZXcgRXJyb3IoJ2Rlc3QgYWxyZWFkeSBleGlzdHMuJykpXG4gICAgcmV0dXJuIHJlbmFtZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSwgY2IpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHJlbmFtZSAoc3JjLCBkZXN0LCBvdmVyd3JpdGUsIGNiKSB7XG4gIGZzLnJlbmFtZShzcmMsIGRlc3QsIGVyciA9PiB7XG4gICAgaWYgKCFlcnIpIHJldHVybiBjYigpXG4gICAgaWYgKGVyci5jb2RlICE9PSAnRVhERVYnKSByZXR1cm4gY2IoZXJyKVxuICAgIHJldHVybiBtb3ZlQWNyb3NzRGV2aWNlKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBjYilcbiAgfSlcbn1cblxuZnVuY3Rpb24gbW92ZUFjcm9zc0RldmljZSAoc3JjLCBkZXN0LCBvdmVyd3JpdGUsIGNiKSB7XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgb3ZlcndyaXRlLFxuICAgIGVycm9yT25FeGlzdDogdHJ1ZVxuICB9XG4gIGNvcHkoc3JjLCBkZXN0LCBvcHRzLCBlcnIgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgcmV0dXJuIHJlbW92ZShzcmMsIGNiKVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1vdmVcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbW92ZTogdShyZXF1aXJlKCcuL21vdmUnKSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gRXhwb3J0IHByb21pc2VpZmllZCBncmFjZWZ1bC1mczpcbiAgLi4ucmVxdWlyZSgnLi9mcycpLFxuICAvLyBFeHBvcnQgZXh0cmEgbWV0aG9kczpcbiAgLi4ucmVxdWlyZSgnLi9jb3B5LXN5bmMnKSxcbiAgLi4ucmVxdWlyZSgnLi9jb3B5JyksXG4gIC4uLnJlcXVpcmUoJy4vZW1wdHknKSxcbiAgLi4ucmVxdWlyZSgnLi9lbnN1cmUnKSxcbiAgLi4ucmVxdWlyZSgnLi9qc29uJyksXG4gIC4uLnJlcXVpcmUoJy4vbWtkaXJzJyksXG4gIC4uLnJlcXVpcmUoJy4vbW92ZS1zeW5jJyksXG4gIC4uLnJlcXVpcmUoJy4vbW92ZScpLFxuICAuLi5yZXF1aXJlKCcuL291dHB1dCcpLFxuICAuLi5yZXF1aXJlKCcuL3BhdGgtZXhpc3RzJyksXG4gIC4uLnJlcXVpcmUoJy4vcmVtb3ZlJylcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DYW5jZWxsYXRpb25FcnJvciA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW4gPSB2b2lkIDA7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jbGFzcyBDYW5jZWxsYXRpb25Ub2tlbiBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgLy8gYmFiZWwgY2Fubm90IGNvbXBpbGUgLi4uIGNvcnJlY3RseSBmb3Igc3VwZXIgY2FsbHNcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wYXJlbnRDYW5jZWxIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGNhbmNlbGxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbmNlbGxlZCB8fCAodGhpcy5fcGFyZW50ICE9IG51bGwgJiYgdGhpcy5fcGFyZW50LmNhbmNlbGxlZCk7XG4gICAgfVxuICAgIHNldCBwYXJlbnQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVQYXJlbnRDYW5jZWxIYW5kbGVyKCk7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IHZhbHVlO1xuICAgICAgICB0aGlzLnBhcmVudENhbmNlbEhhbmRsZXIgPSAoKSA9PiB0aGlzLmNhbmNlbCgpO1xuICAgICAgICB0aGlzLl9wYXJlbnQub25DYW5jZWwodGhpcy5wYXJlbnRDYW5jZWxIYW5kbGVyKTtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICB0aGlzLl9jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXQoXCJjYW5jZWxcIik7XG4gICAgfVxuICAgIG9uQ2FuY2VsKGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBoYW5kbGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9uY2UoXCJjYW5jZWxcIiwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlUHJvbWlzZShjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgQ2FuY2VsbGF0aW9uRXJyb3IoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmluYWxseUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2FuY2VsSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihcImNhbmNlbFwiLCBjYW5jZWxIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsSGFuZGxlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChpZ25vcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgY2FuY2VsSGFuZGxlciA9IG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgYWRkZWRDYW5jZWxIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgICAgIGNhbmNlbEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZGVkQ2FuY2VsSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRlZENhbmNlbEhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZGVkQ2FuY2VsSGFuZGxlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgQ2FuY2VsbGF0aW9uRXJyb3IoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgIGNhbmNlbEhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9uQ2FuY2VsKGNhbmNlbEhhbmRsZXIpO1xuICAgICAgICAgICAgY2FsbGJhY2socmVzb2x2ZSwgcmVqZWN0LCAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICBhZGRlZENhbmNlbEhhbmRsZXIgPSBjYWxsYmFjaztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oaXQgPT4ge1xuICAgICAgICAgICAgZmluYWxseUhhbmRsZXIoKTtcbiAgICAgICAgICAgIHJldHVybiBpdDtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChlID0+IHtcbiAgICAgICAgICAgIGZpbmFsbHlIYW5kbGVyKCk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVtb3ZlUGFyZW50Q2FuY2VsSGFuZGxlcigpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuICAgICAgICBpZiAocGFyZW50ICE9IG51bGwgJiYgdGhpcy5wYXJlbnRDYW5jZWxIYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHBhcmVudC5yZW1vdmVMaXN0ZW5lcihcImNhbmNlbFwiLCB0aGlzLnBhcmVudENhbmNlbEhhbmRsZXIpO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRDYW5jZWxIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVQYXJlbnRDYW5jZWxIYW5kbGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW4gPSBDYW5jZWxsYXRpb25Ub2tlbjtcbmNsYXNzIENhbmNlbGxhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcImNhbmNlbGxlZFwiKTtcbiAgICB9XG59XG5leHBvcnRzLkNhbmNlbGxhdGlvbkVycm9yID0gQ2FuY2VsbGF0aW9uRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYW5jZWxsYXRpb25Ub2tlbi5qcy5tYXAiLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsKSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oLT8oPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHdlZWtzP3x3fHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICd3ZWVrcyc6XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgY2FzZSAndyc6XG4gICAgICByZXR1cm4gbiAqIHc7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGQsICdkYXknKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBoLCAnaG91cicpO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIG0sICdtaW51dGUnKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBzLCAnc2Vjb25kJyk7XG4gIH1cbiAgcmV0dXJuIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBtc0FicywgbiwgbmFtZSkge1xuICB2YXIgaXNQbHVyYWwgPSBtc0FicyA+PSBuICogMS41O1xuICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG4pICsgJyAnICsgbmFtZSArIChpc1BsdXJhbCA/ICdzJyA6ICcnKTtcbn1cbiIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICovXG5cbmZ1bmN0aW9uIHNldHVwKGVudikge1xuXHRjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5kZWZhdWx0ID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmNvZXJjZSA9IGNvZXJjZTtcblx0Y3JlYXRlRGVidWcuZGlzYWJsZSA9IGRpc2FibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZSA9IGVuYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlZCA9IGVuYWJsZWQ7XG5cdGNyZWF0ZURlYnVnLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblx0Y3JlYXRlRGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG5cblx0T2JqZWN0LmtleXMoZW52KS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0Y3JlYXRlRGVidWdba2V5XSA9IGVudltrZXldO1xuXHR9KTtcblxuXHQvKipcblx0KiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cblx0Ki9cblxuXHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdC8qKlxuXHQqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cblx0KlxuXHQqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cblx0Ki9cblx0Y3JlYXRlRGVidWcuZm9ybWF0dGVycyA9IHt9O1xuXG5cdC8qKlxuXHQqIFNlbGVjdHMgYSBjb2xvciBmb3IgYSBkZWJ1ZyBuYW1lc3BhY2Vcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIFRoZSBuYW1lc3BhY2Ugc3RyaW5nIGZvciB0aGUgZm9yIHRoZSBkZWJ1ZyBpbnN0YW5jZSB0byBiZSBjb2xvcmVkXG5cdCogQHJldHVybiB7TnVtYmVyfFN0cmluZ30gQW4gQU5TSSBjb2xvciBjb2RlIGZvciB0aGUgZ2l2ZW4gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuXHRcdGxldCBoYXNoID0gMDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcblx0XHRcdGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNyZWF0ZURlYnVnLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGNyZWF0ZURlYnVnLmNvbG9ycy5sZW5ndGhdO1xuXHR9XG5cdGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yID0gc2VsZWN0Q29sb3I7XG5cblx0LyoqXG5cdCogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQHJldHVybiB7RnVuY3Rpb259XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cdFx0bGV0IHByZXZUaW1lO1xuXHRcdGxldCBlbmFibGVPdmVycmlkZSA9IG51bGw7XG5cdFx0bGV0IG5hbWVzcGFjZXNDYWNoZTtcblx0XHRsZXQgZW5hYmxlZENhY2hlO1xuXG5cdFx0ZnVuY3Rpb24gZGVidWcoLi4uYXJncykge1xuXHRcdFx0Ly8gRGlzYWJsZWQ/XG5cdFx0XHRpZiAoIWRlYnVnLmVuYWJsZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzZWxmID0gZGVidWc7XG5cblx0XHRcdC8vIFNldCBgZGlmZmAgdGltZXN0YW1wXG5cdFx0XHRjb25zdCBjdXJyID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xuXHRcdFx0Y29uc3QgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuXHRcdFx0c2VsZi5kaWZmID0gbXM7XG5cdFx0XHRzZWxmLnByZXYgPSBwcmV2VGltZTtcblx0XHRcdHNlbGYuY3VyciA9IGN1cnI7XG5cdFx0XHRwcmV2VGltZSA9IGN1cnI7XG5cblx0XHRcdGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XG5cblx0XHRcdGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0Ly8gQW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cblx0XHRcdFx0YXJncy51bnNoaWZ0KCclTycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXHRcdFx0bGV0IGluZGV4ID0gMDtcblx0XHRcdGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCAobWF0Y2gsIGZvcm1hdCkgPT4ge1xuXHRcdFx0XHQvLyBJZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG5cdFx0XHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0XHRcdHJldHVybiAnJSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0Y29uc3QgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXHRcdFx0XHRpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdGNvbnN0IHZhbCA9IGFyZ3NbaW5kZXhdO1xuXHRcdFx0XHRcdG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuXHRcdFx0XHRcdC8vIE5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcblx0XHRcdFx0XHRhcmdzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcblx0XHRcdGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuXHRcdFx0Y29uc3QgbG9nRm4gPSBzZWxmLmxvZyB8fCBjcmVhdGVEZWJ1Zy5sb2c7XG5cdFx0XHRsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcblx0XHR9XG5cblx0XHRkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cdFx0ZGVidWcudXNlQ29sb3JzID0gY3JlYXRlRGVidWcudXNlQ29sb3JzKCk7XG5cdFx0ZGVidWcuY29sb3IgPSBjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXHRcdGRlYnVnLmV4dGVuZCA9IGV4dGVuZDtcblx0XHRkZWJ1Zy5kZXN0cm95ID0gY3JlYXRlRGVidWcuZGVzdHJveTsgLy8gWFhYIFRlbXBvcmFyeS4gV2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVidWcsICdlbmFibGVkJywge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cdFx0XHRnZXQ6ICgpID0+IHtcblx0XHRcdFx0aWYgKGVuYWJsZU92ZXJyaWRlICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVuYWJsZU92ZXJyaWRlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChuYW1lc3BhY2VzQ2FjaGUgIT09IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMpIHtcblx0XHRcdFx0XHRuYW1lc3BhY2VzQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzO1xuXHRcdFx0XHRcdGVuYWJsZWRDYWNoZSA9IGNyZWF0ZURlYnVnLmVuYWJsZWQobmFtZXNwYWNlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbmFibGVkQ2FjaGU7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiB2ID0+IHtcblx0XHRcdFx0ZW5hYmxlT3ZlcnJpZGUgPSB2O1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gRW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcblx0XHRpZiAodHlwZW9mIGNyZWF0ZURlYnVnLmluaXQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNyZWF0ZURlYnVnLmluaXQoZGVidWcpO1xuXHRcdH1cblxuXHRcdHJldHVybiBkZWJ1Zztcblx0fVxuXG5cdGZ1bmN0aW9uIGV4dGVuZChuYW1lc3BhY2UsIGRlbGltaXRlcikge1xuXHRcdGNvbnN0IG5ld0RlYnVnID0gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnOicgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcblx0XHRuZXdEZWJ1Zy5sb2cgPSB0aGlzLmxvZztcblx0XHRyZXR1cm4gbmV3RGVidWc7XG5cdH1cblxuXHQvKipcblx0KiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG5cdCogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcblx0XHRjcmVhdGVEZWJ1Zy5zYXZlKG5hbWVzcGFjZXMpO1xuXHRcdGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMgPSBuYW1lc3BhY2VzO1xuXG5cdFx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0XHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdFx0bGV0IGk7XG5cdFx0Y29uc3Qgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuXHRcdGNvbnN0IGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKCFzcGxpdFtpXSkge1xuXHRcdFx0XHQvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0bmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG5cblx0XHRcdGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuXHQqXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0XHRjb25zdCBuYW1lc3BhY2VzID0gW1xuXHRcdFx0Li4uY3JlYXRlRGVidWcubmFtZXMubWFwKHRvTmFtZXNwYWNlKSxcblx0XHRcdC4uLmNyZWF0ZURlYnVnLnNraXBzLm1hcCh0b05hbWVzcGFjZSkubWFwKG5hbWVzcGFjZSA9PiAnLScgKyBuYW1lc3BhY2UpXG5cdFx0XS5qb2luKCcsJyk7XG5cdFx0Y3JlYXRlRGVidWcuZW5hYmxlKCcnKTtcblx0XHRyZXR1cm4gbmFtZXNwYWNlcztcblx0fVxuXG5cdC8qKlxuXHQqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdCogQHJldHVybiB7Qm9vbGVhbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcblx0XHRpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGxldCBpO1xuXHRcdGxldCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0KiBDb252ZXJ0IHJlZ2V4cCB0byBuYW1lc3BhY2Vcblx0KlxuXHQqIEBwYXJhbSB7UmVnRXhwfSByZWd4ZXBcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiB0b05hbWVzcGFjZShyZWdleHApIHtcblx0XHRyZXR1cm4gcmVnZXhwLnRvU3RyaW5nKClcblx0XHRcdC5zdWJzdHJpbmcoMiwgcmVnZXhwLnRvU3RyaW5nKCkubGVuZ3RoIC0gMilcblx0XHRcdC5yZXBsYWNlKC9cXC5cXCpcXD8kLywgJyonKTtcblx0fVxuXG5cdC8qKlxuXHQqIENvZXJjZSBgdmFsYC5cblx0KlxuXHQqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuXHQqIEByZXR1cm4ge01peGVkfVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG5cdFx0aWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0XHRyZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG5cblx0LyoqXG5cdCogWFhYIERPIE5PVCBVU0UuIFRoaXMgaXMgYSB0ZW1wb3Jhcnkgc3R1YiBmdW5jdGlvbi5cblx0KiBYWFggSXQgV0lMTCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cdCovXG5cdGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdH1cblxuXHRjcmVhdGVEZWJ1Zy5lbmFibGUoY3JlYXRlRGVidWcubG9hZCgpKTtcblxuXHRyZXR1cm4gY3JlYXRlRGVidWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0dXA7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSBsb2NhbHN0b3JhZ2UoKTtcbmV4cG9ydHMuZGVzdHJveSA9ICgoKSA9PiB7XG5cdGxldCB3YXJuZWQgPSBmYWxzZTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlmICghd2FybmVkKSB7XG5cdFx0XHR3YXJuZWQgPSB0cnVlO1xuXHRcdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdFx0fVxuXHR9O1xufSkoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG5cdCcjMDAwMENDJyxcblx0JyMwMDAwRkYnLFxuXHQnIzAwMzNDQycsXG5cdCcjMDAzM0ZGJyxcblx0JyMwMDY2Q0MnLFxuXHQnIzAwNjZGRicsXG5cdCcjMDA5OUNDJyxcblx0JyMwMDk5RkYnLFxuXHQnIzAwQ0MwMCcsXG5cdCcjMDBDQzMzJyxcblx0JyMwMENDNjYnLFxuXHQnIzAwQ0M5OScsXG5cdCcjMDBDQ0NDJyxcblx0JyMwMENDRkYnLFxuXHQnIzMzMDBDQycsXG5cdCcjMzMwMEZGJyxcblx0JyMzMzMzQ0MnLFxuXHQnIzMzMzNGRicsXG5cdCcjMzM2NkNDJyxcblx0JyMzMzY2RkYnLFxuXHQnIzMzOTlDQycsXG5cdCcjMzM5OUZGJyxcblx0JyMzM0NDMDAnLFxuXHQnIzMzQ0MzMycsXG5cdCcjMzNDQzY2Jyxcblx0JyMzM0NDOTknLFxuXHQnIzMzQ0NDQycsXG5cdCcjMzNDQ0ZGJyxcblx0JyM2NjAwQ0MnLFxuXHQnIzY2MDBGRicsXG5cdCcjNjYzM0NDJyxcblx0JyM2NjMzRkYnLFxuXHQnIzY2Q0MwMCcsXG5cdCcjNjZDQzMzJyxcblx0JyM5OTAwQ0MnLFxuXHQnIzk5MDBGRicsXG5cdCcjOTkzM0NDJyxcblx0JyM5OTMzRkYnLFxuXHQnIzk5Q0MwMCcsXG5cdCcjOTlDQzMzJyxcblx0JyNDQzAwMDAnLFxuXHQnI0NDMDAzMycsXG5cdCcjQ0MwMDY2Jyxcblx0JyNDQzAwOTknLFxuXHQnI0NDMDBDQycsXG5cdCcjQ0MwMEZGJyxcblx0JyNDQzMzMDAnLFxuXHQnI0NDMzMzMycsXG5cdCcjQ0MzMzY2Jyxcblx0JyNDQzMzOTknLFxuXHQnI0NDMzNDQycsXG5cdCcjQ0MzM0ZGJyxcblx0JyNDQzY2MDAnLFxuXHQnI0NDNjYzMycsXG5cdCcjQ0M5OTAwJyxcblx0JyNDQzk5MzMnLFxuXHQnI0NDQ0MwMCcsXG5cdCcjQ0NDQzMzJyxcblx0JyNGRjAwMDAnLFxuXHQnI0ZGMDAzMycsXG5cdCcjRkYwMDY2Jyxcblx0JyNGRjAwOTknLFxuXHQnI0ZGMDBDQycsXG5cdCcjRkYwMEZGJyxcblx0JyNGRjMzMDAnLFxuXHQnI0ZGMzMzMycsXG5cdCcjRkYzMzY2Jyxcblx0JyNGRjMzOTknLFxuXHQnI0ZGMzNDQycsXG5cdCcjRkYzM0ZGJyxcblx0JyNGRjY2MDAnLFxuXHQnI0ZGNjYzMycsXG5cdCcjRkY5OTAwJyxcblx0JyNGRjk5MzMnLFxuXHQnI0ZGQ0MwMCcsXG5cdCcjRkZDQzMzJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuXHQvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG5cdC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG5cdC8vIGV4cGxpY2l0bHlcblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHdpbmRvdy5wcm9jZXNzLl9fbndqcykpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cblx0aWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gSXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcblx0Ly8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcblx0cmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG5cdFx0Ly8gSXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuXHRcdCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG5cdFx0Ly8gSXMgZmlyZWZveCA+PSB2MzE/XG5cdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG5cdFx0Ly8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdGFyZ3NbMF0gPSAodGhpcy51c2VDb2xvcnMgPyAnJWMnIDogJycpICtcblx0XHR0aGlzLm5hbWVzcGFjZSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyAlYycgOiAnICcpICtcblx0XHRhcmdzWzBdICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgK1xuXHRcdCcrJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cblx0aWYgKCF0aGlzLnVzZUNvbG9ycykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuXHRhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKTtcblxuXHQvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuXHQvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG5cdC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXHRsZXQgaW5kZXggPSAwO1xuXHRsZXQgbGFzdEMgPSAwO1xuXHRhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgbWF0Y2ggPT4ge1xuXHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpbmRleCsrO1xuXHRcdGlmIChtYXRjaCA9PT0gJyVjJykge1xuXHRcdFx0Ly8gV2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG5cdFx0XHQvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuXHRcdFx0bGFzdEMgPSBpbmRleDtcblx0XHR9XG5cdH0pO1xuXG5cdGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmRlYnVnKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICogSWYgYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhdmFpbGFibGUsIGZhbGxzIGJhY2tcbiAqIHRvIGBjb25zb2xlLmxvZ2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZXhwb3J0cy5sb2cgPSBjb25zb2xlLmRlYnVnIHx8IGNvbnNvbGUubG9nIHx8ICgoKSA9PiB7fSk7XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcblx0dHJ5IHtcblx0XHRpZiAobmFtZXNwYWNlcykge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnNldEl0ZW0oJ2RlYnVnJywgbmFtZXNwYWNlcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbG9hZCgpIHtcblx0bGV0IHI7XG5cdHRyeSB7XG5cdFx0ciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxuXG5cdC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcblx0aWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG5cdFx0ciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG5cblx0cmV0dXJuIHI7XG59XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuXHR0cnkge1xuXHRcdC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcblx0XHQvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuXHRcdHJldHVybiBsb2NhbFN0b3JhZ2U7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcblxuY29uc3Qge2Zvcm1hdHRlcnN9ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuXHR9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlByb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm0gPSB2b2lkIDA7XG5jb25zdCBzdHJlYW1fMSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG5jbGFzcyBQcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtIGV4dGVuZHMgc3RyZWFtXzEuVHJhbnNmb3JtIHtcbiAgICBjb25zdHJ1Y3Rvcih0b3RhbCwgY2FuY2VsbGF0aW9uVG9rZW4sIG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICB0aGlzLmNhbmNlbGxhdGlvblRva2VuID0gY2FuY2VsbGF0aW9uVG9rZW47XG4gICAgICAgIHRoaXMub25Qcm9ncmVzcyA9IG9uUHJvZ3Jlc3M7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLnRyYW5zZmVycmVkID0gMDtcbiAgICAgICAgdGhpcy5kZWx0YSA9IDA7XG4gICAgICAgIHRoaXMubmV4dFVwZGF0ZSA9IHRoaXMuc3RhcnQgKyAxMDAwO1xuICAgIH1cbiAgICBfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuY2VsbGF0aW9uVG9rZW4uY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoXCJjYW5jZWxsZWRcIiksIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhbnNmZXJyZWQgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICB0aGlzLmRlbHRhICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKG5vdyA+PSB0aGlzLm5leHRVcGRhdGUgJiYgdGhpcy50cmFuc2ZlcnJlZCAhPT0gdGhpcy50b3RhbCAvKiB3aWxsIGJlIGVtaXR0ZWQgb24gX2ZsdXNoICovKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRVcGRhdGUgPSBub3cgKyAxMDAwO1xuICAgICAgICAgICAgdGhpcy5vblByb2dyZXNzKHtcbiAgICAgICAgICAgICAgICB0b3RhbDogdGhpcy50b3RhbCxcbiAgICAgICAgICAgICAgICBkZWx0YTogdGhpcy5kZWx0YSxcbiAgICAgICAgICAgICAgICB0cmFuc2ZlcnJlZDogdGhpcy50cmFuc2ZlcnJlZCxcbiAgICAgICAgICAgICAgICBwZXJjZW50OiAodGhpcy50cmFuc2ZlcnJlZCAvIHRoaXMudG90YWwpICogMTAwLFxuICAgICAgICAgICAgICAgIGJ5dGVzUGVyU2Vjb25kOiBNYXRoLnJvdW5kKHRoaXMudHJhbnNmZXJyZWQgLyAoKG5vdyAtIHRoaXMuc3RhcnQpIC8gMTAwMCkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmRlbHRhID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhudWxsLCBjaHVuayk7XG4gICAgfVxuICAgIF9mbHVzaChjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5jYW5jZWxsYXRpb25Ub2tlbi5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihcImNhbmNlbGxlZFwiKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vblByb2dyZXNzKHtcbiAgICAgICAgICAgIHRvdGFsOiB0aGlzLnRvdGFsLFxuICAgICAgICAgICAgZGVsdGE6IHRoaXMuZGVsdGEsXG4gICAgICAgICAgICB0cmFuc2ZlcnJlZDogdGhpcy50b3RhbCxcbiAgICAgICAgICAgIHBlcmNlbnQ6IDEwMCxcbiAgICAgICAgICAgIGJ5dGVzUGVyU2Vjb25kOiBNYXRoLnJvdW5kKHRoaXMudHJhbnNmZXJyZWQgLyAoKERhdGUubm93KCkgLSB0aGlzLnN0YXJ0KSAvIDEwMDApKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGVsdGEgPSAwO1xuICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICB9XG59XG5leHBvcnRzLlByb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm0gPSBQcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2FmZVN0cmluZ2lmeUpzb24gPSBleHBvcnRzLmNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zID0gZXhwb3J0cy5zYWZlR2V0SGVhZGVyID0gZXhwb3J0cy5EaWdlc3RUcmFuc2Zvcm0gPSBleHBvcnRzLmNvbmZpZ3VyZVJlcXVlc3RVcmwgPSBleHBvcnRzLmNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zRnJvbVVybCA9IGV4cG9ydHMuSHR0cEV4ZWN1dG9yID0gZXhwb3J0cy5wYXJzZUpzb24gPSBleHBvcnRzLkh0dHBFcnJvciA9IGV4cG9ydHMuY3JlYXRlSHR0cEVycm9yID0gdm9pZCAwO1xuY29uc3QgY3J5cHRvXzEgPSByZXF1aXJlKFwiY3J5cHRvXCIpO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IGZzXzEgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCBzdHJlYW1fMSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG5jb25zdCB1cmxfMSA9IHJlcXVpcmUoXCJ1cmxcIik7XG5jb25zdCBDYW5jZWxsYXRpb25Ub2tlbl8xID0gcmVxdWlyZShcIi4vQ2FuY2VsbGF0aW9uVG9rZW5cIik7XG5jb25zdCBpbmRleF8xID0gcmVxdWlyZShcIi4vaW5kZXhcIik7XG5jb25zdCBQcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtXzEgPSByZXF1aXJlKFwiLi9Qcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtXCIpO1xuY29uc3QgZGVidWcgPSBkZWJ1Z18xLmRlZmF1bHQoXCJlbGVjdHJvbi1idWlsZGVyXCIpO1xuZnVuY3Rpb24gY3JlYXRlSHR0cEVycm9yKHJlc3BvbnNlLCBkZXNjcmlwdGlvbiA9IG51bGwpIHtcbiAgICByZXR1cm4gbmV3IEh0dHBFcnJvcihyZXNwb25zZS5zdGF0dXNDb2RlIHx8IC0xLCBgJHtyZXNwb25zZS5zdGF0dXNDb2RlfSAke3Jlc3BvbnNlLnN0YXR1c01lc3NhZ2V9YCArXG4gICAgICAgIChkZXNjcmlwdGlvbiA9PSBudWxsID8gXCJcIiA6IFwiXFxuXCIgKyBKU09OLnN0cmluZ2lmeShkZXNjcmlwdGlvbiwgbnVsbCwgXCIgIFwiKSkgK1xuICAgICAgICBcIlxcbkhlYWRlcnM6IFwiICtcbiAgICAgICAgc2FmZVN0cmluZ2lmeUpzb24ocmVzcG9uc2UuaGVhZGVycyksIGRlc2NyaXB0aW9uKTtcbn1cbmV4cG9ydHMuY3JlYXRlSHR0cEVycm9yID0gY3JlYXRlSHR0cEVycm9yO1xuY29uc3QgSFRUUF9TVEFUVVNfQ09ERVMgPSBuZXcgTWFwKFtcbiAgICBbNDI5LCBcIlRvbyBtYW55IHJlcXVlc3RzXCJdLFxuICAgIFs0MDAsIFwiQmFkIHJlcXVlc3RcIl0sXG4gICAgWzQwMywgXCJGb3JiaWRkZW5cIl0sXG4gICAgWzQwNCwgXCJOb3QgZm91bmRcIl0sXG4gICAgWzQwNSwgXCJNZXRob2Qgbm90IGFsbG93ZWRcIl0sXG4gICAgWzQwNiwgXCJOb3QgYWNjZXB0YWJsZVwiXSxcbiAgICBbNDA4LCBcIlJlcXVlc3QgdGltZW91dFwiXSxcbiAgICBbNDEzLCBcIlJlcXVlc3QgZW50aXR5IHRvbyBsYXJnZVwiXSxcbiAgICBbNTAwLCBcIkludGVybmFsIHNlcnZlciBlcnJvclwiXSxcbiAgICBbNTAyLCBcIkJhZCBnYXRld2F5XCJdLFxuICAgIFs1MDMsIFwiU2VydmljZSB1bmF2YWlsYWJsZVwiXSxcbiAgICBbNTA0LCBcIkdhdGV3YXkgdGltZW91dFwiXSxcbiAgICBbNTA1LCBcIkhUVFAgdmVyc2lvbiBub3Qgc3VwcG9ydGVkXCJdLFxuXSk7XG5jbGFzcyBIdHRwRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3Ioc3RhdHVzQ29kZSwgbWVzc2FnZSA9IGBIVFRQIGVycm9yOiAke0hUVFBfU1RBVFVTX0NPREVTLmdldChzdGF0dXNDb2RlKSB8fCBzdGF0dXNDb2RlfWAsIGRlc2NyaXB0aW9uID0gbnVsbCkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkh0dHBFcnJvclwiO1xuICAgICAgICB0aGlzLmNvZGUgPSBgSFRUUF9FUlJPUl8ke3N0YXR1c0NvZGV9YDtcbiAgICB9XG4gICAgaXNTZXJ2ZXJFcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzQ29kZSA+PSA1MDAgJiYgdGhpcy5zdGF0dXNDb2RlIDw9IDU5OTtcbiAgICB9XG59XG5leHBvcnRzLkh0dHBFcnJvciA9IEh0dHBFcnJvcjtcbmZ1bmN0aW9uIHBhcnNlSnNvbihyZXN1bHQpIHtcbiAgICByZXR1cm4gcmVzdWx0LnRoZW4oaXQgPT4gKGl0ID09IG51bGwgfHwgaXQubGVuZ3RoID09PSAwID8gbnVsbCA6IEpTT04ucGFyc2UoaXQpKSk7XG59XG5leHBvcnRzLnBhcnNlSnNvbiA9IHBhcnNlSnNvbjtcbmNsYXNzIEh0dHBFeGVjdXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubWF4UmVkaXJlY3RzID0gMTA7XG4gICAgfVxuICAgIHJlcXVlc3Qob3B0aW9ucywgY2FuY2VsbGF0aW9uVG9rZW4gPSBuZXcgQ2FuY2VsbGF0aW9uVG9rZW5fMS5DYW5jZWxsYXRpb25Ub2tlbigpLCBkYXRhKSB7XG4gICAgICAgIGNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBqc29uID0gZGF0YSA9PSBudWxsID8gdW5kZWZpbmVkIDogSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgIGNvbnN0IGVuY29kZWREYXRhID0ganNvbiA/IEJ1ZmZlci5mcm9tKGpzb24pIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAoZW5jb2RlZERhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgZGVidWcoanNvbik7XG4gICAgICAgICAgICBjb25zdCB7IGhlYWRlcnMsIC4uLm9wdHMgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJwb3N0XCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LUxlbmd0aFwiOiBlbmNvZGVkRGF0YS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIC4uLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAuLi5vcHRzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kb0FwaVJlcXVlc3Qob3B0aW9ucywgY2FuY2VsbGF0aW9uVG9rZW4sIGl0ID0+IHtcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGl0LmVuZChlbmNvZGVkRGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkb0FwaVJlcXVlc3Qob3B0aW9ucywgY2FuY2VsbGF0aW9uVG9rZW4sIHJlcXVlc3RQcm9jZXNzb3IsIHJlZGlyZWN0Q291bnQgPSAwKSB7XG4gICAgICAgIGlmIChkZWJ1Zy5lbmFibGVkKSB7XG4gICAgICAgICAgICBkZWJ1ZyhgUmVxdWVzdDogJHtzYWZlU3RyaW5naWZ5SnNvbihvcHRpb25zKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FuY2VsbGF0aW9uVG9rZW4uY3JlYXRlUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0LCBvbkNhbmNlbCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuY3JlYXRlUmVxdWVzdChvcHRpb25zLCAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlLCBvcHRpb25zLCBjYW5jZWxsYXRpb25Ub2tlbiwgcmVzb2x2ZSwgcmVqZWN0LCByZWRpcmVjdENvdW50LCByZXF1ZXN0UHJvY2Vzc29yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5hZGRFcnJvckFuZFRpbWVvdXRIYW5kbGVycyhyZXF1ZXN0LCByZWplY3QpO1xuICAgICAgICAgICAgdGhpcy5hZGRSZWRpcmVjdEhhbmRsZXJzKHJlcXVlc3QsIG9wdGlvbnMsIHJlamVjdCwgcmVkaXJlY3RDb3VudCwgb3B0aW9ucyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0FwaVJlcXVlc3Qob3B0aW9ucywgY2FuY2VsbGF0aW9uVG9rZW4sIHJlcXVlc3RQcm9jZXNzb3IsIHJlZGlyZWN0Q291bnQpLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVxdWVzdFByb2Nlc3NvcihyZXF1ZXN0LCByZWplY3QpO1xuICAgICAgICAgICAgb25DYW5jZWwoKCkgPT4gcmVxdWVzdC5hYm9ydCgpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIG5vaW5zcGVjdGlvbiBKU1VudXNlZExvY2FsU3ltYm9sc1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIGFkZFJlZGlyZWN0SGFuZGxlcnMocmVxdWVzdCwgb3B0aW9ucywgcmVqZWN0LCByZWRpcmVjdENvdW50LCBoYW5kbGVyKSB7XG4gICAgICAgIC8vIG5vdCByZXF1aXJlZCBmb3IgTm9kZUpTXG4gICAgfVxuICAgIGFkZEVycm9yQW5kVGltZW91dEhhbmRsZXJzKHJlcXVlc3QsIHJlamVjdCkge1xuICAgICAgICB0aGlzLmFkZFRpbWVPdXRIYW5kbGVyKHJlcXVlc3QsIHJlamVjdCk7XG4gICAgICAgIHJlcXVlc3Qub24oXCJlcnJvclwiLCByZWplY3QpO1xuICAgICAgICByZXF1ZXN0Lm9uKFwiYWJvcnRlZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiUmVxdWVzdCBoYXMgYmVlbiBhYm9ydGVkIGJ5IHRoZSBzZXJ2ZXJcIikpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UsIG9wdGlvbnMsIGNhbmNlbGxhdGlvblRva2VuLCByZXNvbHZlLCByZWplY3QsIHJlZGlyZWN0Q291bnQsIHJlcXVlc3RQcm9jZXNzb3IpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoZGVidWcuZW5hYmxlZCkge1xuICAgICAgICAgICAgZGVidWcoYFJlc3BvbnNlOiAke3Jlc3BvbnNlLnN0YXR1c0NvZGV9ICR7cmVzcG9uc2Uuc3RhdHVzTWVzc2FnZX0sIHJlcXVlc3Qgb3B0aW9uczogJHtzYWZlU3RyaW5naWZ5SnNvbihvcHRpb25zKX1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSBoYW5kbGUgYW55IG90aGVyID49IDQwMCBlcnJvciBvbiByZXF1ZXN0IGVuZCAocmVhZCBkZXRhaWxlZCBtZXNzYWdlIGluIHRoZSByZXNwb25zZSBib2R5KVxuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNDA0KSB7XG4gICAgICAgICAgICAvLyBlcnJvciBpcyBjbGVhciwgd2UgZG9uJ3QgbmVlZCB0byByZWFkIGRldGFpbGVkIGVycm9yIGRlc2NyaXB0aW9uXG4gICAgICAgICAgICByZWplY3QoY3JlYXRlSHR0cEVycm9yKHJlc3BvbnNlLCBgbWV0aG9kOiAke29wdGlvbnMubWV0aG9kIHx8IFwiR0VUXCJ9IHVybDogJHtvcHRpb25zLnByb3RvY29sIHx8IFwiaHR0cHM6XCJ9Ly8ke29wdGlvbnMuaG9zdG5hbWV9JHtvcHRpb25zLnBvcnQgPyBgOiR7b3B0aW9ucy5wb3J0fWAgOiBcIlwifSR7b3B0aW9ucy5wYXRofVxuXG5QbGVhc2UgZG91YmxlIGNoZWNrIHRoYXQgeW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBpcyBjb3JyZWN0LiBEdWUgdG8gc2VjdXJpdHkgcmVhc29ucywgYWN0dWFsIHN0YXR1cyBtYXliZSBub3QgcmVwb3J0ZWQsIGJ1dCA0MDQuXG5gKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMjA0KSB7XG4gICAgICAgICAgICAvLyBvbiBERUxFVEUgcmVxdWVzdFxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvZGUgPSAoX2EgPSByZXNwb25zZS5zdGF0dXNDb2RlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICBjb25zdCBzaG91bGRSZWRpcmVjdCA9IGNvZGUgPj0gMzAwICYmIGNvZGUgPCA0MDA7XG4gICAgICAgIGNvbnN0IHJlZGlyZWN0VXJsID0gc2FmZUdldEhlYWRlcihyZXNwb25zZSwgXCJsb2NhdGlvblwiKTtcbiAgICAgICAgaWYgKHNob3VsZFJlZGlyZWN0ICYmIHJlZGlyZWN0VXJsICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChyZWRpcmVjdENvdW50ID4gdGhpcy5tYXhSZWRpcmVjdHMpIHtcbiAgICAgICAgICAgICAgICByZWplY3QodGhpcy5jcmVhdGVNYXhSZWRpcmVjdEVycm9yKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZG9BcGlSZXF1ZXN0KEh0dHBFeGVjdXRvci5wcmVwYXJlUmVkaXJlY3RVcmxPcHRpb25zKHJlZGlyZWN0VXJsLCBvcHRpb25zKSwgY2FuY2VsbGF0aW9uVG9rZW4sIHJlcXVlc3RQcm9jZXNzb3IsIHJlZGlyZWN0Q291bnQpLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXNwb25zZS5zZXRFbmNvZGluZyhcInV0ZjhcIik7XG4gICAgICAgIGxldCBkYXRhID0gXCJcIjtcbiAgICAgICAgcmVzcG9uc2Uub24oXCJlcnJvclwiLCByZWplY3QpO1xuICAgICAgICByZXNwb25zZS5vbihcImRhdGFcIiwgKGNodW5rKSA9PiAoZGF0YSArPSBjaHVuaykpO1xuICAgICAgICByZXNwb25zZS5vbihcImVuZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlICE9IG51bGwgJiYgcmVzcG9uc2Uuc3RhdHVzQ29kZSA+PSA0MDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSBzYWZlR2V0SGVhZGVyKHJlc3BvbnNlLCBcImNvbnRlbnQtdHlwZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNKc29uID0gY29udGVudFR5cGUgIT0gbnVsbCAmJiAoQXJyYXkuaXNBcnJheShjb250ZW50VHlwZSkgPyBjb250ZW50VHlwZS5maW5kKGl0ID0+IGl0LmluY2x1ZGVzKFwianNvblwiKSkgIT0gbnVsbCA6IGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwianNvblwiKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChjcmVhdGVIdHRwRXJyb3IocmVzcG9uc2UsIGBtZXRob2Q6ICR7b3B0aW9ucy5tZXRob2QgfHwgXCJHRVRcIn0gdXJsOiAke29wdGlvbnMucHJvdG9jb2wgfHwgXCJodHRwczpcIn0vLyR7b3B0aW9ucy5ob3N0bmFtZX0ke29wdGlvbnMucG9ydCA/IGA6JHtvcHRpb25zLnBvcnR9YCA6IFwiXCJ9JHtvcHRpb25zLnBhdGh9XG5cbiAgICAgICAgICBEYXRhOlxuICAgICAgICAgICR7aXNKc29uID8gSlNPTi5zdHJpbmdpZnkoSlNPTi5wYXJzZShkYXRhKSkgOiBkYXRhfVxuICAgICAgICAgIGApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YS5sZW5ndGggPT09IDAgPyBudWxsIDogZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBkb3dubG9hZFRvQnVmZmVyKHVybCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gYXdhaXQgb3B0aW9ucy5jYW5jZWxsYXRpb25Ub2tlbi5jcmVhdGVQcm9taXNlKChyZXNvbHZlLCByZWplY3QsIG9uQ2FuY2VsKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVycyB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBQcml2YXRlR2l0SHViUHJvdmlkZXIgcmVxdWlyZXMgSHR0cEV4ZWN1dG9yLnByZXBhcmVSZWRpcmVjdFVybE9wdGlvbnMgbG9naWMsIHNvLCB3ZSBuZWVkIHRvIHJlZGlyZWN0IG1hbnVhbGx5XG4gICAgICAgICAgICAgICAgcmVkaXJlY3Q6IFwibWFudWFsXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uZmlndXJlUmVxdWVzdFVybCh1cmwsIHJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgICAgIGNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zKHJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuZG9Eb3dubG9hZChyZXF1ZXN0T3B0aW9ucywge1xuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uOiBudWxsLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgb25DYW5jZWwsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlSGFuZGxlcjogKHJlc3BvbnNlLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gc2FmZUdldEhlYWRlcihyZXNwb25zZSwgXCJjb250ZW50LWxlbmd0aFwiKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50TGVuZ3RoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSBwYXJzZUludChjb250ZW50TGVuZ3RoLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2l6ZSA+IDUyNDI4ODAwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoXCJNYXhpbXVtIGFsbG93ZWQgc2l6ZSBpcyA1MDAgTUJcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IEJ1ZmZlci5hbGxvYyhzaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uub24oXCJkYXRhXCIsIChjaHVuaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLmNvcHkocmVzdWx0LCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gNTI0Mjg4MDAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihcIk1heGltdW0gYWxsb3dlZCBzaXplIGlzIDUwMCBNQlwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gQnVmZmVyLmNvbmNhdChbcmVzdWx0LCBjaHVua10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uub24oXCJlbmRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPSBudWxsICYmIHBvc2l0aW9uICE9PSAtMSAmJiBwb3NpdGlvbiAhPT0gcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihgUmVjZWl2ZWQgZGF0YSBsZW5ndGggJHtwb3NpdGlvbn0gaXMgbm90IGVxdWFsIHRvIGV4cGVjdGVkICR7cmVzdWx0Lmxlbmd0aH1gKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZG9Eb3dubG9hZChyZXF1ZXN0T3B0aW9ucywgb3B0aW9ucywgcmVkaXJlY3RDb3VudCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5jcmVhdGVSZXF1ZXN0KHJlcXVlc3RPcHRpb25zLCAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID49IDQwMCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2sobmV3IEVycm9yKGBDYW5ub3QgZG93bmxvYWQgXCIke3JlcXVlc3RPcHRpb25zLnByb3RvY29sIHx8IFwiaHR0cHM6XCJ9Ly8ke3JlcXVlc3RPcHRpb25zLmhvc3RuYW1lfSR7cmVxdWVzdE9wdGlvbnMucGF0aH1cIiwgc3RhdHVzICR7cmVzcG9uc2Uuc3RhdHVzQ29kZX06ICR7cmVzcG9uc2Uuc3RhdHVzTWVzc2FnZX1gKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSXQgaXMgcG9zc2libGUgZm9yIHRoZSByZXNwb25zZSBzdHJlYW0gdG8gZmFpbCwgZS5nLiB3aGVuIGEgbmV0d29yayBpcyBsb3N0IHdoaWxlXG4gICAgICAgICAgICAvLyByZXNwb25zZSBzdHJlYW0gaXMgaW4gcHJvZ3Jlc3MuIFN0b3Agd2FpdGluZyBhbmQgcmVqZWN0IHNvIGNvbnN1bWVyIGNhbiBjYXRjaCB0aGUgZXJyb3IuXG4gICAgICAgICAgICByZXNwb25zZS5vbihcImVycm9yXCIsIG9wdGlvbnMuY2FsbGJhY2spO1xuICAgICAgICAgICAgLy8gdGhpcyBjb2RlIG5vdCByZWxldmFudCBmb3IgRWxlY3Ryb24gKHJlZGlyZWN0IGV2ZW50IGluc3RlYWQgaGFuZGxlZClcbiAgICAgICAgICAgIGNvbnN0IHJlZGlyZWN0VXJsID0gc2FmZUdldEhlYWRlcihyZXNwb25zZSwgXCJsb2NhdGlvblwiKTtcbiAgICAgICAgICAgIGlmIChyZWRpcmVjdFVybCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlZGlyZWN0Q291bnQgPCB0aGlzLm1heFJlZGlyZWN0cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvRG93bmxvYWQoSHR0cEV4ZWN1dG9yLnByZXBhcmVSZWRpcmVjdFVybE9wdGlvbnMocmVkaXJlY3RVcmwsIHJlcXVlc3RPcHRpb25zKSwgb3B0aW9ucywgcmVkaXJlY3RDb3VudCsrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2sodGhpcy5jcmVhdGVNYXhSZWRpcmVjdEVycm9yKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5yZXNwb25zZUhhbmRsZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyZVBpcGVzKG9wdGlvbnMsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucmVzcG9uc2VIYW5kbGVyKHJlc3BvbnNlLCBvcHRpb25zLmNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWRkRXJyb3JBbmRUaW1lb3V0SGFuZGxlcnMocmVxdWVzdCwgb3B0aW9ucy5jYWxsYmFjayk7XG4gICAgICAgIHRoaXMuYWRkUmVkaXJlY3RIYW5kbGVycyhyZXF1ZXN0LCByZXF1ZXN0T3B0aW9ucywgb3B0aW9ucy5jYWxsYmFjaywgcmVkaXJlY3RDb3VudCwgcmVxdWVzdE9wdGlvbnMgPT4ge1xuICAgICAgICAgICAgdGhpcy5kb0Rvd25sb2FkKHJlcXVlc3RPcHRpb25zLCBvcHRpb25zLCByZWRpcmVjdENvdW50KyspO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVxdWVzdC5lbmQoKTtcbiAgICB9XG4gICAgY3JlYXRlTWF4UmVkaXJlY3RFcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgVG9vIG1hbnkgcmVkaXJlY3RzICg+ICR7dGhpcy5tYXhSZWRpcmVjdHN9KWApO1xuICAgIH1cbiAgICBhZGRUaW1lT3V0SGFuZGxlcihyZXF1ZXN0LCBjYWxsYmFjaykge1xuICAgICAgICByZXF1ZXN0Lm9uKFwic29ja2V0XCIsIChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgIHNvY2tldC5zZXRUaW1lb3V0KDYwICogMTAwMCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoXCJSZXF1ZXN0IHRpbWVkIG91dFwiKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBwcmVwYXJlUmVkaXJlY3RVcmxPcHRpb25zKHJlZGlyZWN0VXJsLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG5ld09wdGlvbnMgPSBjb25maWd1cmVSZXF1ZXN0T3B0aW9uc0Zyb21VcmwocmVkaXJlY3RVcmwsIHsgLi4ub3B0aW9ucyB9KTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG5ld09wdGlvbnMuaGVhZGVycztcbiAgICAgICAgaWYgKGhlYWRlcnMgPT09IG51bGwgfHwgaGVhZGVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaGVhZGVycy5hdXRob3JpemF0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWROZXdVcmwgPSBuZXcgdXJsXzEuVVJMKHJlZGlyZWN0VXJsKTtcbiAgICAgICAgICAgIGlmIChwYXJzZWROZXdVcmwuaG9zdG5hbWUuZW5kc1dpdGgoXCIuYW1hem9uYXdzLmNvbVwiKSB8fCBwYXJzZWROZXdVcmwuc2VhcmNoUGFyYW1zLmhhcyhcIlgtQW16LUNyZWRlbnRpYWxcIikpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaGVhZGVycy5hdXRob3JpemF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdPcHRpb25zO1xuICAgIH1cbiAgICBzdGF0aWMgcmV0cnlPblNlcnZlckVycm9yKHRhc2ssIG1heFJldHJpZXMgPSAzKSB7XG4gICAgICAgIGZvciAobGV0IGF0dGVtcHROdW1iZXIgPSAwOzsgYXR0ZW1wdE51bWJlcisrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChhdHRlbXB0TnVtYmVyIDwgbWF4UmV0cmllcyAmJiAoKGUgaW5zdGFuY2VvZiBIdHRwRXJyb3IgJiYgZS5pc1NlcnZlckVycm9yKCkpIHx8IGUuY29kZSA9PT0gXCJFUElQRVwiKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuSHR0cEV4ZWN1dG9yID0gSHR0cEV4ZWN1dG9yO1xuZnVuY3Rpb24gY29uZmlndXJlUmVxdWVzdE9wdGlvbnNGcm9tVXJsKHVybCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbmZpZ3VyZVJlcXVlc3RVcmwobmV3IHVybF8xLlVSTCh1cmwpLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zRnJvbVVybCA9IGNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zRnJvbVVybDtcbmZ1bmN0aW9uIGNvbmZpZ3VyZVJlcXVlc3RVcmwodXJsLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucy5wcm90b2NvbCA9IHVybC5wcm90b2NvbDtcbiAgICBvcHRpb25zLmhvc3RuYW1lID0gdXJsLmhvc3RuYW1lO1xuICAgIGlmICh1cmwucG9ydCkge1xuICAgICAgICBvcHRpb25zLnBvcnQgPSB1cmwucG9ydDtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9ucy5wb3J0KSB7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLnBvcnQ7XG4gICAgfVxuICAgIG9wdGlvbnMucGF0aCA9IHVybC5wYXRobmFtZSArIHVybC5zZWFyY2g7XG59XG5leHBvcnRzLmNvbmZpZ3VyZVJlcXVlc3RVcmwgPSBjb25maWd1cmVSZXF1ZXN0VXJsO1xuY2xhc3MgRGlnZXN0VHJhbnNmb3JtIGV4dGVuZHMgc3RyZWFtXzEuVHJhbnNmb3JtIHtcbiAgICBjb25zdHJ1Y3RvcihleHBlY3RlZCwgYWxnb3JpdGhtID0gXCJzaGE1MTJcIiwgZW5jb2RpbmcgPSBcImJhc2U2NFwiKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZXhwZWN0ZWQgPSBleHBlY3RlZDtcbiAgICAgICAgdGhpcy5hbGdvcml0aG0gPSBhbGdvcml0aG07XG4gICAgICAgIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICAgICAgdGhpcy5fYWN0dWFsID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc1ZhbGlkYXRlT25FbmQgPSB0cnVlO1xuICAgICAgICB0aGlzLmRpZ2VzdGVyID0gY3J5cHRvXzEuY3JlYXRlSGFzaChhbGdvcml0aG0pO1xuICAgIH1cbiAgICAvLyBub2luc3BlY3Rpb24gSlNVbnVzZWRHbG9iYWxTeW1ib2xzXG4gICAgZ2V0IGFjdHVhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdHVhbDtcbiAgICB9XG4gICAgLy8gbm9pbnNwZWN0aW9uIEpTVW51c2VkR2xvYmFsU3ltYm9sc1xuICAgIF90cmFuc2Zvcm0oY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmRpZ2VzdGVyLnVwZGF0ZShjaHVuayk7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGNodW5rKTtcbiAgICB9XG4gICAgLy8gbm9pbnNwZWN0aW9uIEpTVW51c2VkR2xvYmFsU3ltYm9sc1xuICAgIF9mbHVzaChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9hY3R1YWwgPSB0aGlzLmRpZ2VzdGVyLmRpZ2VzdCh0aGlzLmVuY29kaW5nKTtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZGF0ZU9uRW5kKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgIH1cbiAgICB2YWxpZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FjdHVhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBpbmRleF8xLm5ld0Vycm9yKFwiTm90IGZpbmlzaGVkIHlldFwiLCBcIkVSUl9TVFJFQU1fTk9UX0ZJTklTSEVEXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9hY3R1YWwgIT09IHRoaXMuZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IGluZGV4XzEubmV3RXJyb3IoYCR7dGhpcy5hbGdvcml0aG19IGNoZWNrc3VtIG1pc21hdGNoLCBleHBlY3RlZCAke3RoaXMuZXhwZWN0ZWR9LCBnb3QgJHt0aGlzLl9hY3R1YWx9YCwgXCJFUlJfQ0hFQ0tTVU1fTUlTTUFUQ0hcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5EaWdlc3RUcmFuc2Zvcm0gPSBEaWdlc3RUcmFuc2Zvcm07XG5mdW5jdGlvbiBjaGVja1NoYTIoc2hhMkhlYWRlciwgc2hhMiwgY2FsbGJhY2spIHtcbiAgICBpZiAoc2hhMkhlYWRlciAhPSBudWxsICYmIHNoYTIgIT0gbnVsbCAmJiBzaGEySGVhZGVyICE9PSBzaGEyKSB7XG4gICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihgY2hlY2tzdW0gbWlzbWF0Y2g6IGV4cGVjdGVkICR7c2hhMn0gYnV0IGdvdCAke3NoYTJIZWFkZXJ9IChYLUNoZWNrc3VtLVNoYTIgaGVhZGVyKWApKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHNhZmVHZXRIZWFkZXIocmVzcG9uc2UsIGhlYWRlcktleSkge1xuICAgIGNvbnN0IHZhbHVlID0gcmVzcG9uc2UuaGVhZGVyc1toZWFkZXJLZXldO1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAvLyBlbGVjdHJvbiBBUElcbiAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA9PT0gMCA/IG51bGwgOiB2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5leHBvcnRzLnNhZmVHZXRIZWFkZXIgPSBzYWZlR2V0SGVhZGVyO1xuZnVuY3Rpb24gY29uZmlndXJlUGlwZXMob3B0aW9ucywgcmVzcG9uc2UpIHtcbiAgICBpZiAoIWNoZWNrU2hhMihzYWZlR2V0SGVhZGVyKHJlc3BvbnNlLCBcIlgtQ2hlY2tzdW0tU2hhMlwiKSwgb3B0aW9ucy5vcHRpb25zLnNoYTIsIG9wdGlvbnMuY2FsbGJhY2spKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RyZWFtcyA9IFtdO1xuICAgIGlmIChvcHRpb25zLm9wdGlvbnMub25Qcm9ncmVzcyAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBzYWZlR2V0SGVhZGVyKHJlc3BvbnNlLCBcImNvbnRlbnQtbGVuZ3RoXCIpO1xuICAgICAgICBpZiAoY29udGVudExlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzdHJlYW1zLnB1c2gobmV3IFByb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm1fMS5Qcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtKHBhcnNlSW50KGNvbnRlbnRMZW5ndGgsIDEwKSwgb3B0aW9ucy5vcHRpb25zLmNhbmNlbGxhdGlvblRva2VuLCBvcHRpb25zLm9wdGlvbnMub25Qcm9ncmVzcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNoYTUxMiA9IG9wdGlvbnMub3B0aW9ucy5zaGE1MTI7XG4gICAgaWYgKHNoYTUxMiAhPSBudWxsKSB7XG4gICAgICAgIHN0cmVhbXMucHVzaChuZXcgRGlnZXN0VHJhbnNmb3JtKHNoYTUxMiwgXCJzaGE1MTJcIiwgc2hhNTEyLmxlbmd0aCA9PT0gMTI4ICYmICFzaGE1MTIuaW5jbHVkZXMoXCIrXCIpICYmICFzaGE1MTIuaW5jbHVkZXMoXCJaXCIpICYmICFzaGE1MTIuaW5jbHVkZXMoXCI9XCIpID8gXCJoZXhcIiA6IFwiYmFzZTY0XCIpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9ucy5vcHRpb25zLnNoYTIgIT0gbnVsbCkge1xuICAgICAgICBzdHJlYW1zLnB1c2gobmV3IERpZ2VzdFRyYW5zZm9ybShvcHRpb25zLm9wdGlvbnMuc2hhMiwgXCJzaGEyNTZcIiwgXCJoZXhcIikpO1xuICAgIH1cbiAgICBjb25zdCBmaWxlT3V0ID0gZnNfMS5jcmVhdGVXcml0ZVN0cmVhbShvcHRpb25zLmRlc3RpbmF0aW9uKTtcbiAgICBzdHJlYW1zLnB1c2goZmlsZU91dCk7XG4gICAgbGV0IGxhc3RTdHJlYW0gPSByZXNwb25zZTtcbiAgICBmb3IgKGNvbnN0IHN0cmVhbSBvZiBzdHJlYW1zKSB7XG4gICAgICAgIHN0cmVhbS5vbihcImVycm9yXCIsIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLm9wdGlvbnMuY2FuY2VsbGF0aW9uVG9rZW4uY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsYXN0U3RyZWFtID0gbGFzdFN0cmVhbS5waXBlKHN0cmVhbSk7XG4gICAgfVxuICAgIGZpbGVPdXQub24oXCJmaW5pc2hcIiwgKCkgPT4ge1xuICAgICAgICA7XG4gICAgICAgIGZpbGVPdXQuY2xvc2Uob3B0aW9ucy5jYWxsYmFjayk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjb25maWd1cmVSZXF1ZXN0T3B0aW9ucyhvcHRpb25zLCB0b2tlbiwgbWV0aG9kKSB7XG4gICAgaWYgKG1ldGhvZCAhPSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMubWV0aG9kID0gbWV0aG9kO1xuICAgIH1cbiAgICBvcHRpb25zLmhlYWRlcnMgPSB7IC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgIGNvbnN0IGhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnM7XG4gICAgaWYgKHRva2VuICE9IG51bGwpIHtcbiAgICAgICAgO1xuICAgICAgICBoZWFkZXJzLmF1dGhvcml6YXRpb24gPSB0b2tlbi5zdGFydHNXaXRoKFwiQmFzaWNcIikgfHwgdG9rZW4uc3RhcnRzV2l0aChcIkJlYXJlclwiKSA/IHRva2VuIDogYHRva2VuICR7dG9rZW59YDtcbiAgICB9XG4gICAgaWYgKGhlYWRlcnNbXCJVc2VyLUFnZW50XCJdID09IG51bGwpIHtcbiAgICAgICAgaGVhZGVyc1tcIlVzZXItQWdlbnRcIl0gPSBcImVsZWN0cm9uLWJ1aWxkZXJcIjtcbiAgICB9XG4gICAgaWYgKG1ldGhvZCA9PSBudWxsIHx8IG1ldGhvZCA9PT0gXCJHRVRcIiB8fCBoZWFkZXJzW1wiQ2FjaGUtQ29udHJvbFwiXSA9PSBudWxsKSB7XG4gICAgICAgIGhlYWRlcnNbXCJDYWNoZS1Db250cm9sXCJdID0gXCJuby1jYWNoZVwiO1xuICAgIH1cbiAgICAvLyBkbyBub3Qgc3BlY2lmeSBmb3Igbm9kZSAoaW4gYW55IGNhc2Ugd2UgdXNlIGh0dHBzIG1vZHVsZSlcbiAgICBpZiAob3B0aW9ucy5wcm90b2NvbCA9PSBudWxsICYmIHByb2Nlc3MudmVyc2lvbnMuZWxlY3Ryb24gIT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zLnByb3RvY29sID0gXCJodHRwczpcIjtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG5leHBvcnRzLmNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zID0gY29uZmlndXJlUmVxdWVzdE9wdGlvbnM7XG5mdW5jdGlvbiBzYWZlU3RyaW5naWZ5SnNvbihkYXRhLCBza2lwcGVkTmFtZXMpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSwgKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmIChuYW1lLmVuZHNXaXRoKFwiQXV0aG9yaXphdGlvblwiKSB8fFxuICAgICAgICAgICAgbmFtZS5lbmRzV2l0aChcImF1dGhvcml6YXRpb25cIikgfHxcbiAgICAgICAgICAgIG5hbWUuZW5kc1dpdGgoXCJQYXNzd29yZFwiKSB8fFxuICAgICAgICAgICAgbmFtZS5lbmRzV2l0aChcIlBBU1NXT1JEXCIpIHx8XG4gICAgICAgICAgICBuYW1lLmVuZHNXaXRoKFwiVG9rZW5cIikgfHxcbiAgICAgICAgICAgIG5hbWUuaW5jbHVkZXMoXCJwYXNzd29yZFwiKSB8fFxuICAgICAgICAgICAgbmFtZS5pbmNsdWRlcyhcInRva2VuXCIpIHx8XG4gICAgICAgICAgICAoc2tpcHBlZE5hbWVzICE9IG51bGwgJiYgc2tpcHBlZE5hbWVzLmhhcyhuYW1lKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBcIjxzdHJpcHBlZCBzZW5zaXRpdmUgZGF0YT5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSwgMik7XG59XG5leHBvcnRzLnNhZmVTdHJpbmdpZnlKc29uID0gc2FmZVN0cmluZ2lmeUpzb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1odHRwRXhlY3V0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFMzTGlrZVByb3ZpZGVyQmFzZVVybCA9IGV4cG9ydHMuZ2l0aHViVXJsID0gdm9pZCAwO1xuLyoqIEBwcml2YXRlICovXG5mdW5jdGlvbiBnaXRodWJVcmwob3B0aW9ucywgZGVmYXVsdEhvc3QgPSBcImdpdGh1Yi5jb21cIikge1xuICAgIHJldHVybiBgJHtvcHRpb25zLnByb3RvY29sIHx8IFwiaHR0cHNcIn06Ly8ke29wdGlvbnMuaG9zdCB8fCBkZWZhdWx0SG9zdH1gO1xufVxuZXhwb3J0cy5naXRodWJVcmwgPSBnaXRodWJVcmw7XG5mdW5jdGlvbiBnZXRTM0xpa2VQcm92aWRlckJhc2VVcmwoY29uZmlndXJhdGlvbikge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gY29uZmlndXJhdGlvbi5wcm92aWRlcjtcbiAgICBpZiAocHJvdmlkZXIgPT09IFwiczNcIikge1xuICAgICAgICByZXR1cm4gczNVcmwoY29uZmlndXJhdGlvbik7XG4gICAgfVxuICAgIGlmIChwcm92aWRlciA9PT0gXCJzcGFjZXNcIikge1xuICAgICAgICByZXR1cm4gc3BhY2VzVXJsKGNvbmZpZ3VyYXRpb24pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBzdXBwb3J0ZWQgcHJvdmlkZXI6ICR7cHJvdmlkZXJ9YCk7XG59XG5leHBvcnRzLmdldFMzTGlrZVByb3ZpZGVyQmFzZVVybCA9IGdldFMzTGlrZVByb3ZpZGVyQmFzZVVybDtcbmZ1bmN0aW9uIHMzVXJsKG9wdGlvbnMpIHtcbiAgICBsZXQgdXJsO1xuICAgIGlmIChvcHRpb25zLmVuZHBvaW50ICE9IG51bGwpIHtcbiAgICAgICAgdXJsID0gYCR7b3B0aW9ucy5lbmRwb2ludH0vJHtvcHRpb25zLmJ1Y2tldH1gO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb25zLmJ1Y2tldC5pbmNsdWRlcyhcIi5cIikpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucmVnaW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQnVja2V0IG5hbWUgXCIke29wdGlvbnMuYnVja2V0fVwiIGluY2x1ZGVzIGEgZG90LCBidXQgUzMgcmVnaW9uIGlzIG1pc3NpbmdgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzcGVjaWFsIGNhc2UsIHNlZSBodHRwOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BbWF6b25TMy9sYXRlc3QvZGV2L1VzaW5nQnVja2V0Lmh0bWwjYWNjZXNzLWJ1Y2tldC1pbnRyb1xuICAgICAgICBpZiAob3B0aW9ucy5yZWdpb24gPT09IFwidXMtZWFzdC0xXCIpIHtcbiAgICAgICAgICAgIHVybCA9IGBodHRwczovL3MzLmFtYXpvbmF3cy5jb20vJHtvcHRpb25zLmJ1Y2tldH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXJsID0gYGh0dHBzOi8vczMtJHtvcHRpb25zLnJlZ2lvbn0uYW1hem9uYXdzLmNvbS8ke29wdGlvbnMuYnVja2V0fWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9ucy5yZWdpb24gPT09IFwiY24tbm9ydGgtMVwiKSB7XG4gICAgICAgIHVybCA9IGBodHRwczovLyR7b3B0aW9ucy5idWNrZXR9LnMzLiR7b3B0aW9ucy5yZWdpb259LmFtYXpvbmF3cy5jb20uY25gO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdXJsID0gYGh0dHBzOi8vJHtvcHRpb25zLmJ1Y2tldH0uczMuYW1hem9uYXdzLmNvbWA7XG4gICAgfVxuICAgIHJldHVybiBhcHBlbmRQYXRoKHVybCwgb3B0aW9ucy5wYXRoKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZFBhdGgodXJsLCBwKSB7XG4gICAgaWYgKHAgIT0gbnVsbCAmJiBwLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKCFwLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICAgICAgICB1cmwgKz0gXCIvXCI7XG4gICAgICAgIH1cbiAgICAgICAgdXJsICs9IHA7XG4gICAgfVxuICAgIHJldHVybiB1cmw7XG59XG5mdW5jdGlvbiBzcGFjZXNVcmwob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLm5hbWUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5hbWUgaXMgbWlzc2luZ2ApO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yZWdpb24gPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHJlZ2lvbiBpcyBtaXNzaW5nYCk7XG4gICAgfVxuICAgIHJldHVybiBhcHBlbmRQYXRoKGBodHRwczovLyR7b3B0aW9ucy5uYW1lfS4ke29wdGlvbnMucmVnaW9ufS5kaWdpdGFsb2NlYW5zcGFjZXMuY29tYCwgb3B0aW9ucy5wYXRoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXB1Ymxpc2hPcHRpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXJzZURuID0gdm9pZCAwO1xuZnVuY3Rpb24gcGFyc2VEbihzZXEpIHtcbiAgICBsZXQgcXVvdGVkID0gZmFsc2U7XG4gICAgbGV0IGtleSA9IG51bGw7XG4gICAgbGV0IHRva2VuID0gXCJcIjtcbiAgICBsZXQgbmV4dE5vblNwYWNlID0gMDtcbiAgICBzZXEgPSBzZXEudHJpbSgpO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBzZXEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGkgPT09IHNlcS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGtleSwgdG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2ggPSBzZXFbaV07XG4gICAgICAgIGlmIChxdW90ZWQpIHtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ1wiJykge1xuICAgICAgICAgICAgICAgIHF1b3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNoID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgcXVvdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaCA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JkID0gcGFyc2VJbnQoc2VxLnNsaWNlKGksIGkgKyAyKSwgMTYpO1xuICAgICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNOYU4ob3JkKSkge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiArPSBzZXFbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuICs9IFN0cmluZy5mcm9tQ2hhckNvZGUob3JkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBudWxsICYmIGNoID09PSBcIj1cIikge1xuICAgICAgICAgICAgICAgIGtleSA9IHRva2VuO1xuICAgICAgICAgICAgICAgIHRva2VuID0gXCJcIjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaCA9PT0gXCIsXCIgfHwgY2ggPT09IFwiO1wiIHx8IGNoID09PSBcIitcIikge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldChrZXksIHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAga2V5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IFwiXCI7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoID09PSBcIiBcIiAmJiAhcXVvdGVkKSB7XG4gICAgICAgICAgICBpZiAodG9rZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA+IG5leHROb25TcGFjZSkge1xuICAgICAgICAgICAgICAgIGxldCBqID0gaTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc2VxW2pdID09PSBcIiBcIikge1xuICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHROb25TcGFjZSA9IGo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dE5vblNwYWNlID49IHNlcS5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICBzZXFbbmV4dE5vblNwYWNlXSA9PT0gXCIsXCIgfHxcbiAgICAgICAgICAgICAgICBzZXFbbmV4dE5vblNwYWNlXSA9PT0gXCI7XCIgfHxcbiAgICAgICAgICAgICAgICAoa2V5ID09PSBudWxsICYmIHNlcVtuZXh0Tm9uU3BhY2VdID09PSBcIj1cIikgfHxcbiAgICAgICAgICAgICAgICAoa2V5ICE9PSBudWxsICYmIHNlcVtuZXh0Tm9uU3BhY2VdID09PSBcIitcIikpIHtcbiAgICAgICAgICAgICAgICBpID0gbmV4dE5vblNwYWNlIC0gMTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0b2tlbiArPSBjaDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMucGFyc2VEbiA9IHBhcnNlRG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZmMyMjUzUGFyc2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5uaWwgPSBleHBvcnRzLlVVSUQgPSB2b2lkIDA7XG5jb25zdCBjcnlwdG9fMSA9IHJlcXVpcmUoXCJjcnlwdG9cIik7XG5jb25zdCBpbmRleF8xID0gcmVxdWlyZShcIi4vaW5kZXhcIik7XG5jb25zdCBpbnZhbGlkTmFtZSA9IFwib3B0aW9ucy5uYW1lIG11c3QgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGEgQnVmZmVyXCI7XG4vLyBOb2RlIElEIGFjY29yZGluZyB0byByZmM0MTIyI3NlY3Rpb24tNC41XG5jb25zdCByYW5kb21Ib3N0ID0gY3J5cHRvXzEucmFuZG9tQnl0ZXMoMTYpO1xucmFuZG9tSG9zdFswXSA9IHJhbmRvbUhvc3RbMF0gfCAweDAxO1xuLy8gbG9va3VwIHRhYmxlIGhleCB0byBieXRlXG5jb25zdCBoZXgyYnl0ZSA9IHt9O1xuLy8gbG9va3VwIHRhYmxlIGJ5dGUgdG8gaGV4XG5jb25zdCBieXRlMmhleCA9IFtdO1xuLy8gcG9wdWxhdGUgbG9va3VwIHRhYmxlc1xuZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgIGNvbnN0IGhleCA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG4gICAgaGV4MmJ5dGVbaGV4XSA9IGk7XG4gICAgYnl0ZTJoZXhbaV0gPSBoZXg7XG59XG4vLyBVVUlEIGNsYXNzXG5jbGFzcyBVVUlEIHtcbiAgICBjb25zdHJ1Y3Rvcih1dWlkKSB7XG4gICAgICAgIHRoaXMuYXNjaWkgPSBudWxsO1xuICAgICAgICB0aGlzLmJpbmFyeSA9IG51bGw7XG4gICAgICAgIGNvbnN0IGNoZWNrID0gVVVJRC5jaGVjayh1dWlkKTtcbiAgICAgICAgaWYgKCFjaGVjaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGEgVVVJRFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZlcnNpb24gPSBjaGVjay52ZXJzaW9uO1xuICAgICAgICBpZiAoY2hlY2suZm9ybWF0ID09PSBcImFzY2lpXCIpIHtcbiAgICAgICAgICAgIHRoaXMuYXNjaWkgPSB1dWlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5iaW5hcnkgPSB1dWlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyB2NShuYW1lLCBuYW1lc3BhY2UpIHtcbiAgICAgICAgcmV0dXJuIHV1aWROYW1lZChuYW1lLCBcInNoYTFcIiwgMHg1MCwgbmFtZXNwYWNlKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLmFzY2lpID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYXNjaWkgPSBzdHJpbmdpZnkodGhpcy5iaW5hcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFzY2lpO1xuICAgIH1cbiAgICBpbnNwZWN0KCkge1xuICAgICAgICByZXR1cm4gYFVVSUQgdiR7dGhpcy52ZXJzaW9ufSAke3RoaXMudG9TdHJpbmcoKX1gO1xuICAgIH1cbiAgICBzdGF0aWMgY2hlY2sodXVpZCwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBpZiAodHlwZW9mIHV1aWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHV1aWQgPSB1dWlkLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoIS9eW2EtZjAtOV17OH0oLVthLWYwLTldezR9KXszfS0oW2EtZjAtOV17MTJ9KSQvLnRlc3QodXVpZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXVpZCA9PT0gXCIwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDBcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZlcnNpb246IHVuZGVmaW5lZCwgdmFyaWFudDogXCJuaWxcIiwgZm9ybWF0OiBcImFzY2lpXCIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogKGhleDJieXRlW3V1aWRbMTRdICsgdXVpZFsxNV1dICYgMHhmMCkgPj4gNCxcbiAgICAgICAgICAgICAgICB2YXJpYW50OiBnZXRWYXJpYW50KChoZXgyYnl0ZVt1dWlkWzE5XSArIHV1aWRbMjBdXSAmIDB4ZTApID4+IDUpLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogXCJhc2NpaVwiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHV1aWQpKSB7XG4gICAgICAgICAgICBpZiAodXVpZC5sZW5ndGggPCBvZmZzZXQgKyAxNikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh1dWlkW29mZnNldCArIGldICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID09PSAxNikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZlcnNpb246IHVuZGVmaW5lZCwgdmFyaWFudDogXCJuaWxcIiwgZm9ybWF0OiBcImJpbmFyeVwiIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZlcnNpb246ICh1dWlkW29mZnNldCArIDZdICYgMHhmMCkgPj4gNCxcbiAgICAgICAgICAgICAgICB2YXJpYW50OiBnZXRWYXJpYW50KCh1dWlkW29mZnNldCArIDhdICYgMHhlMCkgPj4gNSksXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcImJpbmFyeVwiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBpbmRleF8xLm5ld0Vycm9yKFwiVW5rbm93biB0eXBlIG9mIHV1aWRcIiwgXCJFUlJfVU5LTk9XTl9VVUlEX1RZUEVcIik7XG4gICAgfVxuICAgIC8vIHJlYWQgc3RyaW5naWZpZWQgdXVpZCBpbnRvIGEgQnVmZmVyXG4gICAgc3RhdGljIHBhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgxNik7XG4gICAgICAgIGxldCBqID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgICBidWZmZXJbaV0gPSBoZXgyYnl0ZVtpbnB1dFtqKytdICsgaW5wdXRbaisrXV07XG4gICAgICAgICAgICBpZiAoaSA9PT0gMyB8fCBpID09PSA1IHx8IGkgPT09IDcgfHwgaSA9PT0gOSkge1xuICAgICAgICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cbn1cbmV4cG9ydHMuVVVJRCA9IFVVSUQ7XG4vLyBmcm9tIHJmYzQxMjIjYXBwZW5kaXgtQ1xuVVVJRC5PSUQgPSBVVUlELnBhcnNlKFwiNmJhN2I4MTItOWRhZC0xMWQxLTgwYjQtMDBjMDRmZDQzMGM4XCIpO1xuLy8gYWNjb3JkaW5nIHRvIHJmYzQxMjIjc2VjdGlvbi00LjEuMVxuZnVuY3Rpb24gZ2V0VmFyaWFudChiaXRzKSB7XG4gICAgc3dpdGNoIChiaXRzKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gXCJuY3NcIjtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gXCJyZmM0MTIyXCI7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHJldHVybiBcIm1pY3Jvc29mdFwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFwiZnV0dXJlXCI7XG4gICAgfVxufVxudmFyIFV1aWRFbmNvZGluZztcbihmdW5jdGlvbiAoVXVpZEVuY29kaW5nKSB7XG4gICAgVXVpZEVuY29kaW5nW1V1aWRFbmNvZGluZ1tcIkFTQ0lJXCJdID0gMF0gPSBcIkFTQ0lJXCI7XG4gICAgVXVpZEVuY29kaW5nW1V1aWRFbmNvZGluZ1tcIkJJTkFSWVwiXSA9IDFdID0gXCJCSU5BUllcIjtcbiAgICBVdWlkRW5jb2RpbmdbVXVpZEVuY29kaW5nW1wiT0JKRUNUXCJdID0gMl0gPSBcIk9CSkVDVFwiO1xufSkoVXVpZEVuY29kaW5nIHx8IChVdWlkRW5jb2RpbmcgPSB7fSkpO1xuLy8gdjMgKyB2NVxuZnVuY3Rpb24gdXVpZE5hbWVkKG5hbWUsIGhhc2hNZXRob2QsIHZlcnNpb24sIG5hbWVzcGFjZSwgZW5jb2RpbmcgPSBVdWlkRW5jb2RpbmcuQVNDSUkpIHtcbiAgICBjb25zdCBoYXNoID0gY3J5cHRvXzEuY3JlYXRlSGFzaChoYXNoTWV0aG9kKTtcbiAgICBjb25zdCBuYW1lSXNOb3RBU3RyaW5nID0gdHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCI7XG4gICAgaWYgKG5hbWVJc05vdEFTdHJpbmcgJiYgIUJ1ZmZlci5pc0J1ZmZlcihuYW1lKSkge1xuICAgICAgICB0aHJvdyBpbmRleF8xLm5ld0Vycm9yKGludmFsaWROYW1lLCBcIkVSUl9JTlZBTElEX1VVSURfTkFNRVwiKTtcbiAgICB9XG4gICAgaGFzaC51cGRhdGUobmFtZXNwYWNlKTtcbiAgICBoYXNoLnVwZGF0ZShuYW1lKTtcbiAgICBjb25zdCBidWZmZXIgPSBoYXNoLmRpZ2VzdCgpO1xuICAgIGxldCByZXN1bHQ7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgICBjYXNlIFV1aWRFbmNvZGluZy5CSU5BUlk6XG4gICAgICAgICAgICBidWZmZXJbNl0gPSAoYnVmZmVyWzZdICYgMHgwZikgfCB2ZXJzaW9uO1xuICAgICAgICAgICAgYnVmZmVyWzhdID0gKGJ1ZmZlcls4XSAmIDB4M2YpIHwgMHg4MDtcbiAgICAgICAgICAgIHJlc3VsdCA9IGJ1ZmZlcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFV1aWRFbmNvZGluZy5PQkpFQ1Q6XG4gICAgICAgICAgICBidWZmZXJbNl0gPSAoYnVmZmVyWzZdICYgMHgwZikgfCB2ZXJzaW9uO1xuICAgICAgICAgICAgYnVmZmVyWzhdID0gKGJ1ZmZlcls4XSAmIDB4M2YpIHwgMHg4MDtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBVVUlEKGJ1ZmZlcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgYnl0ZTJoZXhbYnVmZmVyWzBdXSArXG4gICAgICAgICAgICAgICAgICAgIGJ5dGUyaGV4W2J1ZmZlclsxXV0gK1xuICAgICAgICAgICAgICAgICAgICBieXRlMmhleFtidWZmZXJbMl1dICtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZTJoZXhbYnVmZmVyWzNdXSArXG4gICAgICAgICAgICAgICAgICAgIFwiLVwiICtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZTJoZXhbYnVmZmVyWzRdXSArXG4gICAgICAgICAgICAgICAgICAgIGJ5dGUyaGV4W2J1ZmZlcls1XV0gK1xuICAgICAgICAgICAgICAgICAgICBcIi1cIiArXG4gICAgICAgICAgICAgICAgICAgIGJ5dGUyaGV4WyhidWZmZXJbNl0gJiAweDBmKSB8IHZlcnNpb25dICtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZTJoZXhbYnVmZmVyWzddXSArXG4gICAgICAgICAgICAgICAgICAgIFwiLVwiICtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZTJoZXhbKGJ1ZmZlcls4XSAmIDB4M2YpIHwgMHg4MF0gK1xuICAgICAgICAgICAgICAgICAgICBieXRlMmhleFtidWZmZXJbOV1dICtcbiAgICAgICAgICAgICAgICAgICAgXCItXCIgK1xuICAgICAgICAgICAgICAgICAgICBieXRlMmhleFtidWZmZXJbMTBdXSArXG4gICAgICAgICAgICAgICAgICAgIGJ5dGUyaGV4W2J1ZmZlclsxMV1dICtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZTJoZXhbYnVmZmVyWzEyXV0gK1xuICAgICAgICAgICAgICAgICAgICBieXRlMmhleFtidWZmZXJbMTNdXSArXG4gICAgICAgICAgICAgICAgICAgIGJ5dGUyaGV4W2J1ZmZlclsxNF1dICtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZTJoZXhbYnVmZmVyWzE1XV07XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeShidWZmZXIpIHtcbiAgICByZXR1cm4gKGJ5dGUyaGV4W2J1ZmZlclswXV0gK1xuICAgICAgICBieXRlMmhleFtidWZmZXJbMV1dICtcbiAgICAgICAgYnl0ZTJoZXhbYnVmZmVyWzJdXSArXG4gICAgICAgIGJ5dGUyaGV4W2J1ZmZlclszXV0gK1xuICAgICAgICBcIi1cIiArXG4gICAgICAgIGJ5dGUyaGV4W2J1ZmZlcls0XV0gK1xuICAgICAgICBieXRlMmhleFtidWZmZXJbNV1dICtcbiAgICAgICAgXCItXCIgK1xuICAgICAgICBieXRlMmhleFtidWZmZXJbNl1dICtcbiAgICAgICAgYnl0ZTJoZXhbYnVmZmVyWzddXSArXG4gICAgICAgIFwiLVwiICtcbiAgICAgICAgYnl0ZTJoZXhbYnVmZmVyWzhdXSArXG4gICAgICAgIGJ5dGUyaGV4W2J1ZmZlcls5XV0gK1xuICAgICAgICBcIi1cIiArXG4gICAgICAgIGJ5dGUyaGV4W2J1ZmZlclsxMF1dICtcbiAgICAgICAgYnl0ZTJoZXhbYnVmZmVyWzExXV0gK1xuICAgICAgICBieXRlMmhleFtidWZmZXJbMTJdXSArXG4gICAgICAgIGJ5dGUyaGV4W2J1ZmZlclsxM11dICtcbiAgICAgICAgYnl0ZTJoZXhbYnVmZmVyWzE0XV0gK1xuICAgICAgICBieXRlMmhleFtidWZmZXJbMTVdXSk7XG59XG4vLyBhY2NvcmRpbmcgdG8gcmZjNDEyMiNzZWN0aW9uLTQuMS43XG5leHBvcnRzLm5pbCA9IG5ldyBVVUlEKFwiMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwXCIpO1xuLy8gVVVJRC52NCA9IHV1aWRSYW5kb21cbi8vIFVVSUQudjRmYXN0ID0gdXVpZFJhbmRvbUZhc3Rcbi8vIFVVSUQudjMgPSBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuLy8gICAgIHJldHVybiB1dWlkTmFtZWQoXCJtZDVcIiwgMHgzMCwgb3B0aW9ucywgY2FsbGJhY2spXG4vLyB9XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dWlkLmpzLm1hcCIsIjsoZnVuY3Rpb24gKHNheCkgeyAvLyB3cmFwcGVyIGZvciBub24tbm9kZSBlbnZzXG4gIHNheC5wYXJzZXIgPSBmdW5jdGlvbiAoc3RyaWN0LCBvcHQpIHsgcmV0dXJuIG5ldyBTQVhQYXJzZXIoc3RyaWN0LCBvcHQpIH1cbiAgc2F4LlNBWFBhcnNlciA9IFNBWFBhcnNlclxuICBzYXguU0FYU3RyZWFtID0gU0FYU3RyZWFtXG4gIHNheC5jcmVhdGVTdHJlYW0gPSBjcmVhdGVTdHJlYW1cblxuICAvLyBXaGVuIHdlIHBhc3MgdGhlIE1BWF9CVUZGRVJfTEVOR1RIIHBvc2l0aW9uLCBzdGFydCBjaGVja2luZyBmb3IgYnVmZmVyIG92ZXJydW5zLlxuICAvLyBXaGVuIHdlIGNoZWNrLCBzY2hlZHVsZSB0aGUgbmV4dCBjaGVjayBmb3IgTUFYX0JVRkZFUl9MRU5HVEggLSAobWF4KGJ1ZmZlciBsZW5ndGhzKSksXG4gIC8vIHNpbmNlIHRoYXQncyB0aGUgZWFybGllc3QgdGhhdCBhIGJ1ZmZlciBvdmVycnVuIGNvdWxkIG9jY3VyLiAgVGhpcyB3YXksIGNoZWNrcyBhcmVcbiAgLy8gYXMgcmFyZSBhcyByZXF1aXJlZCwgYnV0IGFzIG9mdGVuIGFzIG5lY2Vzc2FyeSB0byBlbnN1cmUgbmV2ZXIgY3Jvc3NpbmcgdGhpcyBib3VuZC5cbiAgLy8gRnVydGhlcm1vcmUsIGJ1ZmZlcnMgYXJlIG9ubHkgdGVzdGVkIGF0IG1vc3Qgb25jZSBwZXIgd3JpdGUoKSwgc28gcGFzc2luZyBhIHZlcnlcbiAgLy8gbGFyZ2Ugc3RyaW5nIGludG8gd3JpdGUoKSBtaWdodCBoYXZlIHVuZGVzaXJhYmxlIGVmZmVjdHMsIGJ1dCB0aGlzIGlzIG1hbmFnZWFibGUgYnlcbiAgLy8gdGhlIGNhbGxlciwgc28gaXQgaXMgYXNzdW1lZCB0byBiZSBzYWZlLiAgVGh1cywgYSBjYWxsIHRvIHdyaXRlKCkgbWF5LCBpbiB0aGUgZXh0cmVtZVxuICAvLyBlZGdlIGNhc2UsIHJlc3VsdCBpbiBjcmVhdGluZyBhdCBtb3N0IG9uZSBjb21wbGV0ZSBjb3B5IG9mIHRoZSBzdHJpbmcgcGFzc2VkIGluLlxuICAvLyBTZXQgdG8gSW5maW5pdHkgdG8gaGF2ZSB1bmxpbWl0ZWQgYnVmZmVycy5cbiAgc2F4Lk1BWF9CVUZGRVJfTEVOR1RIID0gNjQgKiAxMDI0XG5cbiAgdmFyIGJ1ZmZlcnMgPSBbXG4gICAgJ2NvbW1lbnQnLCAnc2dtbERlY2wnLCAndGV4dE5vZGUnLCAndGFnTmFtZScsICdkb2N0eXBlJyxcbiAgICAncHJvY0luc3ROYW1lJywgJ3Byb2NJbnN0Qm9keScsICdlbnRpdHknLCAnYXR0cmliTmFtZScsXG4gICAgJ2F0dHJpYlZhbHVlJywgJ2NkYXRhJywgJ3NjcmlwdCdcbiAgXVxuXG4gIHNheC5FVkVOVFMgPSBbXG4gICAgJ3RleHQnLFxuICAgICdwcm9jZXNzaW5naW5zdHJ1Y3Rpb24nLFxuICAgICdzZ21sZGVjbGFyYXRpb24nLFxuICAgICdkb2N0eXBlJyxcbiAgICAnY29tbWVudCcsXG4gICAgJ29wZW50YWdzdGFydCcsXG4gICAgJ2F0dHJpYnV0ZScsXG4gICAgJ29wZW50YWcnLFxuICAgICdjbG9zZXRhZycsXG4gICAgJ29wZW5jZGF0YScsXG4gICAgJ2NkYXRhJyxcbiAgICAnY2xvc2VjZGF0YScsXG4gICAgJ2Vycm9yJyxcbiAgICAnZW5kJyxcbiAgICAncmVhZHknLFxuICAgICdzY3JpcHQnLFxuICAgICdvcGVubmFtZXNwYWNlJyxcbiAgICAnY2xvc2VuYW1lc3BhY2UnXG4gIF1cblxuICBmdW5jdGlvbiBTQVhQYXJzZXIgKHN0cmljdCwgb3B0KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNBWFBhcnNlcikpIHtcbiAgICAgIHJldHVybiBuZXcgU0FYUGFyc2VyKHN0cmljdCwgb3B0KVxuICAgIH1cblxuICAgIHZhciBwYXJzZXIgPSB0aGlzXG4gICAgY2xlYXJCdWZmZXJzKHBhcnNlcilcbiAgICBwYXJzZXIucSA9IHBhcnNlci5jID0gJydcbiAgICBwYXJzZXIuYnVmZmVyQ2hlY2tQb3NpdGlvbiA9IHNheC5NQVhfQlVGRkVSX0xFTkdUSFxuICAgIHBhcnNlci5vcHQgPSBvcHQgfHwge31cbiAgICBwYXJzZXIub3B0Lmxvd2VyY2FzZSA9IHBhcnNlci5vcHQubG93ZXJjYXNlIHx8IHBhcnNlci5vcHQubG93ZXJjYXNldGFnc1xuICAgIHBhcnNlci5sb29zZUNhc2UgPSBwYXJzZXIub3B0Lmxvd2VyY2FzZSA/ICd0b0xvd2VyQ2FzZScgOiAndG9VcHBlckNhc2UnXG4gICAgcGFyc2VyLnRhZ3MgPSBbXVxuICAgIHBhcnNlci5jbG9zZWQgPSBwYXJzZXIuY2xvc2VkUm9vdCA9IHBhcnNlci5zYXdSb290ID0gZmFsc2VcbiAgICBwYXJzZXIudGFnID0gcGFyc2VyLmVycm9yID0gbnVsbFxuICAgIHBhcnNlci5zdHJpY3QgPSAhIXN0cmljdFxuICAgIHBhcnNlci5ub3NjcmlwdCA9ICEhKHN0cmljdCB8fCBwYXJzZXIub3B0Lm5vc2NyaXB0KVxuICAgIHBhcnNlci5zdGF0ZSA9IFMuQkVHSU5cbiAgICBwYXJzZXIuc3RyaWN0RW50aXRpZXMgPSBwYXJzZXIub3B0LnN0cmljdEVudGl0aWVzXG4gICAgcGFyc2VyLkVOVElUSUVTID0gcGFyc2VyLnN0cmljdEVudGl0aWVzID8gT2JqZWN0LmNyZWF0ZShzYXguWE1MX0VOVElUSUVTKSA6IE9iamVjdC5jcmVhdGUoc2F4LkVOVElUSUVTKVxuICAgIHBhcnNlci5hdHRyaWJMaXN0ID0gW11cblxuICAgIC8vIG5hbWVzcGFjZXMgZm9ybSBhIHByb3RvdHlwZSBjaGFpbi5cbiAgICAvLyBpdCBhbHdheXMgcG9pbnRzIGF0IHRoZSBjdXJyZW50IHRhZyxcbiAgICAvLyB3aGljaCBwcm90b3MgdG8gaXRzIHBhcmVudCB0YWcuXG4gICAgaWYgKHBhcnNlci5vcHQueG1sbnMpIHtcbiAgICAgIHBhcnNlci5ucyA9IE9iamVjdC5jcmVhdGUocm9vdE5TKVxuICAgIH1cblxuICAgIC8vIG1vc3RseSBqdXN0IGZvciBlcnJvciByZXBvcnRpbmdcbiAgICBwYXJzZXIudHJhY2tQb3NpdGlvbiA9IHBhcnNlci5vcHQucG9zaXRpb24gIT09IGZhbHNlXG4gICAgaWYgKHBhcnNlci50cmFja1Bvc2l0aW9uKSB7XG4gICAgICBwYXJzZXIucG9zaXRpb24gPSBwYXJzZXIubGluZSA9IHBhcnNlci5jb2x1bW4gPSAwXG4gICAgfVxuICAgIGVtaXQocGFyc2VyLCAnb25yZWFkeScpXG4gIH1cblxuICBpZiAoIU9iamVjdC5jcmVhdGUpIHtcbiAgICBPYmplY3QuY3JlYXRlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIGZ1bmN0aW9uIEYgKCkge31cbiAgICAgIEYucHJvdG90eXBlID0gb1xuICAgICAgdmFyIG5ld2YgPSBuZXcgRigpXG4gICAgICByZXR1cm4gbmV3ZlxuICAgIH1cbiAgfVxuXG4gIGlmICghT2JqZWN0LmtleXMpIHtcbiAgICBPYmplY3Qua2V5cyA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgYSA9IFtdXG4gICAgICBmb3IgKHZhciBpIGluIG8pIGlmIChvLmhhc093blByb3BlcnR5KGkpKSBhLnB1c2goaSlcbiAgICAgIHJldHVybiBhXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tCdWZmZXJMZW5ndGggKHBhcnNlcikge1xuICAgIHZhciBtYXhBbGxvd2VkID0gTWF0aC5tYXgoc2F4Lk1BWF9CVUZGRVJfTEVOR1RILCAxMClcbiAgICB2YXIgbWF4QWN0dWFsID0gMFxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYnVmZmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBsZW4gPSBwYXJzZXJbYnVmZmVyc1tpXV0ubGVuZ3RoXG4gICAgICBpZiAobGVuID4gbWF4QWxsb3dlZCkge1xuICAgICAgICAvLyBUZXh0L2NkYXRhIG5vZGVzIGNhbiBnZXQgYmlnLCBhbmQgc2luY2UgdGhleSdyZSBidWZmZXJlZCxcbiAgICAgICAgLy8gd2UgY2FuIGdldCBoZXJlIHVuZGVyIG5vcm1hbCBjb25kaXRpb25zLlxuICAgICAgICAvLyBBdm9pZCBpc3N1ZXMgYnkgZW1pdHRpbmcgdGhlIHRleHQgbm9kZSBub3csXG4gICAgICAgIC8vIHNvIGF0IGxlYXN0IGl0IHdvbid0IGdldCBhbnkgYmlnZ2VyLlxuICAgICAgICBzd2l0Y2ggKGJ1ZmZlcnNbaV0pIHtcbiAgICAgICAgICBjYXNlICd0ZXh0Tm9kZSc6XG4gICAgICAgICAgICBjbG9zZVRleHQocGFyc2VyKVxuICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgIGNhc2UgJ2NkYXRhJzpcbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uY2RhdGEnLCBwYXJzZXIuY2RhdGEpXG4gICAgICAgICAgICBwYXJzZXIuY2RhdGEgPSAnJ1xuICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgIGNhc2UgJ3NjcmlwdCc6XG4gICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbnNjcmlwdCcsIHBhcnNlci5zY3JpcHQpXG4gICAgICAgICAgICBwYXJzZXIuc2NyaXB0ID0gJydcbiAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZXJyb3IocGFyc2VyLCAnTWF4IGJ1ZmZlciBsZW5ndGggZXhjZWVkZWQ6ICcgKyBidWZmZXJzW2ldKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtYXhBY3R1YWwgPSBNYXRoLm1heChtYXhBY3R1YWwsIGxlbilcbiAgICB9XG4gICAgLy8gc2NoZWR1bGUgdGhlIG5leHQgY2hlY2sgZm9yIHRoZSBlYXJsaWVzdCBwb3NzaWJsZSBidWZmZXIgb3ZlcnJ1bi5cbiAgICB2YXIgbSA9IHNheC5NQVhfQlVGRkVSX0xFTkdUSCAtIG1heEFjdHVhbFxuICAgIHBhcnNlci5idWZmZXJDaGVja1Bvc2l0aW9uID0gbSArIHBhcnNlci5wb3NpdGlvblxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJCdWZmZXJzIChwYXJzZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGJ1ZmZlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBwYXJzZXJbYnVmZmVyc1tpXV0gPSAnJ1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoQnVmZmVycyAocGFyc2VyKSB7XG4gICAgY2xvc2VUZXh0KHBhcnNlcilcbiAgICBpZiAocGFyc2VyLmNkYXRhICE9PSAnJykge1xuICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25jZGF0YScsIHBhcnNlci5jZGF0YSlcbiAgICAgIHBhcnNlci5jZGF0YSA9ICcnXG4gICAgfVxuICAgIGlmIChwYXJzZXIuc2NyaXB0ICE9PSAnJykge1xuICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25zY3JpcHQnLCBwYXJzZXIuc2NyaXB0KVxuICAgICAgcGFyc2VyLnNjcmlwdCA9ICcnXG4gICAgfVxuICB9XG5cbiAgU0FYUGFyc2VyLnByb3RvdHlwZSA9IHtcbiAgICBlbmQ6IGZ1bmN0aW9uICgpIHsgZW5kKHRoaXMpIH0sXG4gICAgd3JpdGU6IHdyaXRlLFxuICAgIHJlc3VtZTogZnVuY3Rpb24gKCkgeyB0aGlzLmVycm9yID0gbnVsbDsgcmV0dXJuIHRoaXMgfSxcbiAgICBjbG9zZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy53cml0ZShudWxsKSB9LFxuICAgIGZsdXNoOiBmdW5jdGlvbiAoKSB7IGZsdXNoQnVmZmVycyh0aGlzKSB9XG4gIH1cblxuICB2YXIgU3RyZWFtXG4gIHRyeSB7XG4gICAgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJykuU3RyZWFtXG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgU3RyZWFtID0gZnVuY3Rpb24gKCkge31cbiAgfVxuXG4gIHZhciBzdHJlYW1XcmFwcyA9IHNheC5FVkVOVFMuZmlsdGVyKGZ1bmN0aW9uIChldikge1xuICAgIHJldHVybiBldiAhPT0gJ2Vycm9yJyAmJiBldiAhPT0gJ2VuZCdcbiAgfSlcblxuICBmdW5jdGlvbiBjcmVhdGVTdHJlYW0gKHN0cmljdCwgb3B0KSB7XG4gICAgcmV0dXJuIG5ldyBTQVhTdHJlYW0oc3RyaWN0LCBvcHQpXG4gIH1cblxuICBmdW5jdGlvbiBTQVhTdHJlYW0gKHN0cmljdCwgb3B0KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNBWFN0cmVhbSkpIHtcbiAgICAgIHJldHVybiBuZXcgU0FYU3RyZWFtKHN0cmljdCwgb3B0KVxuICAgIH1cblxuICAgIFN0cmVhbS5hcHBseSh0aGlzKVxuXG4gICAgdGhpcy5fcGFyc2VyID0gbmV3IFNBWFBhcnNlcihzdHJpY3QsIG9wdClcbiAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZVxuICAgIHRoaXMucmVhZGFibGUgPSB0cnVlXG5cbiAgICB2YXIgbWUgPSB0aGlzXG5cbiAgICB0aGlzLl9wYXJzZXIub25lbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBtZS5lbWl0KCdlbmQnKVxuICAgIH1cblxuICAgIHRoaXMuX3BhcnNlci5vbmVycm9yID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgICBtZS5lbWl0KCdlcnJvcicsIGVyKVxuXG4gICAgICAvLyBpZiBkaWRuJ3QgdGhyb3csIHRoZW4gbWVhbnMgZXJyb3Igd2FzIGhhbmRsZWQuXG4gICAgICAvLyBnbyBhaGVhZCBhbmQgY2xlYXIgZXJyb3IsIHNvIHdlIGNhbiB3cml0ZSBhZ2Fpbi5cbiAgICAgIG1lLl9wYXJzZXIuZXJyb3IgPSBudWxsXG4gICAgfVxuXG4gICAgdGhpcy5fZGVjb2RlciA9IG51bGxcblxuICAgIHN0cmVhbVdyYXBzLmZvckVhY2goZnVuY3Rpb24gKGV2KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWUsICdvbicgKyBldiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gbWUuX3BhcnNlclsnb24nICsgZXZdXG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgICBpZiAoIWgpIHtcbiAgICAgICAgICAgIG1lLnJlbW92ZUFsbExpc3RlbmVycyhldilcbiAgICAgICAgICAgIG1lLl9wYXJzZXJbJ29uJyArIGV2XSA9IGhcbiAgICAgICAgICAgIHJldHVybiBoXG4gICAgICAgICAgfVxuICAgICAgICAgIG1lLm9uKGV2LCBoKVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBTQVhTdHJlYW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdHJlYW0ucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBTQVhTdHJlYW1cbiAgICB9XG4gIH0pXG5cbiAgU0FYU3RyZWFtLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIHR5cGVvZiBCdWZmZXIuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgaWYgKCF0aGlzLl9kZWNvZGVyKSB7XG4gICAgICAgIHZhciBTRCA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyJykuU3RyaW5nRGVjb2RlclxuICAgICAgICB0aGlzLl9kZWNvZGVyID0gbmV3IFNEKCd1dGY4JylcbiAgICAgIH1cbiAgICAgIGRhdGEgPSB0aGlzLl9kZWNvZGVyLndyaXRlKGRhdGEpXG4gICAgfVxuXG4gICAgdGhpcy5fcGFyc2VyLndyaXRlKGRhdGEudG9TdHJpbmcoKSlcbiAgICB0aGlzLmVtaXQoJ2RhdGEnLCBkYXRhKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBTQVhTdHJlYW0ucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHRoaXMud3JpdGUoY2h1bmspXG4gICAgfVxuICAgIHRoaXMuX3BhcnNlci5lbmQoKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBTQVhTdHJlYW0ucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBoYW5kbGVyKSB7XG4gICAgdmFyIG1lID0gdGhpc1xuICAgIGlmICghbWUuX3BhcnNlclsnb24nICsgZXZdICYmIHN0cmVhbVdyYXBzLmluZGV4T2YoZXYpICE9PSAtMSkge1xuICAgICAgbWUuX3BhcnNlclsnb24nICsgZXZdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBbYXJndW1lbnRzWzBdXSA6IEFycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgICAgICAgYXJncy5zcGxpY2UoMCwgMCwgZXYpXG4gICAgICAgIG1lLmVtaXQuYXBwbHkobWUsIGFyZ3MpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFN0cmVhbS5wcm90b3R5cGUub24uY2FsbChtZSwgZXYsIGhhbmRsZXIpXG4gIH1cblxuICAvLyB0aGlzIHJlYWxseSBuZWVkcyB0byBiZSByZXBsYWNlZCB3aXRoIGNoYXJhY3RlciBjbGFzc2VzLlxuICAvLyBYTUwgYWxsb3dzIGFsbCBtYW5uZXIgb2YgcmlkaWN1bG91cyBudW1iZXJzIGFuZCBkaWdpdHMuXG4gIHZhciBDREFUQSA9ICdbQ0RBVEFbJ1xuICB2YXIgRE9DVFlQRSA9ICdET0NUWVBFJ1xuICB2YXIgWE1MX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnXG4gIHZhciBYTUxOU19OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nXG4gIHZhciByb290TlMgPSB7IHhtbDogWE1MX05BTUVTUEFDRSwgeG1sbnM6IFhNTE5TX05BTUVTUEFDRSB9XG5cbiAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLXhtbC8jTlQtTmFtZVN0YXJ0Q2hhclxuICAvLyBUaGlzIGltcGxlbWVudGF0aW9uIHdvcmtzIG9uIHN0cmluZ3MsIGEgc2luZ2xlIGNoYXJhY3RlciBhdCBhIHRpbWVcbiAgLy8gYXMgc3VjaCwgaXQgY2Fubm90IGV2ZXIgc3VwcG9ydCBhc3RyYWwtcGxhbmUgY2hhcmFjdGVycyAoMTAwMDAtRUZGRkYpXG4gIC8vIHdpdGhvdXQgYSBzaWduaWZpY2FudCBicmVha2luZyBjaGFuZ2UgdG8gZWl0aGVyIHRoaXMgIHBhcnNlciwgb3IgdGhlXG4gIC8vIEphdmFTY3JpcHQgbGFuZ3VhZ2UuICBJbXBsZW1lbnRhdGlvbiBvZiBhbiBlbW9qaS1jYXBhYmxlIHhtbCBwYXJzZXJcbiAgLy8gaXMgbGVmdCBhcyBhbiBleGVyY2lzZSBmb3IgdGhlIHJlYWRlci5cbiAgdmFyIG5hbWVTdGFydCA9IC9bOl9BLVphLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRdL1xuXG4gIHZhciBuYW1lQm9keSA9IC9bOl9BLVphLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRcXHUwMEI3XFx1MDMwMC1cXHUwMzZGXFx1MjAzRi1cXHUyMDQwLlxcZC1dL1xuXG4gIHZhciBlbnRpdHlTdGFydCA9IC9bIzpfQS1aYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXS9cbiAgdmFyIGVudGl0eUJvZHkgPSAvWyM6X0EtWmEtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRFxcdTAwQjdcXHUwMzAwLVxcdTAzNkZcXHUyMDNGLVxcdTIwNDAuXFxkLV0vXG5cbiAgZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChjKSB7XG4gICAgcmV0dXJuIGMgPT09ICcgJyB8fCBjID09PSAnXFxuJyB8fCBjID09PSAnXFxyJyB8fCBjID09PSAnXFx0J1xuICB9XG5cbiAgZnVuY3Rpb24gaXNRdW90ZSAoYykge1xuICAgIHJldHVybiBjID09PSAnXCInIHx8IGMgPT09ICdcXCcnXG4gIH1cblxuICBmdW5jdGlvbiBpc0F0dHJpYkVuZCAoYykge1xuICAgIHJldHVybiBjID09PSAnPicgfHwgaXNXaGl0ZXNwYWNlKGMpXG4gIH1cblxuICBmdW5jdGlvbiBpc01hdGNoIChyZWdleCwgYykge1xuICAgIHJldHVybiByZWdleC50ZXN0KGMpXG4gIH1cblxuICBmdW5jdGlvbiBub3RNYXRjaCAocmVnZXgsIGMpIHtcbiAgICByZXR1cm4gIWlzTWF0Y2gocmVnZXgsIGMpXG4gIH1cblxuICB2YXIgUyA9IDBcbiAgc2F4LlNUQVRFID0ge1xuICAgIEJFR0lOOiBTKyssIC8vIGxlYWRpbmcgYnl0ZSBvcmRlciBtYXJrIG9yIHdoaXRlc3BhY2VcbiAgICBCRUdJTl9XSElURVNQQUNFOiBTKyssIC8vIGxlYWRpbmcgd2hpdGVzcGFjZVxuICAgIFRFWFQ6IFMrKywgLy8gZ2VuZXJhbCBzdHVmZlxuICAgIFRFWFRfRU5USVRZOiBTKyssIC8vICZhbXAgYW5kIHN1Y2guXG4gICAgT1BFTl9XQUtBOiBTKyssIC8vIDxcbiAgICBTR01MX0RFQ0w6IFMrKywgLy8gPCFCTEFSR1xuICAgIFNHTUxfREVDTF9RVU9URUQ6IFMrKywgLy8gPCFCTEFSRyBmb28gXCJiYXJcbiAgICBET0NUWVBFOiBTKyssIC8vIDwhRE9DVFlQRVxuICAgIERPQ1RZUEVfUVVPVEVEOiBTKyssIC8vIDwhRE9DVFlQRSBcIi8vYmxhaFxuICAgIERPQ1RZUEVfRFREOiBTKyssIC8vIDwhRE9DVFlQRSBcIi8vYmxhaFwiIFsgLi4uXG4gICAgRE9DVFlQRV9EVERfUVVPVEVEOiBTKyssIC8vIDwhRE9DVFlQRSBcIi8vYmxhaFwiIFsgXCJmb29cbiAgICBDT01NRU5UX1NUQVJUSU5HOiBTKyssIC8vIDwhLVxuICAgIENPTU1FTlQ6IFMrKywgLy8gPCEtLVxuICAgIENPTU1FTlRfRU5ESU5HOiBTKyssIC8vIDwhLS0gYmxhaCAtXG4gICAgQ09NTUVOVF9FTkRFRDogUysrLCAvLyA8IS0tIGJsYWggLS1cbiAgICBDREFUQTogUysrLCAvLyA8IVtDREFUQVsgc29tZXRoaW5nXG4gICAgQ0RBVEFfRU5ESU5HOiBTKyssIC8vIF1cbiAgICBDREFUQV9FTkRJTkdfMjogUysrLCAvLyBdXVxuICAgIFBST0NfSU5TVDogUysrLCAvLyA8P2hpXG4gICAgUFJPQ19JTlNUX0JPRFk6IFMrKywgLy8gPD9oaSB0aGVyZVxuICAgIFBST0NfSU5TVF9FTkRJTkc6IFMrKywgLy8gPD9oaSBcInRoZXJlXCIgP1xuICAgIE9QRU5fVEFHOiBTKyssIC8vIDxzdHJvbmdcbiAgICBPUEVOX1RBR19TTEFTSDogUysrLCAvLyA8c3Ryb25nIC9cbiAgICBBVFRSSUI6IFMrKywgLy8gPGFcbiAgICBBVFRSSUJfTkFNRTogUysrLCAvLyA8YSBmb29cbiAgICBBVFRSSUJfTkFNRV9TQVdfV0hJVEU6IFMrKywgLy8gPGEgZm9vIF9cbiAgICBBVFRSSUJfVkFMVUU6IFMrKywgLy8gPGEgZm9vPVxuICAgIEFUVFJJQl9WQUxVRV9RVU9URUQ6IFMrKywgLy8gPGEgZm9vPVwiYmFyXG4gICAgQVRUUklCX1ZBTFVFX0NMT1NFRDogUysrLCAvLyA8YSBmb289XCJiYXJcIlxuICAgIEFUVFJJQl9WQUxVRV9VTlFVT1RFRDogUysrLCAvLyA8YSBmb289YmFyXG4gICAgQVRUUklCX1ZBTFVFX0VOVElUWV9ROiBTKyssIC8vIDxmb28gYmFyPVwiJnF1b3Q7XCJcbiAgICBBVFRSSUJfVkFMVUVfRU5USVRZX1U6IFMrKywgLy8gPGZvbyBiYXI9JnF1b3RcbiAgICBDTE9TRV9UQUc6IFMrKywgLy8gPC9hXG4gICAgQ0xPU0VfVEFHX1NBV19XSElURTogUysrLCAvLyA8L2EgICA+XG4gICAgU0NSSVBUOiBTKyssIC8vIDxzY3JpcHQ+IC4uLlxuICAgIFNDUklQVF9FTkRJTkc6IFMrKyAvLyA8c2NyaXB0PiAuLi4gPFxuICB9XG5cbiAgc2F4LlhNTF9FTlRJVElFUyA9IHtcbiAgICAnYW1wJzogJyYnLFxuICAgICdndCc6ICc+JyxcbiAgICAnbHQnOiAnPCcsXG4gICAgJ3F1b3QnOiAnXCInLFxuICAgICdhcG9zJzogXCInXCJcbiAgfVxuXG4gIHNheC5FTlRJVElFUyA9IHtcbiAgICAnYW1wJzogJyYnLFxuICAgICdndCc6ICc+JyxcbiAgICAnbHQnOiAnPCcsXG4gICAgJ3F1b3QnOiAnXCInLFxuICAgICdhcG9zJzogXCInXCIsXG4gICAgJ0FFbGlnJzogMTk4LFxuICAgICdBYWN1dGUnOiAxOTMsXG4gICAgJ0FjaXJjJzogMTk0LFxuICAgICdBZ3JhdmUnOiAxOTIsXG4gICAgJ0FyaW5nJzogMTk3LFxuICAgICdBdGlsZGUnOiAxOTUsXG4gICAgJ0F1bWwnOiAxOTYsXG4gICAgJ0NjZWRpbCc6IDE5OSxcbiAgICAnRVRIJzogMjA4LFxuICAgICdFYWN1dGUnOiAyMDEsXG4gICAgJ0VjaXJjJzogMjAyLFxuICAgICdFZ3JhdmUnOiAyMDAsXG4gICAgJ0V1bWwnOiAyMDMsXG4gICAgJ0lhY3V0ZSc6IDIwNSxcbiAgICAnSWNpcmMnOiAyMDYsXG4gICAgJ0lncmF2ZSc6IDIwNCxcbiAgICAnSXVtbCc6IDIwNyxcbiAgICAnTnRpbGRlJzogMjA5LFxuICAgICdPYWN1dGUnOiAyMTEsXG4gICAgJ09jaXJjJzogMjEyLFxuICAgICdPZ3JhdmUnOiAyMTAsXG4gICAgJ09zbGFzaCc6IDIxNixcbiAgICAnT3RpbGRlJzogMjEzLFxuICAgICdPdW1sJzogMjE0LFxuICAgICdUSE9STic6IDIyMixcbiAgICAnVWFjdXRlJzogMjE4LFxuICAgICdVY2lyYyc6IDIxOSxcbiAgICAnVWdyYXZlJzogMjE3LFxuICAgICdVdW1sJzogMjIwLFxuICAgICdZYWN1dGUnOiAyMjEsXG4gICAgJ2FhY3V0ZSc6IDIyNSxcbiAgICAnYWNpcmMnOiAyMjYsXG4gICAgJ2FlbGlnJzogMjMwLFxuICAgICdhZ3JhdmUnOiAyMjQsXG4gICAgJ2FyaW5nJzogMjI5LFxuICAgICdhdGlsZGUnOiAyMjcsXG4gICAgJ2F1bWwnOiAyMjgsXG4gICAgJ2NjZWRpbCc6IDIzMSxcbiAgICAnZWFjdXRlJzogMjMzLFxuICAgICdlY2lyYyc6IDIzNCxcbiAgICAnZWdyYXZlJzogMjMyLFxuICAgICdldGgnOiAyNDAsXG4gICAgJ2V1bWwnOiAyMzUsXG4gICAgJ2lhY3V0ZSc6IDIzNyxcbiAgICAnaWNpcmMnOiAyMzgsXG4gICAgJ2lncmF2ZSc6IDIzNixcbiAgICAnaXVtbCc6IDIzOSxcbiAgICAnbnRpbGRlJzogMjQxLFxuICAgICdvYWN1dGUnOiAyNDMsXG4gICAgJ29jaXJjJzogMjQ0LFxuICAgICdvZ3JhdmUnOiAyNDIsXG4gICAgJ29zbGFzaCc6IDI0OCxcbiAgICAnb3RpbGRlJzogMjQ1LFxuICAgICdvdW1sJzogMjQ2LFxuICAgICdzemxpZyc6IDIyMyxcbiAgICAndGhvcm4nOiAyNTQsXG4gICAgJ3VhY3V0ZSc6IDI1MCxcbiAgICAndWNpcmMnOiAyNTEsXG4gICAgJ3VncmF2ZSc6IDI0OSxcbiAgICAndXVtbCc6IDI1MixcbiAgICAneWFjdXRlJzogMjUzLFxuICAgICd5dW1sJzogMjU1LFxuICAgICdjb3B5JzogMTY5LFxuICAgICdyZWcnOiAxNzQsXG4gICAgJ25ic3AnOiAxNjAsXG4gICAgJ2lleGNsJzogMTYxLFxuICAgICdjZW50JzogMTYyLFxuICAgICdwb3VuZCc6IDE2MyxcbiAgICAnY3VycmVuJzogMTY0LFxuICAgICd5ZW4nOiAxNjUsXG4gICAgJ2JydmJhcic6IDE2NixcbiAgICAnc2VjdCc6IDE2NyxcbiAgICAndW1sJzogMTY4LFxuICAgICdvcmRmJzogMTcwLFxuICAgICdsYXF1byc6IDE3MSxcbiAgICAnbm90JzogMTcyLFxuICAgICdzaHknOiAxNzMsXG4gICAgJ21hY3InOiAxNzUsXG4gICAgJ2RlZyc6IDE3NixcbiAgICAncGx1c21uJzogMTc3LFxuICAgICdzdXAxJzogMTg1LFxuICAgICdzdXAyJzogMTc4LFxuICAgICdzdXAzJzogMTc5LFxuICAgICdhY3V0ZSc6IDE4MCxcbiAgICAnbWljcm8nOiAxODEsXG4gICAgJ3BhcmEnOiAxODIsXG4gICAgJ21pZGRvdCc6IDE4MyxcbiAgICAnY2VkaWwnOiAxODQsXG4gICAgJ29yZG0nOiAxODYsXG4gICAgJ3JhcXVvJzogMTg3LFxuICAgICdmcmFjMTQnOiAxODgsXG4gICAgJ2ZyYWMxMic6IDE4OSxcbiAgICAnZnJhYzM0JzogMTkwLFxuICAgICdpcXVlc3QnOiAxOTEsXG4gICAgJ3RpbWVzJzogMjE1LFxuICAgICdkaXZpZGUnOiAyNDcsXG4gICAgJ09FbGlnJzogMzM4LFxuICAgICdvZWxpZyc6IDMzOSxcbiAgICAnU2Nhcm9uJzogMzUyLFxuICAgICdzY2Fyb24nOiAzNTMsXG4gICAgJ1l1bWwnOiAzNzYsXG4gICAgJ2Zub2YnOiA0MDIsXG4gICAgJ2NpcmMnOiA3MTAsXG4gICAgJ3RpbGRlJzogNzMyLFxuICAgICdBbHBoYSc6IDkxMyxcbiAgICAnQmV0YSc6IDkxNCxcbiAgICAnR2FtbWEnOiA5MTUsXG4gICAgJ0RlbHRhJzogOTE2LFxuICAgICdFcHNpbG9uJzogOTE3LFxuICAgICdaZXRhJzogOTE4LFxuICAgICdFdGEnOiA5MTksXG4gICAgJ1RoZXRhJzogOTIwLFxuICAgICdJb3RhJzogOTIxLFxuICAgICdLYXBwYSc6IDkyMixcbiAgICAnTGFtYmRhJzogOTIzLFxuICAgICdNdSc6IDkyNCxcbiAgICAnTnUnOiA5MjUsXG4gICAgJ1hpJzogOTI2LFxuICAgICdPbWljcm9uJzogOTI3LFxuICAgICdQaSc6IDkyOCxcbiAgICAnUmhvJzogOTI5LFxuICAgICdTaWdtYSc6IDkzMSxcbiAgICAnVGF1JzogOTMyLFxuICAgICdVcHNpbG9uJzogOTMzLFxuICAgICdQaGknOiA5MzQsXG4gICAgJ0NoaSc6IDkzNSxcbiAgICAnUHNpJzogOTM2LFxuICAgICdPbWVnYSc6IDkzNyxcbiAgICAnYWxwaGEnOiA5NDUsXG4gICAgJ2JldGEnOiA5NDYsXG4gICAgJ2dhbW1hJzogOTQ3LFxuICAgICdkZWx0YSc6IDk0OCxcbiAgICAnZXBzaWxvbic6IDk0OSxcbiAgICAnemV0YSc6IDk1MCxcbiAgICAnZXRhJzogOTUxLFxuICAgICd0aGV0YSc6IDk1MixcbiAgICAnaW90YSc6IDk1MyxcbiAgICAna2FwcGEnOiA5NTQsXG4gICAgJ2xhbWJkYSc6IDk1NSxcbiAgICAnbXUnOiA5NTYsXG4gICAgJ251JzogOTU3LFxuICAgICd4aSc6IDk1OCxcbiAgICAnb21pY3Jvbic6IDk1OSxcbiAgICAncGknOiA5NjAsXG4gICAgJ3Jobyc6IDk2MSxcbiAgICAnc2lnbWFmJzogOTYyLFxuICAgICdzaWdtYSc6IDk2MyxcbiAgICAndGF1JzogOTY0LFxuICAgICd1cHNpbG9uJzogOTY1LFxuICAgICdwaGknOiA5NjYsXG4gICAgJ2NoaSc6IDk2NyxcbiAgICAncHNpJzogOTY4LFxuICAgICdvbWVnYSc6IDk2OSxcbiAgICAndGhldGFzeW0nOiA5NzcsXG4gICAgJ3Vwc2loJzogOTc4LFxuICAgICdwaXYnOiA5ODIsXG4gICAgJ2Vuc3AnOiA4MTk0LFxuICAgICdlbXNwJzogODE5NSxcbiAgICAndGhpbnNwJzogODIwMSxcbiAgICAnenduaic6IDgyMDQsXG4gICAgJ3p3aic6IDgyMDUsXG4gICAgJ2xybSc6IDgyMDYsXG4gICAgJ3JsbSc6IDgyMDcsXG4gICAgJ25kYXNoJzogODIxMSxcbiAgICAnbWRhc2gnOiA4MjEyLFxuICAgICdsc3F1byc6IDgyMTYsXG4gICAgJ3JzcXVvJzogODIxNyxcbiAgICAnc2JxdW8nOiA4MjE4LFxuICAgICdsZHF1byc6IDgyMjAsXG4gICAgJ3JkcXVvJzogODIyMSxcbiAgICAnYmRxdW8nOiA4MjIyLFxuICAgICdkYWdnZXInOiA4MjI0LFxuICAgICdEYWdnZXInOiA4MjI1LFxuICAgICdidWxsJzogODIyNixcbiAgICAnaGVsbGlwJzogODIzMCxcbiAgICAncGVybWlsJzogODI0MCxcbiAgICAncHJpbWUnOiA4MjQyLFxuICAgICdQcmltZSc6IDgyNDMsXG4gICAgJ2xzYXF1byc6IDgyNDksXG4gICAgJ3JzYXF1byc6IDgyNTAsXG4gICAgJ29saW5lJzogODI1NCxcbiAgICAnZnJhc2wnOiA4MjYwLFxuICAgICdldXJvJzogODM2NCxcbiAgICAnaW1hZ2UnOiA4NDY1LFxuICAgICd3ZWllcnAnOiA4NDcyLFxuICAgICdyZWFsJzogODQ3NixcbiAgICAndHJhZGUnOiA4NDgyLFxuICAgICdhbGVmc3ltJzogODUwMSxcbiAgICAnbGFycic6IDg1OTIsXG4gICAgJ3VhcnInOiA4NTkzLFxuICAgICdyYXJyJzogODU5NCxcbiAgICAnZGFycic6IDg1OTUsXG4gICAgJ2hhcnInOiA4NTk2LFxuICAgICdjcmFycic6IDg2MjksXG4gICAgJ2xBcnInOiA4NjU2LFxuICAgICd1QXJyJzogODY1NyxcbiAgICAnckFycic6IDg2NTgsXG4gICAgJ2RBcnInOiA4NjU5LFxuICAgICdoQXJyJzogODY2MCxcbiAgICAnZm9yYWxsJzogODcwNCxcbiAgICAncGFydCc6IDg3MDYsXG4gICAgJ2V4aXN0JzogODcwNyxcbiAgICAnZW1wdHknOiA4NzA5LFxuICAgICduYWJsYSc6IDg3MTEsXG4gICAgJ2lzaW4nOiA4NzEyLFxuICAgICdub3Rpbic6IDg3MTMsXG4gICAgJ25pJzogODcxNSxcbiAgICAncHJvZCc6IDg3MTksXG4gICAgJ3N1bSc6IDg3MjEsXG4gICAgJ21pbnVzJzogODcyMixcbiAgICAnbG93YXN0JzogODcyNyxcbiAgICAncmFkaWMnOiA4NzMwLFxuICAgICdwcm9wJzogODczMyxcbiAgICAnaW5maW4nOiA4NzM0LFxuICAgICdhbmcnOiA4NzM2LFxuICAgICdhbmQnOiA4NzQzLFxuICAgICdvcic6IDg3NDQsXG4gICAgJ2NhcCc6IDg3NDUsXG4gICAgJ2N1cCc6IDg3NDYsXG4gICAgJ2ludCc6IDg3NDcsXG4gICAgJ3RoZXJlNCc6IDg3NTYsXG4gICAgJ3NpbSc6IDg3NjQsXG4gICAgJ2NvbmcnOiA4NzczLFxuICAgICdhc3ltcCc6IDg3NzYsXG4gICAgJ25lJzogODgwMCxcbiAgICAnZXF1aXYnOiA4ODAxLFxuICAgICdsZSc6IDg4MDQsXG4gICAgJ2dlJzogODgwNSxcbiAgICAnc3ViJzogODgzNCxcbiAgICAnc3VwJzogODgzNSxcbiAgICAnbnN1Yic6IDg4MzYsXG4gICAgJ3N1YmUnOiA4ODM4LFxuICAgICdzdXBlJzogODgzOSxcbiAgICAnb3BsdXMnOiA4ODUzLFxuICAgICdvdGltZXMnOiA4ODU1LFxuICAgICdwZXJwJzogODg2OSxcbiAgICAnc2RvdCc6IDg5MDEsXG4gICAgJ2xjZWlsJzogODk2OCxcbiAgICAncmNlaWwnOiA4OTY5LFxuICAgICdsZmxvb3InOiA4OTcwLFxuICAgICdyZmxvb3InOiA4OTcxLFxuICAgICdsYW5nJzogOTAwMSxcbiAgICAncmFuZyc6IDkwMDIsXG4gICAgJ2xveic6IDk2NzQsXG4gICAgJ3NwYWRlcyc6IDk4MjQsXG4gICAgJ2NsdWJzJzogOTgyNyxcbiAgICAnaGVhcnRzJzogOTgyOSxcbiAgICAnZGlhbXMnOiA5ODMwXG4gIH1cblxuICBPYmplY3Qua2V5cyhzYXguRU5USVRJRVMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBlID0gc2F4LkVOVElUSUVTW2tleV1cbiAgICB2YXIgcyA9IHR5cGVvZiBlID09PSAnbnVtYmVyJyA/IFN0cmluZy5mcm9tQ2hhckNvZGUoZSkgOiBlXG4gICAgc2F4LkVOVElUSUVTW2tleV0gPSBzXG4gIH0pXG5cbiAgZm9yICh2YXIgcyBpbiBzYXguU1RBVEUpIHtcbiAgICBzYXguU1RBVEVbc2F4LlNUQVRFW3NdXSA9IHNcbiAgfVxuXG4gIC8vIHNob3J0aGFuZFxuICBTID0gc2F4LlNUQVRFXG5cbiAgZnVuY3Rpb24gZW1pdCAocGFyc2VyLCBldmVudCwgZGF0YSkge1xuICAgIHBhcnNlcltldmVudF0gJiYgcGFyc2VyW2V2ZW50XShkYXRhKVxuICB9XG5cbiAgZnVuY3Rpb24gZW1pdE5vZGUgKHBhcnNlciwgbm9kZVR5cGUsIGRhdGEpIHtcbiAgICBpZiAocGFyc2VyLnRleHROb2RlKSBjbG9zZVRleHQocGFyc2VyKVxuICAgIGVtaXQocGFyc2VyLCBub2RlVHlwZSwgZGF0YSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlVGV4dCAocGFyc2VyKSB7XG4gICAgcGFyc2VyLnRleHROb2RlID0gdGV4dG9wdHMocGFyc2VyLm9wdCwgcGFyc2VyLnRleHROb2RlKVxuICAgIGlmIChwYXJzZXIudGV4dE5vZGUpIGVtaXQocGFyc2VyLCAnb250ZXh0JywgcGFyc2VyLnRleHROb2RlKVxuICAgIHBhcnNlci50ZXh0Tm9kZSA9ICcnXG4gIH1cblxuICBmdW5jdGlvbiB0ZXh0b3B0cyAob3B0LCB0ZXh0KSB7XG4gICAgaWYgKG9wdC50cmltKSB0ZXh0ID0gdGV4dC50cmltKClcbiAgICBpZiAob3B0Lm5vcm1hbGl6ZSkgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxzKy9nLCAnICcpXG4gICAgcmV0dXJuIHRleHRcbiAgfVxuXG4gIGZ1bmN0aW9uIGVycm9yIChwYXJzZXIsIGVyKSB7XG4gICAgY2xvc2VUZXh0KHBhcnNlcilcbiAgICBpZiAocGFyc2VyLnRyYWNrUG9zaXRpb24pIHtcbiAgICAgIGVyICs9ICdcXG5MaW5lOiAnICsgcGFyc2VyLmxpbmUgK1xuICAgICAgICAnXFxuQ29sdW1uOiAnICsgcGFyc2VyLmNvbHVtbiArXG4gICAgICAgICdcXG5DaGFyOiAnICsgcGFyc2VyLmNcbiAgICB9XG4gICAgZXIgPSBuZXcgRXJyb3IoZXIpXG4gICAgcGFyc2VyLmVycm9yID0gZXJcbiAgICBlbWl0KHBhcnNlciwgJ29uZXJyb3InLCBlcilcbiAgICByZXR1cm4gcGFyc2VyXG4gIH1cblxuICBmdW5jdGlvbiBlbmQgKHBhcnNlcikge1xuICAgIGlmIChwYXJzZXIuc2F3Um9vdCAmJiAhcGFyc2VyLmNsb3NlZFJvb3QpIHN0cmljdEZhaWwocGFyc2VyLCAnVW5jbG9zZWQgcm9vdCB0YWcnKVxuICAgIGlmICgocGFyc2VyLnN0YXRlICE9PSBTLkJFR0lOKSAmJlxuICAgICAgKHBhcnNlci5zdGF0ZSAhPT0gUy5CRUdJTl9XSElURVNQQUNFKSAmJlxuICAgICAgKHBhcnNlci5zdGF0ZSAhPT0gUy5URVhUKSkge1xuICAgICAgZXJyb3IocGFyc2VyLCAnVW5leHBlY3RlZCBlbmQnKVxuICAgIH1cbiAgICBjbG9zZVRleHQocGFyc2VyKVxuICAgIHBhcnNlci5jID0gJydcbiAgICBwYXJzZXIuY2xvc2VkID0gdHJ1ZVxuICAgIGVtaXQocGFyc2VyLCAnb25lbmQnKVxuICAgIFNBWFBhcnNlci5jYWxsKHBhcnNlciwgcGFyc2VyLnN0cmljdCwgcGFyc2VyLm9wdClcbiAgICByZXR1cm4gcGFyc2VyXG4gIH1cblxuICBmdW5jdGlvbiBzdHJpY3RGYWlsIChwYXJzZXIsIG1lc3NhZ2UpIHtcbiAgICBpZiAodHlwZW9mIHBhcnNlciAhPT0gJ29iamVjdCcgfHwgIShwYXJzZXIgaW5zdGFuY2VvZiBTQVhQYXJzZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBjYWxsIHRvIHN0cmljdEZhaWwnKVxuICAgIH1cbiAgICBpZiAocGFyc2VyLnN0cmljdCkge1xuICAgICAgZXJyb3IocGFyc2VyLCBtZXNzYWdlKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5ld1RhZyAocGFyc2VyKSB7XG4gICAgaWYgKCFwYXJzZXIuc3RyaWN0KSBwYXJzZXIudGFnTmFtZSA9IHBhcnNlci50YWdOYW1lW3BhcnNlci5sb29zZUNhc2VdKClcbiAgICB2YXIgcGFyZW50ID0gcGFyc2VyLnRhZ3NbcGFyc2VyLnRhZ3MubGVuZ3RoIC0gMV0gfHwgcGFyc2VyXG4gICAgdmFyIHRhZyA9IHBhcnNlci50YWcgPSB7IG5hbWU6IHBhcnNlci50YWdOYW1lLCBhdHRyaWJ1dGVzOiB7fSB9XG5cbiAgICAvLyB3aWxsIGJlIG92ZXJyaWRkZW4gaWYgdGFnIGNvbnRhaWxzIGFuIHhtbG5zPVwiZm9vXCIgb3IgeG1sbnM6Zm9vPVwiYmFyXCJcbiAgICBpZiAocGFyc2VyLm9wdC54bWxucykge1xuICAgICAgdGFnLm5zID0gcGFyZW50Lm5zXG4gICAgfVxuICAgIHBhcnNlci5hdHRyaWJMaXN0Lmxlbmd0aCA9IDBcbiAgICBlbWl0Tm9kZShwYXJzZXIsICdvbm9wZW50YWdzdGFydCcsIHRhZylcbiAgfVxuXG4gIGZ1bmN0aW9uIHFuYW1lIChuYW1lLCBhdHRyaWJ1dGUpIHtcbiAgICB2YXIgaSA9IG5hbWUuaW5kZXhPZignOicpXG4gICAgdmFyIHF1YWxOYW1lID0gaSA8IDAgPyBbICcnLCBuYW1lIF0gOiBuYW1lLnNwbGl0KCc6JylcbiAgICB2YXIgcHJlZml4ID0gcXVhbE5hbWVbMF1cbiAgICB2YXIgbG9jYWwgPSBxdWFsTmFtZVsxXVxuXG4gICAgLy8gPHggXCJ4bWxuc1wiPVwiaHR0cDovL2Zvb1wiPlxuICAgIGlmIChhdHRyaWJ1dGUgJiYgbmFtZSA9PT0gJ3htbG5zJykge1xuICAgICAgcHJlZml4ID0gJ3htbG5zJ1xuICAgICAgbG9jYWwgPSAnJ1xuICAgIH1cblxuICAgIHJldHVybiB7IHByZWZpeDogcHJlZml4LCBsb2NhbDogbG9jYWwgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXR0cmliIChwYXJzZXIpIHtcbiAgICBpZiAoIXBhcnNlci5zdHJpY3QpIHtcbiAgICAgIHBhcnNlci5hdHRyaWJOYW1lID0gcGFyc2VyLmF0dHJpYk5hbWVbcGFyc2VyLmxvb3NlQ2FzZV0oKVxuICAgIH1cblxuICAgIGlmIChwYXJzZXIuYXR0cmliTGlzdC5pbmRleE9mKHBhcnNlci5hdHRyaWJOYW1lKSAhPT0gLTEgfHxcbiAgICAgIHBhcnNlci50YWcuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShwYXJzZXIuYXR0cmliTmFtZSkpIHtcbiAgICAgIHBhcnNlci5hdHRyaWJOYW1lID0gcGFyc2VyLmF0dHJpYlZhbHVlID0gJydcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChwYXJzZXIub3B0LnhtbG5zKSB7XG4gICAgICB2YXIgcW4gPSBxbmFtZShwYXJzZXIuYXR0cmliTmFtZSwgdHJ1ZSlcbiAgICAgIHZhciBwcmVmaXggPSBxbi5wcmVmaXhcbiAgICAgIHZhciBsb2NhbCA9IHFuLmxvY2FsXG5cbiAgICAgIGlmIChwcmVmaXggPT09ICd4bWxucycpIHtcbiAgICAgICAgLy8gbmFtZXNwYWNlIGJpbmRpbmcgYXR0cmlidXRlLiBwdXNoIHRoZSBiaW5kaW5nIGludG8gc2NvcGVcbiAgICAgICAgaWYgKGxvY2FsID09PSAneG1sJyAmJiBwYXJzZXIuYXR0cmliVmFsdWUgIT09IFhNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlcixcbiAgICAgICAgICAgICd4bWw6IHByZWZpeCBtdXN0IGJlIGJvdW5kIHRvICcgKyBYTUxfTkFNRVNQQUNFICsgJ1xcbicgK1xuICAgICAgICAgICAgJ0FjdHVhbDogJyArIHBhcnNlci5hdHRyaWJWYWx1ZSlcbiAgICAgICAgfSBlbHNlIGlmIChsb2NhbCA9PT0gJ3htbG5zJyAmJiBwYXJzZXIuYXR0cmliVmFsdWUgIT09IFhNTE5TX05BTUVTUEFDRSkge1xuICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLFxuICAgICAgICAgICAgJ3htbG5zOiBwcmVmaXggbXVzdCBiZSBib3VuZCB0byAnICsgWE1MTlNfTkFNRVNQQUNFICsgJ1xcbicgK1xuICAgICAgICAgICAgJ0FjdHVhbDogJyArIHBhcnNlci5hdHRyaWJWYWx1ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdGFnID0gcGFyc2VyLnRhZ1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBwYXJzZXIudGFnc1twYXJzZXIudGFncy5sZW5ndGggLSAxXSB8fCBwYXJzZXJcbiAgICAgICAgICBpZiAodGFnLm5zID09PSBwYXJlbnQubnMpIHtcbiAgICAgICAgICAgIHRhZy5ucyA9IE9iamVjdC5jcmVhdGUocGFyZW50Lm5zKVxuICAgICAgICAgIH1cbiAgICAgICAgICB0YWcubnNbbG9jYWxdID0gcGFyc2VyLmF0dHJpYlZhbHVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZGVmZXIgb25hdHRyaWJ1dGUgZXZlbnRzIHVudGlsIGFsbCBhdHRyaWJ1dGVzIGhhdmUgYmVlbiBzZWVuXG4gICAgICAvLyBzbyBhbnkgbmV3IGJpbmRpbmdzIGNhbiB0YWtlIGVmZmVjdC4gcHJlc2VydmUgYXR0cmlidXRlIG9yZGVyXG4gICAgICAvLyBzbyBkZWZlcnJlZCBldmVudHMgY2FuIGJlIGVtaXR0ZWQgaW4gZG9jdW1lbnQgb3JkZXJcbiAgICAgIHBhcnNlci5hdHRyaWJMaXN0LnB1c2goW3BhcnNlci5hdHRyaWJOYW1lLCBwYXJzZXIuYXR0cmliVmFsdWVdKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbiBub24teG1sbnMgbW9kZSwgd2UgY2FuIGVtaXQgdGhlIGV2ZW50IHJpZ2h0IGF3YXlcbiAgICAgIHBhcnNlci50YWcuYXR0cmlidXRlc1twYXJzZXIuYXR0cmliTmFtZV0gPSBwYXJzZXIuYXR0cmliVmFsdWVcbiAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uYXR0cmlidXRlJywge1xuICAgICAgICBuYW1lOiBwYXJzZXIuYXR0cmliTmFtZSxcbiAgICAgICAgdmFsdWU6IHBhcnNlci5hdHRyaWJWYWx1ZVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBwYXJzZXIuYXR0cmliTmFtZSA9IHBhcnNlci5hdHRyaWJWYWx1ZSA9ICcnXG4gIH1cblxuICBmdW5jdGlvbiBvcGVuVGFnIChwYXJzZXIsIHNlbGZDbG9zaW5nKSB7XG4gICAgaWYgKHBhcnNlci5vcHQueG1sbnMpIHtcbiAgICAgIC8vIGVtaXQgbmFtZXNwYWNlIGJpbmRpbmcgZXZlbnRzXG4gICAgICB2YXIgdGFnID0gcGFyc2VyLnRhZ1xuXG4gICAgICAvLyBhZGQgbmFtZXNwYWNlIGluZm8gdG8gdGFnXG4gICAgICB2YXIgcW4gPSBxbmFtZShwYXJzZXIudGFnTmFtZSlcbiAgICAgIHRhZy5wcmVmaXggPSBxbi5wcmVmaXhcbiAgICAgIHRhZy5sb2NhbCA9IHFuLmxvY2FsXG4gICAgICB0YWcudXJpID0gdGFnLm5zW3FuLnByZWZpeF0gfHwgJydcblxuICAgICAgaWYgKHRhZy5wcmVmaXggJiYgIXRhZy51cmkpIHtcbiAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdVbmJvdW5kIG5hbWVzcGFjZSBwcmVmaXg6ICcgK1xuICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHBhcnNlci50YWdOYW1lKSlcbiAgICAgICAgdGFnLnVyaSA9IHFuLnByZWZpeFxuICAgICAgfVxuXG4gICAgICB2YXIgcGFyZW50ID0gcGFyc2VyLnRhZ3NbcGFyc2VyLnRhZ3MubGVuZ3RoIC0gMV0gfHwgcGFyc2VyXG4gICAgICBpZiAodGFnLm5zICYmIHBhcmVudC5ucyAhPT0gdGFnLm5zKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHRhZy5ucykuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29ub3Blbm5hbWVzcGFjZScsIHtcbiAgICAgICAgICAgIHByZWZpeDogcCxcbiAgICAgICAgICAgIHVyaTogdGFnLm5zW3BdXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgLy8gaGFuZGxlIGRlZmVycmVkIG9uYXR0cmlidXRlIGV2ZW50c1xuICAgICAgLy8gTm90ZTogZG8gbm90IGFwcGx5IGRlZmF1bHQgbnMgdG8gYXR0cmlidXRlczpcbiAgICAgIC8vICAgaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLXhtbC1uYW1lcy8jZGVmYXVsdGluZ1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXJzZXIuYXR0cmliTGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIG52ID0gcGFyc2VyLmF0dHJpYkxpc3RbaV1cbiAgICAgICAgdmFyIG5hbWUgPSBudlswXVxuICAgICAgICB2YXIgdmFsdWUgPSBudlsxXVxuICAgICAgICB2YXIgcXVhbE5hbWUgPSBxbmFtZShuYW1lLCB0cnVlKVxuICAgICAgICB2YXIgcHJlZml4ID0gcXVhbE5hbWUucHJlZml4XG4gICAgICAgIHZhciBsb2NhbCA9IHF1YWxOYW1lLmxvY2FsXG4gICAgICAgIHZhciB1cmkgPSBwcmVmaXggPT09ICcnID8gJycgOiAodGFnLm5zW3ByZWZpeF0gfHwgJycpXG4gICAgICAgIHZhciBhID0ge1xuICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICAgIGxvY2FsOiBsb2NhbCxcbiAgICAgICAgICB1cmk6IHVyaVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlcmUncyBhbnkgYXR0cmlidXRlcyB3aXRoIGFuIHVuZGVmaW5lZCBuYW1lc3BhY2UsXG4gICAgICAgIC8vIHRoZW4gZmFpbCBvbiB0aGVtIG5vdy5cbiAgICAgICAgaWYgKHByZWZpeCAmJiBwcmVmaXggIT09ICd4bWxucycgJiYgIXVyaSkge1xuICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnVW5ib3VuZCBuYW1lc3BhY2UgcHJlZml4OiAnICtcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHByZWZpeCkpXG4gICAgICAgICAgYS51cmkgPSBwcmVmaXhcbiAgICAgICAgfVxuICAgICAgICBwYXJzZXIudGFnLmF0dHJpYnV0ZXNbbmFtZV0gPSBhXG4gICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uYXR0cmlidXRlJywgYSlcbiAgICAgIH1cbiAgICAgIHBhcnNlci5hdHRyaWJMaXN0Lmxlbmd0aCA9IDBcbiAgICB9XG5cbiAgICBwYXJzZXIudGFnLmlzU2VsZkNsb3NpbmcgPSAhIXNlbGZDbG9zaW5nXG5cbiAgICAvLyBwcm9jZXNzIHRoZSB0YWdcbiAgICBwYXJzZXIuc2F3Um9vdCA9IHRydWVcbiAgICBwYXJzZXIudGFncy5wdXNoKHBhcnNlci50YWcpXG4gICAgZW1pdE5vZGUocGFyc2VyLCAnb25vcGVudGFnJywgcGFyc2VyLnRhZylcbiAgICBpZiAoIXNlbGZDbG9zaW5nKSB7XG4gICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIDxzY3JpcHQ+IGluIG5vbi1zdHJpY3QgbW9kZS5cbiAgICAgIGlmICghcGFyc2VyLm5vc2NyaXB0ICYmIHBhcnNlci50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzY3JpcHQnKSB7XG4gICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0NSSVBUXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICAgIH1cbiAgICAgIHBhcnNlci50YWcgPSBudWxsXG4gICAgICBwYXJzZXIudGFnTmFtZSA9ICcnXG4gICAgfVxuICAgIHBhcnNlci5hdHRyaWJOYW1lID0gcGFyc2VyLmF0dHJpYlZhbHVlID0gJydcbiAgICBwYXJzZXIuYXR0cmliTGlzdC5sZW5ndGggPSAwXG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZVRhZyAocGFyc2VyKSB7XG4gICAgaWYgKCFwYXJzZXIudGFnTmFtZSkge1xuICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdXZWlyZCBlbXB0eSBjbG9zZSB0YWcuJylcbiAgICAgIHBhcnNlci50ZXh0Tm9kZSArPSAnPC8+J1xuICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAocGFyc2VyLnNjcmlwdCkge1xuICAgICAgaWYgKHBhcnNlci50YWdOYW1lICE9PSAnc2NyaXB0Jykge1xuICAgICAgICBwYXJzZXIuc2NyaXB0ICs9ICc8LycgKyBwYXJzZXIudGFnTmFtZSArICc+J1xuICAgICAgICBwYXJzZXIudGFnTmFtZSA9ICcnXG4gICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0NSSVBUXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25zY3JpcHQnLCBwYXJzZXIuc2NyaXB0KVxuICAgICAgcGFyc2VyLnNjcmlwdCA9ICcnXG4gICAgfVxuXG4gICAgLy8gZmlyc3QgbWFrZSBzdXJlIHRoYXQgdGhlIGNsb3NpbmcgdGFnIGFjdHVhbGx5IGV4aXN0cy5cbiAgICAvLyA8YT48Yj48L2M+PC9iPjwvYT4gd2lsbCBjbG9zZSBldmVyeXRoaW5nLCBvdGhlcndpc2UuXG4gICAgdmFyIHQgPSBwYXJzZXIudGFncy5sZW5ndGhcbiAgICB2YXIgdGFnTmFtZSA9IHBhcnNlci50YWdOYW1lXG4gICAgaWYgKCFwYXJzZXIuc3RyaWN0KSB7XG4gICAgICB0YWdOYW1lID0gdGFnTmFtZVtwYXJzZXIubG9vc2VDYXNlXSgpXG4gICAgfVxuICAgIHZhciBjbG9zZVRvID0gdGFnTmFtZVxuICAgIHdoaWxlICh0LS0pIHtcbiAgICAgIHZhciBjbG9zZSA9IHBhcnNlci50YWdzW3RdXG4gICAgICBpZiAoY2xvc2UubmFtZSAhPT0gY2xvc2VUbykge1xuICAgICAgICAvLyBmYWlsIHRoZSBmaXJzdCB0aW1lIGluIHN0cmljdCBtb2RlXG4gICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnVW5leHBlY3RlZCBjbG9zZSB0YWcnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkaWRuJ3QgZmluZCBpdC4gIHdlIGFscmVhZHkgZmFpbGVkIGZvciBzdHJpY3QsIHNvIGp1c3QgYWJvcnQuXG4gICAgaWYgKHQgPCAwKSB7XG4gICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1VubWF0Y2hlZCBjbG9zaW5nIHRhZzogJyArIHBhcnNlci50YWdOYW1lKVxuICAgICAgcGFyc2VyLnRleHROb2RlICs9ICc8LycgKyBwYXJzZXIudGFnTmFtZSArICc+J1xuICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgcGFyc2VyLnRhZ05hbWUgPSB0YWdOYW1lXG4gICAgdmFyIHMgPSBwYXJzZXIudGFncy5sZW5ndGhcbiAgICB3aGlsZSAocy0tID4gdCkge1xuICAgICAgdmFyIHRhZyA9IHBhcnNlci50YWcgPSBwYXJzZXIudGFncy5wb3AoKVxuICAgICAgcGFyc2VyLnRhZ05hbWUgPSBwYXJzZXIudGFnLm5hbWVcbiAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uY2xvc2V0YWcnLCBwYXJzZXIudGFnTmFtZSlcblxuICAgICAgdmFyIHggPSB7fVxuICAgICAgZm9yICh2YXIgaSBpbiB0YWcubnMpIHtcbiAgICAgICAgeFtpXSA9IHRhZy5uc1tpXVxuICAgICAgfVxuXG4gICAgICB2YXIgcGFyZW50ID0gcGFyc2VyLnRhZ3NbcGFyc2VyLnRhZ3MubGVuZ3RoIC0gMV0gfHwgcGFyc2VyXG4gICAgICBpZiAocGFyc2VyLm9wdC54bWxucyAmJiB0YWcubnMgIT09IHBhcmVudC5ucykge1xuICAgICAgICAvLyByZW1vdmUgbmFtZXNwYWNlIGJpbmRpbmdzIGludHJvZHVjZWQgYnkgdGFnXG4gICAgICAgIE9iamVjdC5rZXlzKHRhZy5ucykuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgICAgIHZhciBuID0gdGFnLm5zW3BdXG4gICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25jbG9zZW5hbWVzcGFjZScsIHsgcHJlZml4OiBwLCB1cmk6IG4gfSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHQgPT09IDApIHBhcnNlci5jbG9zZWRSb290ID0gdHJ1ZVxuICAgIHBhcnNlci50YWdOYW1lID0gcGFyc2VyLmF0dHJpYlZhbHVlID0gcGFyc2VyLmF0dHJpYk5hbWUgPSAnJ1xuICAgIHBhcnNlci5hdHRyaWJMaXN0Lmxlbmd0aCA9IDBcbiAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRW50aXR5IChwYXJzZXIpIHtcbiAgICB2YXIgZW50aXR5ID0gcGFyc2VyLmVudGl0eVxuICAgIHZhciBlbnRpdHlMQyA9IGVudGl0eS50b0xvd2VyQ2FzZSgpXG4gICAgdmFyIG51bVxuICAgIHZhciBudW1TdHIgPSAnJ1xuXG4gICAgaWYgKHBhcnNlci5FTlRJVElFU1tlbnRpdHldKSB7XG4gICAgICByZXR1cm4gcGFyc2VyLkVOVElUSUVTW2VudGl0eV1cbiAgICB9XG4gICAgaWYgKHBhcnNlci5FTlRJVElFU1tlbnRpdHlMQ10pIHtcbiAgICAgIHJldHVybiBwYXJzZXIuRU5USVRJRVNbZW50aXR5TENdXG4gICAgfVxuICAgIGVudGl0eSA9IGVudGl0eUxDXG4gICAgaWYgKGVudGl0eS5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgaWYgKGVudGl0eS5jaGFyQXQoMSkgPT09ICd4Jykge1xuICAgICAgICBlbnRpdHkgPSBlbnRpdHkuc2xpY2UoMilcbiAgICAgICAgbnVtID0gcGFyc2VJbnQoZW50aXR5LCAxNilcbiAgICAgICAgbnVtU3RyID0gbnVtLnRvU3RyaW5nKDE2KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW50aXR5ID0gZW50aXR5LnNsaWNlKDEpXG4gICAgICAgIG51bSA9IHBhcnNlSW50KGVudGl0eSwgMTApXG4gICAgICAgIG51bVN0ciA9IG51bS50b1N0cmluZygxMClcbiAgICAgIH1cbiAgICB9XG4gICAgZW50aXR5ID0gZW50aXR5LnJlcGxhY2UoL14wKy8sICcnKVxuICAgIGlmIChpc05hTihudW0pIHx8IG51bVN0ci50b0xvd2VyQ2FzZSgpICE9PSBlbnRpdHkpIHtcbiAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCBjaGFyYWN0ZXIgZW50aXR5JylcbiAgICAgIHJldHVybiAnJicgKyBwYXJzZXIuZW50aXR5ICsgJzsnXG4gICAgfVxuXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KG51bSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGJlZ2luV2hpdGVTcGFjZSAocGFyc2VyLCBjKSB7XG4gICAgaWYgKGMgPT09ICc8Jykge1xuICAgICAgcGFyc2VyLnN0YXRlID0gUy5PUEVOX1dBS0FcbiAgICAgIHBhcnNlci5zdGFydFRhZ1Bvc2l0aW9uID0gcGFyc2VyLnBvc2l0aW9uXG4gICAgfSBlbHNlIGlmICghaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAvLyBoYXZlIHRvIHByb2Nlc3MgdGhpcyBhcyBhIHRleHQgbm9kZS5cbiAgICAgIC8vIHdlaXJkLCBidXQgaGFwcGVucy5cbiAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnTm9uLXdoaXRlc3BhY2UgYmVmb3JlIGZpcnN0IHRhZy4nKVxuICAgICAgcGFyc2VyLnRleHROb2RlID0gY1xuICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hhckF0IChjaHVuaywgaSkge1xuICAgIHZhciByZXN1bHQgPSAnJ1xuICAgIGlmIChpIDwgY2h1bmsubGVuZ3RoKSB7XG4gICAgICByZXN1bHQgPSBjaHVuay5jaGFyQXQoaSlcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgZnVuY3Rpb24gd3JpdGUgKGNodW5rKSB7XG4gICAgdmFyIHBhcnNlciA9IHRoaXNcbiAgICBpZiAodGhpcy5lcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5lcnJvclxuICAgIH1cbiAgICBpZiAocGFyc2VyLmNsb3NlZCkge1xuICAgICAgcmV0dXJuIGVycm9yKHBhcnNlcixcbiAgICAgICAgJ0Nhbm5vdCB3cml0ZSBhZnRlciBjbG9zZS4gQXNzaWduIGFuIG9ucmVhZHkgaGFuZGxlci4nKVxuICAgIH1cbiAgICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbmQocGFyc2VyKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnb2JqZWN0Jykge1xuICAgICAgY2h1bmsgPSBjaHVuay50b1N0cmluZygpXG4gICAgfVxuICAgIHZhciBpID0gMFxuICAgIHZhciBjID0gJydcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgYyA9IGNoYXJBdChjaHVuaywgaSsrKVxuICAgICAgcGFyc2VyLmMgPSBjXG5cbiAgICAgIGlmICghYykge1xuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyc2VyLnRyYWNrUG9zaXRpb24pIHtcbiAgICAgICAgcGFyc2VyLnBvc2l0aW9uKytcbiAgICAgICAgaWYgKGMgPT09ICdcXG4nKSB7XG4gICAgICAgICAgcGFyc2VyLmxpbmUrK1xuICAgICAgICAgIHBhcnNlci5jb2x1bW4gPSAwXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyc2VyLmNvbHVtbisrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwYXJzZXIuc3RhdGUpIHtcbiAgICAgICAgY2FzZSBTLkJFR0lOOlxuICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQkVHSU5fV0hJVEVTUEFDRVxuICAgICAgICAgIGlmIChjID09PSAnXFx1RkVGRicpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJlZ2luV2hpdGVTcGFjZShwYXJzZXIsIGMpXG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQkVHSU5fV0hJVEVTUEFDRTpcbiAgICAgICAgICBiZWdpbldoaXRlU3BhY2UocGFyc2VyLCBjKVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLlRFWFQ6XG4gICAgICAgICAgaWYgKHBhcnNlci5zYXdSb290ICYmICFwYXJzZXIuY2xvc2VkUm9vdCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0aSA9IGkgLSAxXG4gICAgICAgICAgICB3aGlsZSAoYyAmJiBjICE9PSAnPCcgJiYgYyAhPT0gJyYnKSB7XG4gICAgICAgICAgICAgIGMgPSBjaGFyQXQoY2h1bmssIGkrKylcbiAgICAgICAgICAgICAgaWYgKGMgJiYgcGFyc2VyLnRyYWNrUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIucG9zaXRpb24rK1xuICAgICAgICAgICAgICAgIGlmIChjID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgcGFyc2VyLmxpbmUrK1xuICAgICAgICAgICAgICAgICAgcGFyc2VyLmNvbHVtbiA9IDBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGFyc2VyLmNvbHVtbisrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZXIudGV4dE5vZGUgKz0gY2h1bmsuc3Vic3RyaW5nKHN0YXJ0aSwgaSAtIDEpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjID09PSAnPCcgJiYgIShwYXJzZXIuc2F3Um9vdCAmJiBwYXJzZXIuY2xvc2VkUm9vdCAmJiAhcGFyc2VyLnN0cmljdCkpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuT1BFTl9XQUtBXG4gICAgICAgICAgICBwYXJzZXIuc3RhcnRUYWdQb3NpdGlvbiA9IHBhcnNlci5wb3NpdGlvblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWlzV2hpdGVzcGFjZShjKSAmJiAoIXBhcnNlci5zYXdSb290IHx8IHBhcnNlci5jbG9zZWRSb290KSkge1xuICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1RleHQgZGF0YSBvdXRzaWRlIG9mIHJvb3Qgbm9kZS4nKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT09ICcmJykge1xuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRfRU5USVRZXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwYXJzZXIudGV4dE5vZGUgKz0gY1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5TQ1JJUFQ6XG4gICAgICAgICAgLy8gb25seSBub24tc3RyaWN0XG4gICAgICAgICAgaWYgKGMgPT09ICc8Jykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TQ1JJUFRfRU5ESU5HXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5zY3JpcHQgKz0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5TQ1JJUFRfRU5ESU5HOlxuICAgICAgICAgIGlmIChjID09PSAnLycpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0xPU0VfVEFHXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5zY3JpcHQgKz0gJzwnICsgY1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TQ1JJUFRcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuT1BFTl9XQUtBOlxuICAgICAgICAgIC8vIGVpdGhlciBhIC8sID8sICEsIG9yIHRleHQgaXMgY29taW5nIG5leHQuXG4gICAgICAgICAgaWYgKGMgPT09ICchJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TR01MX0RFQ0xcbiAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCA9ICcnXG4gICAgICAgICAgfSBlbHNlIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIC8vIHdhaXQgZm9yIGl0Li4uXG4gICAgICAgICAgfSBlbHNlIGlmIChpc01hdGNoKG5hbWVTdGFydCwgYykpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuT1BFTl9UQUdcbiAgICAgICAgICAgIHBhcnNlci50YWdOYW1lID0gY1xuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJy8nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNMT1NFX1RBR1xuICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgPSAnJ1xuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJz8nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlBST0NfSU5TVFxuICAgICAgICAgICAgcGFyc2VyLnByb2NJbnN0TmFtZSA9IHBhcnNlci5wcm9jSW5zdEJvZHkgPSAnJ1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1VuZW5jb2RlZCA8JylcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIHdhcyBzb21lIHdoaXRlc3BhY2UsIHRoZW4gYWRkIHRoYXQgaW4uXG4gICAgICAgICAgICBpZiAocGFyc2VyLnN0YXJ0VGFnUG9zaXRpb24gKyAxIDwgcGFyc2VyLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgIHZhciBwYWQgPSBwYXJzZXIucG9zaXRpb24gLSBwYXJzZXIuc3RhcnRUYWdQb3NpdGlvblxuICAgICAgICAgICAgICBjID0gbmV3IEFycmF5KHBhZCkuam9pbignICcpICsgY1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VyLnRleHROb2RlICs9ICc8JyArIGNcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVFxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5TR01MX0RFQ0w6XG4gICAgICAgICAgaWYgKChwYXJzZXIuc2dtbERlY2wgKyBjKS50b1VwcGVyQ2FzZSgpID09PSBDREFUQSkge1xuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25vcGVuY2RhdGEnKVxuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DREFUQVxuICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsID0gJydcbiAgICAgICAgICAgIHBhcnNlci5jZGF0YSA9ICcnXG4gICAgICAgICAgfSBlbHNlIGlmIChwYXJzZXIuc2dtbERlY2wgKyBjID09PSAnLS0nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNPTU1FTlRcbiAgICAgICAgICAgIHBhcnNlci5jb21tZW50ID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCA9ICcnXG4gICAgICAgICAgfSBlbHNlIGlmICgocGFyc2VyLnNnbWxEZWNsICsgYykudG9VcHBlckNhc2UoKSA9PT0gRE9DVFlQRSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFXG4gICAgICAgICAgICBpZiAocGFyc2VyLmRvY3R5cGUgfHwgcGFyc2VyLnNhd1Jvb3QpIHtcbiAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsXG4gICAgICAgICAgICAgICAgJ0luYXBwcm9wcmlhdGVseSBsb2NhdGVkIGRvY3R5cGUgZGVjbGFyYXRpb24nKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VyLmRvY3R5cGUgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsID0gJydcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25zZ21sZGVjbGFyYXRpb24nLCBwYXJzZXIuc2dtbERlY2wpXG4gICAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICAgICAgfSBlbHNlIGlmIChpc1F1b3RlKGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNHTUxfREVDTF9RVU9URURcbiAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCArPSBjXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCArPSBjXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLlNHTUxfREVDTF9RVU9URUQ6XG4gICAgICAgICAgaWYgKGMgPT09IHBhcnNlci5xKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNHTUxfREVDTFxuICAgICAgICAgICAgcGFyc2VyLnEgPSAnJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgKz0gY1xuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkRPQ1RZUEU6XG4gICAgICAgICAgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmRvY3R5cGUnLCBwYXJzZXIuZG9jdHlwZSlcbiAgICAgICAgICAgIHBhcnNlci5kb2N0eXBlID0gdHJ1ZSAvLyBqdXN0IHJlbWVtYmVyIHRoYXQgd2Ugc2F3IGl0LlxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIuZG9jdHlwZSArPSBjXG4gICAgICAgICAgICBpZiAoYyA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRV9EVERcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNRdW90ZShjKSkge1xuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkRPQ1RZUEVfUVVPVEVEXG4gICAgICAgICAgICAgIHBhcnNlci5xID0gY1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5ET0NUWVBFX1FVT1RFRDpcbiAgICAgICAgICBwYXJzZXIuZG9jdHlwZSArPSBjXG4gICAgICAgICAgaWYgKGMgPT09IHBhcnNlci5xKSB7XG4gICAgICAgICAgICBwYXJzZXIucSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkRPQ1RZUEVcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuRE9DVFlQRV9EVEQ6XG4gICAgICAgICAgcGFyc2VyLmRvY3R5cGUgKz0gY1xuICAgICAgICAgIGlmIChjID09PSAnXScpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNRdW90ZShjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFX0RURF9RVU9URURcbiAgICAgICAgICAgIHBhcnNlci5xID0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5ET0NUWVBFX0RURF9RVU9URUQ6XG4gICAgICAgICAgcGFyc2VyLmRvY3R5cGUgKz0gY1xuICAgICAgICAgIGlmIChjID09PSBwYXJzZXIucSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFX0RURFxuICAgICAgICAgICAgcGFyc2VyLnEgPSAnJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5DT01NRU5UOlxuICAgICAgICAgIGlmIChjID09PSAnLScpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ09NTUVOVF9FTkRJTkdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLmNvbW1lbnQgKz0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5DT01NRU5UX0VORElORzpcbiAgICAgICAgICBpZiAoYyA9PT0gJy0nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNPTU1FTlRfRU5ERURcbiAgICAgICAgICAgIHBhcnNlci5jb21tZW50ID0gdGV4dG9wdHMocGFyc2VyLm9wdCwgcGFyc2VyLmNvbW1lbnQpXG4gICAgICAgICAgICBpZiAocGFyc2VyLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25jb21tZW50JywgcGFyc2VyLmNvbW1lbnQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZXIuY29tbWVudCA9ICcnXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5jb21tZW50ICs9ICctJyArIGNcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ09NTUVOVFxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5DT01NRU5UX0VOREVEOlxuICAgICAgICAgIGlmIChjICE9PSAnPicpIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnTWFsZm9ybWVkIGNvbW1lbnQnKVxuICAgICAgICAgICAgLy8gYWxsb3cgPCEtLSBibGFoIC0tIGJsb28gLS0+IGluIG5vbi1zdHJpY3QgbW9kZSxcbiAgICAgICAgICAgIC8vIHdoaWNoIGlzIGEgY29tbWVudCBvZiBcIiBibGFoIC0tIGJsb28gXCJcbiAgICAgICAgICAgIHBhcnNlci5jb21tZW50ICs9ICctLScgKyBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNPTU1FTlRcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkNEQVRBOlxuICAgICAgICAgIGlmIChjID09PSAnXScpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0RBVEFfRU5ESU5HXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5jZGF0YSArPSBjXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkNEQVRBX0VORElORzpcbiAgICAgICAgICBpZiAoYyA9PT0gJ10nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNEQVRBX0VORElOR18yXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5jZGF0YSArPSAnXScgKyBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNEQVRBXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkNEQVRBX0VORElOR18yOlxuICAgICAgICAgIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIGlmIChwYXJzZXIuY2RhdGEpIHtcbiAgICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25jZGF0YScsIHBhcnNlci5jZGF0YSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uY2xvc2VjZGF0YScpXG4gICAgICAgICAgICBwYXJzZXIuY2RhdGEgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnXScpIHtcbiAgICAgICAgICAgIHBhcnNlci5jZGF0YSArPSAnXSdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLmNkYXRhICs9ICddXScgKyBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNEQVRBXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLlBST0NfSU5TVDpcbiAgICAgICAgICBpZiAoYyA9PT0gJz8nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlBST0NfSU5TVF9FTkRJTkdcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5QUk9DX0lOU1RfQk9EWVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIucHJvY0luc3ROYW1lICs9IGNcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuUFJPQ19JTlNUX0JPRFk6XG4gICAgICAgICAgaWYgKCFwYXJzZXIucHJvY0luc3RCb2R5ICYmIGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICc/Jykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5QUk9DX0lOU1RfRU5ESU5HXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5wcm9jSW5zdEJvZHkgKz0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5QUk9DX0lOU1RfRU5ESU5HOlxuICAgICAgICAgIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29ucHJvY2Vzc2luZ2luc3RydWN0aW9uJywge1xuICAgICAgICAgICAgICBuYW1lOiBwYXJzZXIucHJvY0luc3ROYW1lLFxuICAgICAgICAgICAgICBib2R5OiBwYXJzZXIucHJvY0luc3RCb2R5XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgcGFyc2VyLnByb2NJbnN0TmFtZSA9IHBhcnNlci5wcm9jSW5zdEJvZHkgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5wcm9jSW5zdEJvZHkgKz0gJz8nICsgY1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5QUk9DX0lOU1RfQk9EWVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5PUEVOX1RBRzpcbiAgICAgICAgICBpZiAoaXNNYXRjaChuYW1lQm9keSwgYykpIHtcbiAgICAgICAgICAgIHBhcnNlci50YWdOYW1lICs9IGNcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3VGFnKHBhcnNlcilcbiAgICAgICAgICAgIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICcvJykge1xuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLk9QRU5fVEFHX1NMQVNIXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoIWlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCBjaGFyYWN0ZXIgaW4gdGFnIG5hbWUnKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLk9QRU5fVEFHX1NMQVNIOlxuICAgICAgICAgIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyLCB0cnVlKVxuICAgICAgICAgICAgY2xvc2VUYWcocGFyc2VyKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ZvcndhcmQtc2xhc2ggaW4gb3BlbmluZyB0YWcgbm90IGZvbGxvd2VkIGJ5ID4nKVxuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQVRUUklCOlxuICAgICAgICAgIC8vIGhhdmVuJ3QgcmVhZCB0aGUgYXR0cmlidXRlIG5hbWUgeWV0LlxuICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyKVxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJy8nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLk9QRU5fVEFHX1NMQVNIXG4gICAgICAgICAgfSBlbHNlIGlmIChpc01hdGNoKG5hbWVTdGFydCwgYykpIHtcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJOYW1lID0gY1xuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX05BTUVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lJylcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQVRUUklCX05BTUU6XG4gICAgICAgICAgaWYgKGMgPT09ICc9Jykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfVkFMVUVcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdBdHRyaWJ1dGUgd2l0aG91dCB2YWx1ZScpXG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliVmFsdWUgPSBwYXJzZXIuYXR0cmliTmFtZVxuICAgICAgICAgICAgYXR0cmliKHBhcnNlcilcbiAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyKVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9OQU1FX1NBV19XSElURVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNNYXRjaChuYW1lQm9keSwgYykpIHtcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJOYW1lICs9IGNcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lJylcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQVRUUklCX05BTUVfU0FXX1dISVRFOlxuICAgICAgICAgIGlmIChjID09PSAnPScpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX1ZBTFVFXG4gICAgICAgICAgfSBlbHNlIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnQXR0cmlidXRlIHdpdGhvdXQgdmFsdWUnKVxuICAgICAgICAgICAgcGFyc2VyLnRhZy5hdHRyaWJ1dGVzW3BhcnNlci5hdHRyaWJOYW1lXSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliVmFsdWUgPSAnJ1xuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25hdHRyaWJ1dGUnLCB7XG4gICAgICAgICAgICAgIG5hbWU6IHBhcnNlci5hdHRyaWJOYW1lLFxuICAgICAgICAgICAgICB2YWx1ZTogJydcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliTmFtZSA9ICcnXG4gICAgICAgICAgICBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc01hdGNoKG5hbWVTdGFydCwgYykpIHtcbiAgICAgICAgICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBjXG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX05BTUVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCBhdHRyaWJ1dGUgbmFtZScpXG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRTpcbiAgICAgICAgICBpZiAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNRdW90ZShjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnEgPSBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9RVU9URURcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdVbnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUnKVxuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfVkFMVUVfVU5RVU9URURcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSA9IGNcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFX1FVT1RFRDpcbiAgICAgICAgICBpZiAoYyAhPT0gcGFyc2VyLnEpIHtcbiAgICAgICAgICAgIGlmIChjID09PSAnJicpIHtcbiAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfVkFMVUVfRU5USVRZX1FcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSArPSBjXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBhdHRyaWIocGFyc2VyKVxuICAgICAgICAgIHBhcnNlci5xID0gJydcbiAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9DTE9TRURcbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfQ0xPU0VEOlxuICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyKVxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJy8nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLk9QRU5fVEFHX1NMQVNIXG4gICAgICAgICAgfSBlbHNlIGlmIChpc01hdGNoKG5hbWVTdGFydCwgYykpIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnTm8gd2hpdGVzcGFjZSBiZXR3ZWVuIGF0dHJpYnV0ZXMnKVxuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBjXG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliVmFsdWUgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfTkFNRVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgYXR0cmlidXRlIG5hbWUnKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfVU5RVU9URUQ6XG4gICAgICAgICAgaWYgKCFpc0F0dHJpYkVuZChjKSkge1xuICAgICAgICAgICAgaWYgKGMgPT09ICcmJykge1xuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9FTlRJVFlfVVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlICs9IGNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGF0dHJpYihwYXJzZXIpXG4gICAgICAgICAgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkNMT1NFX1RBRzpcbiAgICAgICAgICBpZiAoIXBhcnNlci50YWdOYW1lKSB7XG4gICAgICAgICAgICBpZiAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vdE1hdGNoKG5hbWVTdGFydCwgYykpIHtcbiAgICAgICAgICAgICAgaWYgKHBhcnNlci5zY3JpcHQpIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuc2NyaXB0ICs9ICc8LycgKyBjXG4gICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TQ1JJUFRcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgdGFnbmFtZSBpbiBjbG9zaW5nIHRhZy4nKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwYXJzZXIudGFnTmFtZSA9IGNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgY2xvc2VUYWcocGFyc2VyKVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNNYXRjaChuYW1lQm9keSwgYykpIHtcbiAgICAgICAgICAgIHBhcnNlci50YWdOYW1lICs9IGNcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhcnNlci5zY3JpcHQpIHtcbiAgICAgICAgICAgIHBhcnNlci5zY3JpcHQgKz0gJzwvJyArIHBhcnNlci50YWdOYW1lXG4gICAgICAgICAgICBwYXJzZXIudGFnTmFtZSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNDUklQVFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgdGFnbmFtZSBpbiBjbG9zaW5nIHRhZycpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNMT1NFX1RBR19TQVdfV0hJVEVcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQ0xPU0VfVEFHX1NBV19XSElURTpcbiAgICAgICAgICBpZiAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBjbG9zZVRhZyhwYXJzZXIpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCBjaGFyYWN0ZXJzIGluIGNsb3NpbmcgdGFnJylcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuVEVYVF9FTlRJVFk6XG4gICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfRU5USVRZX1E6XG4gICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfRU5USVRZX1U6XG4gICAgICAgICAgdmFyIHJldHVyblN0YXRlXG4gICAgICAgICAgdmFyIGJ1ZmZlclxuICAgICAgICAgIHN3aXRjaCAocGFyc2VyLnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIFMuVEVYVF9FTlRJVFk6XG4gICAgICAgICAgICAgIHJldHVyblN0YXRlID0gUy5URVhUXG4gICAgICAgICAgICAgIGJ1ZmZlciA9ICd0ZXh0Tm9kZSdcbiAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRV9FTlRJVFlfUTpcbiAgICAgICAgICAgICAgcmV0dXJuU3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9RVU9URURcbiAgICAgICAgICAgICAgYnVmZmVyID0gJ2F0dHJpYlZhbHVlJ1xuICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFX0VOVElUWV9VOlxuICAgICAgICAgICAgICByZXR1cm5TdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX1VOUVVPVEVEXG4gICAgICAgICAgICAgIGJ1ZmZlciA9ICdhdHRyaWJWYWx1ZSdcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYyA9PT0gJzsnKSB7XG4gICAgICAgICAgICBwYXJzZXJbYnVmZmVyXSArPSBwYXJzZUVudGl0eShwYXJzZXIpXG4gICAgICAgICAgICBwYXJzZXIuZW50aXR5ID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IHJldHVyblN0YXRlXG4gICAgICAgICAgfSBlbHNlIGlmIChpc01hdGNoKHBhcnNlci5lbnRpdHkubGVuZ3RoID8gZW50aXR5Qm9keSA6IGVudGl0eVN0YXJ0LCBjKSkge1xuICAgICAgICAgICAgcGFyc2VyLmVudGl0eSArPSBjXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCBjaGFyYWN0ZXIgaW4gZW50aXR5IG5hbWUnKVxuICAgICAgICAgICAgcGFyc2VyW2J1ZmZlcl0gKz0gJyYnICsgcGFyc2VyLmVudGl0eSArIGNcbiAgICAgICAgICAgIHBhcnNlci5lbnRpdHkgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gcmV0dXJuU3RhdGVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHBhcnNlciwgJ1Vua25vd24gc3RhdGU6ICcgKyBwYXJzZXIuc3RhdGUpXG4gICAgICB9XG4gICAgfSAvLyB3aGlsZVxuXG4gICAgaWYgKHBhcnNlci5wb3NpdGlvbiA+PSBwYXJzZXIuYnVmZmVyQ2hlY2tQb3NpdGlvbikge1xuICAgICAgY2hlY2tCdWZmZXJMZW5ndGgocGFyc2VyKVxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VyXG4gIH1cblxuICAvKiEgaHR0cDovL210aHMuYmUvZnJvbWNvZGVwb2ludCB2MC4xLjAgYnkgQG1hdGhpYXMgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKCFTdHJpbmcuZnJvbUNvZGVQb2ludCkge1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZVxuICAgICAgdmFyIGZsb29yID0gTWF0aC5mbG9vclxuICAgICAgdmFyIGZyb21Db2RlUG9pbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBNQVhfU0laRSA9IDB4NDAwMFxuICAgICAgICB2YXIgY29kZVVuaXRzID0gW11cbiAgICAgICAgdmFyIGhpZ2hTdXJyb2dhdGVcbiAgICAgICAgdmFyIGxvd1N1cnJvZ2F0ZVxuICAgICAgICB2YXIgaW5kZXggPSAtMVxuICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiAnJ1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSAnJ1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBjb2RlUG9pbnQgPSBOdW1iZXIoYXJndW1lbnRzW2luZGV4XSlcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhaXNGaW5pdGUoY29kZVBvaW50KSB8fCAvLyBgTmFOYCwgYCtJbmZpbml0eWAsIG9yIGAtSW5maW5pdHlgXG4gICAgICAgICAgICBjb2RlUG9pbnQgPCAwIHx8IC8vIG5vdCBhIHZhbGlkIFVuaWNvZGUgY29kZSBwb2ludFxuICAgICAgICAgICAgY29kZVBvaW50ID4gMHgxMEZGRkYgfHwgLy8gbm90IGEgdmFsaWQgVW5pY29kZSBjb2RlIHBvaW50XG4gICAgICAgICAgICBmbG9vcihjb2RlUG9pbnQpICE9PSBjb2RlUG9pbnQgLy8gbm90IGFuIGludGVnZXJcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludDogJyArIGNvZGVQb2ludClcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvZGVQb2ludCA8PSAweEZGRkYpIHsgLy8gQk1QIGNvZGUgcG9pbnRcbiAgICAgICAgICAgIGNvZGVVbml0cy5wdXNoKGNvZGVQb2ludClcbiAgICAgICAgICB9IGVsc2UgeyAvLyBBc3RyYWwgY29kZSBwb2ludDsgc3BsaXQgaW4gc3Vycm9nYXRlIGhhbHZlc1xuICAgICAgICAgICAgLy8gaHR0cDovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZyNzdXJyb2dhdGUtZm9ybXVsYWVcbiAgICAgICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICAgICAgICBoaWdoU3Vycm9nYXRlID0gKGNvZGVQb2ludCA+PiAxMCkgKyAweEQ4MDBcbiAgICAgICAgICAgIGxvd1N1cnJvZ2F0ZSA9IChjb2RlUG9pbnQgJSAweDQwMCkgKyAweERDMDBcbiAgICAgICAgICAgIGNvZGVVbml0cy5wdXNoKGhpZ2hTdXJyb2dhdGUsIGxvd1N1cnJvZ2F0ZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluZGV4ICsgMSA9PT0gbGVuZ3RoIHx8IGNvZGVVbml0cy5sZW5ndGggPiBNQVhfU0laRSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZS5hcHBseShudWxsLCBjb2RlVW5pdHMpXG4gICAgICAgICAgICBjb2RlVW5pdHMubGVuZ3RoID0gMFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RyaW5nLCAnZnJvbUNvZGVQb2ludCcsIHtcbiAgICAgICAgICB2YWx1ZTogZnJvbUNvZGVQb2ludCxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFN0cmluZy5mcm9tQ29kZVBvaW50ID0gZnJvbUNvZGVQb2ludFxuICAgICAgfVxuICAgIH0oKSlcbiAgfVxufSkodHlwZW9mIGV4cG9ydHMgPT09ICd1bmRlZmluZWQnID8gdGhpcy5zYXggPSB7fSA6IGV4cG9ydHMpXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGFyc2VYbWwgPSBleHBvcnRzLlhFbGVtZW50ID0gdm9pZCAwO1xuY29uc3Qgc2F4ID0gcmVxdWlyZShcInNheFwiKTtcbmNvbnN0IGluZGV4XzEgPSByZXF1aXJlKFwiLi9pbmRleFwiKTtcbmNsYXNzIFhFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBudWxsO1xuICAgICAgICB0aGlzLmlzQ0RhdGEgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IG51bGw7XG4gICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgaW5kZXhfMS5uZXdFcnJvcihcIkVsZW1lbnQgbmFtZSBjYW5ub3QgYmUgZW1wdHlcIiwgXCJFUlJfWE1MX0VMRU1FTlRfTkFNRV9FTVBUWVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVmFsaWROYW1lKG5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBpbmRleF8xLm5ld0Vycm9yKGBJbnZhbGlkIGVsZW1lbnQgbmFtZTogJHtuYW1lfWAsIFwiRVJSX1hNTF9FTEVNRU5UX0lOVkFMSURfTkFNRVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhdHRyaWJ1dGUobmFtZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmF0dHJpYnV0ZXMgPT09IG51bGwgPyBudWxsIDogdGhpcy5hdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IGluZGV4XzEubmV3RXJyb3IoYE5vIGF0dHJpYnV0ZSBcIiR7bmFtZX1cImAsIFwiRVJSX1hNTF9NSVNTRURfQVRUUklCVVRFXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJlbW92ZUF0dHJpYnV0ZShuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxlbWVudChuYW1lLCBpZ25vcmVDYXNlID0gZmFsc2UsIGVycm9ySWZNaXNzZWQgPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZWxlbWVudE9yTnVsbChuYW1lLCBpZ25vcmVDYXNlKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgaW5kZXhfMS5uZXdFcnJvcihlcnJvcklmTWlzc2VkIHx8IGBObyBlbGVtZW50IFwiJHtuYW1lfVwiYCwgXCJFUlJfWE1MX01JU1NFRF9FTEVNRU5UXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVsZW1lbnRPck51bGwobmFtZSwgaWdub3JlQ2FzZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnRzID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy5lbGVtZW50cykge1xuICAgICAgICAgICAgaWYgKGlzTmFtZUVxdWFscyhlbGVtZW50LCBuYW1lLCBpZ25vcmVDYXNlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXRFbGVtZW50cyhuYW1lLCBpZ25vcmVDYXNlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50cy5maWx0ZXIoaXQgPT4gaXNOYW1lRXF1YWxzKGl0LCBuYW1lLCBpZ25vcmVDYXNlKSk7XG4gICAgfVxuICAgIGVsZW1lbnRWYWx1ZU9yRW1wdHkobmFtZSwgaWdub3JlQ2FzZSA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRPck51bGwobmFtZSwgaWdub3JlQ2FzZSk7XG4gICAgICAgIHJldHVybiBlbGVtZW50ID09PSBudWxsID8gXCJcIiA6IGVsZW1lbnQudmFsdWU7XG4gICAgfVxufVxuZXhwb3J0cy5YRWxlbWVudCA9IFhFbGVtZW50O1xuY29uc3QgTkFNRV9SRUdfRVhQID0gbmV3IFJlZ0V4cCgvXltBLVphLXpfXVs6QS1aYS16MC05Xy1dKiQvaSk7XG5mdW5jdGlvbiBpc1ZhbGlkTmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIE5BTUVfUkVHX0VYUC50ZXN0KG5hbWUpO1xufVxuZnVuY3Rpb24gaXNOYW1lRXF1YWxzKGVsZW1lbnQsIG5hbWUsIGlnbm9yZUNhc2UpIHtcbiAgICBjb25zdCBlbGVtZW50TmFtZSA9IGVsZW1lbnQubmFtZTtcbiAgICByZXR1cm4gZWxlbWVudE5hbWUgPT09IG5hbWUgfHwgKGlnbm9yZUNhc2UgPT09IHRydWUgJiYgZWxlbWVudE5hbWUubGVuZ3RoID09PSBuYW1lLmxlbmd0aCAmJiBlbGVtZW50TmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCkpO1xufVxuZnVuY3Rpb24gcGFyc2VYbWwoZGF0YSkge1xuICAgIGxldCByb290RWxlbWVudCA9IG51bGw7XG4gICAgY29uc3QgcGFyc2VyID0gc2F4LnBhcnNlcih0cnVlLCB7fSk7XG4gICAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgICBwYXJzZXIub25vcGVudGFnID0gc2F4RWxlbWVudCA9PiB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBuZXcgWEVsZW1lbnQoc2F4RWxlbWVudC5uYW1lKTtcbiAgICAgICAgZWxlbWVudC5hdHRyaWJ1dGVzID0gc2F4RWxlbWVudC5hdHRyaWJ1dGVzO1xuICAgICAgICBpZiAocm9vdEVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJvb3RFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IGVsZW1lbnRzW2VsZW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKHBhcmVudC5lbGVtZW50cyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LmVsZW1lbnRzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQuZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgIH07XG4gICAgcGFyc2VyLm9uY2xvc2V0YWcgPSAoKSA9PiB7XG4gICAgICAgIGVsZW1lbnRzLnBvcCgpO1xuICAgIH07XG4gICAgcGFyc2VyLm9udGV4dCA9IHRleHQgPT4ge1xuICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZWxlbWVudHNbZWxlbWVudHMubGVuZ3RoIC0gMV0udmFsdWUgPSB0ZXh0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBwYXJzZXIub25jZGF0YSA9IGNkYXRhID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2VsZW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBlbGVtZW50LnZhbHVlID0gY2RhdGE7XG4gICAgICAgIGVsZW1lbnQuaXNDRGF0YSA9IHRydWU7XG4gICAgfTtcbiAgICBwYXJzZXIub25lcnJvciA9IGVyciA9PiB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9O1xuICAgIHBhcnNlci53cml0ZShkYXRhKTtcbiAgICByZXR1cm4gcm9vdEVsZW1lbnQ7XG59XG5leHBvcnRzLnBhcnNlWG1sID0gcGFyc2VYbWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD14bWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm5ld0Vycm9yID0gZXhwb3J0cy5hc0FycmF5ID0gZXhwb3J0cy5DVVJSRU5UX0FQUF9QQUNLQUdFX0ZJTEVfTkFNRSA9IGV4cG9ydHMuQ1VSUkVOVF9BUFBfSU5TVEFMTEVSX0ZJTEVfTkFNRSA9IGV4cG9ydHMuWEVsZW1lbnQgPSBleHBvcnRzLnBhcnNlWG1sID0gZXhwb3J0cy5Qcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtID0gZXhwb3J0cy5VVUlEID0gZXhwb3J0cy5wYXJzZURuID0gZXhwb3J0cy5naXRodWJVcmwgPSBleHBvcnRzLmdldFMzTGlrZVByb3ZpZGVyQmFzZVVybCA9IGV4cG9ydHMuY29uZmlndXJlUmVxdWVzdFVybCA9IGV4cG9ydHMucGFyc2VKc29uID0gZXhwb3J0cy5zYWZlU3RyaW5naWZ5SnNvbiA9IGV4cG9ydHMuY29uZmlndXJlUmVxdWVzdE9wdGlvbnNGcm9tVXJsID0gZXhwb3J0cy5jb25maWd1cmVSZXF1ZXN0T3B0aW9ucyA9IGV4cG9ydHMuc2FmZUdldEhlYWRlciA9IGV4cG9ydHMuRGlnZXN0VHJhbnNmb3JtID0gZXhwb3J0cy5IdHRwRXhlY3V0b3IgPSBleHBvcnRzLmNyZWF0ZUh0dHBFcnJvciA9IGV4cG9ydHMuSHR0cEVycm9yID0gZXhwb3J0cy5DYW5jZWxsYXRpb25FcnJvciA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW4gPSB2b2lkIDA7XG52YXIgQ2FuY2VsbGF0aW9uVG9rZW5fMSA9IHJlcXVpcmUoXCIuL0NhbmNlbGxhdGlvblRva2VuXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FuY2VsbGF0aW9uVG9rZW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENhbmNlbGxhdGlvblRva2VuXzEuQ2FuY2VsbGF0aW9uVG9rZW47IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYW5jZWxsYXRpb25FcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQ2FuY2VsbGF0aW9uVG9rZW5fMS5DYW5jZWxsYXRpb25FcnJvcjsgfSB9KTtcbnZhciBodHRwRXhlY3V0b3JfMSA9IHJlcXVpcmUoXCIuL2h0dHBFeGVjdXRvclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkh0dHBFcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaHR0cEV4ZWN1dG9yXzEuSHR0cEVycm9yOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlSHR0cEVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBodHRwRXhlY3V0b3JfMS5jcmVhdGVIdHRwRXJyb3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJIdHRwRXhlY3V0b3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGh0dHBFeGVjdXRvcl8xLkh0dHBFeGVjdXRvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRpZ2VzdFRyYW5zZm9ybVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaHR0cEV4ZWN1dG9yXzEuRGlnZXN0VHJhbnNmb3JtOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2FmZUdldEhlYWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaHR0cEV4ZWN1dG9yXzEuc2FmZUdldEhlYWRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBodHRwRXhlY3V0b3JfMS5jb25maWd1cmVSZXF1ZXN0T3B0aW9uczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zRnJvbVVybFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaHR0cEV4ZWN1dG9yXzEuY29uZmlndXJlUmVxdWVzdE9wdGlvbnNGcm9tVXJsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2FmZVN0cmluZ2lmeUpzb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGh0dHBFeGVjdXRvcl8xLnNhZmVTdHJpbmdpZnlKc29uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VKc29uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBodHRwRXhlY3V0b3JfMS5wYXJzZUpzb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb25maWd1cmVSZXF1ZXN0VXJsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBodHRwRXhlY3V0b3JfMS5jb25maWd1cmVSZXF1ZXN0VXJsOyB9IH0pO1xudmFyIHB1Ymxpc2hPcHRpb25zXzEgPSByZXF1aXJlKFwiLi9wdWJsaXNoT3B0aW9uc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldFMzTGlrZVByb3ZpZGVyQmFzZVVybFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHVibGlzaE9wdGlvbnNfMS5nZXRTM0xpa2VQcm92aWRlckJhc2VVcmw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnaXRodWJVcmxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHB1Ymxpc2hPcHRpb25zXzEuZ2l0aHViVXJsOyB9IH0pO1xudmFyIHJmYzIyNTNQYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3JmYzIyNTNQYXJzZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXJzZURuXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZmMyMjUzUGFyc2VyXzEucGFyc2VEbjsgfSB9KTtcbnZhciB1dWlkXzEgPSByZXF1aXJlKFwiLi91dWlkXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVVVJRFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXVpZF8xLlVVSUQ7IH0gfSk7XG52YXIgUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybV8xID0gcmVxdWlyZShcIi4vUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlByb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm1cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFByb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm1fMS5Qcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtOyB9IH0pO1xudmFyIHhtbF8xID0gcmVxdWlyZShcIi4veG1sXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VYbWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHhtbF8xLnBhcnNlWG1sOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiWEVsZW1lbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHhtbF8xLlhFbGVtZW50OyB9IH0pO1xuLy8gbnNpc1xuZXhwb3J0cy5DVVJSRU5UX0FQUF9JTlNUQUxMRVJfRklMRV9OQU1FID0gXCJpbnN0YWxsZXIuZXhlXCI7XG4vLyBuc2lzLXdlYlxuZXhwb3J0cy5DVVJSRU5UX0FQUF9QQUNLQUdFX0ZJTEVfTkFNRSA9IFwicGFja2FnZS43elwiO1xuZnVuY3Rpb24gYXNBcnJheSh2KSB7XG4gICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW3ZdO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNBcnJheSA9IGFzQXJyYXk7XG5mdW5jdGlvbiBuZXdFcnJvcihtZXNzYWdlLCBjb2RlKSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gICAgcmV0dXJuIGVycm9yO1xufVxuZXhwb3J0cy5uZXdFcnJvciA9IG5ld0Vycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbmZ1bmN0aW9uIGlzTm90aGluZyhzdWJqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIHN1YmplY3QgPT09ICd1bmRlZmluZWQnKSB8fCAoc3ViamVjdCA9PT0gbnVsbCk7XG59XG5cblxuZnVuY3Rpb24gaXNPYmplY3Qoc3ViamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0JykgJiYgKHN1YmplY3QgIT09IG51bGwpO1xufVxuXG5cbmZ1bmN0aW9uIHRvQXJyYXkoc2VxdWVuY2UpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc2VxdWVuY2UpKSByZXR1cm4gc2VxdWVuY2U7XG4gIGVsc2UgaWYgKGlzTm90aGluZyhzZXF1ZW5jZSkpIHJldHVybiBbXTtcblxuICByZXR1cm4gWyBzZXF1ZW5jZSBdO1xufVxuXG5cbmZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xuICB2YXIgaW5kZXgsIGxlbmd0aCwga2V5LCBzb3VyY2VLZXlzO1xuXG4gIGlmIChzb3VyY2UpIHtcbiAgICBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBzb3VyY2VLZXlzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgIGtleSA9IHNvdXJjZUtleXNbaW5kZXhdO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5cbmZ1bmN0aW9uIHJlcGVhdChzdHJpbmcsIGNvdW50KSB7XG4gIHZhciByZXN1bHQgPSAnJywgY3ljbGU7XG5cbiAgZm9yIChjeWNsZSA9IDA7IGN5Y2xlIDwgY291bnQ7IGN5Y2xlICs9IDEpIHtcbiAgICByZXN1bHQgKz0gc3RyaW5nO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5mdW5jdGlvbiBpc05lZ2F0aXZlWmVybyhudW1iZXIpIHtcbiAgcmV0dXJuIChudW1iZXIgPT09IDApICYmIChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgPT09IDEgLyBudW1iZXIpO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzLmlzTm90aGluZyAgICAgID0gaXNOb3RoaW5nO1xubW9kdWxlLmV4cG9ydHMuaXNPYmplY3QgICAgICAgPSBpc09iamVjdDtcbm1vZHVsZS5leHBvcnRzLnRvQXJyYXkgICAgICAgID0gdG9BcnJheTtcbm1vZHVsZS5leHBvcnRzLnJlcGVhdCAgICAgICAgID0gcmVwZWF0O1xubW9kdWxlLmV4cG9ydHMuaXNOZWdhdGl2ZVplcm8gPSBpc05lZ2F0aXZlWmVybztcbm1vZHVsZS5leHBvcnRzLmV4dGVuZCAgICAgICAgID0gZXh0ZW5kO1xuIiwiLy8gWUFNTCBlcnJvciBjbGFzcy4gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84NDU4OTg0XG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKGV4Y2VwdGlvbiwgY29tcGFjdCkge1xuICB2YXIgd2hlcmUgPSAnJywgbWVzc2FnZSA9IGV4Y2VwdGlvbi5yZWFzb24gfHwgJyh1bmtub3duIHJlYXNvbiknO1xuXG4gIGlmICghZXhjZXB0aW9uLm1hcmspIHJldHVybiBtZXNzYWdlO1xuXG4gIGlmIChleGNlcHRpb24ubWFyay5uYW1lKSB7XG4gICAgd2hlcmUgKz0gJ2luIFwiJyArIGV4Y2VwdGlvbi5tYXJrLm5hbWUgKyAnXCIgJztcbiAgfVxuXG4gIHdoZXJlICs9ICcoJyArIChleGNlcHRpb24ubWFyay5saW5lICsgMSkgKyAnOicgKyAoZXhjZXB0aW9uLm1hcmsuY29sdW1uICsgMSkgKyAnKSc7XG5cbiAgaWYgKCFjb21wYWN0ICYmIGV4Y2VwdGlvbi5tYXJrLnNuaXBwZXQpIHtcbiAgICB3aGVyZSArPSAnXFxuXFxuJyArIGV4Y2VwdGlvbi5tYXJrLnNuaXBwZXQ7XG4gIH1cblxuICByZXR1cm4gbWVzc2FnZSArICcgJyArIHdoZXJlO1xufVxuXG5cbmZ1bmN0aW9uIFlBTUxFeGNlcHRpb24ocmVhc29uLCBtYXJrKSB7XG4gIC8vIFN1cGVyIGNvbnN0cnVjdG9yXG4gIEVycm9yLmNhbGwodGhpcyk7XG5cbiAgdGhpcy5uYW1lID0gJ1lBTUxFeGNlcHRpb24nO1xuICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgdGhpcy5tYXJrID0gbWFyaztcbiAgdGhpcy5tZXNzYWdlID0gZm9ybWF0RXJyb3IodGhpcywgZmFsc2UpO1xuXG4gIC8vIEluY2x1ZGUgc3RhY2sgdHJhY2UgaW4gZXJyb3Igb2JqZWN0XG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIC8vIENocm9tZSBhbmQgTm9kZUpTXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gRkYsIElFIDEwKyBhbmQgU2FmYXJpIDYrLiBGYWxsYmFjayBmb3Igb3RoZXJzXG4gICAgdGhpcy5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2sgfHwgJyc7XG4gIH1cbn1cblxuXG4vLyBJbmhlcml0IGZyb20gRXJyb3JcbllBTUxFeGNlcHRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuWUFNTEV4Y2VwdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBZQU1MRXhjZXB0aW9uO1xuXG5cbllBTUxFeGNlcHRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoY29tcGFjdCkge1xuICByZXR1cm4gdGhpcy5uYW1lICsgJzogJyArIGZvcm1hdEVycm9yKHRoaXMsIGNvbXBhY3QpO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFlBTUxFeGNlcHRpb247XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cblxuLy8gZ2V0IHNuaXBwZXQgZm9yIGEgc2luZ2xlIGxpbmUsIHJlc3BlY3RpbmcgbWF4TGVuZ3RoXG5mdW5jdGlvbiBnZXRMaW5lKGJ1ZmZlciwgbGluZVN0YXJ0LCBsaW5lRW5kLCBwb3NpdGlvbiwgbWF4TGluZUxlbmd0aCkge1xuICB2YXIgaGVhZCA9ICcnO1xuICB2YXIgdGFpbCA9ICcnO1xuICB2YXIgbWF4SGFsZkxlbmd0aCA9IE1hdGguZmxvb3IobWF4TGluZUxlbmd0aCAvIDIpIC0gMTtcblxuICBpZiAocG9zaXRpb24gLSBsaW5lU3RhcnQgPiBtYXhIYWxmTGVuZ3RoKSB7XG4gICAgaGVhZCA9ICcgLi4uICc7XG4gICAgbGluZVN0YXJ0ID0gcG9zaXRpb24gLSBtYXhIYWxmTGVuZ3RoICsgaGVhZC5sZW5ndGg7XG4gIH1cblxuICBpZiAobGluZUVuZCAtIHBvc2l0aW9uID4gbWF4SGFsZkxlbmd0aCkge1xuICAgIHRhaWwgPSAnIC4uLic7XG4gICAgbGluZUVuZCA9IHBvc2l0aW9uICsgbWF4SGFsZkxlbmd0aCAtIHRhaWwubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdHI6IGhlYWQgKyBidWZmZXIuc2xpY2UobGluZVN0YXJ0LCBsaW5lRW5kKS5yZXBsYWNlKC9cXHQvZywgJ+KGkicpICsgdGFpbCxcbiAgICBwb3M6IHBvc2l0aW9uIC0gbGluZVN0YXJ0ICsgaGVhZC5sZW5ndGggLy8gcmVsYXRpdmUgcG9zaXRpb25cbiAgfTtcbn1cblxuXG5mdW5jdGlvbiBwYWRTdGFydChzdHJpbmcsIG1heCkge1xuICByZXR1cm4gY29tbW9uLnJlcGVhdCgnICcsIG1heCAtIHN0cmluZy5sZW5ndGgpICsgc3RyaW5nO1xufVxuXG5cbmZ1bmN0aW9uIG1ha2VTbmlwcGV0KG1hcmssIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUob3B0aW9ucyB8fCBudWxsKTtcblxuICBpZiAoIW1hcmsuYnVmZmVyKSByZXR1cm4gbnVsbDtcblxuICBpZiAoIW9wdGlvbnMubWF4TGVuZ3RoKSBvcHRpb25zLm1heExlbmd0aCA9IDc5O1xuICBpZiAodHlwZW9mIG9wdGlvbnMuaW5kZW50ICAgICAgIT09ICdudW1iZXInKSBvcHRpb25zLmluZGVudCAgICAgID0gMTtcbiAgaWYgKHR5cGVvZiBvcHRpb25zLmxpbmVzQmVmb3JlICE9PSAnbnVtYmVyJykgb3B0aW9ucy5saW5lc0JlZm9yZSA9IDM7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5saW5lc0FmdGVyICAhPT0gJ251bWJlcicpIG9wdGlvbnMubGluZXNBZnRlciAgPSAyO1xuXG4gIHZhciByZSA9IC9cXHI/XFxufFxccnxcXDAvZztcbiAgdmFyIGxpbmVTdGFydHMgPSBbIDAgXTtcbiAgdmFyIGxpbmVFbmRzID0gW107XG4gIHZhciBtYXRjaDtcbiAgdmFyIGZvdW5kTGluZU5vID0gLTE7XG5cbiAgd2hpbGUgKChtYXRjaCA9IHJlLmV4ZWMobWFyay5idWZmZXIpKSkge1xuICAgIGxpbmVFbmRzLnB1c2gobWF0Y2guaW5kZXgpO1xuICAgIGxpbmVTdGFydHMucHVzaChtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG5cbiAgICBpZiAobWFyay5wb3NpdGlvbiA8PSBtYXRjaC5pbmRleCAmJiBmb3VuZExpbmVObyA8IDApIHtcbiAgICAgIGZvdW5kTGluZU5vID0gbGluZVN0YXJ0cy5sZW5ndGggLSAyO1xuICAgIH1cbiAgfVxuXG4gIGlmIChmb3VuZExpbmVObyA8IDApIGZvdW5kTGluZU5vID0gbGluZVN0YXJ0cy5sZW5ndGggLSAxO1xuXG4gIHZhciByZXN1bHQgPSAnJywgaSwgbGluZTtcbiAgdmFyIGxpbmVOb0xlbmd0aCA9IE1hdGgubWluKG1hcmsubGluZSArIG9wdGlvbnMubGluZXNBZnRlciwgbGluZUVuZHMubGVuZ3RoKS50b1N0cmluZygpLmxlbmd0aDtcbiAgdmFyIG1heExpbmVMZW5ndGggPSBvcHRpb25zLm1heExlbmd0aCAtIChvcHRpb25zLmluZGVudCArIGxpbmVOb0xlbmd0aCArIDMpO1xuXG4gIGZvciAoaSA9IDE7IGkgPD0gb3B0aW9ucy5saW5lc0JlZm9yZTsgaSsrKSB7XG4gICAgaWYgKGZvdW5kTGluZU5vIC0gaSA8IDApIGJyZWFrO1xuICAgIGxpbmUgPSBnZXRMaW5lKFxuICAgICAgbWFyay5idWZmZXIsXG4gICAgICBsaW5lU3RhcnRzW2ZvdW5kTGluZU5vIC0gaV0sXG4gICAgICBsaW5lRW5kc1tmb3VuZExpbmVObyAtIGldLFxuICAgICAgbWFyay5wb3NpdGlvbiAtIChsaW5lU3RhcnRzW2ZvdW5kTGluZU5vXSAtIGxpbmVTdGFydHNbZm91bmRMaW5lTm8gLSBpXSksXG4gICAgICBtYXhMaW5lTGVuZ3RoXG4gICAgKTtcbiAgICByZXN1bHQgPSBjb21tb24ucmVwZWF0KCcgJywgb3B0aW9ucy5pbmRlbnQpICsgcGFkU3RhcnQoKG1hcmsubGluZSAtIGkgKyAxKS50b1N0cmluZygpLCBsaW5lTm9MZW5ndGgpICtcbiAgICAgICcgfCAnICsgbGluZS5zdHIgKyAnXFxuJyArIHJlc3VsdDtcbiAgfVxuXG4gIGxpbmUgPSBnZXRMaW5lKG1hcmsuYnVmZmVyLCBsaW5lU3RhcnRzW2ZvdW5kTGluZU5vXSwgbGluZUVuZHNbZm91bmRMaW5lTm9dLCBtYXJrLnBvc2l0aW9uLCBtYXhMaW5lTGVuZ3RoKTtcbiAgcmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJyAnLCBvcHRpb25zLmluZGVudCkgKyBwYWRTdGFydCgobWFyay5saW5lICsgMSkudG9TdHJpbmcoKSwgbGluZU5vTGVuZ3RoKSArXG4gICAgJyB8ICcgKyBsaW5lLnN0ciArICdcXG4nO1xuICByZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnLScsIG9wdGlvbnMuaW5kZW50ICsgbGluZU5vTGVuZ3RoICsgMyArIGxpbmUucG9zKSArICdeJyArICdcXG4nO1xuXG4gIGZvciAoaSA9IDE7IGkgPD0gb3B0aW9ucy5saW5lc0FmdGVyOyBpKyspIHtcbiAgICBpZiAoZm91bmRMaW5lTm8gKyBpID49IGxpbmVFbmRzLmxlbmd0aCkgYnJlYWs7XG4gICAgbGluZSA9IGdldExpbmUoXG4gICAgICBtYXJrLmJ1ZmZlcixcbiAgICAgIGxpbmVTdGFydHNbZm91bmRMaW5lTm8gKyBpXSxcbiAgICAgIGxpbmVFbmRzW2ZvdW5kTGluZU5vICsgaV0sXG4gICAgICBtYXJrLnBvc2l0aW9uIC0gKGxpbmVTdGFydHNbZm91bmRMaW5lTm9dIC0gbGluZVN0YXJ0c1tmb3VuZExpbmVObyArIGldKSxcbiAgICAgIG1heExpbmVMZW5ndGhcbiAgICApO1xuICAgIHJlc3VsdCArPSBjb21tb24ucmVwZWF0KCcgJywgb3B0aW9ucy5pbmRlbnQpICsgcGFkU3RhcnQoKG1hcmsubGluZSArIGkgKyAxKS50b1N0cmluZygpLCBsaW5lTm9MZW5ndGgpICtcbiAgICAgICcgfCAnICsgbGluZS5zdHIgKyAnXFxuJztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQucmVwbGFjZSgvXFxuJC8sICcnKTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IG1ha2VTbmlwcGV0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgWUFNTEV4Y2VwdGlvbiA9IHJlcXVpcmUoJy4vZXhjZXB0aW9uJyk7XG5cbnZhciBUWVBFX0NPTlNUUlVDVE9SX09QVElPTlMgPSBbXG4gICdraW5kJyxcbiAgJ211bHRpJyxcbiAgJ3Jlc29sdmUnLFxuICAnY29uc3RydWN0JyxcbiAgJ2luc3RhbmNlT2YnLFxuICAncHJlZGljYXRlJyxcbiAgJ3JlcHJlc2VudCcsXG4gICdyZXByZXNlbnROYW1lJyxcbiAgJ2RlZmF1bHRTdHlsZScsXG4gICdzdHlsZUFsaWFzZXMnXG5dO1xuXG52YXIgWUFNTF9OT0RFX0tJTkRTID0gW1xuICAnc2NhbGFyJyxcbiAgJ3NlcXVlbmNlJyxcbiAgJ21hcHBpbmcnXG5dO1xuXG5mdW5jdGlvbiBjb21waWxlU3R5bGVBbGlhc2VzKG1hcCkge1xuICB2YXIgcmVzdWx0ID0ge307XG5cbiAgaWYgKG1hcCAhPT0gbnVsbCkge1xuICAgIE9iamVjdC5rZXlzKG1hcCkuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgIG1hcFtzdHlsZV0uZm9yRWFjaChmdW5jdGlvbiAoYWxpYXMpIHtcbiAgICAgICAgcmVzdWx0W1N0cmluZyhhbGlhcyldID0gc3R5bGU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIFR5cGUodGFnLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAoVFlQRV9DT05TVFJVQ1RPUl9PUFRJT05TLmluZGV4T2YobmFtZSkgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignVW5rbm93biBvcHRpb24gXCInICsgbmFtZSArICdcIiBpcyBtZXQgaW4gZGVmaW5pdGlvbiBvZiBcIicgKyB0YWcgKyAnXCIgWUFNTCB0eXBlLicpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gVE9ETzogQWRkIHRhZyBmb3JtYXQgY2hlY2suXG4gIHRoaXMub3B0aW9ucyAgICAgICA9IG9wdGlvbnM7IC8vIGtlZXAgb3JpZ2luYWwgb3B0aW9ucyBpbiBjYXNlIHVzZXIgd2FudHMgdG8gZXh0ZW5kIHRoaXMgdHlwZSBsYXRlclxuICB0aGlzLnRhZyAgICAgICAgICAgPSB0YWc7XG4gIHRoaXMua2luZCAgICAgICAgICA9IG9wdGlvbnNbJ2tpbmQnXSAgICAgICAgICB8fCBudWxsO1xuICB0aGlzLnJlc29sdmUgICAgICAgPSBvcHRpb25zWydyZXNvbHZlJ10gICAgICAgfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTtcbiAgdGhpcy5jb25zdHJ1Y3QgICAgID0gb3B0aW9uc1snY29uc3RydWN0J10gICAgIHx8IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhOyB9O1xuICB0aGlzLmluc3RhbmNlT2YgICAgPSBvcHRpb25zWydpbnN0YW5jZU9mJ10gICAgfHwgbnVsbDtcbiAgdGhpcy5wcmVkaWNhdGUgICAgID0gb3B0aW9uc1sncHJlZGljYXRlJ10gICAgIHx8IG51bGw7XG4gIHRoaXMucmVwcmVzZW50ICAgICA9IG9wdGlvbnNbJ3JlcHJlc2VudCddICAgICB8fCBudWxsO1xuICB0aGlzLnJlcHJlc2VudE5hbWUgPSBvcHRpb25zWydyZXByZXNlbnROYW1lJ10gfHwgbnVsbDtcbiAgdGhpcy5kZWZhdWx0U3R5bGUgID0gb3B0aW9uc1snZGVmYXVsdFN0eWxlJ10gIHx8IG51bGw7XG4gIHRoaXMubXVsdGkgICAgICAgICA9IG9wdGlvbnNbJ211bHRpJ10gICAgICAgICB8fCBmYWxzZTtcbiAgdGhpcy5zdHlsZUFsaWFzZXMgID0gY29tcGlsZVN0eWxlQWxpYXNlcyhvcHRpb25zWydzdHlsZUFsaWFzZXMnXSB8fCBudWxsKTtcblxuICBpZiAoWUFNTF9OT0RFX0tJTkRTLmluZGV4T2YodGhpcy5raW5kKSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignVW5rbm93biBraW5kIFwiJyArIHRoaXMua2luZCArICdcIiBpcyBzcGVjaWZpZWQgZm9yIFwiJyArIHRhZyArICdcIiBZQU1MIHR5cGUuJyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUeXBlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludC1kaXNhYmxlIG1heC1sZW4qL1xuXG52YXIgWUFNTEV4Y2VwdGlvbiA9IHJlcXVpcmUoJy4vZXhjZXB0aW9uJyk7XG52YXIgVHlwZSAgICAgICAgICA9IHJlcXVpcmUoJy4vdHlwZScpO1xuXG5cbmZ1bmN0aW9uIGNvbXBpbGVMaXN0KHNjaGVtYSwgbmFtZSkge1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgc2NoZW1hW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKGN1cnJlbnRUeXBlKSB7XG4gICAgdmFyIG5ld0luZGV4ID0gcmVzdWx0Lmxlbmd0aDtcblxuICAgIHJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChwcmV2aW91c1R5cGUsIHByZXZpb3VzSW5kZXgpIHtcbiAgICAgIGlmIChwcmV2aW91c1R5cGUudGFnID09PSBjdXJyZW50VHlwZS50YWcgJiZcbiAgICAgICAgICBwcmV2aW91c1R5cGUua2luZCA9PT0gY3VycmVudFR5cGUua2luZCAmJlxuICAgICAgICAgIHByZXZpb3VzVHlwZS5tdWx0aSA9PT0gY3VycmVudFR5cGUubXVsdGkpIHtcblxuICAgICAgICBuZXdJbmRleCA9IHByZXZpb3VzSW5kZXg7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXN1bHRbbmV3SW5kZXhdID0gY3VycmVudFR5cGU7XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuZnVuY3Rpb24gY29tcGlsZU1hcCgvKiBsaXN0cy4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICBzY2FsYXI6IHt9LFxuICAgICAgICBzZXF1ZW5jZToge30sXG4gICAgICAgIG1hcHBpbmc6IHt9LFxuICAgICAgICBmYWxsYmFjazoge30sXG4gICAgICAgIG11bHRpOiB7XG4gICAgICAgICAgc2NhbGFyOiBbXSxcbiAgICAgICAgICBzZXF1ZW5jZTogW10sXG4gICAgICAgICAgbWFwcGluZzogW10sXG4gICAgICAgICAgZmFsbGJhY2s6IFtdXG4gICAgICAgIH1cbiAgICAgIH0sIGluZGV4LCBsZW5ndGg7XG5cbiAgZnVuY3Rpb24gY29sbGVjdFR5cGUodHlwZSkge1xuICAgIGlmICh0eXBlLm11bHRpKSB7XG4gICAgICByZXN1bHQubXVsdGlbdHlwZS5raW5kXS5wdXNoKHR5cGUpO1xuICAgICAgcmVzdWx0Lm11bHRpWydmYWxsYmFjayddLnB1c2godHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFt0eXBlLmtpbmRdW3R5cGUudGFnXSA9IHJlc3VsdFsnZmFsbGJhY2snXVt0eXBlLnRhZ10gPSB0eXBlO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIGFyZ3VtZW50c1tpbmRleF0uZm9yRWFjaChjb2xsZWN0VHlwZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5mdW5jdGlvbiBTY2hlbWEoZGVmaW5pdGlvbikge1xuICByZXR1cm4gdGhpcy5leHRlbmQoZGVmaW5pdGlvbik7XG59XG5cblxuU2NoZW1hLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbiBleHRlbmQoZGVmaW5pdGlvbikge1xuICB2YXIgaW1wbGljaXQgPSBbXTtcbiAgdmFyIGV4cGxpY2l0ID0gW107XG5cbiAgaWYgKGRlZmluaXRpb24gaW5zdGFuY2VvZiBUeXBlKSB7XG4gICAgLy8gU2NoZW1hLmV4dGVuZCh0eXBlKVxuICAgIGV4cGxpY2l0LnB1c2goZGVmaW5pdGlvbik7XG5cbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRlZmluaXRpb24pKSB7XG4gICAgLy8gU2NoZW1hLmV4dGVuZChbIHR5cGUxLCB0eXBlMiwgLi4uIF0pXG4gICAgZXhwbGljaXQgPSBleHBsaWNpdC5jb25jYXQoZGVmaW5pdGlvbik7XG5cbiAgfSBlbHNlIGlmIChkZWZpbml0aW9uICYmIChBcnJheS5pc0FycmF5KGRlZmluaXRpb24uaW1wbGljaXQpIHx8IEFycmF5LmlzQXJyYXkoZGVmaW5pdGlvbi5leHBsaWNpdCkpKSB7XG4gICAgLy8gU2NoZW1hLmV4dGVuZCh7IGV4cGxpY2l0OiBbIHR5cGUxLCB0eXBlMiwgLi4uIF0sIGltcGxpY2l0OiBbIHR5cGUxLCB0eXBlMiwgLi4uIF0gfSlcbiAgICBpZiAoZGVmaW5pdGlvbi5pbXBsaWNpdCkgaW1wbGljaXQgPSBpbXBsaWNpdC5jb25jYXQoZGVmaW5pdGlvbi5pbXBsaWNpdCk7XG4gICAgaWYgKGRlZmluaXRpb24uZXhwbGljaXQpIGV4cGxpY2l0ID0gZXhwbGljaXQuY29uY2F0KGRlZmluaXRpb24uZXhwbGljaXQpO1xuXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ1NjaGVtYS5leHRlbmQgYXJndW1lbnQgc2hvdWxkIGJlIGEgVHlwZSwgWyBUeXBlIF0sICcgK1xuICAgICAgJ29yIGEgc2NoZW1hIGRlZmluaXRpb24gKHsgaW1wbGljaXQ6IFsuLi5dLCBleHBsaWNpdDogWy4uLl0gfSknKTtcbiAgfVxuXG4gIGltcGxpY2l0LmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBpZiAoISh0eXBlIGluc3RhbmNlb2YgVHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdTcGVjaWZpZWQgbGlzdCBvZiBZQU1MIHR5cGVzIChvciBhIHNpbmdsZSBUeXBlIG9iamVjdCkgY29udGFpbnMgYSBub24tVHlwZSBvYmplY3QuJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUubG9hZEtpbmQgJiYgdHlwZS5sb2FkS2luZCAhPT0gJ3NjYWxhcicpIHtcbiAgICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdUaGVyZSBpcyBhIG5vbi1zY2FsYXIgdHlwZSBpbiB0aGUgaW1wbGljaXQgbGlzdCBvZiBhIHNjaGVtYS4gSW1wbGljaXQgcmVzb2x2aW5nIG9mIHN1Y2ggdHlwZXMgaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZS5tdWx0aSkge1xuICAgICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ1RoZXJlIGlzIGEgbXVsdGkgdHlwZSBpbiB0aGUgaW1wbGljaXQgbGlzdCBvZiBhIHNjaGVtYS4gTXVsdGkgdGFncyBjYW4gb25seSBiZSBsaXN0ZWQgYXMgZXhwbGljaXQuJyk7XG4gICAgfVxuICB9KTtcblxuICBleHBsaWNpdC5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgaWYgKCEodHlwZSBpbnN0YW5jZW9mIFR5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignU3BlY2lmaWVkIGxpc3Qgb2YgWUFNTCB0eXBlcyAob3IgYSBzaW5nbGUgVHlwZSBvYmplY3QpIGNvbnRhaW5zIGEgbm9uLVR5cGUgb2JqZWN0LicpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUoU2NoZW1hLnByb3RvdHlwZSk7XG5cbiAgcmVzdWx0LmltcGxpY2l0ID0gKHRoaXMuaW1wbGljaXQgfHwgW10pLmNvbmNhdChpbXBsaWNpdCk7XG4gIHJlc3VsdC5leHBsaWNpdCA9ICh0aGlzLmV4cGxpY2l0IHx8IFtdKS5jb25jYXQoZXhwbGljaXQpO1xuXG4gIHJlc3VsdC5jb21waWxlZEltcGxpY2l0ID0gY29tcGlsZUxpc3QocmVzdWx0LCAnaW1wbGljaXQnKTtcbiAgcmVzdWx0LmNvbXBpbGVkRXhwbGljaXQgPSBjb21waWxlTGlzdChyZXN1bHQsICdleHBsaWNpdCcpO1xuICByZXN1bHQuY29tcGlsZWRUeXBlTWFwICA9IGNvbXBpbGVNYXAocmVzdWx0LmNvbXBpbGVkSW1wbGljaXQsIHJlc3VsdC5jb21waWxlZEV4cGxpY2l0KTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkYXRhIDogJyc7IH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6c2VxJywge1xuICBraW5kOiAnc2VxdWVuY2UnLFxuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhICE9PSBudWxsID8gZGF0YSA6IFtdOyB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm1hcCcsIHtcbiAga2luZDogJ21hcHBpbmcnLFxuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhICE9PSBudWxsID8gZGF0YSA6IHt9OyB9XG59KTtcbiIsIi8vIFN0YW5kYXJkIFlBTUwncyBGYWlsc2FmZSBzY2hlbWEuXG4vLyBodHRwOi8vd3d3LnlhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNpZDI4MDIzNDZcblxuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFNjaGVtYSA9IHJlcXVpcmUoJy4uL3NjaGVtYScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFNjaGVtYSh7XG4gIGV4cGxpY2l0OiBbXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9zdHInKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL3NlcScpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvbWFwJylcbiAgXVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbE51bGwoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG5cbiAgdmFyIG1heCA9IGRhdGEubGVuZ3RoO1xuXG4gIHJldHVybiAobWF4ID09PSAxICYmIGRhdGEgPT09ICd+JykgfHxcbiAgICAgICAgIChtYXggPT09IDQgJiYgKGRhdGEgPT09ICdudWxsJyB8fCBkYXRhID09PSAnTnVsbCcgfHwgZGF0YSA9PT0gJ05VTEwnKSk7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxOdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNOdWxsKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ID09PSBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpudWxsJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxOdWxsLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxOdWxsLFxuICBwcmVkaWNhdGU6IGlzTnVsbCxcbiAgcmVwcmVzZW50OiB7XG4gICAgY2Fub25pY2FsOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnfic7ICAgIH0sXG4gICAgbG93ZXJjYXNlOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnbnVsbCc7IH0sXG4gICAgdXBwZXJjYXNlOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnTlVMTCc7IH0sXG4gICAgY2FtZWxjYXNlOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnTnVsbCc7IH0sXG4gICAgZW1wdHk6ICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiAnJzsgICAgIH1cbiAgfSxcbiAgZGVmYXVsdFN0eWxlOiAnbG93ZXJjYXNlJ1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEJvb2xlYW4oZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBtYXggPSBkYXRhLmxlbmd0aDtcblxuICByZXR1cm4gKG1heCA9PT0gNCAmJiAoZGF0YSA9PT0gJ3RydWUnIHx8IGRhdGEgPT09ICdUcnVlJyB8fCBkYXRhID09PSAnVFJVRScpKSB8fFxuICAgICAgICAgKG1heCA9PT0gNSAmJiAoZGF0YSA9PT0gJ2ZhbHNlJyB8fCBkYXRhID09PSAnRmFsc2UnIHx8IGRhdGEgPT09ICdGQUxTRScpKTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEJvb2xlYW4oZGF0YSkge1xuICByZXR1cm4gZGF0YSA9PT0gJ3RydWUnIHx8XG4gICAgICAgICBkYXRhID09PSAnVHJ1ZScgfHxcbiAgICAgICAgIGRhdGEgPT09ICdUUlVFJztcbn1cblxuZnVuY3Rpb24gaXNCb29sZWFuKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IEJvb2xlYW5dJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6Ym9vbCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sQm9vbGVhbixcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sQm9vbGVhbixcbiAgcHJlZGljYXRlOiBpc0Jvb2xlYW4sXG4gIHJlcHJlc2VudDoge1xuICAgIGxvd2VyY2FzZTogZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4gb2JqZWN0ID8gJ3RydWUnIDogJ2ZhbHNlJzsgfSxcbiAgICB1cHBlcmNhc2U6IGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuIG9iamVjdCA/ICdUUlVFJyA6ICdGQUxTRSc7IH0sXG4gICAgY2FtZWxjYXNlOiBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiBvYmplY3QgPyAnVHJ1ZScgOiAnRmFsc2UnOyB9XG4gIH0sXG4gIGRlZmF1bHRTdHlsZTogJ2xvd2VyY2FzZSdcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG52YXIgVHlwZSAgID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5mdW5jdGlvbiBpc0hleENvZGUoYykge1xuICByZXR1cm4gKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM5LyogOSAqLykpIHx8XG4gICAgICAgICAoKDB4NDEvKiBBICovIDw9IGMpICYmIChjIDw9IDB4NDYvKiBGICovKSkgfHxcbiAgICAgICAgICgoMHg2MS8qIGEgKi8gPD0gYykgJiYgKGMgPD0gMHg2Ni8qIGYgKi8pKTtcbn1cblxuZnVuY3Rpb24gaXNPY3RDb2RlKGMpIHtcbiAgcmV0dXJuICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzNy8qIDcgKi8pKTtcbn1cblxuZnVuY3Rpb24gaXNEZWNDb2RlKGMpIHtcbiAgcmV0dXJuICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzOS8qIDkgKi8pKTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxJbnRlZ2VyKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICB2YXIgbWF4ID0gZGF0YS5sZW5ndGgsXG4gICAgICBpbmRleCA9IDAsXG4gICAgICBoYXNEaWdpdHMgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIGlmICghbWF4KSByZXR1cm4gZmFsc2U7XG5cbiAgY2ggPSBkYXRhW2luZGV4XTtcblxuICAvLyBzaWduXG4gIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcbiAgICBjaCA9IGRhdGFbKytpbmRleF07XG4gIH1cblxuICBpZiAoY2ggPT09ICcwJykge1xuICAgIC8vIDBcbiAgICBpZiAoaW5kZXggKyAxID09PSBtYXgpIHJldHVybiB0cnVlO1xuICAgIGNoID0gZGF0YVsrK2luZGV4XTtcblxuICAgIC8vIGJhc2UgMiwgYmFzZSA4LCBiYXNlIDE2XG5cbiAgICBpZiAoY2ggPT09ICdiJykge1xuICAgICAgLy8gYmFzZSAyXG4gICAgICBpbmRleCsrO1xuXG4gICAgICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICAgICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGNoID09PSAnXycpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoY2ggIT09ICcwJyAmJiBjaCAhPT0gJzEnKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGhhc0RpZ2l0cyA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzRGlnaXRzICYmIGNoICE9PSAnXyc7XG4gICAgfVxuXG5cbiAgICBpZiAoY2ggPT09ICd4Jykge1xuICAgICAgLy8gYmFzZSAxNlxuICAgICAgaW5kZXgrKztcblxuICAgICAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgICAgIGlmIChjaCA9PT0gJ18nKSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFpc0hleENvZGUoZGF0YS5jaGFyQ29kZUF0KGluZGV4KSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaGFzRGlnaXRzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNEaWdpdHMgJiYgY2ggIT09ICdfJztcbiAgICB9XG5cblxuICAgIGlmIChjaCA9PT0gJ28nKSB7XG4gICAgICAvLyBiYXNlIDhcbiAgICAgIGluZGV4Kys7XG5cbiAgICAgIGZvciAoOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgICAgICBjaCA9IGRhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoY2ggPT09ICdfJykgY29udGludWU7XG4gICAgICAgIGlmICghaXNPY3RDb2RlKGRhdGEuY2hhckNvZGVBdChpbmRleCkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGhhc0RpZ2l0cyA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzRGlnaXRzICYmIGNoICE9PSAnXyc7XG4gICAgfVxuICB9XG5cbiAgLy8gYmFzZSAxMCAoZXhjZXB0IDApXG5cbiAgLy8gdmFsdWUgc2hvdWxkIG5vdCBzdGFydCB3aXRoIGBfYDtcbiAgaWYgKGNoID09PSAnXycpIHJldHVybiBmYWxzZTtcblxuICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICBjaCA9IGRhdGFbaW5kZXhdO1xuICAgIGlmIChjaCA9PT0gJ18nKSBjb250aW51ZTtcbiAgICBpZiAoIWlzRGVjQ29kZShkYXRhLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICB9XG5cbiAgLy8gU2hvdWxkIGhhdmUgZGlnaXRzIGFuZCBzaG91bGQgbm90IGVuZCB3aXRoIGBfYFxuICBpZiAoIWhhc0RpZ2l0cyB8fCBjaCA9PT0gJ18nKSByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxJbnRlZ2VyKGRhdGEpIHtcbiAgdmFyIHZhbHVlID0gZGF0YSwgc2lnbiA9IDEsIGNoO1xuXG4gIGlmICh2YWx1ZS5pbmRleE9mKCdfJykgIT09IC0xKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9fL2csICcnKTtcbiAgfVxuXG4gIGNoID0gdmFsdWVbMF07XG5cbiAgaWYgKGNoID09PSAnLScgfHwgY2ggPT09ICcrJykge1xuICAgIGlmIChjaCA9PT0gJy0nKSBzaWduID0gLTE7XG4gICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxKTtcbiAgICBjaCA9IHZhbHVlWzBdO1xuICB9XG5cbiAgaWYgKHZhbHVlID09PSAnMCcpIHJldHVybiAwO1xuXG4gIGlmIChjaCA9PT0gJzAnKSB7XG4gICAgaWYgKHZhbHVlWzFdID09PSAnYicpIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIDIpO1xuICAgIGlmICh2YWx1ZVsxXSA9PT0gJ3gnKSByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCAxNik7XG4gICAgaWYgKHZhbHVlWzFdID09PSAnbycpIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIDgpO1xuICB9XG5cbiAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZSwgMTApO1xufVxuXG5mdW5jdGlvbiBpc0ludGVnZXIob2JqZWN0KSB7XG4gIHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkpID09PSAnW29iamVjdCBOdW1iZXJdJyAmJlxuICAgICAgICAgKG9iamVjdCAlIDEgPT09IDAgJiYgIWNvbW1vbi5pc05lZ2F0aXZlWmVybyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6aW50Jywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxJbnRlZ2VyLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxJbnRlZ2VyLFxuICBwcmVkaWNhdGU6IGlzSW50ZWdlcixcbiAgcmVwcmVzZW50OiB7XG4gICAgYmluYXJ5OiAgICAgIGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiA+PSAwID8gJzBiJyArIG9iai50b1N0cmluZygyKSA6ICctMGInICsgb2JqLnRvU3RyaW5nKDIpLnNsaWNlKDEpOyB9LFxuICAgIG9jdGFsOiAgICAgICBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogPj0gMCA/ICcwbycgICsgb2JqLnRvU3RyaW5nKDgpIDogJy0wbycgICsgb2JqLnRvU3RyaW5nKDgpLnNsaWNlKDEpOyB9LFxuICAgIGRlY2ltYWw6ICAgICBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmoudG9TdHJpbmcoMTApOyB9LFxuICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbiAgICBoZXhhZGVjaW1hbDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqID49IDAgPyAnMHgnICsgb2JqLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpIDogICctMHgnICsgb2JqLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpLnNsaWNlKDEpOyB9XG4gIH0sXG4gIGRlZmF1bHRTdHlsZTogJ2RlY2ltYWwnLFxuICBzdHlsZUFsaWFzZXM6IHtcbiAgICBiaW5hcnk6ICAgICAgWyAyLCAgJ2JpbicgXSxcbiAgICBvY3RhbDogICAgICAgWyA4LCAgJ29jdCcgXSxcbiAgICBkZWNpbWFsOiAgICAgWyAxMCwgJ2RlYycgXSxcbiAgICBoZXhhZGVjaW1hbDogWyAxNiwgJ2hleCcgXVxuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xudmFyIFR5cGUgICA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIFlBTUxfRkxPQVRfUEFUVEVSTiA9IG5ldyBSZWdFeHAoXG4gIC8vIDIuNWU0LCAyLjUgYW5kIGludGVnZXJzXG4gICdeKD86Wy0rXT8oPzpbMC05XVswLTlfXSopKD86XFxcXC5bMC05X10qKT8oPzpbZUVdWy0rXT9bMC05XSspPycgK1xuICAvLyAuMmU0LCAuMlxuICAvLyBzcGVjaWFsIGNhc2UsIHNlZW1zIG5vdCBmcm9tIHNwZWNcbiAgJ3xcXFxcLlswLTlfXSsoPzpbZUVdWy0rXT9bMC05XSspPycgK1xuICAvLyAuaW5mXG4gICd8Wy0rXT9cXFxcLig/OmluZnxJbmZ8SU5GKScgK1xuICAvLyAubmFuXG4gICd8XFxcXC4oPzpuYW58TmFOfE5BTikpJCcpO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEZsb2F0KGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICBpZiAoIVlBTUxfRkxPQVRfUEFUVEVSTi50ZXN0KGRhdGEpIHx8XG4gICAgICAvLyBRdWljayBoYWNrIHRvIG5vdCBhbGxvdyBpbnRlZ2VycyBlbmQgd2l0aCBgX2BcbiAgICAgIC8vIFByb2JhYmx5IHNob3VsZCB1cGRhdGUgcmVnZXhwICYgY2hlY2sgc3BlZWRcbiAgICAgIGRhdGFbZGF0YS5sZW5ndGggLSAxXSA9PT0gJ18nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxGbG9hdChkYXRhKSB7XG4gIHZhciB2YWx1ZSwgc2lnbjtcblxuICB2YWx1ZSAgPSBkYXRhLnJlcGxhY2UoL18vZywgJycpLnRvTG93ZXJDYXNlKCk7XG4gIHNpZ24gICA9IHZhbHVlWzBdID09PSAnLScgPyAtMSA6IDE7XG5cbiAgaWYgKCcrLScuaW5kZXhPZih2YWx1ZVswXSkgPj0gMCkge1xuICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMSk7XG4gIH1cblxuICBpZiAodmFsdWUgPT09ICcuaW5mJykge1xuICAgIHJldHVybiAoc2lnbiA9PT0gMSkgPyBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgOiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG5cbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJy5uYW4nKSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuICByZXR1cm4gc2lnbiAqIHBhcnNlRmxvYXQodmFsdWUsIDEwKTtcbn1cblxuXG52YXIgU0NJRU5USUZJQ19XSVRIT1VUX0RPVCA9IC9eWy0rXT9bMC05XStlLztcblxuZnVuY3Rpb24gcmVwcmVzZW50WWFtbEZsb2F0KG9iamVjdCwgc3R5bGUpIHtcbiAgdmFyIHJlcztcblxuICBpZiAoaXNOYU4ob2JqZWN0KSkge1xuICAgIHN3aXRjaCAoc3R5bGUpIHtcbiAgICAgIGNhc2UgJ2xvd2VyY2FzZSc6IHJldHVybiAnLm5hbic7XG4gICAgICBjYXNlICd1cHBlcmNhc2UnOiByZXR1cm4gJy5OQU4nO1xuICAgICAgY2FzZSAnY2FtZWxjYXNlJzogcmV0dXJuICcuTmFOJztcbiAgICB9XG4gIH0gZWxzZSBpZiAoTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZID09PSBvYmplY3QpIHtcbiAgICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgICBjYXNlICdsb3dlcmNhc2UnOiByZXR1cm4gJy5pbmYnO1xuICAgICAgY2FzZSAndXBwZXJjYXNlJzogcmV0dXJuICcuSU5GJztcbiAgICAgIGNhc2UgJ2NhbWVsY2FzZSc6IHJldHVybiAnLkluZic7XG4gICAgfVxuICB9IGVsc2UgaWYgKE51bWJlci5ORUdBVElWRV9JTkZJTklUWSA9PT0gb2JqZWN0KSB7XG4gICAgc3dpdGNoIChzdHlsZSkge1xuICAgICAgY2FzZSAnbG93ZXJjYXNlJzogcmV0dXJuICctLmluZic7XG4gICAgICBjYXNlICd1cHBlcmNhc2UnOiByZXR1cm4gJy0uSU5GJztcbiAgICAgIGNhc2UgJ2NhbWVsY2FzZSc6IHJldHVybiAnLS5JbmYnO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjb21tb24uaXNOZWdhdGl2ZVplcm8ob2JqZWN0KSkge1xuICAgIHJldHVybiAnLTAuMCc7XG4gIH1cblxuICByZXMgPSBvYmplY3QudG9TdHJpbmcoMTApO1xuXG4gIC8vIEpTIHN0cmluZ2lmaWVyIGNhbiBidWlsZCBzY2llbnRpZmljIGZvcm1hdCB3aXRob3V0IGRvdHM6IDVlLTEwMCxcbiAgLy8gd2hpbGUgWUFNTCByZXF1cmVzIGRvdDogNS5lLTEwMC4gRml4IGl0IHdpdGggc2ltcGxlIGhhY2tcblxuICByZXR1cm4gU0NJRU5USUZJQ19XSVRIT1VUX0RPVC50ZXN0KHJlcykgPyByZXMucmVwbGFjZSgnZScsICcuZScpIDogcmVzO1xufVxuXG5mdW5jdGlvbiBpc0Zsb2F0KG9iamVjdCkge1xuICByZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBOdW1iZXJdJykgJiZcbiAgICAgICAgIChvYmplY3QgJSAxICE9PSAwIHx8IGNvbW1vbi5pc05lZ2F0aXZlWmVybyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEZsb2F0LFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxGbG9hdCxcbiAgcHJlZGljYXRlOiBpc0Zsb2F0LFxuICByZXByZXNlbnQ6IHJlcHJlc2VudFlhbWxGbG9hdCxcbiAgZGVmYXVsdFN0eWxlOiAnbG93ZXJjYXNlJ1xufSk7XG4iLCIvLyBTdGFuZGFyZCBZQU1MJ3MgSlNPTiBzY2hlbWEuXG4vLyBodHRwOi8vd3d3LnlhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNpZDI4MDMyMzFcbi8vXG4vLyBOT1RFOiBKUy1ZQU1MIGRvZXMgbm90IHN1cHBvcnQgc2NoZW1hLXNwZWNpZmljIHRhZyByZXNvbHV0aW9uIHJlc3RyaWN0aW9ucy5cbi8vIFNvLCB0aGlzIHNjaGVtYSBpcyBub3Qgc3VjaCBzdHJpY3QgYXMgZGVmaW5lZCBpbiB0aGUgWUFNTCBzcGVjaWZpY2F0aW9uLlxuLy8gSXQgYWxsb3dzIG51bWJlcnMgaW4gYmluYXJ5IG5vdGFpb24sIHVzZSBgTnVsbGAgYW5kIGBOVUxMYCBhcyBgbnVsbGAsIGV0Yy5cblxuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhaWxzYWZlJykuZXh0ZW5kKHtcbiAgaW1wbGljaXQ6IFtcbiAgICByZXF1aXJlKCcuLi90eXBlL251bGwnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL2Jvb2wnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL2ludCcpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvZmxvYXQnKVxuICBdXG59KTtcbiIsIi8vIFN0YW5kYXJkIFlBTUwncyBDb3JlIHNjaGVtYS5cbi8vIGh0dHA6Ly93d3cueWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI2lkMjgwNDkyM1xuLy9cbi8vIE5PVEU6IEpTLVlBTUwgZG9lcyBub3Qgc3VwcG9ydCBzY2hlbWEtc3BlY2lmaWMgdGFnIHJlc29sdXRpb24gcmVzdHJpY3Rpb25zLlxuLy8gU28sIENvcmUgc2NoZW1hIGhhcyBubyBkaXN0aW5jdGlvbnMgZnJvbSBKU09OIHNjaGVtYSBpcyBKUy1ZQU1MLlxuXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vanNvbicpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIFlBTUxfREFURV9SRUdFWFAgPSBuZXcgUmVnRXhwKFxuICAnXihbMC05XVswLTldWzAtOV1bMC05XSknICAgICAgICAgICsgLy8gWzFdIHllYXJcbiAgJy0oWzAtOV1bMC05XSknICAgICAgICAgICAgICAgICAgICArIC8vIFsyXSBtb250aFxuICAnLShbMC05XVswLTldKSQnKTsgICAgICAgICAgICAgICAgICAgLy8gWzNdIGRheVxuXG52YXIgWUFNTF9USU1FU1RBTVBfUkVHRVhQID0gbmV3IFJlZ0V4cChcbiAgJ14oWzAtOV1bMC05XVswLTldWzAtOV0pJyAgICAgICAgICArIC8vIFsxXSB5ZWFyXG4gICctKFswLTldWzAtOV0/KScgICAgICAgICAgICAgICAgICAgKyAvLyBbMl0gbW9udGhcbiAgJy0oWzAtOV1bMC05XT8pJyAgICAgICAgICAgICAgICAgICArIC8vIFszXSBkYXlcbiAgJyg/OltUdF18WyBcXFxcdF0rKScgICAgICAgICAgICAgICAgICsgLy8gLi4uXG4gICcoWzAtOV1bMC05XT8pJyAgICAgICAgICAgICAgICAgICAgKyAvLyBbNF0gaG91clxuICAnOihbMC05XVswLTldKScgICAgICAgICAgICAgICAgICAgICsgLy8gWzVdIG1pbnV0ZVxuICAnOihbMC05XVswLTldKScgICAgICAgICAgICAgICAgICAgICsgLy8gWzZdIHNlY29uZFxuICAnKD86XFxcXC4oWzAtOV0qKSk/JyAgICAgICAgICAgICAgICAgKyAvLyBbN10gZnJhY3Rpb25cbiAgJyg/OlsgXFxcXHRdKihafChbLStdKShbMC05XVswLTldPyknICsgLy8gWzhdIHR6IFs5XSB0el9zaWduIFsxMF0gdHpfaG91clxuICAnKD86OihbMC05XVswLTldKSk/KSk/JCcpOyAgICAgICAgICAgLy8gWzExXSB0el9taW51dGVcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxUaW1lc3RhbXAoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoWUFNTF9EQVRFX1JFR0VYUC5leGVjKGRhdGEpICE9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKFlBTUxfVElNRVNUQU1QX1JFR0VYUC5leGVjKGRhdGEpICE9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sVGltZXN0YW1wKGRhdGEpIHtcbiAgdmFyIG1hdGNoLCB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgZnJhY3Rpb24gPSAwLFxuICAgICAgZGVsdGEgPSBudWxsLCB0el9ob3VyLCB0el9taW51dGUsIGRhdGU7XG5cbiAgbWF0Y2ggPSBZQU1MX0RBVEVfUkVHRVhQLmV4ZWMoZGF0YSk7XG4gIGlmIChtYXRjaCA9PT0gbnVsbCkgbWF0Y2ggPSBZQU1MX1RJTUVTVEFNUF9SRUdFWFAuZXhlYyhkYXRhKTtcblxuICBpZiAobWF0Y2ggPT09IG51bGwpIHRocm93IG5ldyBFcnJvcignRGF0ZSByZXNvbHZlIGVycm9yJyk7XG5cbiAgLy8gbWF0Y2g6IFsxXSB5ZWFyIFsyXSBtb250aCBbM10gZGF5XG5cbiAgeWVhciA9ICsobWF0Y2hbMV0pO1xuICBtb250aCA9ICsobWF0Y2hbMl0pIC0gMTsgLy8gSlMgbW9udGggc3RhcnRzIHdpdGggMFxuICBkYXkgPSArKG1hdGNoWzNdKTtcblxuICBpZiAoIW1hdGNoWzRdKSB7IC8vIG5vIGhvdXJcbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSkpO1xuICB9XG5cbiAgLy8gbWF0Y2g6IFs0XSBob3VyIFs1XSBtaW51dGUgWzZdIHNlY29uZCBbN10gZnJhY3Rpb25cblxuICBob3VyID0gKyhtYXRjaFs0XSk7XG4gIG1pbnV0ZSA9ICsobWF0Y2hbNV0pO1xuICBzZWNvbmQgPSArKG1hdGNoWzZdKTtcblxuICBpZiAobWF0Y2hbN10pIHtcbiAgICBmcmFjdGlvbiA9IG1hdGNoWzddLnNsaWNlKDAsIDMpO1xuICAgIHdoaWxlIChmcmFjdGlvbi5sZW5ndGggPCAzKSB7IC8vIG1pbGxpLXNlY29uZHNcbiAgICAgIGZyYWN0aW9uICs9ICcwJztcbiAgICB9XG4gICAgZnJhY3Rpb24gPSArZnJhY3Rpb247XG4gIH1cblxuICAvLyBtYXRjaDogWzhdIHR6IFs5XSB0el9zaWduIFsxMF0gdHpfaG91ciBbMTFdIHR6X21pbnV0ZVxuXG4gIGlmIChtYXRjaFs5XSkge1xuICAgIHR6X2hvdXIgPSArKG1hdGNoWzEwXSk7XG4gICAgdHpfbWludXRlID0gKyhtYXRjaFsxMV0gfHwgMCk7XG4gICAgZGVsdGEgPSAodHpfaG91ciAqIDYwICsgdHpfbWludXRlKSAqIDYwMDAwOyAvLyBkZWx0YSBpbiBtaWxpLXNlY29uZHNcbiAgICBpZiAobWF0Y2hbOV0gPT09ICctJykgZGVsdGEgPSAtZGVsdGE7XG4gIH1cblxuICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIGZyYWN0aW9uKSk7XG5cbiAgaWYgKGRlbHRhKSBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgLSBkZWx0YSk7XG5cbiAgcmV0dXJuIGRhdGU7XG59XG5cbmZ1bmN0aW9uIHJlcHJlc2VudFlhbWxUaW1lc3RhbXAob2JqZWN0IC8qLCBzdHlsZSovKSB7XG4gIHJldHVybiBvYmplY3QudG9JU09TdHJpbmcoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6dGltZXN0YW1wJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxUaW1lc3RhbXAsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbFRpbWVzdGFtcCxcbiAgaW5zdGFuY2VPZjogRGF0ZSxcbiAgcmVwcmVzZW50OiByZXByZXNlbnRZYW1sVGltZXN0YW1wXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sTWVyZ2UoZGF0YSkge1xuICByZXR1cm4gZGF0YSA9PT0gJzw8JyB8fCBkYXRhID09PSBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjptZXJnZScsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sTWVyZ2Vcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UqL1xuXG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5cbi8vIFsgNjQsIDY1LCA2NiBdIC0+IFsgcGFkZGluZywgQ1IsIExGIF1cbnZhciBCQVNFNjRfTUFQID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XFxuXFxyJztcblxuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEJpbmFyeShkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGNvZGUsIGlkeCwgYml0bGVuID0gMCwgbWF4ID0gZGF0YS5sZW5ndGgsIG1hcCA9IEJBU0U2NF9NQVA7XG5cbiAgLy8gQ29udmVydCBvbmUgYnkgb25lLlxuICBmb3IgKGlkeCA9IDA7IGlkeCA8IG1heDsgaWR4KyspIHtcbiAgICBjb2RlID0gbWFwLmluZGV4T2YoZGF0YS5jaGFyQXQoaWR4KSk7XG5cbiAgICAvLyBTa2lwIENSL0xGXG4gICAgaWYgKGNvZGUgPiA2NCkgY29udGludWU7XG5cbiAgICAvLyBGYWlsIG9uIGlsbGVnYWwgY2hhcmFjdGVyc1xuICAgIGlmIChjb2RlIDwgMCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgYml0bGVuICs9IDY7XG4gIH1cblxuICAvLyBJZiB0aGVyZSBhcmUgYW55IGJpdHMgbGVmdCwgc291cmNlIHdhcyBjb3JydXB0ZWRcbiAgcmV0dXJuIChiaXRsZW4gJSA4KSA9PT0gMDtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEJpbmFyeShkYXRhKSB7XG4gIHZhciBpZHgsIHRhaWxiaXRzLFxuICAgICAgaW5wdXQgPSBkYXRhLnJlcGxhY2UoL1tcXHJcXG49XS9nLCAnJyksIC8vIHJlbW92ZSBDUi9MRiAmIHBhZGRpbmcgdG8gc2ltcGxpZnkgc2NhblxuICAgICAgbWF4ID0gaW5wdXQubGVuZ3RoLFxuICAgICAgbWFwID0gQkFTRTY0X01BUCxcbiAgICAgIGJpdHMgPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgLy8gQ29sbGVjdCBieSA2KjQgYml0cyAoMyBieXRlcylcblxuICBmb3IgKGlkeCA9IDA7IGlkeCA8IG1heDsgaWR4KyspIHtcbiAgICBpZiAoKGlkeCAlIDQgPT09IDApICYmIGlkeCkge1xuICAgICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gMTYpICYgMHhGRik7XG4gICAgICByZXN1bHQucHVzaCgoYml0cyA+PiA4KSAmIDB4RkYpO1xuICAgICAgcmVzdWx0LnB1c2goYml0cyAmIDB4RkYpO1xuICAgIH1cblxuICAgIGJpdHMgPSAoYml0cyA8PCA2KSB8IG1hcC5pbmRleE9mKGlucHV0LmNoYXJBdChpZHgpKTtcbiAgfVxuXG4gIC8vIER1bXAgdGFpbFxuXG4gIHRhaWxiaXRzID0gKG1heCAlIDQpICogNjtcblxuICBpZiAodGFpbGJpdHMgPT09IDApIHtcbiAgICByZXN1bHQucHVzaCgoYml0cyA+PiAxNikgJiAweEZGKTtcbiAgICByZXN1bHQucHVzaCgoYml0cyA+PiA4KSAmIDB4RkYpO1xuICAgIHJlc3VsdC5wdXNoKGJpdHMgJiAweEZGKTtcbiAgfSBlbHNlIGlmICh0YWlsYml0cyA9PT0gMTgpIHtcbiAgICByZXN1bHQucHVzaCgoYml0cyA+PiAxMCkgJiAweEZGKTtcbiAgICByZXN1bHQucHVzaCgoYml0cyA+PiAyKSAmIDB4RkYpO1xuICB9IGVsc2UgaWYgKHRhaWxiaXRzID09PSAxMikge1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDQpICYgMHhGRik7XG4gIH1cblxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVzdWx0KTtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50WWFtbEJpbmFyeShvYmplY3QgLyosIHN0eWxlKi8pIHtcbiAgdmFyIHJlc3VsdCA9ICcnLCBiaXRzID0gMCwgaWR4LCB0YWlsLFxuICAgICAgbWF4ID0gb2JqZWN0Lmxlbmd0aCxcbiAgICAgIG1hcCA9IEJBU0U2NF9NQVA7XG5cbiAgLy8gQ29udmVydCBldmVyeSB0aHJlZSBieXRlcyB0byA0IEFTQ0lJIGNoYXJhY3RlcnMuXG5cbiAgZm9yIChpZHggPSAwOyBpZHggPCBtYXg7IGlkeCsrKSB7XG4gICAgaWYgKChpZHggJSAzID09PSAwKSAmJiBpZHgpIHtcbiAgICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTgpICYgMHgzRl07XG4gICAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDEyKSAmIDB4M0ZdO1xuICAgICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiA2KSAmIDB4M0ZdO1xuICAgICAgcmVzdWx0ICs9IG1hcFtiaXRzICYgMHgzRl07XG4gICAgfVxuXG4gICAgYml0cyA9IChiaXRzIDw8IDgpICsgb2JqZWN0W2lkeF07XG4gIH1cblxuICAvLyBEdW1wIHRhaWxcblxuICB0YWlsID0gbWF4ICUgMztcblxuICBpZiAodGFpbCA9PT0gMCkge1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTgpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAxMikgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDYpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFtiaXRzICYgMHgzRl07XG4gIH0gZWxzZSBpZiAodGFpbCA9PT0gMikge1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTApICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiA0KSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPDwgMikgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWzY0XTtcbiAgfSBlbHNlIGlmICh0YWlsID09PSAxKSB7XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAyKSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPDwgNCkgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWzY0XTtcbiAgICByZXN1bHQgKz0gbWFwWzY0XTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGlzQmluYXJ5KG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICAnW29iamVjdCBVaW50OEFycmF5XSc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmJpbmFyeScsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sQmluYXJ5LFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxCaW5hcnksXG4gIHByZWRpY2F0ZTogaXNCaW5hcnksXG4gIHJlcHJlc2VudDogcmVwcmVzZW50WWFtbEJpbmFyeVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG52YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfdG9TdHJpbmcgICAgICAgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbE9tYXAoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG5cbiAgdmFyIG9iamVjdEtleXMgPSBbXSwgaW5kZXgsIGxlbmd0aCwgcGFpciwgcGFpcktleSwgcGFpckhhc0tleSxcbiAgICAgIG9iamVjdCA9IGRhdGE7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpciA9IG9iamVjdFtpbmRleF07XG4gICAgcGFpckhhc0tleSA9IGZhbHNlO1xuXG4gICAgaWYgKF90b1N0cmluZy5jYWxsKHBhaXIpICE9PSAnW29iamVjdCBPYmplY3RdJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChwYWlyS2V5IGluIHBhaXIpIHtcbiAgICAgIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbChwYWlyLCBwYWlyS2V5KSkge1xuICAgICAgICBpZiAoIXBhaXJIYXNLZXkpIHBhaXJIYXNLZXkgPSB0cnVlO1xuICAgICAgICBlbHNlIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXBhaXJIYXNLZXkpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChvYmplY3RLZXlzLmluZGV4T2YocGFpcktleSkgPT09IC0xKSBvYmplY3RLZXlzLnB1c2gocGFpcktleSk7XG4gICAgZWxzZSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbE9tYXAoZGF0YSkge1xuICByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6b21hcCcsIHtcbiAga2luZDogJ3NlcXVlbmNlJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxPbWFwLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxPbWFwXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbnZhciBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbFBhaXJzKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiB0cnVlO1xuXG4gIHZhciBpbmRleCwgbGVuZ3RoLCBwYWlyLCBrZXlzLCByZXN1bHQsXG4gICAgICBvYmplY3QgPSBkYXRhO1xuXG4gIHJlc3VsdCA9IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyID0gb2JqZWN0W2luZGV4XTtcblxuICAgIGlmIChfdG9TdHJpbmcuY2FsbChwYWlyKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHJldHVybiBmYWxzZTtcblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhwYWlyKTtcblxuICAgIGlmIChrZXlzLmxlbmd0aCAhPT0gMSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmVzdWx0W2luZGV4XSA9IFsga2V5c1swXSwgcGFpcltrZXlzWzBdXSBdO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxQYWlycyhkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gW107XG5cbiAgdmFyIGluZGV4LCBsZW5ndGgsIHBhaXIsIGtleXMsIHJlc3VsdCxcbiAgICAgIG9iamVjdCA9IGRhdGE7XG5cbiAgcmVzdWx0ID0gbmV3IEFycmF5KG9iamVjdC5sZW5ndGgpO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHBhaXIgPSBvYmplY3RbaW5kZXhdO1xuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHBhaXIpO1xuXG4gICAgcmVzdWx0W2luZGV4XSA9IFsga2V5c1swXSwgcGFpcltrZXlzWzBdXSBdO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6cGFpcnMnLCB7XG4gIGtpbmQ6ICdzZXF1ZW5jZScsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sUGFpcnMsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbFBhaXJzXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbnZhciBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbFNldChkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIga2V5LCBvYmplY3QgPSBkYXRhO1xuXG4gIGZvciAoa2V5IGluIG9iamVjdCkge1xuICAgIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgIGlmIChvYmplY3Rba2V5XSAhPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sU2V0KGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkYXRhIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnNldCcsIHtcbiAga2luZDogJ21hcHBpbmcnLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbFNldCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sU2V0XG59KTtcbiIsIi8vIEpTLVlBTUwncyBkZWZhdWx0IHNjaGVtYSBmb3IgYHNhZmVMb2FkYCBmdW5jdGlvbi5cbi8vIEl0IGlzIG5vdCBkZXNjcmliZWQgaW4gdGhlIFlBTUwgc3BlY2lmaWNhdGlvbi5cbi8vXG4vLyBUaGlzIHNjaGVtYSBpcyBiYXNlZCBvbiBzdGFuZGFyZCBZQU1MJ3MgQ29yZSBzY2hlbWEgYW5kIGluY2x1ZGVzIG1vc3Qgb2Zcbi8vIGV4dHJhIHR5cGVzIGRlc2NyaWJlZCBhdCBZQU1MIHRhZyByZXBvc2l0b3J5LiAoaHR0cDovL3lhbWwub3JnL3R5cGUvKVxuXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29yZScpLmV4dGVuZCh7XG4gIGltcGxpY2l0OiBbXG4gICAgcmVxdWlyZSgnLi4vdHlwZS90aW1lc3RhbXAnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL21lcmdlJylcbiAgXSxcbiAgZXhwbGljaXQ6IFtcbiAgICByZXF1aXJlKCcuLi90eXBlL2JpbmFyeScpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvb21hcCcpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvcGFpcnMnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL3NldCcpXG4gIF1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludC1kaXNhYmxlIG1heC1sZW4sbm8tdXNlLWJlZm9yZS1kZWZpbmUqL1xuXG52YXIgY29tbW9uICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG52YXIgWUFNTEV4Y2VwdGlvbiAgICAgICA9IHJlcXVpcmUoJy4vZXhjZXB0aW9uJyk7XG52YXIgbWFrZVNuaXBwZXQgICAgICAgICA9IHJlcXVpcmUoJy4vc25pcHBldCcpO1xudmFyIERFRkFVTFRfU0NIRU1BICAgICAgPSByZXF1aXJlKCcuL3NjaGVtYS9kZWZhdWx0Jyk7XG5cblxudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cblxudmFyIENPTlRFWFRfRkxPV19JTiAgID0gMTtcbnZhciBDT05URVhUX0ZMT1dfT1VUICA9IDI7XG52YXIgQ09OVEVYVF9CTE9DS19JTiAgPSAzO1xudmFyIENPTlRFWFRfQkxPQ0tfT1VUID0gNDtcblxuXG52YXIgQ0hPTVBJTkdfQ0xJUCAgPSAxO1xudmFyIENIT01QSU5HX1NUUklQID0gMjtcbnZhciBDSE9NUElOR19LRUVQICA9IDM7XG5cblxudmFyIFBBVFRFUk5fTk9OX1BSSU5UQUJMRSAgICAgICAgID0gL1tcXHgwMC1cXHgwOFxceDBCXFx4MENcXHgwRS1cXHgxRlxceDdGLVxceDg0XFx4ODYtXFx4OUZcXHVGRkZFXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0vO1xudmFyIFBBVFRFUk5fTk9OX0FTQ0lJX0xJTkVfQlJFQUtTID0gL1tcXHg4NVxcdTIwMjhcXHUyMDI5XS87XG52YXIgUEFUVEVSTl9GTE9XX0lORElDQVRPUlMgICAgICAgPSAvWyxcXFtcXF1cXHtcXH1dLztcbnZhciBQQVRURVJOX1RBR19IQU5ETEUgICAgICAgICAgICA9IC9eKD86IXwhIXwhW2EtelxcLV0rISkkL2k7XG52YXIgUEFUVEVSTl9UQUdfVVJJICAgICAgICAgICAgICAgPSAvXig/OiF8W14sXFxbXFxdXFx7XFx9XSkoPzolWzAtOWEtZl17Mn18WzAtOWEtelxcLSM7XFwvXFw/OkAmPVxcK1xcJCxfXFwuIX5cXConXFwoXFwpXFxbXFxdXSkqJC9pO1xuXG5cbmZ1bmN0aW9uIF9jbGFzcyhvYmopIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopOyB9XG5cbmZ1bmN0aW9uIGlzX0VPTChjKSB7XG4gIHJldHVybiAoYyA9PT0gMHgwQS8qIExGICovKSB8fCAoYyA9PT0gMHgwRC8qIENSICovKTtcbn1cblxuZnVuY3Rpb24gaXNfV0hJVEVfU1BBQ0UoYykge1xuICByZXR1cm4gKGMgPT09IDB4MDkvKiBUYWIgKi8pIHx8IChjID09PSAweDIwLyogU3BhY2UgKi8pO1xufVxuXG5mdW5jdGlvbiBpc19XU19PUl9FT0woYykge1xuICByZXR1cm4gKGMgPT09IDB4MDkvKiBUYWIgKi8pIHx8XG4gICAgICAgICAoYyA9PT0gMHgyMC8qIFNwYWNlICovKSB8fFxuICAgICAgICAgKGMgPT09IDB4MEEvKiBMRiAqLykgfHxcbiAgICAgICAgIChjID09PSAweDBELyogQ1IgKi8pO1xufVxuXG5mdW5jdGlvbiBpc19GTE9XX0lORElDQVRPUihjKSB7XG4gIHJldHVybiBjID09PSAweDJDLyogLCAqLyB8fFxuICAgICAgICAgYyA9PT0gMHg1Qi8qIFsgKi8gfHxcbiAgICAgICAgIGMgPT09IDB4NUQvKiBdICovIHx8XG4gICAgICAgICBjID09PSAweDdCLyogeyAqLyB8fFxuICAgICAgICAgYyA9PT0gMHg3RC8qIH0gKi87XG59XG5cbmZ1bmN0aW9uIGZyb21IZXhDb2RlKGMpIHtcbiAgdmFyIGxjO1xuXG4gIGlmICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzOS8qIDkgKi8pKSB7XG4gICAgcmV0dXJuIGMgLSAweDMwO1xuICB9XG5cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlKi9cbiAgbGMgPSBjIHwgMHgyMDtcblxuICBpZiAoKDB4NjEvKiBhICovIDw9IGxjKSAmJiAobGMgPD0gMHg2Ni8qIGYgKi8pKSB7XG4gICAgcmV0dXJuIGxjIC0gMHg2MSArIDEwO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVkSGV4TGVuKGMpIHtcbiAgaWYgKGMgPT09IDB4NzgvKiB4ICovKSB7IHJldHVybiAyOyB9XG4gIGlmIChjID09PSAweDc1LyogdSAqLykgeyByZXR1cm4gNDsgfVxuICBpZiAoYyA9PT0gMHg1NS8qIFUgKi8pIHsgcmV0dXJuIDg7IH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGZyb21EZWNpbWFsQ29kZShjKSB7XG4gIGlmICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzOS8qIDkgKi8pKSB7XG4gICAgcmV0dXJuIGMgLSAweDMwO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVFc2NhcGVTZXF1ZW5jZShjKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIGluZGVudCAqL1xuICByZXR1cm4gKGMgPT09IDB4MzAvKiAwICovKSA/ICdcXHgwMCcgOlxuICAgICAgICAoYyA9PT0gMHg2MS8qIGEgKi8pID8gJ1xceDA3JyA6XG4gICAgICAgIChjID09PSAweDYyLyogYiAqLykgPyAnXFx4MDgnIDpcbiAgICAgICAgKGMgPT09IDB4NzQvKiB0ICovKSA/ICdcXHgwOScgOlxuICAgICAgICAoYyA9PT0gMHgwOS8qIFRhYiAqLykgPyAnXFx4MDknIDpcbiAgICAgICAgKGMgPT09IDB4NkUvKiBuICovKSA/ICdcXHgwQScgOlxuICAgICAgICAoYyA9PT0gMHg3Ni8qIHYgKi8pID8gJ1xceDBCJyA6XG4gICAgICAgIChjID09PSAweDY2LyogZiAqLykgPyAnXFx4MEMnIDpcbiAgICAgICAgKGMgPT09IDB4NzIvKiByICovKSA/ICdcXHgwRCcgOlxuICAgICAgICAoYyA9PT0gMHg2NS8qIGUgKi8pID8gJ1xceDFCJyA6XG4gICAgICAgIChjID09PSAweDIwLyogU3BhY2UgKi8pID8gJyAnIDpcbiAgICAgICAgKGMgPT09IDB4MjIvKiBcIiAqLykgPyAnXFx4MjInIDpcbiAgICAgICAgKGMgPT09IDB4MkYvKiAvICovKSA/ICcvJyA6XG4gICAgICAgIChjID09PSAweDVDLyogXFwgKi8pID8gJ1xceDVDJyA6XG4gICAgICAgIChjID09PSAweDRFLyogTiAqLykgPyAnXFx4ODUnIDpcbiAgICAgICAgKGMgPT09IDB4NUYvKiBfICovKSA/ICdcXHhBMCcgOlxuICAgICAgICAoYyA9PT0gMHg0Qy8qIEwgKi8pID8gJ1xcdTIwMjgnIDpcbiAgICAgICAgKGMgPT09IDB4NTAvKiBQICovKSA/ICdcXHUyMDI5JyA6ICcnO1xufVxuXG5mdW5jdGlvbiBjaGFyRnJvbUNvZGVwb2ludChjKSB7XG4gIGlmIChjIDw9IDB4RkZGRikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICB9XG4gIC8vIEVuY29kZSBVVEYtMTYgc3Vycm9nYXRlIHBhaXJcbiAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTE2I0NvZGVfcG9pbnRzX1UuMkIwMTAwMDBfdG9fVS4yQjEwRkZGRlxuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAoKGMgLSAweDAxMDAwMCkgPj4gMTApICsgMHhEODAwLFxuICAgICgoYyAtIDB4MDEwMDAwKSAmIDB4MDNGRikgKyAweERDMDBcbiAgKTtcbn1cblxudmFyIHNpbXBsZUVzY2FwZUNoZWNrID0gbmV3IEFycmF5KDI1Nik7IC8vIGludGVnZXIsIGZvciBmYXN0IGFjY2Vzc1xudmFyIHNpbXBsZUVzY2FwZU1hcCA9IG5ldyBBcnJheSgyNTYpO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICBzaW1wbGVFc2NhcGVDaGVja1tpXSA9IHNpbXBsZUVzY2FwZVNlcXVlbmNlKGkpID8gMSA6IDA7XG4gIHNpbXBsZUVzY2FwZU1hcFtpXSA9IHNpbXBsZUVzY2FwZVNlcXVlbmNlKGkpO1xufVxuXG5cbmZ1bmN0aW9uIFN0YXRlKGlucHV0LCBvcHRpb25zKSB7XG4gIHRoaXMuaW5wdXQgPSBpbnB1dDtcblxuICB0aGlzLmZpbGVuYW1lICA9IG9wdGlvbnNbJ2ZpbGVuYW1lJ10gIHx8IG51bGw7XG4gIHRoaXMuc2NoZW1hICAgID0gb3B0aW9uc1snc2NoZW1hJ10gICAgfHwgREVGQVVMVF9TQ0hFTUE7XG4gIHRoaXMub25XYXJuaW5nID0gb3B0aW9uc1snb25XYXJuaW5nJ10gfHwgbnVsbDtcbiAgLy8gKEhpZGRlbikgUmVtb3ZlPyBtYWtlcyB0aGUgbG9hZGVyIHRvIGV4cGVjdCBZQU1MIDEuMSBkb2N1bWVudHNcbiAgLy8gaWYgc3VjaCBkb2N1bWVudHMgaGF2ZSBubyBleHBsaWNpdCAlWUFNTCBkaXJlY3RpdmVcbiAgdGhpcy5sZWdhY3kgICAgPSBvcHRpb25zWydsZWdhY3knXSAgICB8fCBmYWxzZTtcblxuICB0aGlzLmpzb24gICAgICA9IG9wdGlvbnNbJ2pzb24nXSAgICAgIHx8IGZhbHNlO1xuICB0aGlzLmxpc3RlbmVyICA9IG9wdGlvbnNbJ2xpc3RlbmVyJ10gIHx8IG51bGw7XG5cbiAgdGhpcy5pbXBsaWNpdFR5cGVzID0gdGhpcy5zY2hlbWEuY29tcGlsZWRJbXBsaWNpdDtcbiAgdGhpcy50eXBlTWFwICAgICAgID0gdGhpcy5zY2hlbWEuY29tcGlsZWRUeXBlTWFwO1xuXG4gIHRoaXMubGVuZ3RoICAgICA9IGlucHV0Lmxlbmd0aDtcbiAgdGhpcy5wb3NpdGlvbiAgID0gMDtcbiAgdGhpcy5saW5lICAgICAgID0gMDtcbiAgdGhpcy5saW5lU3RhcnQgID0gMDtcbiAgdGhpcy5saW5lSW5kZW50ID0gMDtcblxuICAvLyBwb3NpdGlvbiBvZiBmaXJzdCBsZWFkaW5nIHRhYiBpbiB0aGUgY3VycmVudCBsaW5lLFxuICAvLyB1c2VkIHRvIG1ha2Ugc3VyZSB0aGVyZSBhcmUgbm8gdGFicyBpbiB0aGUgaW5kZW50YXRpb25cbiAgdGhpcy5maXJzdFRhYkluTGluZSA9IC0xO1xuXG4gIHRoaXMuZG9jdW1lbnRzID0gW107XG5cbiAgLypcbiAgdGhpcy52ZXJzaW9uO1xuICB0aGlzLmNoZWNrTGluZUJyZWFrcztcbiAgdGhpcy50YWdNYXA7XG4gIHRoaXMuYW5jaG9yTWFwO1xuICB0aGlzLnRhZztcbiAgdGhpcy5hbmNob3I7XG4gIHRoaXMua2luZDtcbiAgdGhpcy5yZXN1bHQ7Ki9cblxufVxuXG5cbmZ1bmN0aW9uIGdlbmVyYXRlRXJyb3Ioc3RhdGUsIG1lc3NhZ2UpIHtcbiAgdmFyIG1hcmsgPSB7XG4gICAgbmFtZTogICAgIHN0YXRlLmZpbGVuYW1lLFxuICAgIGJ1ZmZlcjogICBzdGF0ZS5pbnB1dC5zbGljZSgwLCAtMSksIC8vIG9taXQgdHJhaWxpbmcgXFwwXG4gICAgcG9zaXRpb246IHN0YXRlLnBvc2l0aW9uLFxuICAgIGxpbmU6ICAgICBzdGF0ZS5saW5lLFxuICAgIGNvbHVtbjogICBzdGF0ZS5wb3NpdGlvbiAtIHN0YXRlLmxpbmVTdGFydFxuICB9O1xuXG4gIG1hcmsuc25pcHBldCA9IG1ha2VTbmlwcGV0KG1hcmspO1xuXG4gIHJldHVybiBuZXcgWUFNTEV4Y2VwdGlvbihtZXNzYWdlLCBtYXJrKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dFcnJvcihzdGF0ZSwgbWVzc2FnZSkge1xuICB0aHJvdyBnZW5lcmF0ZUVycm9yKHN0YXRlLCBtZXNzYWdlKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dXYXJuaW5nKHN0YXRlLCBtZXNzYWdlKSB7XG4gIGlmIChzdGF0ZS5vbldhcm5pbmcpIHtcbiAgICBzdGF0ZS5vbldhcm5pbmcuY2FsbChudWxsLCBnZW5lcmF0ZUVycm9yKHN0YXRlLCBtZXNzYWdlKSk7XG4gIH1cbn1cblxuXG52YXIgZGlyZWN0aXZlSGFuZGxlcnMgPSB7XG5cbiAgWUFNTDogZnVuY3Rpb24gaGFuZGxlWWFtbERpcmVjdGl2ZShzdGF0ZSwgbmFtZSwgYXJncykge1xuXG4gICAgdmFyIG1hdGNoLCBtYWpvciwgbWlub3I7XG5cbiAgICBpZiAoc3RhdGUudmVyc2lvbiAhPT0gbnVsbCkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0aW9uIG9mICVZQU1MIGRpcmVjdGl2ZScpO1xuICAgIH1cblxuICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ1lBTUwgZGlyZWN0aXZlIGFjY2VwdHMgZXhhY3RseSBvbmUgYXJndW1lbnQnKTtcbiAgICB9XG5cbiAgICBtYXRjaCA9IC9eKFswLTldKylcXC4oWzAtOV0rKSQvLmV4ZWMoYXJnc1swXSk7XG5cbiAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbGwtZm9ybWVkIGFyZ3VtZW50IG9mIHRoZSBZQU1MIGRpcmVjdGl2ZScpO1xuICAgIH1cblxuICAgIG1ham9yID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICBtaW5vciA9IHBhcnNlSW50KG1hdGNoWzJdLCAxMCk7XG5cbiAgICBpZiAobWFqb3IgIT09IDEpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmFjY2VwdGFibGUgWUFNTCB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudCcpO1xuICAgIH1cblxuICAgIHN0YXRlLnZlcnNpb24gPSBhcmdzWzBdO1xuICAgIHN0YXRlLmNoZWNrTGluZUJyZWFrcyA9IChtaW5vciA8IDIpO1xuXG4gICAgaWYgKG1pbm9yICE9PSAxICYmIG1pbm9yICE9PSAyKSB7XG4gICAgICB0aHJvd1dhcm5pbmcoc3RhdGUsICd1bnN1cHBvcnRlZCBZQU1MIHZlcnNpb24gb2YgdGhlIGRvY3VtZW50Jyk7XG4gICAgfVxuICB9LFxuXG4gIFRBRzogZnVuY3Rpb24gaGFuZGxlVGFnRGlyZWN0aXZlKHN0YXRlLCBuYW1lLCBhcmdzKSB7XG5cbiAgICB2YXIgaGFuZGxlLCBwcmVmaXg7XG5cbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdUQUcgZGlyZWN0aXZlIGFjY2VwdHMgZXhhY3RseSB0d28gYXJndW1lbnRzJyk7XG4gICAgfVxuXG4gICAgaGFuZGxlID0gYXJnc1swXTtcbiAgICBwcmVmaXggPSBhcmdzWzFdO1xuXG4gICAgaWYgKCFQQVRURVJOX1RBR19IQU5ETEUudGVzdChoYW5kbGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnaWxsLWZvcm1lZCB0YWcgaGFuZGxlIChmaXJzdCBhcmd1bWVudCkgb2YgdGhlIFRBRyBkaXJlY3RpdmUnKTtcbiAgICB9XG5cbiAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwoc3RhdGUudGFnTWFwLCBoYW5kbGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGhlcmUgaXMgYSBwcmV2aW91c2x5IGRlY2xhcmVkIHN1ZmZpeCBmb3IgXCInICsgaGFuZGxlICsgJ1wiIHRhZyBoYW5kbGUnKTtcbiAgICB9XG5cbiAgICBpZiAoIVBBVFRFUk5fVEFHX1VSSS50ZXN0KHByZWZpeCkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbGwtZm9ybWVkIHRhZyBwcmVmaXggKHNlY29uZCBhcmd1bWVudCkgb2YgdGhlIFRBRyBkaXJlY3RpdmUnKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcHJlZml4ID0gZGVjb2RlVVJJQ29tcG9uZW50KHByZWZpeCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFnIHByZWZpeCBpcyBtYWxmb3JtZWQ6ICcgKyBwcmVmaXgpO1xuICAgIH1cblxuICAgIHN0YXRlLnRhZ01hcFtoYW5kbGVdID0gcHJlZml4O1xuICB9XG59O1xuXG5cbmZ1bmN0aW9uIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBzdGFydCwgZW5kLCBjaGVja0pzb24pIHtcbiAgdmFyIF9wb3NpdGlvbiwgX2xlbmd0aCwgX2NoYXJhY3RlciwgX3Jlc3VsdDtcblxuICBpZiAoc3RhcnQgPCBlbmQpIHtcbiAgICBfcmVzdWx0ID0gc3RhdGUuaW5wdXQuc2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBpZiAoY2hlY2tKc29uKSB7XG4gICAgICBmb3IgKF9wb3NpdGlvbiA9IDAsIF9sZW5ndGggPSBfcmVzdWx0Lmxlbmd0aDsgX3Bvc2l0aW9uIDwgX2xlbmd0aDsgX3Bvc2l0aW9uICs9IDEpIHtcbiAgICAgICAgX2NoYXJhY3RlciA9IF9yZXN1bHQuY2hhckNvZGVBdChfcG9zaXRpb24pO1xuICAgICAgICBpZiAoIShfY2hhcmFjdGVyID09PSAweDA5IHx8XG4gICAgICAgICAgICAgICgweDIwIDw9IF9jaGFyYWN0ZXIgJiYgX2NoYXJhY3RlciA8PSAweDEwRkZGRikpKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2V4cGVjdGVkIHZhbGlkIEpTT04gY2hhcmFjdGVyJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFBBVFRFUk5fTk9OX1BSSU5UQUJMRS50ZXN0KF9yZXN1bHQpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGhlIHN0cmVhbSBjb250YWlucyBub24tcHJpbnRhYmxlIGNoYXJhY3RlcnMnKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5yZXN1bHQgKz0gX3Jlc3VsdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZU1hcHBpbmdzKHN0YXRlLCBkZXN0aW5hdGlvbiwgc291cmNlLCBvdmVycmlkYWJsZUtleXMpIHtcbiAgdmFyIHNvdXJjZUtleXMsIGtleSwgaW5kZXgsIHF1YW50aXR5O1xuXG4gIGlmICghY29tbW9uLmlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2Fubm90IG1lcmdlIG1hcHBpbmdzOyB0aGUgcHJvdmlkZWQgc291cmNlIG9iamVjdCBpcyB1bmFjY2VwdGFibGUnKTtcbiAgfVxuXG4gIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuXG4gIGZvciAoaW5kZXggPSAwLCBxdWFudGl0eSA9IHNvdXJjZUtleXMubGVuZ3RoOyBpbmRleCA8IHF1YW50aXR5OyBpbmRleCArPSAxKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpbmRleF07XG5cbiAgICBpZiAoIV9oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlc3RpbmF0aW9uLCBrZXkpKSB7XG4gICAgICBkZXN0aW5hdGlvbltrZXldID0gc291cmNlW2tleV07XG4gICAgICBvdmVycmlkYWJsZUtleXNba2V5XSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCB2YWx1ZU5vZGUsXG4gIHN0YXJ0TGluZSwgc3RhcnRMaW5lU3RhcnQsIHN0YXJ0UG9zKSB7XG5cbiAgdmFyIGluZGV4LCBxdWFudGl0eTtcblxuICAvLyBUaGUgb3V0cHV0IGlzIGEgcGxhaW4gb2JqZWN0IGhlcmUsIHNvIGtleXMgY2FuIG9ubHkgYmUgc3RyaW5ncy5cbiAgLy8gV2UgbmVlZCB0byBjb252ZXJ0IGtleU5vZGUgdG8gYSBzdHJpbmcsIGJ1dCBkb2luZyBzbyBjYW4gaGFuZyB0aGUgcHJvY2Vzc1xuICAvLyAoZGVlcGx5IG5lc3RlZCBhcnJheXMgdGhhdCBleHBsb2RlIGV4cG9uZW50aWFsbHkgdXNpbmcgYWxpYXNlcykuXG4gIGlmIChBcnJheS5pc0FycmF5KGtleU5vZGUpKSB7XG4gICAga2V5Tm9kZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGtleU5vZGUpO1xuXG4gICAgZm9yIChpbmRleCA9IDAsIHF1YW50aXR5ID0ga2V5Tm9kZS5sZW5ndGg7IGluZGV4IDwgcXVhbnRpdHk7IGluZGV4ICs9IDEpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGtleU5vZGVbaW5kZXhdKSkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnbmVzdGVkIGFycmF5cyBhcmUgbm90IHN1cHBvcnRlZCBpbnNpZGUga2V5cycpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGtleU5vZGUgPT09ICdvYmplY3QnICYmIF9jbGFzcyhrZXlOb2RlW2luZGV4XSkgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAgIGtleU5vZGVbaW5kZXhdID0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQXZvaWQgY29kZSBleGVjdXRpb24gaW4gbG9hZCgpIHZpYSB0b1N0cmluZyBwcm9wZXJ0eVxuICAvLyAoc3RpbGwgdXNlIGl0cyBvd24gdG9TdHJpbmcgZm9yIGFycmF5cywgdGltZXN0YW1wcyxcbiAgLy8gYW5kIHdoYXRldmVyIHVzZXIgc2NoZW1hIGV4dGVuc2lvbnMgaGFwcGVuIHRvIGhhdmUgQEB0b1N0cmluZ1RhZylcbiAgaWYgKHR5cGVvZiBrZXlOb2RlID09PSAnb2JqZWN0JyAmJiBfY2xhc3Moa2V5Tm9kZSkgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAga2V5Tm9kZSA9ICdbb2JqZWN0IE9iamVjdF0nO1xuICB9XG5cblxuICBrZXlOb2RlID0gU3RyaW5nKGtleU5vZGUpO1xuXG4gIGlmIChfcmVzdWx0ID09PSBudWxsKSB7XG4gICAgX3Jlc3VsdCA9IHt9O1xuICB9XG5cbiAgaWYgKGtleVRhZyA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOm1lcmdlJykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlTm9kZSkpIHtcbiAgICAgIGZvciAoaW5kZXggPSAwLCBxdWFudGl0eSA9IHZhbHVlTm9kZS5sZW5ndGg7IGluZGV4IDwgcXVhbnRpdHk7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgbWVyZ2VNYXBwaW5ncyhzdGF0ZSwgX3Jlc3VsdCwgdmFsdWVOb2RlW2luZGV4XSwgb3ZlcnJpZGFibGVLZXlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWVyZ2VNYXBwaW5ncyhzdGF0ZSwgX3Jlc3VsdCwgdmFsdWVOb2RlLCBvdmVycmlkYWJsZUtleXMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoIXN0YXRlLmpzb24gJiZcbiAgICAgICAgIV9oYXNPd25Qcm9wZXJ0eS5jYWxsKG92ZXJyaWRhYmxlS2V5cywga2V5Tm9kZSkgJiZcbiAgICAgICAgX2hhc093blByb3BlcnR5LmNhbGwoX3Jlc3VsdCwga2V5Tm9kZSkpIHtcbiAgICAgIHN0YXRlLmxpbmUgPSBzdGFydExpbmUgfHwgc3RhdGUubGluZTtcbiAgICAgIHN0YXRlLmxpbmVTdGFydCA9IHN0YXJ0TGluZVN0YXJ0IHx8IHN0YXRlLmxpbmVTdGFydDtcbiAgICAgIHN0YXRlLnBvc2l0aW9uID0gc3RhcnRQb3MgfHwgc3RhdGUucG9zaXRpb247XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZHVwbGljYXRlZCBtYXBwaW5nIGtleScpO1xuICAgIH1cblxuICAgIC8vIHVzZWQgZm9yIHRoaXMgc3BlY2lmaWMga2V5IG9ubHkgYmVjYXVzZSBPYmplY3QuZGVmaW5lUHJvcGVydHkgaXMgc2xvd1xuICAgIGlmIChrZXlOb2RlID09PSAnX19wcm90b19fJykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9yZXN1bHQsIGtleU5vZGUsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlTm9kZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9yZXN1bHRba2V5Tm9kZV0gPSB2YWx1ZU5vZGU7XG4gICAgfVxuICAgIGRlbGV0ZSBvdmVycmlkYWJsZUtleXNba2V5Tm9kZV07XG4gIH1cblxuICByZXR1cm4gX3Jlc3VsdDtcbn1cblxuZnVuY3Rpb24gcmVhZExpbmVCcmVhayhzdGF0ZSkge1xuICB2YXIgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggPT09IDB4MEEvKiBMRiAqLykge1xuICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gIH0gZWxzZSBpZiAoY2ggPT09IDB4MEQvKiBDUiAqLykge1xuICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgaWYgKHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pID09PSAweDBBLyogTEYgKi8pIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdhIGxpbmUgYnJlYWsgaXMgZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIHN0YXRlLmxpbmUgKz0gMTtcbiAgc3RhdGUubGluZVN0YXJ0ID0gc3RhdGUucG9zaXRpb247XG4gIHN0YXRlLmZpcnN0VGFiSW5MaW5lID0gLTE7XG59XG5cbmZ1bmN0aW9uIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGFsbG93Q29tbWVudHMsIGNoZWNrSW5kZW50KSB7XG4gIHZhciBsaW5lQnJlYWtzID0gMCxcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgd2hpbGUgKGlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgICAgaWYgKGNoID09PSAweDA5LyogVGFiICovICYmIHN0YXRlLmZpcnN0VGFiSW5MaW5lID09PSAtMSkge1xuICAgICAgICBzdGF0ZS5maXJzdFRhYkluTGluZSA9IHN0YXRlLnBvc2l0aW9uO1xuICAgICAgfVxuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGlmIChhbGxvd0NvbW1lbnRzICYmIGNoID09PSAweDIzLyogIyAqLykge1xuICAgICAgZG8ge1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICB9IHdoaWxlIChjaCAhPT0gMHgwQS8qIExGICovICYmIGNoICE9PSAweDBELyogQ1IgKi8gJiYgY2ggIT09IDApO1xuICAgIH1cblxuICAgIGlmIChpc19FT0woY2gpKSB7XG4gICAgICByZWFkTGluZUJyZWFrKHN0YXRlKTtcblxuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcbiAgICAgIGxpbmVCcmVha3MrKztcbiAgICAgIHN0YXRlLmxpbmVJbmRlbnQgPSAwO1xuXG4gICAgICB3aGlsZSAoY2ggPT09IDB4MjAvKiBTcGFjZSAqLykge1xuICAgICAgICBzdGF0ZS5saW5lSW5kZW50Kys7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNoZWNrSW5kZW50ICE9PSAtMSAmJiBsaW5lQnJlYWtzICE9PSAwICYmIHN0YXRlLmxpbmVJbmRlbnQgPCBjaGVja0luZGVudCkge1xuICAgIHRocm93V2FybmluZyhzdGF0ZSwgJ2RlZmljaWVudCBpbmRlbnRhdGlvbicpO1xuICB9XG5cbiAgcmV0dXJuIGxpbmVCcmVha3M7XG59XG5cbmZ1bmN0aW9uIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkge1xuICB2YXIgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb24sXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uKTtcblxuICAvLyBDb25kaXRpb24gc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCBpcyB0ZXN0ZWRcbiAgLy8gaW4gcGFyZW50IG9uIGVhY2ggY2FsbCwgZm9yIGVmZmljaWVuY3kuIE5vIG5lZWRzIHRvIHRlc3QgaGVyZSBhZ2Fpbi5cbiAgaWYgKChjaCA9PT0gMHgyRC8qIC0gKi8gfHwgY2ggPT09IDB4MkUvKiAuICovKSAmJlxuICAgICAgY2ggPT09IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uICsgMSkgJiZcbiAgICAgIGNoID09PSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KF9wb3NpdGlvbiArIDIpKSB7XG5cbiAgICBfcG9zaXRpb24gKz0gMztcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChfcG9zaXRpb24pO1xuXG4gICAgaWYgKGNoID09PSAwIHx8IGlzX1dTX09SX0VPTChjaCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgY291bnQpIHtcbiAgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgc3RhdGUucmVzdWx0ICs9ICcgJztcbiAgfSBlbHNlIGlmIChjb3VudCA+IDEpIHtcbiAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgY291bnQgLSAxKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHJlYWRQbGFpblNjYWxhcihzdGF0ZSwgbm9kZUluZGVudCwgd2l0aGluRmxvd0NvbGxlY3Rpb24pIHtcbiAgdmFyIHByZWNlZGluZyxcbiAgICAgIGZvbGxvd2luZyxcbiAgICAgIGNhcHR1cmVTdGFydCxcbiAgICAgIGNhcHR1cmVFbmQsXG4gICAgICBoYXNQZW5kaW5nQ29udGVudCxcbiAgICAgIF9saW5lLFxuICAgICAgX2xpbmVTdGFydCxcbiAgICAgIF9saW5lSW5kZW50LFxuICAgICAgX2tpbmQgPSBzdGF0ZS5raW5kLFxuICAgICAgX3Jlc3VsdCA9IHN0YXRlLnJlc3VsdCxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGlzX1dTX09SX0VPTChjaCkgICAgICB8fFxuICAgICAgaXNfRkxPV19JTkRJQ0FUT1IoY2gpIHx8XG4gICAgICBjaCA9PT0gMHgyMy8qICMgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDI2LyogJiAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MkEvKiAqICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgyMS8qICEgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDdDLyogfCAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4M0UvKiA+ICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgyNy8qICcgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDIyLyogXCIgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDI1LyogJSAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4NDAvKiBAICovICAgIHx8XG4gICAgICBjaCA9PT0gMHg2MC8qIGAgKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoY2ggPT09IDB4M0YvKiA/ICovIHx8IGNoID09PSAweDJELyogLSAqLykge1xuICAgIGZvbGxvd2luZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKTtcblxuICAgIGlmIChpc19XU19PUl9FT0woZm9sbG93aW5nKSB8fFxuICAgICAgICB3aXRoaW5GbG93Q29sbGVjdGlvbiAmJiBpc19GTE9XX0lORElDQVRPUihmb2xsb3dpbmcpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUua2luZCA9ICdzY2FsYXInO1xuICBzdGF0ZS5yZXN1bHQgPSAnJztcbiAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICBoYXNQZW5kaW5nQ29udGVudCA9IGZhbHNlO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIGlmIChjaCA9PT0gMHgzQS8qIDogKi8pIHtcbiAgICAgIGZvbGxvd2luZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKTtcblxuICAgICAgaWYgKGlzX1dTX09SX0VPTChmb2xsb3dpbmcpIHx8XG4gICAgICAgICAgd2l0aGluRmxvd0NvbGxlY3Rpb24gJiYgaXNfRkxPV19JTkRJQ0FUT1IoZm9sbG93aW5nKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4MjMvKiAjICovKSB7XG4gICAgICBwcmVjZWRpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uIC0gMSk7XG5cbiAgICAgIGlmIChpc19XU19PUl9FT0wocHJlY2VkaW5nKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoKHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgJiYgdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSkgfHxcbiAgICAgICAgICAgICAgIHdpdGhpbkZsb3dDb2xsZWN0aW9uICYmIGlzX0ZMT1dfSU5ESUNBVE9SKGNoKSkge1xuICAgICAgYnJlYWs7XG5cbiAgICB9IGVsc2UgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIF9saW5lID0gc3RhdGUubGluZTtcbiAgICAgIF9saW5lU3RhcnQgPSBzdGF0ZS5saW5lU3RhcnQ7XG4gICAgICBfbGluZUluZGVudCA9IHN0YXRlLmxpbmVJbmRlbnQ7XG4gICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBmYWxzZSwgLTEpO1xuXG4gICAgICBpZiAoc3RhdGUubGluZUluZGVudCA+PSBub2RlSW5kZW50KSB7XG4gICAgICAgIGhhc1BlbmRpbmdDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbiA9IGNhcHR1cmVFbmQ7XG4gICAgICAgIHN0YXRlLmxpbmUgPSBfbGluZTtcbiAgICAgICAgc3RhdGUubGluZVN0YXJ0ID0gX2xpbmVTdGFydDtcbiAgICAgICAgc3RhdGUubGluZUluZGVudCA9IF9saW5lSW5kZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzUGVuZGluZ0NvbnRlbnQpIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQsIGZhbHNlKTtcbiAgICAgIHdyaXRlRm9sZGVkTGluZXMoc3RhdGUsIHN0YXRlLmxpbmUgLSBfbGluZSk7XG4gICAgICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gICAgICBoYXNQZW5kaW5nQ29udGVudCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb24gKyAxO1xuICAgIH1cblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgfVxuXG4gIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQsIGZhbHNlKTtcblxuICBpZiAoc3RhdGUucmVzdWx0KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBzdGF0ZS5raW5kID0gX2tpbmQ7XG4gIHN0YXRlLnJlc3VsdCA9IF9yZXN1bHQ7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmVhZFNpbmdsZVF1b3RlZFNjYWxhcihzdGF0ZSwgbm9kZUluZGVudCkge1xuICB2YXIgY2gsXG4gICAgICBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQ7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggIT09IDB4MjcvKiAnICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGUua2luZCA9ICdzY2FsYXInO1xuICBzdGF0ZS5yZXN1bHQgPSAnJztcbiAgc3RhdGUucG9zaXRpb24rKztcbiAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gIHdoaWxlICgoY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSkgIT09IDApIHtcbiAgICBpZiAoY2ggPT09IDB4MjcvKiAnICovKSB7XG4gICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBzdGF0ZS5wb3NpdGlvbiwgdHJ1ZSk7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgIGlmIChjaCA9PT0gMHgyNy8qICcgKi8pIHtcbiAgICAgICAgY2FwdHVyZVN0YXJ0ID0gc3RhdGUucG9zaXRpb247XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChpc19FT0woY2gpKSB7XG4gICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBjYXB0dXJlRW5kLCB0cnVlKTtcbiAgICAgIHdyaXRlRm9sZGVkTGluZXMoc3RhdGUsIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGZhbHNlLCBub2RlSW5kZW50KSk7XG4gICAgICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG5cbiAgICB9IGVsc2UgaWYgKHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgJiYgdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBkb2N1bWVudCB3aXRoaW4gYSBzaW5nbGUgcXVvdGVkIHNjYWxhcicpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gICAgfVxuICB9XG5cbiAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBzdHJlYW0gd2l0aGluIGEgc2luZ2xlIHF1b3RlZCBzY2FsYXInKTtcbn1cblxuZnVuY3Rpb24gcmVhZERvdWJsZVF1b3RlZFNjYWxhcihzdGF0ZSwgbm9kZUluZGVudCkge1xuICB2YXIgY2FwdHVyZVN0YXJ0LFxuICAgICAgY2FwdHVyZUVuZCxcbiAgICAgIGhleExlbmd0aCxcbiAgICAgIGhleFJlc3VsdCxcbiAgICAgIHRtcCxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoICE9PSAweDIyLyogXCIgKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuICBzdGF0ZS5wb3NpdGlvbisrO1xuICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKChjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pKSAhPT0gMCkge1xuICAgIGlmIChjaCA9PT0gMHgyMi8qIFwiICovKSB7XG4gICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBzdGF0ZS5wb3NpdGlvbiwgdHJ1ZSk7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDVDLyogXFwgKi8pIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCB0cnVlKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgZmFsc2UsIG5vZGVJbmRlbnQpO1xuXG4gICAgICAgIC8vIFRPRE86IHJld29yayB0byBpbmxpbmUgZm4gd2l0aCBubyB0eXBlIGNhc3Q/XG4gICAgICB9IGVsc2UgaWYgKGNoIDwgMjU2ICYmIHNpbXBsZUVzY2FwZUNoZWNrW2NoXSkge1xuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gc2ltcGxlRXNjYXBlTWFwW2NoXTtcbiAgICAgICAgc3RhdGUucG9zaXRpb24rKztcblxuICAgICAgfSBlbHNlIGlmICgodG1wID0gZXNjYXBlZEhleExlbihjaCkpID4gMCkge1xuICAgICAgICBoZXhMZW5ndGggPSB0bXA7XG4gICAgICAgIGhleFJlc3VsdCA9IDA7XG5cbiAgICAgICAgZm9yICg7IGhleExlbmd0aCA+IDA7IGhleExlbmd0aC0tKSB7XG4gICAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICAgICAgaWYgKCh0bXAgPSBmcm9tSGV4Q29kZShjaCkpID49IDApIHtcbiAgICAgICAgICAgIGhleFJlc3VsdCA9IChoZXhSZXN1bHQgPDwgNCkgKyB0bXA7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2V4cGVjdGVkIGhleGFkZWNpbWFsIGNoYXJhY3RlcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjaGFyRnJvbUNvZGVwb2ludChoZXhSZXN1bHQpO1xuXG4gICAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmtub3duIGVzY2FwZSBzZXF1ZW5jZScpO1xuICAgICAgfVxuXG4gICAgICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG5cbiAgICB9IGVsc2UgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQsIHRydWUpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgZmFsc2UsIG5vZGVJbmRlbnQpKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIH0gZWxzZSBpZiAoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIGRvY3VtZW50IHdpdGhpbiBhIGRvdWJsZSBxdW90ZWQgc2NhbGFyJyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICB9XG4gIH1cblxuICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSBkb3VibGUgcXVvdGVkIHNjYWxhcicpO1xufVxuXG5mdW5jdGlvbiByZWFkRmxvd0NvbGxlY3Rpb24oc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIHJlYWROZXh0ID0gdHJ1ZSxcbiAgICAgIF9saW5lLFxuICAgICAgX2xpbmVTdGFydCxcbiAgICAgIF9wb3MsXG4gICAgICBfdGFnICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIF9yZXN1bHQsXG4gICAgICBfYW5jaG9yICA9IHN0YXRlLmFuY2hvcixcbiAgICAgIGZvbGxvd2luZyxcbiAgICAgIHRlcm1pbmF0b3IsXG4gICAgICBpc1BhaXIsXG4gICAgICBpc0V4cGxpY2l0UGFpcixcbiAgICAgIGlzTWFwcGluZyxcbiAgICAgIG92ZXJyaWRhYmxlS2V5cyA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBrZXlOb2RlLFxuICAgICAga2V5VGFnLFxuICAgICAgdmFsdWVOb2RlLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggPT09IDB4NUIvKiBbICovKSB7XG4gICAgdGVybWluYXRvciA9IDB4NUQ7LyogXSAqL1xuICAgIGlzTWFwcGluZyA9IGZhbHNlO1xuICAgIF9yZXN1bHQgPSBbXTtcbiAgfSBlbHNlIGlmIChjaCA9PT0gMHg3Qi8qIHsgKi8pIHtcbiAgICB0ZXJtaW5hdG9yID0gMHg3RDsvKiB9ICovXG4gICAgaXNNYXBwaW5nID0gdHJ1ZTtcbiAgICBfcmVzdWx0ID0ge307XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gX3Jlc3VsdDtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoY2ggPT09IHRlcm1pbmF0b3IpIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICBzdGF0ZS50YWcgPSBfdGFnO1xuICAgICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICAgIHN0YXRlLmtpbmQgPSBpc01hcHBpbmcgPyAnbWFwcGluZycgOiAnc2VxdWVuY2UnO1xuICAgICAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIXJlYWROZXh0KSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnbWlzc2VkIGNvbW1hIGJldHdlZW4gZmxvdyBjb2xsZWN0aW9uIGVudHJpZXMnKTtcbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDJDLyogLCAqLykge1xuICAgICAgLy8gXCJmbG93IGNvbGxlY3Rpb24gZW50cmllcyBjYW4gbmV2ZXIgYmUgY29tcGxldGVseSBlbXB0eVwiLCBhcyBwZXIgWUFNTCAxLjIsIHNlY3Rpb24gNy40XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCBcImV4cGVjdGVkIHRoZSBub2RlIGNvbnRlbnQsIGJ1dCBmb3VuZCAnLCdcIik7XG4gICAgfVxuXG4gICAga2V5VGFnID0ga2V5Tm9kZSA9IHZhbHVlTm9kZSA9IG51bGw7XG4gICAgaXNQYWlyID0gaXNFeHBsaWNpdFBhaXIgPSBmYWxzZTtcblxuICAgIGlmIChjaCA9PT0gMHgzRi8qID8gKi8pIHtcbiAgICAgIGZvbGxvd2luZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKTtcblxuICAgICAgaWYgKGlzX1dTX09SX0VPTChmb2xsb3dpbmcpKSB7XG4gICAgICAgIGlzUGFpciA9IGlzRXhwbGljaXRQYWlyID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2xpbmUgPSBzdGF0ZS5saW5lOyAvLyBTYXZlIHRoZSBjdXJyZW50IGxpbmUuXG4gICAgX2xpbmVTdGFydCA9IHN0YXRlLmxpbmVTdGFydDtcbiAgICBfcG9zID0gc3RhdGUucG9zaXRpb247XG4gICAgY29tcG9zZU5vZGUoc3RhdGUsIG5vZGVJbmRlbnQsIENPTlRFWFRfRkxPV19JTiwgZmFsc2UsIHRydWUpO1xuICAgIGtleVRhZyA9IHN0YXRlLnRhZztcbiAgICBrZXlOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmICgoaXNFeHBsaWNpdFBhaXIgfHwgc3RhdGUubGluZSA9PT0gX2xpbmUpICYmIGNoID09PSAweDNBLyogOiAqLykge1xuICAgICAgaXNQYWlyID0gdHJ1ZTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuICAgICAgY29tcG9zZU5vZGUoc3RhdGUsIG5vZGVJbmRlbnQsIENPTlRFWFRfRkxPV19JTiwgZmFsc2UsIHRydWUpO1xuICAgICAgdmFsdWVOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgIH1cblxuICAgIGlmIChpc01hcHBpbmcpIHtcbiAgICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCB2YWx1ZU5vZGUsIF9saW5lLCBfbGluZVN0YXJ0LCBfcG9zKTtcbiAgICB9IGVsc2UgaWYgKGlzUGFpcikge1xuICAgICAgX3Jlc3VsdC5wdXNoKHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIG51bGwsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCB2YWx1ZU5vZGUsIF9saW5lLCBfbGluZVN0YXJ0LCBfcG9zKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9yZXN1bHQucHVzaChrZXlOb2RlKTtcbiAgICB9XG5cbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoY2ggPT09IDB4MkMvKiAsICovKSB7XG4gICAgICByZWFkTmV4dCA9IHRydWU7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlYWROZXh0ID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBzdHJlYW0gd2l0aGluIGEgZmxvdyBjb2xsZWN0aW9uJyk7XG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9ja1NjYWxhcihzdGF0ZSwgbm9kZUluZGVudCkge1xuICB2YXIgY2FwdHVyZVN0YXJ0LFxuICAgICAgZm9sZGluZyxcbiAgICAgIGNob21waW5nICAgICAgID0gQ0hPTVBJTkdfQ0xJUCxcbiAgICAgIGRpZFJlYWRDb250ZW50ID0gZmFsc2UsXG4gICAgICBkZXRlY3RlZEluZGVudCA9IGZhbHNlLFxuICAgICAgdGV4dEluZGVudCAgICAgPSBub2RlSW5kZW50LFxuICAgICAgZW1wdHlMaW5lcyAgICAgPSAwLFxuICAgICAgYXRNb3JlSW5kZW50ZWQgPSBmYWxzZSxcbiAgICAgIHRtcCxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoID09PSAweDdDLyogfCAqLykge1xuICAgIGZvbGRpbmcgPSBmYWxzZTtcbiAgfSBlbHNlIGlmIChjaCA9PT0gMHgzRS8qID4gKi8pIHtcbiAgICBmb2xkaW5nID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChjaCA9PT0gMHgyQi8qICsgKi8gfHwgY2ggPT09IDB4MkQvKiAtICovKSB7XG4gICAgICBpZiAoQ0hPTVBJTkdfQ0xJUCA9PT0gY2hvbXBpbmcpIHtcbiAgICAgICAgY2hvbXBpbmcgPSAoY2ggPT09IDB4MkIvKiArICovKSA/IENIT01QSU5HX0tFRVAgOiBDSE9NUElOR19TVFJJUDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdyZXBlYXQgb2YgYSBjaG9tcGluZyBtb2RlIGlkZW50aWZpZXInKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoKHRtcCA9IGZyb21EZWNpbWFsQ29kZShjaCkpID49IDApIHtcbiAgICAgIGlmICh0bXAgPT09IDApIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2JhZCBleHBsaWNpdCBpbmRlbnRhdGlvbiB3aWR0aCBvZiBhIGJsb2NrIHNjYWxhcjsgaXQgY2Fubm90IGJlIGxlc3MgdGhhbiBvbmUnKTtcbiAgICAgIH0gZWxzZSBpZiAoIWRldGVjdGVkSW5kZW50KSB7XG4gICAgICAgIHRleHRJbmRlbnQgPSBub2RlSW5kZW50ICsgdG1wIC0gMTtcbiAgICAgICAgZGV0ZWN0ZWRJbmRlbnQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3JlcGVhdCBvZiBhbiBpbmRlbnRhdGlvbiB3aWR0aCBpZGVudGlmaWVyJyk7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgIGRvIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG4gICAgd2hpbGUgKGlzX1dISVRFX1NQQUNFKGNoKSk7XG5cbiAgICBpZiAoY2ggPT09IDB4MjMvKiAjICovKSB7XG4gICAgICBkbyB7IGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTsgfVxuICAgICAgd2hpbGUgKCFpc19FT0woY2gpICYmIChjaCAhPT0gMCkpO1xuICAgIH1cbiAgfVxuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIHJlYWRMaW5lQnJlYWsoc3RhdGUpO1xuICAgIHN0YXRlLmxpbmVJbmRlbnQgPSAwO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIHdoaWxlICgoIWRldGVjdGVkSW5kZW50IHx8IHN0YXRlLmxpbmVJbmRlbnQgPCB0ZXh0SW5kZW50KSAmJlxuICAgICAgICAgICAoY2ggPT09IDB4MjAvKiBTcGFjZSAqLykpIHtcbiAgICAgIHN0YXRlLmxpbmVJbmRlbnQrKztcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoIWRldGVjdGVkSW5kZW50ICYmIHN0YXRlLmxpbmVJbmRlbnQgPiB0ZXh0SW5kZW50KSB7XG4gICAgICB0ZXh0SW5kZW50ID0gc3RhdGUubGluZUluZGVudDtcbiAgICB9XG5cbiAgICBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgZW1wdHlMaW5lcysrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gRW5kIG9mIHRoZSBzY2FsYXIuXG4gICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPCB0ZXh0SW5kZW50KSB7XG5cbiAgICAgIC8vIFBlcmZvcm0gdGhlIGNob21waW5nLlxuICAgICAgaWYgKGNob21waW5nID09PSBDSE9NUElOR19LRUVQKSB7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBkaWRSZWFkQ29udGVudCA/IDEgKyBlbXB0eUxpbmVzIDogZW1wdHlMaW5lcyk7XG4gICAgICB9IGVsc2UgaWYgKGNob21waW5nID09PSBDSE9NUElOR19DTElQKSB7XG4gICAgICAgIGlmIChkaWRSZWFkQ29udGVudCkgeyAvLyBpLmUuIG9ubHkgaWYgdGhlIHNjYWxhciBpcyBub3QgZW1wdHkuXG4gICAgICAgICAgc3RhdGUucmVzdWx0ICs9ICdcXG4nO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEJyZWFrIHRoaXMgYHdoaWxlYCBjeWNsZSBhbmQgZ28gdG8gdGhlIGZ1bmNpdG9uJ3MgZXBpbG9ndWUuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBGb2xkZWQgc3R5bGU6IHVzZSBmYW5jeSBydWxlcyB0byBoYW5kbGUgbGluZSBicmVha3MuXG4gICAgaWYgKGZvbGRpbmcpIHtcblxuICAgICAgLy8gTGluZXMgc3RhcnRpbmcgd2l0aCB3aGl0ZSBzcGFjZSBjaGFyYWN0ZXJzIChtb3JlLWluZGVudGVkIGxpbmVzKSBhcmUgbm90IGZvbGRlZC5cbiAgICAgIGlmIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgICAgYXRNb3JlSW5kZW50ZWQgPSB0cnVlO1xuICAgICAgICAvLyBleGNlcHQgZm9yIHRoZSBmaXJzdCBjb250ZW50IGxpbmUgKGNmLiBFeGFtcGxlIDguMSlcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGRpZFJlYWRDb250ZW50ID8gMSArIGVtcHR5TGluZXMgOiBlbXB0eUxpbmVzKTtcblxuICAgICAgLy8gRW5kIG9mIG1vcmUtaW5kZW50ZWQgYmxvY2suXG4gICAgICB9IGVsc2UgaWYgKGF0TW9yZUluZGVudGVkKSB7XG4gICAgICAgIGF0TW9yZUluZGVudGVkID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBlbXB0eUxpbmVzICsgMSk7XG5cbiAgICAgIC8vIEp1c3Qgb25lIGxpbmUgYnJlYWsgLSBwZXJjZWl2ZSBhcyB0aGUgc2FtZSBsaW5lLlxuICAgICAgfSBlbHNlIGlmIChlbXB0eUxpbmVzID09PSAwKSB7XG4gICAgICAgIGlmIChkaWRSZWFkQ29udGVudCkgeyAvLyBpLmUuIG9ubHkgaWYgd2UgaGF2ZSBhbHJlYWR5IHJlYWQgc29tZSBzY2FsYXIgY29udGVudC5cbiAgICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gJyAnO1xuICAgICAgICB9XG5cbiAgICAgIC8vIFNldmVyYWwgbGluZSBicmVha3MgLSBwZXJjZWl2ZSBhcyBkaWZmZXJlbnQgbGluZXMuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZW1wdHlMaW5lcyk7XG4gICAgICB9XG5cbiAgICAvLyBMaXRlcmFsIHN0eWxlOiBqdXN0IGFkZCBleGFjdCBudW1iZXIgb2YgbGluZSBicmVha3MgYmV0d2VlbiBjb250ZW50IGxpbmVzLlxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBLZWVwIGFsbCBsaW5lIGJyZWFrcyBleGNlcHQgdGhlIGhlYWRlciBsaW5lIGJyZWFrLlxuICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGRpZFJlYWRDb250ZW50ID8gMSArIGVtcHR5TGluZXMgOiBlbXB0eUxpbmVzKTtcbiAgICB9XG5cbiAgICBkaWRSZWFkQ29udGVudCA9IHRydWU7XG4gICAgZGV0ZWN0ZWRJbmRlbnQgPSB0cnVlO1xuICAgIGVtcHR5TGluZXMgPSAwO1xuICAgIGNhcHR1cmVTdGFydCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgd2hpbGUgKCFpc19FT0woY2gpICYmIChjaCAhPT0gMCkpIHtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBzdGF0ZS5wb3NpdGlvbiwgZmFsc2UpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBfbGluZSxcbiAgICAgIF90YWcgICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIF9hbmNob3IgICA9IHN0YXRlLmFuY2hvcixcbiAgICAgIF9yZXN1bHQgICA9IFtdLFxuICAgICAgZm9sbG93aW5nLFxuICAgICAgZGV0ZWN0ZWQgID0gZmFsc2UsXG4gICAgICBjaDtcblxuICAvLyB0aGVyZSBpcyBhIGxlYWRpbmcgdGFiIGJlZm9yZSB0aGlzIHRva2VuLCBzbyBpdCBjYW4ndCBiZSBhIGJsb2NrIHNlcXVlbmNlL21hcHBpbmc7XG4gIC8vIGl0IGNhbiBzdGlsbCBiZSBmbG93IHNlcXVlbmNlL21hcHBpbmcgb3IgYSBzY2FsYXJcbiAgaWYgKHN0YXRlLmZpcnN0VGFiSW5MaW5lICE9PSAtMSkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IF9yZXN1bHQ7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIGlmIChzdGF0ZS5maXJzdFRhYkluTGluZSAhPT0gLTEpIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uID0gc3RhdGUuZmlyc3RUYWJJbkxpbmU7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFiIGNoYXJhY3RlcnMgbXVzdCBub3QgYmUgdXNlZCBpbiBpbmRlbnRhdGlvbicpO1xuICAgIH1cblxuICAgIGlmIChjaCAhPT0gMHgyRC8qIC0gKi8pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGZvbGxvd2luZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKTtcblxuICAgIGlmICghaXNfV1NfT1JfRU9MKGZvbGxvd2luZykpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGRldGVjdGVkID0gdHJ1ZTtcbiAgICBzdGF0ZS5wb3NpdGlvbisrO1xuXG4gICAgaWYgKHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKSkge1xuICAgICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPD0gbm9kZUluZGVudCkge1xuICAgICAgICBfcmVzdWx0LnB1c2gobnVsbCk7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9saW5lID0gc3RhdGUubGluZTtcbiAgICBjb21wb3NlTm9kZShzdGF0ZSwgbm9kZUluZGVudCwgQ09OVEVYVF9CTE9DS19JTiwgZmFsc2UsIHRydWUpO1xuICAgIF9yZXN1bHQucHVzaChzdGF0ZS5yZXN1bHQpO1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoKHN0YXRlLmxpbmUgPT09IF9saW5lIHx8IHN0YXRlLmxpbmVJbmRlbnQgPiBub2RlSW5kZW50KSAmJiAoY2ggIT09IDApKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYmFkIGluZGVudGF0aW9uIG9mIGEgc2VxdWVuY2UgZW50cnknKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPCBub2RlSW5kZW50KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoZGV0ZWN0ZWQpIHtcbiAgICBzdGF0ZS50YWcgPSBfdGFnO1xuICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgc3RhdGUua2luZCA9ICdzZXF1ZW5jZSc7XG4gICAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9ja01hcHBpbmcoc3RhdGUsIG5vZGVJbmRlbnQsIGZsb3dJbmRlbnQpIHtcbiAgdmFyIGZvbGxvd2luZyxcbiAgICAgIGFsbG93Q29tcGFjdCxcbiAgICAgIF9saW5lLFxuICAgICAgX2tleUxpbmUsXG4gICAgICBfa2V5TGluZVN0YXJ0LFxuICAgICAgX2tleVBvcyxcbiAgICAgIF90YWcgICAgICAgICAgPSBzdGF0ZS50YWcsXG4gICAgICBfYW5jaG9yICAgICAgID0gc3RhdGUuYW5jaG9yLFxuICAgICAgX3Jlc3VsdCAgICAgICA9IHt9LFxuICAgICAgb3ZlcnJpZGFibGVLZXlzID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIGtleVRhZyAgICAgICAgPSBudWxsLFxuICAgICAga2V5Tm9kZSAgICAgICA9IG51bGwsXG4gICAgICB2YWx1ZU5vZGUgICAgID0gbnVsbCxcbiAgICAgIGF0RXhwbGljaXRLZXkgPSBmYWxzZSxcbiAgICAgIGRldGVjdGVkICAgICAgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIC8vIHRoZXJlIGlzIGEgbGVhZGluZyB0YWIgYmVmb3JlIHRoaXMgdG9rZW4sIHNvIGl0IGNhbid0IGJlIGEgYmxvY2sgc2VxdWVuY2UvbWFwcGluZztcbiAgLy8gaXQgY2FuIHN0aWxsIGJlIGZsb3cgc2VxdWVuY2UvbWFwcGluZyBvciBhIHNjYWxhclxuICBpZiAoc3RhdGUuZmlyc3RUYWJJbkxpbmUgIT09IC0xKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gX3Jlc3VsdDtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgaWYgKCFhdEV4cGxpY2l0S2V5ICYmIHN0YXRlLmZpcnN0VGFiSW5MaW5lICE9PSAtMSkge1xuICAgICAgc3RhdGUucG9zaXRpb24gPSBzdGF0ZS5maXJzdFRhYkluTGluZTtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWIgY2hhcmFjdGVycyBtdXN0IG5vdCBiZSB1c2VkIGluIGluZGVudGF0aW9uJyk7XG4gICAgfVxuXG4gICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuICAgIF9saW5lID0gc3RhdGUubGluZTsgLy8gU2F2ZSB0aGUgY3VycmVudCBsaW5lLlxuXG4gICAgLy9cbiAgICAvLyBFeHBsaWNpdCBub3RhdGlvbiBjYXNlLiBUaGVyZSBhcmUgdHdvIHNlcGFyYXRlIGJsb2NrczpcbiAgICAvLyBmaXJzdCBmb3IgdGhlIGtleSAoZGVub3RlZCBieSBcIj9cIikgYW5kIHNlY29uZCBmb3IgdGhlIHZhbHVlIChkZW5vdGVkIGJ5IFwiOlwiKVxuICAgIC8vXG4gICAgaWYgKChjaCA9PT0gMHgzRi8qID8gKi8gfHwgY2ggPT09IDB4M0EvKiA6ICovKSAmJiBpc19XU19PUl9FT0woZm9sbG93aW5nKSkge1xuXG4gICAgICBpZiAoY2ggPT09IDB4M0YvKiA/ICovKSB7XG4gICAgICAgIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIG51bGwsIF9rZXlMaW5lLCBfa2V5TGluZVN0YXJ0LCBfa2V5UG9zKTtcbiAgICAgICAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRldGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgYXRFeHBsaWNpdEtleSA9IHRydWU7XG4gICAgICAgIGFsbG93Q29tcGFjdCA9IHRydWU7XG5cbiAgICAgIH0gZWxzZSBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgICAgICAvLyBpLmUuIDB4M0EvKiA6ICovID09PSBjaGFyYWN0ZXIgYWZ0ZXIgdGhlIGV4cGxpY2l0IGtleS5cbiAgICAgICAgYXRFeHBsaWNpdEtleSA9IGZhbHNlO1xuICAgICAgICBhbGxvd0NvbXBhY3QgPSB0cnVlO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnaW5jb21wbGV0ZSBleHBsaWNpdCBtYXBwaW5nIHBhaXI7IGEga2V5IG5vZGUgaXMgbWlzc2VkOyBvciBmb2xsb3dlZCBieSBhIG5vbi10YWJ1bGF0ZWQgZW1wdHkgbGluZScpO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZS5wb3NpdGlvbiArPSAxO1xuICAgICAgY2ggPSBmb2xsb3dpbmc7XG5cbiAgICAvL1xuICAgIC8vIEltcGxpY2l0IG5vdGF0aW9uIGNhc2UuIEZsb3ctc3R5bGUgbm9kZSBhcyB0aGUga2V5IGZpcnN0LCB0aGVuIFwiOlwiLCBhbmQgdGhlIHZhbHVlLlxuICAgIC8vXG4gICAgfSBlbHNlIHtcbiAgICAgIF9rZXlMaW5lID0gc3RhdGUubGluZTtcbiAgICAgIF9rZXlMaW5lU3RhcnQgPSBzdGF0ZS5saW5lU3RhcnQ7XG4gICAgICBfa2V5UG9zID0gc3RhdGUucG9zaXRpb247XG5cbiAgICAgIGlmICghY29tcG9zZU5vZGUoc3RhdGUsIGZsb3dJbmRlbnQsIENPTlRFWFRfRkxPV19PVVQsIGZhbHNlLCB0cnVlKSkge1xuICAgICAgICAvLyBOZWl0aGVyIGltcGxpY2l0IG5vciBleHBsaWNpdCBub3RhdGlvbi5cbiAgICAgICAgLy8gUmVhZGluZyBpcyBkb25lLiBHbyB0byB0aGUgZXBpbG9ndWUuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUubGluZSA9PT0gX2xpbmUpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoID09PSAweDNBLyogOiAqLykge1xuICAgICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgICAgIGlmICghaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2Egd2hpdGVzcGFjZSBjaGFyYWN0ZXIgaXMgZXhwZWN0ZWQgYWZ0ZXIgdGhlIGtleS12YWx1ZSBzZXBhcmF0b3Igd2l0aGluIGEgYmxvY2sgbWFwcGluZycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgbnVsbCwgX2tleUxpbmUsIF9rZXlMaW5lU3RhcnQsIF9rZXlQb3MpO1xuICAgICAgICAgICAga2V5VGFnID0ga2V5Tm9kZSA9IHZhbHVlTm9kZSA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGV0ZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIGF0RXhwbGljaXRLZXkgPSBmYWxzZTtcbiAgICAgICAgICBhbGxvd0NvbXBhY3QgPSBmYWxzZTtcbiAgICAgICAgICBrZXlUYWcgPSBzdGF0ZS50YWc7XG4gICAgICAgICAga2V5Tm9kZSA9IHN0YXRlLnJlc3VsdDtcblxuICAgICAgICB9IGVsc2UgaWYgKGRldGVjdGVkKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2NhbiBub3QgcmVhZCBhbiBpbXBsaWNpdCBtYXBwaW5nIHBhaXI7IGEgY29sb24gaXMgbWlzc2VkJyk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS50YWcgPSBfdGFnO1xuICAgICAgICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgICAgICAgcmV0dXJuIHRydWU7IC8vIEtlZXAgdGhlIHJlc3VsdCBvZiBgY29tcG9zZU5vZGVgLlxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZiAoZGV0ZWN0ZWQpIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2NhbiBub3QgcmVhZCBhIGJsb2NrIG1hcHBpbmcgZW50cnk7IGEgbXVsdGlsaW5lIGtleSBtYXkgbm90IGJlIGFuIGltcGxpY2l0IGtleScpO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS50YWcgPSBfdGFnO1xuICAgICAgICBzdGF0ZS5hbmNob3IgPSBfYW5jaG9yO1xuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gS2VlcCB0aGUgcmVzdWx0IG9mIGBjb21wb3NlTm9kZWAuXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBDb21tb24gcmVhZGluZyBjb2RlIGZvciBib3RoIGV4cGxpY2l0IGFuZCBpbXBsaWNpdCBub3RhdGlvbnMuXG4gICAgLy9cbiAgICBpZiAoc3RhdGUubGluZSA9PT0gX2xpbmUgfHwgc3RhdGUubGluZUluZGVudCA+IG5vZGVJbmRlbnQpIHtcbiAgICAgIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgIF9rZXlMaW5lID0gc3RhdGUubGluZTtcbiAgICAgICAgX2tleUxpbmVTdGFydCA9IHN0YXRlLmxpbmVTdGFydDtcbiAgICAgICAgX2tleVBvcyA9IHN0YXRlLnBvc2l0aW9uO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29tcG9zZU5vZGUoc3RhdGUsIG5vZGVJbmRlbnQsIENPTlRFWFRfQkxPQ0tfT1VULCB0cnVlLCBhbGxvd0NvbXBhY3QpKSB7XG4gICAgICAgIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgICAga2V5Tm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCB2YWx1ZU5vZGUsIF9rZXlMaW5lLCBfa2V5TGluZVN0YXJ0LCBfa2V5UG9zKTtcbiAgICAgICAga2V5VGFnID0ga2V5Tm9kZSA9IHZhbHVlTm9kZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKChzdGF0ZS5saW5lID09PSBfbGluZSB8fCBzdGF0ZS5saW5lSW5kZW50ID4gbm9kZUluZGVudCkgJiYgKGNoICE9PSAwKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2JhZCBpbmRlbnRhdGlvbiBvZiBhIG1hcHBpbmcgZW50cnknKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPCBub2RlSW5kZW50KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvL1xuICAvLyBFcGlsb2d1ZS5cbiAgLy9cblxuICAvLyBTcGVjaWFsIGNhc2U6IGxhc3QgbWFwcGluZydzIG5vZGUgY29udGFpbnMgb25seSB0aGUga2V5IGluIGV4cGxpY2l0IG5vdGF0aW9uLlxuICBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCBudWxsLCBfa2V5TGluZSwgX2tleUxpbmVTdGFydCwgX2tleVBvcyk7XG4gIH1cblxuICAvLyBFeHBvc2UgdGhlIHJlc3VsdGluZyBtYXBwaW5nLlxuICBpZiAoZGV0ZWN0ZWQpIHtcbiAgICBzdGF0ZS50YWcgPSBfdGFnO1xuICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgc3RhdGUua2luZCA9ICdtYXBwaW5nJztcbiAgICBzdGF0ZS5yZXN1bHQgPSBfcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIGRldGVjdGVkO1xufVxuXG5mdW5jdGlvbiByZWFkVGFnUHJvcGVydHkoc3RhdGUpIHtcbiAgdmFyIF9wb3NpdGlvbixcbiAgICAgIGlzVmVyYmF0aW0gPSBmYWxzZSxcbiAgICAgIGlzTmFtZWQgICAgPSBmYWxzZSxcbiAgICAgIHRhZ0hhbmRsZSxcbiAgICAgIHRhZ05hbWUsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCAhPT0gMHgyMS8qICEgKi8pIHJldHVybiBmYWxzZTtcblxuICBpZiAoc3RhdGUudGFnICE9PSBudWxsKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0aW9uIG9mIGEgdGFnIHByb3BlcnR5Jyk7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoID09PSAweDNDLyogPCAqLykge1xuICAgIGlzVmVyYmF0aW0gPSB0cnVlO1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICB9IGVsc2UgaWYgKGNoID09PSAweDIxLyogISAqLykge1xuICAgIGlzTmFtZWQgPSB0cnVlO1xuICAgIHRhZ0hhbmRsZSA9ICchISc7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gIH0gZWxzZSB7XG4gICAgdGFnSGFuZGxlID0gJyEnO1xuICB9XG5cbiAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG5cbiAgaWYgKGlzVmVyYmF0aW0pIHtcbiAgICBkbyB7IGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTsgfVxuICAgIHdoaWxlIChjaCAhPT0gMCAmJiBjaCAhPT0gMHgzRS8qID4gKi8pO1xuXG4gICAgaWYgKHN0YXRlLnBvc2l0aW9uIDwgc3RhdGUubGVuZ3RoKSB7XG4gICAgICB0YWdOYW1lID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIHZlcmJhdGltIHRhZycpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX1dTX09SX0VPTChjaCkpIHtcblxuICAgICAgaWYgKGNoID09PSAweDIxLyogISAqLykge1xuICAgICAgICBpZiAoIWlzTmFtZWQpIHtcbiAgICAgICAgICB0YWdIYW5kbGUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24gLSAxLCBzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgICAgICAgaWYgKCFQQVRURVJOX1RBR19IQU5ETEUudGVzdCh0YWdIYW5kbGUpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnbmFtZWQgdGFnIGhhbmRsZSBjYW5ub3QgY29udGFpbiBzdWNoIGNoYXJhY3RlcnMnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpc05hbWVkID0gdHJ1ZTtcbiAgICAgICAgICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbiArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhZyBzdWZmaXggY2Fubm90IGNvbnRhaW4gZXhjbGFtYXRpb24gbWFya3MnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgdGFnTmFtZSA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKFBBVFRFUk5fRkxPV19JTkRJQ0FUT1JTLnRlc3QodGFnTmFtZSkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWcgc3VmZml4IGNhbm5vdCBjb250YWluIGZsb3cgaW5kaWNhdG9yIGNoYXJhY3RlcnMnKTtcbiAgICB9XG4gIH1cblxuICBpZiAodGFnTmFtZSAmJiAhUEFUVEVSTl9UQUdfVVJJLnRlc3QodGFnTmFtZSkpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFnIG5hbWUgY2Fubm90IGNvbnRhaW4gc3VjaCBjaGFyYWN0ZXJzOiAnICsgdGFnTmFtZSk7XG4gIH1cblxuICB0cnkge1xuICAgIHRhZ05hbWUgPSBkZWNvZGVVUklDb21wb25lbnQodGFnTmFtZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWcgbmFtZSBpcyBtYWxmb3JtZWQ6ICcgKyB0YWdOYW1lKTtcbiAgfVxuXG4gIGlmIChpc1ZlcmJhdGltKSB7XG4gICAgc3RhdGUudGFnID0gdGFnTmFtZTtcblxuICB9IGVsc2UgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLnRhZ01hcCwgdGFnSGFuZGxlKSkge1xuICAgIHN0YXRlLnRhZyA9IHN0YXRlLnRhZ01hcFt0YWdIYW5kbGVdICsgdGFnTmFtZTtcblxuICB9IGVsc2UgaWYgKHRhZ0hhbmRsZSA9PT0gJyEnKSB7XG4gICAgc3RhdGUudGFnID0gJyEnICsgdGFnTmFtZTtcblxuICB9IGVsc2UgaWYgKHRhZ0hhbmRsZSA9PT0gJyEhJykge1xuICAgIHN0YXRlLnRhZyA9ICd0YWc6eWFtbC5vcmcsMjAwMjonICsgdGFnTmFtZTtcblxuICB9IGVsc2Uge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmRlY2xhcmVkIHRhZyBoYW5kbGUgXCInICsgdGFnSGFuZGxlICsgJ1wiJyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVhZEFuY2hvclByb3BlcnR5KHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24sXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCAhPT0gMHgyNi8qICYgKi8pIHJldHVybiBmYWxzZTtcblxuICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0aW9uIG9mIGFuIGFuY2hvciBwcm9wZXJ0eScpO1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX1dTX09SX0VPTChjaCkgJiYgIWlzX0ZMT1dfSU5ESUNBVE9SKGNoKSkge1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gX3Bvc2l0aW9uKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25hbWUgb2YgYW4gYW5jaG9yIG5vZGUgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXInKTtcbiAgfVxuXG4gIHN0YXRlLmFuY2hvciA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVhZEFsaWFzKHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24sIGFsaWFzLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggIT09IDB4MkEvKiAqICovKSByZXR1cm4gZmFsc2U7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX1dTX09SX0VPTChjaCkgJiYgIWlzX0ZMT1dfSU5ESUNBVE9SKGNoKSkge1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gX3Bvc2l0aW9uKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25hbWUgb2YgYW4gYWxpYXMgbm9kZSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIGNoYXJhY3RlcicpO1xuICB9XG5cbiAgYWxpYXMgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoIV9oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLmFuY2hvck1hcCwgYWxpYXMpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuaWRlbnRpZmllZCBhbGlhcyBcIicgKyBhbGlhcyArICdcIicpO1xuICB9XG5cbiAgc3RhdGUucmVzdWx0ID0gc3RhdGUuYW5jaG9yTWFwW2FsaWFzXTtcbiAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29tcG9zZU5vZGUoc3RhdGUsIHBhcmVudEluZGVudCwgbm9kZUNvbnRleHQsIGFsbG93VG9TZWVrLCBhbGxvd0NvbXBhY3QpIHtcbiAgdmFyIGFsbG93QmxvY2tTdHlsZXMsXG4gICAgICBhbGxvd0Jsb2NrU2NhbGFycyxcbiAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyxcbiAgICAgIGluZGVudFN0YXR1cyA9IDEsIC8vIDE6IHRoaXM+cGFyZW50LCAwOiB0aGlzPXBhcmVudCwgLTE6IHRoaXM8cGFyZW50XG4gICAgICBhdE5ld0xpbmUgID0gZmFsc2UsXG4gICAgICBoYXNDb250ZW50ID0gZmFsc2UsXG4gICAgICB0eXBlSW5kZXgsXG4gICAgICB0eXBlUXVhbnRpdHksXG4gICAgICB0eXBlTGlzdCxcbiAgICAgIHR5cGUsXG4gICAgICBmbG93SW5kZW50LFxuICAgICAgYmxvY2tJbmRlbnQ7XG5cbiAgaWYgKHN0YXRlLmxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgc3RhdGUubGlzdGVuZXIoJ29wZW4nLCBzdGF0ZSk7XG4gIH1cblxuICBzdGF0ZS50YWcgICAgPSBudWxsO1xuICBzdGF0ZS5hbmNob3IgPSBudWxsO1xuICBzdGF0ZS5raW5kICAgPSBudWxsO1xuICBzdGF0ZS5yZXN1bHQgPSBudWxsO1xuXG4gIGFsbG93QmxvY2tTdHlsZXMgPSBhbGxvd0Jsb2NrU2NhbGFycyA9IGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9XG4gICAgQ09OVEVYVF9CTE9DS19PVVQgPT09IG5vZGVDb250ZXh0IHx8XG4gICAgQ09OVEVYVF9CTE9DS19JTiAgPT09IG5vZGVDb250ZXh0O1xuXG4gIGlmIChhbGxvd1RvU2Vlaykge1xuICAgIGlmIChza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSkpIHtcbiAgICAgIGF0TmV3TGluZSA9IHRydWU7XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID4gcGFyZW50SW5kZW50KSB7XG4gICAgICAgIGluZGVudFN0YXR1cyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IHBhcmVudEluZGVudCkge1xuICAgICAgICBpbmRlbnRTdGF0dXMgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgcGFyZW50SW5kZW50KSB7XG4gICAgICAgIGluZGVudFN0YXR1cyA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpbmRlbnRTdGF0dXMgPT09IDEpIHtcbiAgICB3aGlsZSAocmVhZFRhZ1Byb3BlcnR5KHN0YXRlKSB8fCByZWFkQW5jaG9yUHJvcGVydHkoc3RhdGUpKSB7XG4gICAgICBpZiAoc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpKSB7XG4gICAgICAgIGF0TmV3TGluZSA9IHRydWU7XG4gICAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9IGFsbG93QmxvY2tTdHlsZXM7XG5cbiAgICAgICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgICBpbmRlbnRTdGF0dXMgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGluZGVudFN0YXR1cyA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGluZGVudFN0YXR1cyA9IC0xO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoYWxsb3dCbG9ja0NvbGxlY3Rpb25zKSB7XG4gICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zID0gYXROZXdMaW5lIHx8IGFsbG93Q29tcGFjdDtcbiAgfVxuXG4gIGlmIChpbmRlbnRTdGF0dXMgPT09IDEgfHwgQ09OVEVYVF9CTE9DS19PVVQgPT09IG5vZGVDb250ZXh0KSB7XG4gICAgaWYgKENPTlRFWFRfRkxPV19JTiA9PT0gbm9kZUNvbnRleHQgfHwgQ09OVEVYVF9GTE9XX09VVCA9PT0gbm9kZUNvbnRleHQpIHtcbiAgICAgIGZsb3dJbmRlbnQgPSBwYXJlbnRJbmRlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsb3dJbmRlbnQgPSBwYXJlbnRJbmRlbnQgKyAxO1xuICAgIH1cblxuICAgIGJsb2NrSW5kZW50ID0gc3RhdGUucG9zaXRpb24gLSBzdGF0ZS5saW5lU3RhcnQ7XG5cbiAgICBpZiAoaW5kZW50U3RhdHVzID09PSAxKSB7XG4gICAgICBpZiAoYWxsb3dCbG9ja0NvbGxlY3Rpb25zICYmXG4gICAgICAgICAgKHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBibG9ja0luZGVudCkgfHxcbiAgICAgICAgICAgcmVhZEJsb2NrTWFwcGluZyhzdGF0ZSwgYmxvY2tJbmRlbnQsIGZsb3dJbmRlbnQpKSB8fFxuICAgICAgICAgIHJlYWRGbG93Q29sbGVjdGlvbihzdGF0ZSwgZmxvd0luZGVudCkpIHtcbiAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKGFsbG93QmxvY2tTY2FsYXJzICYmIHJlYWRCbG9ja1NjYWxhcihzdGF0ZSwgZmxvd0luZGVudCkpIHx8XG4gICAgICAgICAgICByZWFkU2luZ2xlUXVvdGVkU2NhbGFyKHN0YXRlLCBmbG93SW5kZW50KSB8fFxuICAgICAgICAgICAgcmVhZERvdWJsZVF1b3RlZFNjYWxhcihzdGF0ZSwgZmxvd0luZGVudCkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlYWRBbGlhcyhzdGF0ZSkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChzdGF0ZS50YWcgIT09IG51bGwgfHwgc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYWxpYXMgbm9kZSBzaG91bGQgbm90IGhhdmUgYW55IHByb3BlcnRpZXMnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWFkUGxhaW5TY2FsYXIoc3RhdGUsIGZsb3dJbmRlbnQsIENPTlRFWFRfRkxPV19JTiA9PT0gbm9kZUNvbnRleHQpKSB7XG4gICAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAoc3RhdGUudGFnID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdGF0ZS50YWcgPSAnPyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpbmRlbnRTdGF0dXMgPT09IDApIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZTogYmxvY2sgc2VxdWVuY2VzIGFyZSBhbGxvd2VkIHRvIGhhdmUgc2FtZSBpbmRlbnRhdGlvbiBsZXZlbCBhcyB0aGUgcGFyZW50LlxuICAgICAgLy8gaHR0cDovL3d3dy55YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjaWQyNzk5Nzg0XG4gICAgICBoYXNDb250ZW50ID0gYWxsb3dCbG9ja0NvbGxlY3Rpb25zICYmIHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBibG9ja0luZGVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLnRhZyA9PT0gbnVsbCkge1xuICAgIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gc3RhdGUucmVzdWx0O1xuICAgIH1cblxuICB9IGVsc2UgaWYgKHN0YXRlLnRhZyA9PT0gJz8nKSB7XG4gICAgLy8gSW1wbGljaXQgcmVzb2x2aW5nIGlzIG5vdCBhbGxvd2VkIGZvciBub24tc2NhbGFyIHR5cGVzLCBhbmQgJz8nXG4gICAgLy8gbm9uLXNwZWNpZmljIHRhZyBpcyBvbmx5IGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgdG8gcGxhaW4gc2NhbGFycy5cbiAgICAvL1xuICAgIC8vIFdlIG9ubHkgbmVlZCB0byBjaGVjayBraW5kIGNvbmZvcm1pdHkgaW4gY2FzZSB1c2VyIGV4cGxpY2l0bHkgYXNzaWducyAnPydcbiAgICAvLyB0YWcsIGZvciBleGFtcGxlIGxpa2UgdGhpczogXCIhPD8+IFswXVwiXG4gICAgLy9cbiAgICBpZiAoc3RhdGUucmVzdWx0ICE9PSBudWxsICYmIHN0YXRlLmtpbmQgIT09ICdzY2FsYXInKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5hY2NlcHRhYmxlIG5vZGUga2luZCBmb3IgITw/PiB0YWc7IGl0IHNob3VsZCBiZSBcInNjYWxhclwiLCBub3QgXCInICsgc3RhdGUua2luZCArICdcIicpO1xuICAgIH1cblxuICAgIGZvciAodHlwZUluZGV4ID0gMCwgdHlwZVF1YW50aXR5ID0gc3RhdGUuaW1wbGljaXRUeXBlcy5sZW5ndGg7IHR5cGVJbmRleCA8IHR5cGVRdWFudGl0eTsgdHlwZUluZGV4ICs9IDEpIHtcbiAgICAgIHR5cGUgPSBzdGF0ZS5pbXBsaWNpdFR5cGVzW3R5cGVJbmRleF07XG5cbiAgICAgIGlmICh0eXBlLnJlc29sdmUoc3RhdGUucmVzdWx0KSkgeyAvLyBgc3RhdGUucmVzdWx0YCB1cGRhdGVkIGluIHJlc29sdmVyIGlmIG1hdGNoZWRcbiAgICAgICAgc3RhdGUucmVzdWx0ID0gdHlwZS5jb25zdHJ1Y3Qoc3RhdGUucmVzdWx0KTtcbiAgICAgICAgc3RhdGUudGFnID0gdHlwZS50YWc7XG4gICAgICAgIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICAgICAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoc3RhdGUudGFnICE9PSAnIScpIHtcbiAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwoc3RhdGUudHlwZU1hcFtzdGF0ZS5raW5kIHx8ICdmYWxsYmFjayddLCBzdGF0ZS50YWcpKSB7XG4gICAgICB0eXBlID0gc3RhdGUudHlwZU1hcFtzdGF0ZS5raW5kIHx8ICdmYWxsYmFjayddW3N0YXRlLnRhZ107XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxvb2tpbmcgZm9yIG11bHRpIHR5cGVcbiAgICAgIHR5cGUgPSBudWxsO1xuICAgICAgdHlwZUxpc3QgPSBzdGF0ZS50eXBlTWFwLm11bHRpW3N0YXRlLmtpbmQgfHwgJ2ZhbGxiYWNrJ107XG5cbiAgICAgIGZvciAodHlwZUluZGV4ID0gMCwgdHlwZVF1YW50aXR5ID0gdHlwZUxpc3QubGVuZ3RoOyB0eXBlSW5kZXggPCB0eXBlUXVhbnRpdHk7IHR5cGVJbmRleCArPSAxKSB7XG4gICAgICAgIGlmIChzdGF0ZS50YWcuc2xpY2UoMCwgdHlwZUxpc3RbdHlwZUluZGV4XS50YWcubGVuZ3RoKSA9PT0gdHlwZUxpc3RbdHlwZUluZGV4XS50YWcpIHtcbiAgICAgICAgICB0eXBlID0gdHlwZUxpc3RbdHlwZUluZGV4XTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdHlwZSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3Vua25vd24gdGFnICE8JyArIHN0YXRlLnRhZyArICc+Jyk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnJlc3VsdCAhPT0gbnVsbCAmJiB0eXBlLmtpbmQgIT09IHN0YXRlLmtpbmQpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmFjY2VwdGFibGUgbm9kZSBraW5kIGZvciAhPCcgKyBzdGF0ZS50YWcgKyAnPiB0YWc7IGl0IHNob3VsZCBiZSBcIicgKyB0eXBlLmtpbmQgKyAnXCIsIG5vdCBcIicgKyBzdGF0ZS5raW5kICsgJ1wiJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0eXBlLnJlc29sdmUoc3RhdGUucmVzdWx0LCBzdGF0ZS50YWcpKSB7IC8vIGBzdGF0ZS5yZXN1bHRgIHVwZGF0ZWQgaW4gcmVzb2x2ZXIgaWYgbWF0Y2hlZFxuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2Nhbm5vdCByZXNvbHZlIGEgbm9kZSB3aXRoICE8JyArIHN0YXRlLnRhZyArICc+IGV4cGxpY2l0IHRhZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5yZXN1bHQgPSB0eXBlLmNvbnN0cnVjdChzdGF0ZS5yZXN1bHQsIHN0YXRlLnRhZyk7XG4gICAgICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gc3RhdGUucmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0ZS5saXN0ZW5lciAhPT0gbnVsbCkge1xuICAgIHN0YXRlLmxpc3RlbmVyKCdjbG9zZScsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gc3RhdGUudGFnICE9PSBudWxsIHx8ICBzdGF0ZS5hbmNob3IgIT09IG51bGwgfHwgaGFzQ29udGVudDtcbn1cblxuZnVuY3Rpb24gcmVhZERvY3VtZW50KHN0YXRlKSB7XG4gIHZhciBkb2N1bWVudFN0YXJ0ID0gc3RhdGUucG9zaXRpb24sXG4gICAgICBfcG9zaXRpb24sXG4gICAgICBkaXJlY3RpdmVOYW1lLFxuICAgICAgZGlyZWN0aXZlQXJncyxcbiAgICAgIGhhc0RpcmVjdGl2ZXMgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIHN0YXRlLnZlcnNpb24gPSBudWxsO1xuICBzdGF0ZS5jaGVja0xpbmVCcmVha3MgPSBzdGF0ZS5sZWdhY3k7XG4gIHN0YXRlLnRhZ01hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHN0YXRlLmFuY2hvck1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgd2hpbGUgKChjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pKSAhPT0gMCkge1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoc3RhdGUubGluZUluZGVudCA+IDAgfHwgY2ggIT09IDB4MjUvKiAlICovKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBoYXNEaXJlY3RpdmVzID0gdHJ1ZTtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG5cbiAgICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX1dTX09SX0VPTChjaCkpIHtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBkaXJlY3RpdmVOYW1lID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG4gICAgZGlyZWN0aXZlQXJncyA9IFtdO1xuXG4gICAgaWYgKGRpcmVjdGl2ZU5hbWUubGVuZ3RoIDwgMSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2RpcmVjdGl2ZSBuYW1lIG11c3Qgbm90IGJlIGxlc3MgdGhhbiBvbmUgY2hhcmFjdGVyIGluIGxlbmd0aCcpO1xuICAgIH1cblxuICAgIHdoaWxlIChjaCAhPT0gMCkge1xuICAgICAgd2hpbGUgKGlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaCA9PT0gMHgyMy8qICMgKi8pIHtcbiAgICAgICAgZG8geyBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7IH1cbiAgICAgICAgd2hpbGUgKGNoICE9PSAwICYmICFpc19FT0woY2gpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc19FT0woY2gpKSBicmVhaztcblxuICAgICAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG5cbiAgICAgIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGRpcmVjdGl2ZUFyZ3MucHVzaChzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKSk7XG4gICAgfVxuXG4gICAgaWYgKGNoICE9PSAwKSByZWFkTGluZUJyZWFrKHN0YXRlKTtcblxuICAgIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbChkaXJlY3RpdmVIYW5kbGVycywgZGlyZWN0aXZlTmFtZSkpIHtcbiAgICAgIGRpcmVjdGl2ZUhhbmRsZXJzW2RpcmVjdGl2ZU5hbWVdKHN0YXRlLCBkaXJlY3RpdmVOYW1lLCBkaXJlY3RpdmVBcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAndW5rbm93biBkb2N1bWVudCBkaXJlY3RpdmUgXCInICsgZGlyZWN0aXZlTmFtZSArICdcIicpO1xuICAgIH1cbiAgfVxuXG4gIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICBpZiAoc3RhdGUubGluZUluZGVudCA9PT0gMCAmJlxuICAgICAgc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikgICAgID09PSAweDJELyogLSAqLyAmJlxuICAgICAgc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpID09PSAweDJELyogLSAqLyAmJlxuICAgICAgc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDIpID09PSAweDJELyogLSAqLykge1xuICAgIHN0YXRlLnBvc2l0aW9uICs9IDM7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gIH0gZWxzZSBpZiAoaGFzRGlyZWN0aXZlcykge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdkaXJlY3RpdmVzIGVuZCBtYXJrIGlzIGV4cGVjdGVkJyk7XG4gIH1cblxuICBjb21wb3NlTm9kZShzdGF0ZSwgc3RhdGUubGluZUluZGVudCAtIDEsIENPTlRFWFRfQkxPQ0tfT1VULCBmYWxzZSwgdHJ1ZSk7XG4gIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICBpZiAoc3RhdGUuY2hlY2tMaW5lQnJlYWtzICYmXG4gICAgICBQQVRURVJOX05PTl9BU0NJSV9MSU5FX0JSRUFLUy50ZXN0KHN0YXRlLmlucHV0LnNsaWNlKGRvY3VtZW50U3RhcnQsIHN0YXRlLnBvc2l0aW9uKSkpIHtcbiAgICB0aHJvd1dhcm5pbmcoc3RhdGUsICdub24tQVNDSUkgbGluZSBicmVha3MgYXJlIGludGVycHJldGVkIGFzIGNvbnRlbnQnKTtcbiAgfVxuXG4gIHN0YXRlLmRvY3VtZW50cy5wdXNoKHN0YXRlLnJlc3VsdCk7XG5cbiAgaWYgKHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgJiYgdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSkge1xuXG4gICAgaWYgKHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pID09PSAweDJFLyogLiAqLykge1xuICAgICAgc3RhdGUucG9zaXRpb24gKz0gMztcbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHN0YXRlLnBvc2l0aW9uIDwgKHN0YXRlLmxlbmd0aCAtIDEpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2VuZCBvZiB0aGUgc3RyZWFtIG9yIGEgZG9jdW1lbnQgc2VwYXJhdG9yIGlzIGV4cGVjdGVkJyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuO1xuICB9XG59XG5cblxuZnVuY3Rpb24gbG9hZERvY3VtZW50cyhpbnB1dCwgb3B0aW9ucykge1xuICBpbnB1dCA9IFN0cmluZyhpbnB1dCk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChpbnB1dC5sZW5ndGggIT09IDApIHtcblxuICAgIC8vIEFkZCB0YWlsaW5nIGBcXG5gIGlmIG5vdCBleGlzdHNcbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChpbnB1dC5sZW5ndGggLSAxKSAhPT0gMHgwQS8qIExGICovICYmXG4gICAgICAgIGlucHV0LmNoYXJDb2RlQXQoaW5wdXQubGVuZ3RoIC0gMSkgIT09IDB4MEQvKiBDUiAqLykge1xuICAgICAgaW5wdXQgKz0gJ1xcbic7XG4gICAgfVxuXG4gICAgLy8gU3RyaXAgQk9NXG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQoMCkgPT09IDB4RkVGRikge1xuICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZSgxKTtcbiAgICB9XG4gIH1cblxuICB2YXIgc3RhdGUgPSBuZXcgU3RhdGUoaW5wdXQsIG9wdGlvbnMpO1xuXG4gIHZhciBudWxscG9zID0gaW5wdXQuaW5kZXhPZignXFwwJyk7XG5cbiAgaWYgKG51bGxwb3MgIT09IC0xKSB7XG4gICAgc3RhdGUucG9zaXRpb24gPSBudWxscG9zO1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdudWxsIGJ5dGUgaXMgbm90IGFsbG93ZWQgaW4gaW5wdXQnKTtcbiAgfVxuXG4gIC8vIFVzZSAwIGFzIHN0cmluZyB0ZXJtaW5hdG9yLiBUaGF0IHNpZ25pZmljYW50bHkgc2ltcGxpZmllcyBib3VuZHMgY2hlY2suXG4gIHN0YXRlLmlucHV0ICs9ICdcXDAnO1xuXG4gIHdoaWxlIChzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSA9PT0gMHgyMC8qIFNwYWNlICovKSB7XG4gICAgc3RhdGUubGluZUluZGVudCArPSAxO1xuICAgIHN0YXRlLnBvc2l0aW9uICs9IDE7XG4gIH1cblxuICB3aGlsZSAoc3RhdGUucG9zaXRpb24gPCAoc3RhdGUubGVuZ3RoIC0gMSkpIHtcbiAgICByZWFkRG9jdW1lbnQoc3RhdGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlLmRvY3VtZW50cztcbn1cblxuXG5mdW5jdGlvbiBsb2FkQWxsKGlucHV0LCBpdGVyYXRvciwgb3B0aW9ucykge1xuICBpZiAoaXRlcmF0b3IgIT09IG51bGwgJiYgdHlwZW9mIGl0ZXJhdG9yID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvcHRpb25zID0gaXRlcmF0b3I7XG4gICAgaXRlcmF0b3IgPSBudWxsO1xuICB9XG5cbiAgdmFyIGRvY3VtZW50cyA9IGxvYWREb2N1bWVudHMoaW5wdXQsIG9wdGlvbnMpO1xuXG4gIGlmICh0eXBlb2YgaXRlcmF0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZG9jdW1lbnRzO1xuICB9XG5cbiAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBkb2N1bWVudHMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIGl0ZXJhdG9yKGRvY3VtZW50c1tpbmRleF0pO1xuICB9XG59XG5cblxuZnVuY3Rpb24gbG9hZChpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgZG9jdW1lbnRzID0gbG9hZERvY3VtZW50cyhpbnB1dCwgb3B0aW9ucyk7XG5cbiAgaWYgKGRvY3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAvKmVzbGludC1kaXNhYmxlIG5vLXVuZGVmaW5lZCovXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmIChkb2N1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50c1swXTtcbiAgfVxuICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignZXhwZWN0ZWQgYSBzaW5nbGUgZG9jdW1lbnQgaW4gdGhlIHN0cmVhbSwgYnV0IGZvdW5kIG1vcmUnKTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cy5sb2FkQWxsID0gbG9hZEFsbDtcbm1vZHVsZS5leHBvcnRzLmxvYWQgICAgPSBsb2FkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLXVzZS1iZWZvcmUtZGVmaW5lKi9cblxudmFyIGNvbW1vbiAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL2NvbW1vbicpO1xudmFyIFlBTUxFeGNlcHRpb24gICAgICAgPSByZXF1aXJlKCcuL2V4Y2VwdGlvbicpO1xudmFyIERFRkFVTFRfU0NIRU1BICAgICAgPSByZXF1aXJlKCcuL3NjaGVtYS9kZWZhdWx0Jyk7XG5cbnZhciBfdG9TdHJpbmcgICAgICAgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBDSEFSX0JPTSAgICAgICAgICAgICAgICAgID0gMHhGRUZGO1xudmFyIENIQVJfVEFCICAgICAgICAgICAgICAgICAgPSAweDA5OyAvKiBUYWIgKi9cbnZhciBDSEFSX0xJTkVfRkVFRCAgICAgICAgICAgID0gMHgwQTsgLyogTEYgKi9cbnZhciBDSEFSX0NBUlJJQUdFX1JFVFVSTiAgICAgID0gMHgwRDsgLyogQ1IgKi9cbnZhciBDSEFSX1NQQUNFICAgICAgICAgICAgICAgID0gMHgyMDsgLyogU3BhY2UgKi9cbnZhciBDSEFSX0VYQ0xBTUFUSU9OICAgICAgICAgID0gMHgyMTsgLyogISAqL1xudmFyIENIQVJfRE9VQkxFX1FVT1RFICAgICAgICAgPSAweDIyOyAvKiBcIiAqL1xudmFyIENIQVJfU0hBUlAgICAgICAgICAgICAgICAgPSAweDIzOyAvKiAjICovXG52YXIgQ0hBUl9QRVJDRU5UICAgICAgICAgICAgICA9IDB4MjU7IC8qICUgKi9cbnZhciBDSEFSX0FNUEVSU0FORCAgICAgICAgICAgID0gMHgyNjsgLyogJiAqL1xudmFyIENIQVJfU0lOR0xFX1FVT1RFICAgICAgICAgPSAweDI3OyAvKiAnICovXG52YXIgQ0hBUl9BU1RFUklTSyAgICAgICAgICAgICA9IDB4MkE7IC8qICogKi9cbnZhciBDSEFSX0NPTU1BICAgICAgICAgICAgICAgID0gMHgyQzsgLyogLCAqL1xudmFyIENIQVJfTUlOVVMgICAgICAgICAgICAgICAgPSAweDJEOyAvKiAtICovXG52YXIgQ0hBUl9DT0xPTiAgICAgICAgICAgICAgICA9IDB4M0E7IC8qIDogKi9cbnZhciBDSEFSX0VRVUFMUyAgICAgICAgICAgICAgID0gMHgzRDsgLyogPSAqL1xudmFyIENIQVJfR1JFQVRFUl9USEFOICAgICAgICAgPSAweDNFOyAvKiA+ICovXG52YXIgQ0hBUl9RVUVTVElPTiAgICAgICAgICAgICA9IDB4M0Y7IC8qID8gKi9cbnZhciBDSEFSX0NPTU1FUkNJQUxfQVQgICAgICAgID0gMHg0MDsgLyogQCAqL1xudmFyIENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVCAgPSAweDVCOyAvKiBbICovXG52YXIgQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVCA9IDB4NUQ7IC8qIF0gKi9cbnZhciBDSEFSX0dSQVZFX0FDQ0VOVCAgICAgICAgID0gMHg2MDsgLyogYCAqL1xudmFyIENIQVJfTEVGVF9DVVJMWV9CUkFDS0VUICAgPSAweDdCOyAvKiB7ICovXG52YXIgQ0hBUl9WRVJUSUNBTF9MSU5FICAgICAgICA9IDB4N0M7IC8qIHwgKi9cbnZhciBDSEFSX1JJR0hUX0NVUkxZX0JSQUNLRVQgID0gMHg3RDsgLyogfSAqL1xuXG52YXIgRVNDQVBFX1NFUVVFTkNFUyA9IHt9O1xuXG5FU0NBUEVfU0VRVUVOQ0VTWzB4MDBdICAgPSAnXFxcXDAnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDA3XSAgID0gJ1xcXFxhJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwOF0gICA9ICdcXFxcYic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MDldICAgPSAnXFxcXHQnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDBBXSAgID0gJ1xcXFxuJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwQl0gICA9ICdcXFxcdic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MENdICAgPSAnXFxcXGYnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDBEXSAgID0gJ1xcXFxyJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgxQl0gICA9ICdcXFxcZSc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MjJdICAgPSAnXFxcXFwiJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHg1Q10gICA9ICdcXFxcXFxcXCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4ODVdICAgPSAnXFxcXE4nO1xuRVNDQVBFX1NFUVVFTkNFU1sweEEwXSAgID0gJ1xcXFxfJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgyMDI4XSA9ICdcXFxcTCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MjAyOV0gPSAnXFxcXFAnO1xuXG52YXIgREVQUkVDQVRFRF9CT09MRUFOU19TWU5UQVggPSBbXG4gICd5JywgJ1knLCAneWVzJywgJ1llcycsICdZRVMnLCAnb24nLCAnT24nLCAnT04nLFxuICAnbicsICdOJywgJ25vJywgJ05vJywgJ05PJywgJ29mZicsICdPZmYnLCAnT0ZGJ1xuXTtcblxudmFyIERFUFJFQ0FURURfQkFTRTYwX1NZTlRBWCA9IC9eWy0rXT9bMC05X10rKD86OlswLTlfXSspKyg/OlxcLlswLTlfXSopPyQvO1xuXG5mdW5jdGlvbiBjb21waWxlU3R5bGVNYXAoc2NoZW1hLCBtYXApIHtcbiAgdmFyIHJlc3VsdCwga2V5cywgaW5kZXgsIGxlbmd0aCwgdGFnLCBzdHlsZSwgdHlwZTtcblxuICBpZiAobWFwID09PSBudWxsKSByZXR1cm4ge307XG5cbiAgcmVzdWx0ID0ge307XG4gIGtleXMgPSBPYmplY3Qua2V5cyhtYXApO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICB0YWcgPSBrZXlzW2luZGV4XTtcbiAgICBzdHlsZSA9IFN0cmluZyhtYXBbdGFnXSk7XG5cbiAgICBpZiAodGFnLnNsaWNlKDAsIDIpID09PSAnISEnKSB7XG4gICAgICB0YWcgPSAndGFnOnlhbWwub3JnLDIwMDI6JyArIHRhZy5zbGljZSgyKTtcbiAgICB9XG4gICAgdHlwZSA9IHNjaGVtYS5jb21waWxlZFR5cGVNYXBbJ2ZhbGxiYWNrJ11bdGFnXTtcblxuICAgIGlmICh0eXBlICYmIF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHR5cGUuc3R5bGVBbGlhc2VzLCBzdHlsZSkpIHtcbiAgICAgIHN0eWxlID0gdHlwZS5zdHlsZUFsaWFzZXNbc3R5bGVdO1xuICAgIH1cblxuICAgIHJlc3VsdFt0YWddID0gc3R5bGU7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBlbmNvZGVIZXgoY2hhcmFjdGVyKSB7XG4gIHZhciBzdHJpbmcsIGhhbmRsZSwgbGVuZ3RoO1xuXG4gIHN0cmluZyA9IGNoYXJhY3Rlci50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblxuICBpZiAoY2hhcmFjdGVyIDw9IDB4RkYpIHtcbiAgICBoYW5kbGUgPSAneCc7XG4gICAgbGVuZ3RoID0gMjtcbiAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPD0gMHhGRkZGKSB7XG4gICAgaGFuZGxlID0gJ3UnO1xuICAgIGxlbmd0aCA9IDQ7XG4gIH0gZWxzZSBpZiAoY2hhcmFjdGVyIDw9IDB4RkZGRkZGRkYpIHtcbiAgICBoYW5kbGUgPSAnVSc7XG4gICAgbGVuZ3RoID0gODtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignY29kZSBwb2ludCB3aXRoaW4gYSBzdHJpbmcgbWF5IG5vdCBiZSBncmVhdGVyIHRoYW4gMHhGRkZGRkZGRicpO1xuICB9XG5cbiAgcmV0dXJuICdcXFxcJyArIGhhbmRsZSArIGNvbW1vbi5yZXBlYXQoJzAnLCBsZW5ndGggLSBzdHJpbmcubGVuZ3RoKSArIHN0cmluZztcbn1cblxuXG52YXIgUVVPVElOR19UWVBFX1NJTkdMRSA9IDEsXG4gICAgUVVPVElOR19UWVBFX0RPVUJMRSA9IDI7XG5cbmZ1bmN0aW9uIFN0YXRlKG9wdGlvbnMpIHtcbiAgdGhpcy5zY2hlbWEgICAgICAgID0gb3B0aW9uc1snc2NoZW1hJ10gfHwgREVGQVVMVF9TQ0hFTUE7XG4gIHRoaXMuaW5kZW50ICAgICAgICA9IE1hdGgubWF4KDEsIChvcHRpb25zWydpbmRlbnQnXSB8fCAyKSk7XG4gIHRoaXMubm9BcnJheUluZGVudCA9IG9wdGlvbnNbJ25vQXJyYXlJbmRlbnQnXSB8fCBmYWxzZTtcbiAgdGhpcy5za2lwSW52YWxpZCAgID0gb3B0aW9uc1snc2tpcEludmFsaWQnXSB8fCBmYWxzZTtcbiAgdGhpcy5mbG93TGV2ZWwgICAgID0gKGNvbW1vbi5pc05vdGhpbmcob3B0aW9uc1snZmxvd0xldmVsJ10pID8gLTEgOiBvcHRpb25zWydmbG93TGV2ZWwnXSk7XG4gIHRoaXMuc3R5bGVNYXAgICAgICA9IGNvbXBpbGVTdHlsZU1hcCh0aGlzLnNjaGVtYSwgb3B0aW9uc1snc3R5bGVzJ10gfHwgbnVsbCk7XG4gIHRoaXMuc29ydEtleXMgICAgICA9IG9wdGlvbnNbJ3NvcnRLZXlzJ10gfHwgZmFsc2U7XG4gIHRoaXMubGluZVdpZHRoICAgICA9IG9wdGlvbnNbJ2xpbmVXaWR0aCddIHx8IDgwO1xuICB0aGlzLm5vUmVmcyAgICAgICAgPSBvcHRpb25zWydub1JlZnMnXSB8fCBmYWxzZTtcbiAgdGhpcy5ub0NvbXBhdE1vZGUgID0gb3B0aW9uc1snbm9Db21wYXRNb2RlJ10gfHwgZmFsc2U7XG4gIHRoaXMuY29uZGVuc2VGbG93ICA9IG9wdGlvbnNbJ2NvbmRlbnNlRmxvdyddIHx8IGZhbHNlO1xuICB0aGlzLnF1b3RpbmdUeXBlICAgPSBvcHRpb25zWydxdW90aW5nVHlwZSddID09PSAnXCInID8gUVVPVElOR19UWVBFX0RPVUJMRSA6IFFVT1RJTkdfVFlQRV9TSU5HTEU7XG4gIHRoaXMuZm9yY2VRdW90ZXMgICA9IG9wdGlvbnNbJ2ZvcmNlUXVvdGVzJ10gfHwgZmFsc2U7XG4gIHRoaXMucmVwbGFjZXIgICAgICA9IHR5cGVvZiBvcHRpb25zWydyZXBsYWNlciddID09PSAnZnVuY3Rpb24nID8gb3B0aW9uc1sncmVwbGFjZXInXSA6IG51bGw7XG5cbiAgdGhpcy5pbXBsaWNpdFR5cGVzID0gdGhpcy5zY2hlbWEuY29tcGlsZWRJbXBsaWNpdDtcbiAgdGhpcy5leHBsaWNpdFR5cGVzID0gdGhpcy5zY2hlbWEuY29tcGlsZWRFeHBsaWNpdDtcblxuICB0aGlzLnRhZyA9IG51bGw7XG4gIHRoaXMucmVzdWx0ID0gJyc7XG5cbiAgdGhpcy5kdXBsaWNhdGVzID0gW107XG4gIHRoaXMudXNlZER1cGxpY2F0ZXMgPSBudWxsO1xufVxuXG4vLyBJbmRlbnRzIGV2ZXJ5IGxpbmUgaW4gYSBzdHJpbmcuIEVtcHR5IGxpbmVzIChcXG4gb25seSkgYXJlIG5vdCBpbmRlbnRlZC5cbmZ1bmN0aW9uIGluZGVudFN0cmluZyhzdHJpbmcsIHNwYWNlcykge1xuICB2YXIgaW5kID0gY29tbW9uLnJlcGVhdCgnICcsIHNwYWNlcyksXG4gICAgICBwb3NpdGlvbiA9IDAsXG4gICAgICBuZXh0ID0gLTEsXG4gICAgICByZXN1bHQgPSAnJyxcbiAgICAgIGxpbmUsXG4gICAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXG4gIHdoaWxlIChwb3NpdGlvbiA8IGxlbmd0aCkge1xuICAgIG5leHQgPSBzdHJpbmcuaW5kZXhPZignXFxuJywgcG9zaXRpb24pO1xuICAgIGlmIChuZXh0ID09PSAtMSkge1xuICAgICAgbGluZSA9IHN0cmluZy5zbGljZShwb3NpdGlvbik7XG4gICAgICBwb3NpdGlvbiA9IGxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZSA9IHN0cmluZy5zbGljZShwb3NpdGlvbiwgbmV4dCArIDEpO1xuICAgICAgcG9zaXRpb24gPSBuZXh0ICsgMTtcbiAgICB9XG5cbiAgICBpZiAobGluZS5sZW5ndGggJiYgbGluZSAhPT0gJ1xcbicpIHJlc3VsdCArPSBpbmQ7XG5cbiAgICByZXN1bHQgKz0gbGluZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlTmV4dExpbmUoc3RhdGUsIGxldmVsKSB7XG4gIHJldHVybiAnXFxuJyArIGNvbW1vbi5yZXBlYXQoJyAnLCBzdGF0ZS5pbmRlbnQgKiBsZXZlbCk7XG59XG5cbmZ1bmN0aW9uIHRlc3RJbXBsaWNpdFJlc29sdmluZyhzdGF0ZSwgc3RyKSB7XG4gIHZhciBpbmRleCwgbGVuZ3RoLCB0eXBlO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBzdGF0ZS5pbXBsaWNpdFR5cGVzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICB0eXBlID0gc3RhdGUuaW1wbGljaXRUeXBlc1tpbmRleF07XG5cbiAgICBpZiAodHlwZS5yZXNvbHZlKHN0cikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gWzMzXSBzLXdoaXRlIDo6PSBzLXNwYWNlIHwgcy10YWJcbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZShjKSB7XG4gIHJldHVybiBjID09PSBDSEFSX1NQQUNFIHx8IGMgPT09IENIQVJfVEFCO1xufVxuXG4vLyBSZXR1cm5zIHRydWUgaWYgdGhlIGNoYXJhY3RlciBjYW4gYmUgcHJpbnRlZCB3aXRob3V0IGVzY2FwaW5nLlxuLy8gRnJvbSBZQU1MIDEuMjogXCJhbnkgYWxsb3dlZCBjaGFyYWN0ZXJzIGtub3duIHRvIGJlIG5vbi1wcmludGFibGVcbi8vIHNob3VsZCBhbHNvIGJlIGVzY2FwZWQuIFtIb3dldmVyLF0gVGhpcyBpc27igJl0IG1hbmRhdG9yeVwiXG4vLyBEZXJpdmVkIGZyb20gbmItY2hhciAtIFxcdCAtICN4ODUgLSAjeEEwIC0gI3gyMDI4IC0gI3gyMDI5LlxuZnVuY3Rpb24gaXNQcmludGFibGUoYykge1xuICByZXR1cm4gICgweDAwMDIwIDw9IGMgJiYgYyA8PSAweDAwMDA3RSlcbiAgICAgIHx8ICgoMHgwMDBBMSA8PSBjICYmIGMgPD0gMHgwMEQ3RkYpICYmIGMgIT09IDB4MjAyOCAmJiBjICE9PSAweDIwMjkpXG4gICAgICB8fCAoKDB4MEUwMDAgPD0gYyAmJiBjIDw9IDB4MDBGRkZEKSAmJiBjICE9PSBDSEFSX0JPTSlcbiAgICAgIHx8ICAoMHgxMDAwMCA8PSBjICYmIGMgPD0gMHgxMEZGRkYpO1xufVxuXG4vLyBbMzRdIG5zLWNoYXIgOjo9IG5iLWNoYXIgLSBzLXdoaXRlXG4vLyBbMjddIG5iLWNoYXIgOjo9IGMtcHJpbnRhYmxlIC0gYi1jaGFyIC0gYy1ieXRlLW9yZGVyLW1hcmtcbi8vIFsyNl0gYi1jaGFyICA6Oj0gYi1saW5lLWZlZWQgfCBiLWNhcnJpYWdlLXJldHVyblxuLy8gSW5jbHVkaW5nIHMtd2hpdGUgKGZvciBzb21lIHJlYXNvbiwgZXhhbXBsZXMgZG9lc24ndCBtYXRjaCBzcGVjcyBpbiB0aGlzIGFzcGVjdClcbi8vIG5zLWNoYXIgOjo9IGMtcHJpbnRhYmxlIC0gYi1saW5lLWZlZWQgLSBiLWNhcnJpYWdlLXJldHVybiAtIGMtYnl0ZS1vcmRlci1tYXJrXG5mdW5jdGlvbiBpc05zQ2hhck9yV2hpdGVzcGFjZShjKSB7XG4gIHJldHVybiBpc1ByaW50YWJsZShjKVxuICAgICYmIGMgIT09IENIQVJfQk9NXG4gICAgLy8gLSBiLWNoYXJcbiAgICAmJiBjICE9PSBDSEFSX0NBUlJJQUdFX1JFVFVSTlxuICAgICYmIGMgIT09IENIQVJfTElORV9GRUVEO1xufVxuXG4vLyBbMTI3XSAgbnMtcGxhaW4tc2FmZShjKSA6Oj0gYyA9IGZsb3ctb3V0ICDih5IgbnMtcGxhaW4tc2FmZS1vdXRcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gZmxvdy1pbiAgIOKHkiBucy1wbGFpbi1zYWZlLWluXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IGJsb2NrLWtleSDih5IgbnMtcGxhaW4tc2FmZS1vdXRcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gZmxvdy1rZXkgIOKHkiBucy1wbGFpbi1zYWZlLWluXG4vLyBbMTI4XSBucy1wbGFpbi1zYWZlLW91dCA6Oj0gbnMtY2hhclxuLy8gWzEyOV0gIG5zLXBsYWluLXNhZmUtaW4gOjo9IG5zLWNoYXIgLSBjLWZsb3ctaW5kaWNhdG9yXG4vLyBbMTMwXSAgbnMtcGxhaW4tY2hhcihjKSA6Oj0gICggbnMtcGxhaW4tc2FmZShjKSAtIOKAnDrigJ0gLSDigJwj4oCdIClcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgKCAvKiBBbiBucy1jaGFyIHByZWNlZGluZyAqLyDigJwj4oCdIClcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgKCDigJw64oCdIC8qIEZvbGxvd2VkIGJ5IGFuIG5zLXBsYWluLXNhZmUoYykgKi8gKVxuZnVuY3Rpb24gaXNQbGFpblNhZmUoYywgcHJldiwgaW5ibG9jaykge1xuICB2YXIgY0lzTnNDaGFyT3JXaGl0ZXNwYWNlID0gaXNOc0NoYXJPcldoaXRlc3BhY2UoYyk7XG4gIHZhciBjSXNOc0NoYXIgPSBjSXNOc0NoYXJPcldoaXRlc3BhY2UgJiYgIWlzV2hpdGVzcGFjZShjKTtcbiAgcmV0dXJuIChcbiAgICAvLyBucy1wbGFpbi1zYWZlXG4gICAgaW5ibG9jayA/IC8vIGMgPSBmbG93LWluXG4gICAgICBjSXNOc0NoYXJPcldoaXRlc3BhY2VcbiAgICAgIDogY0lzTnNDaGFyT3JXaGl0ZXNwYWNlXG4gICAgICAgIC8vIC0gYy1mbG93LWluZGljYXRvclxuICAgICAgICAmJiBjICE9PSBDSEFSX0NPTU1BXG4gICAgICAgICYmIGMgIT09IENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVFxuICAgICAgICAmJiBjICE9PSBDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUXG4gICAgICAgICYmIGMgIT09IENIQVJfTEVGVF9DVVJMWV9CUkFDS0VUXG4gICAgICAgICYmIGMgIT09IENIQVJfUklHSFRfQ1VSTFlfQlJBQ0tFVFxuICApXG4gICAgLy8gbnMtcGxhaW4tY2hhclxuICAgICYmIGMgIT09IENIQVJfU0hBUlAgLy8gZmFsc2Ugb24gJyMnXG4gICAgJiYgIShwcmV2ID09PSBDSEFSX0NPTE9OICYmICFjSXNOc0NoYXIpIC8vIGZhbHNlIG9uICc6ICdcbiAgICB8fCAoaXNOc0NoYXJPcldoaXRlc3BhY2UocHJldikgJiYgIWlzV2hpdGVzcGFjZShwcmV2KSAmJiBjID09PSBDSEFSX1NIQVJQKSAvLyBjaGFuZ2UgdG8gdHJ1ZSBvbiAnW14gXSMnXG4gICAgfHwgKHByZXYgPT09IENIQVJfQ09MT04gJiYgY0lzTnNDaGFyKTsgLy8gY2hhbmdlIHRvIHRydWUgb24gJzpbXiBdJ1xufVxuXG4vLyBTaW1wbGlmaWVkIHRlc3QgZm9yIHZhbHVlcyBhbGxvd2VkIGFzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gcGxhaW4gc3R5bGUuXG5mdW5jdGlvbiBpc1BsYWluU2FmZUZpcnN0KGMpIHtcbiAgLy8gVXNlcyBhIHN1YnNldCBvZiBucy1jaGFyIC0gYy1pbmRpY2F0b3JcbiAgLy8gd2hlcmUgbnMtY2hhciA9IG5iLWNoYXIgLSBzLXdoaXRlLlxuICAvLyBObyBzdXBwb3J0IG9mICggKCDigJw/4oCdIHwg4oCcOuKAnSB8IOKAnC3igJ0gKSAvKiBGb2xsb3dlZCBieSBhbiBucy1wbGFpbi1zYWZlKGMpKSAqLyApIHBhcnRcbiAgcmV0dXJuIGlzUHJpbnRhYmxlKGMpICYmIGMgIT09IENIQVJfQk9NXG4gICAgJiYgIWlzV2hpdGVzcGFjZShjKSAvLyAtIHMtd2hpdGVcbiAgICAvLyAtIChjLWluZGljYXRvciA6Oj1cbiAgICAvLyDigJwt4oCdIHwg4oCcP+KAnSB8IOKAnDrigJ0gfCDigJws4oCdIHwg4oCcW+KAnSB8IOKAnF3igJ0gfCDigJx74oCdIHwg4oCcfeKAnVxuICAgICYmIGMgIT09IENIQVJfTUlOVVNcbiAgICAmJiBjICE9PSBDSEFSX1FVRVNUSU9OXG4gICAgJiYgYyAhPT0gQ0hBUl9DT0xPTlxuICAgICYmIGMgIT09IENIQVJfQ09NTUFcbiAgICAmJiBjICE9PSBDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVRcbiAgICAmJiBjICE9PSBDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUXG4gICAgJiYgYyAhPT0gQ0hBUl9MRUZUX0NVUkxZX0JSQUNLRVRcbiAgICAmJiBjICE9PSBDSEFSX1JJR0hUX0NVUkxZX0JSQUNLRVRcbiAgICAvLyB8IOKAnCPigJ0gfCDigJwm4oCdIHwg4oCcKuKAnSB8IOKAnCHigJ0gfCDigJx84oCdIHwg4oCcPeKAnSB8IOKAnD7igJ0gfCDigJwn4oCdIHwg4oCcXCLigJ1cbiAgICAmJiBjICE9PSBDSEFSX1NIQVJQXG4gICAgJiYgYyAhPT0gQ0hBUl9BTVBFUlNBTkRcbiAgICAmJiBjICE9PSBDSEFSX0FTVEVSSVNLXG4gICAgJiYgYyAhPT0gQ0hBUl9FWENMQU1BVElPTlxuICAgICYmIGMgIT09IENIQVJfVkVSVElDQUxfTElORVxuICAgICYmIGMgIT09IENIQVJfRVFVQUxTXG4gICAgJiYgYyAhPT0gQ0hBUl9HUkVBVEVSX1RIQU5cbiAgICAmJiBjICE9PSBDSEFSX1NJTkdMRV9RVU9URVxuICAgICYmIGMgIT09IENIQVJfRE9VQkxFX1FVT1RFXG4gICAgLy8gfCDigJwl4oCdIHwg4oCcQOKAnSB8IOKAnGDigJ0pXG4gICAgJiYgYyAhPT0gQ0hBUl9QRVJDRU5UXG4gICAgJiYgYyAhPT0gQ0hBUl9DT01NRVJDSUFMX0FUXG4gICAgJiYgYyAhPT0gQ0hBUl9HUkFWRV9BQ0NFTlQ7XG59XG5cbi8vIFNpbXBsaWZpZWQgdGVzdCBmb3IgdmFsdWVzIGFsbG93ZWQgYXMgdGhlIGxhc3QgY2hhcmFjdGVyIGluIHBsYWluIHN0eWxlLlxuZnVuY3Rpb24gaXNQbGFpblNhZmVMYXN0KGMpIHtcbiAgLy8ganVzdCBub3Qgd2hpdGVzcGFjZSBvciBjb2xvbiwgaXQgd2lsbCBiZSBjaGVja2VkIHRvIGJlIHBsYWluIGNoYXJhY3RlciBsYXRlclxuICByZXR1cm4gIWlzV2hpdGVzcGFjZShjKSAmJiBjICE9PSBDSEFSX0NPTE9OO1xufVxuXG4vLyBTYW1lIGFzICdzdHJpbmcnLmNvZGVQb2ludEF0KHBvcyksIGJ1dCB3b3JrcyBpbiBvbGRlciBicm93c2Vycy5cbmZ1bmN0aW9uIGNvZGVQb2ludEF0KHN0cmluZywgcG9zKSB7XG4gIHZhciBmaXJzdCA9IHN0cmluZy5jaGFyQ29kZUF0KHBvcyksIHNlY29uZDtcbiAgaWYgKGZpcnN0ID49IDB4RDgwMCAmJiBmaXJzdCA8PSAweERCRkYgJiYgcG9zICsgMSA8IHN0cmluZy5sZW5ndGgpIHtcbiAgICBzZWNvbmQgPSBzdHJpbmcuY2hhckNvZGVBdChwb3MgKyAxKTtcbiAgICBpZiAoc2Vjb25kID49IDB4REMwMCAmJiBzZWNvbmQgPD0gMHhERkZGKSB7XG4gICAgICAvLyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZyNzdXJyb2dhdGUtZm9ybXVsYWVcbiAgICAgIHJldHVybiAoZmlyc3QgLSAweEQ4MDApICogMHg0MDAgKyBzZWNvbmQgLSAweERDMDAgKyAweDEwMDAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmlyc3Q7XG59XG5cbi8vIERldGVybWluZXMgd2hldGhlciBibG9jayBpbmRlbnRhdGlvbiBpbmRpY2F0b3IgaXMgcmVxdWlyZWQuXG5mdW5jdGlvbiBuZWVkSW5kZW50SW5kaWNhdG9yKHN0cmluZykge1xuICB2YXIgbGVhZGluZ1NwYWNlUmUgPSAvXlxcbiogLztcbiAgcmV0dXJuIGxlYWRpbmdTcGFjZVJlLnRlc3Qoc3RyaW5nKTtcbn1cblxudmFyIFNUWUxFX1BMQUlOICAgPSAxLFxuICAgIFNUWUxFX1NJTkdMRSAgPSAyLFxuICAgIFNUWUxFX0xJVEVSQUwgPSAzLFxuICAgIFNUWUxFX0ZPTERFRCAgPSA0LFxuICAgIFNUWUxFX0RPVUJMRSAgPSA1O1xuXG4vLyBEZXRlcm1pbmVzIHdoaWNoIHNjYWxhciBzdHlsZXMgYXJlIHBvc3NpYmxlIGFuZCByZXR1cm5zIHRoZSBwcmVmZXJyZWQgc3R5bGUuXG4vLyBsaW5lV2lkdGggPSAtMSA9PiBubyBsaW1pdC5cbi8vIFByZS1jb25kaXRpb25zOiBzdHIubGVuZ3RoID4gMC5cbi8vIFBvc3QtY29uZGl0aW9uczpcbi8vICAgIFNUWUxFX1BMQUlOIG9yIFNUWUxFX1NJTkdMRSA9PiBubyBcXG4gYXJlIGluIHRoZSBzdHJpbmcuXG4vLyAgICBTVFlMRV9MSVRFUkFMID0+IG5vIGxpbmVzIGFyZSBzdWl0YWJsZSBmb3IgZm9sZGluZyAob3IgbGluZVdpZHRoIGlzIC0xKS5cbi8vICAgIFNUWUxFX0ZPTERFRCA9PiBhIGxpbmUgPiBsaW5lV2lkdGggYW5kIGNhbiBiZSBmb2xkZWQgKGFuZCBsaW5lV2lkdGggIT0gLTEpLlxuZnVuY3Rpb24gY2hvb3NlU2NhbGFyU3R5bGUoc3RyaW5nLCBzaW5nbGVMaW5lT25seSwgaW5kZW50UGVyTGV2ZWwsIGxpbmVXaWR0aCxcbiAgdGVzdEFtYmlndW91c1R5cGUsIHF1b3RpbmdUeXBlLCBmb3JjZVF1b3RlcywgaW5ibG9jaykge1xuXG4gIHZhciBpO1xuICB2YXIgY2hhciA9IDA7XG4gIHZhciBwcmV2Q2hhciA9IG51bGw7XG4gIHZhciBoYXNMaW5lQnJlYWsgPSBmYWxzZTtcbiAgdmFyIGhhc0ZvbGRhYmxlTGluZSA9IGZhbHNlOyAvLyBvbmx5IGNoZWNrZWQgaWYgc2hvdWxkVHJhY2tXaWR0aFxuICB2YXIgc2hvdWxkVHJhY2tXaWR0aCA9IGxpbmVXaWR0aCAhPT0gLTE7XG4gIHZhciBwcmV2aW91c0xpbmVCcmVhayA9IC0xOyAvLyBjb3VudCB0aGUgZmlyc3QgbGluZSBjb3JyZWN0bHlcbiAgdmFyIHBsYWluID0gaXNQbGFpblNhZmVGaXJzdChjb2RlUG9pbnRBdChzdHJpbmcsIDApKVxuICAgICAgICAgICYmIGlzUGxhaW5TYWZlTGFzdChjb2RlUG9pbnRBdChzdHJpbmcsIHN0cmluZy5sZW5ndGggLSAxKSk7XG5cbiAgaWYgKHNpbmdsZUxpbmVPbmx5IHx8IGZvcmNlUXVvdGVzKSB7XG4gICAgLy8gQ2FzZTogbm8gYmxvY2sgc3R5bGVzLlxuICAgIC8vIENoZWNrIGZvciBkaXNhbGxvd2VkIGNoYXJhY3RlcnMgdG8gcnVsZSBvdXQgcGxhaW4gYW5kIHNpbmdsZS5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgY2hhciA+PSAweDEwMDAwID8gaSArPSAyIDogaSsrKSB7XG4gICAgICBjaGFyID0gY29kZVBvaW50QXQoc3RyaW5nLCBpKTtcbiAgICAgIGlmICghaXNQcmludGFibGUoY2hhcikpIHtcbiAgICAgICAgcmV0dXJuIFNUWUxFX0RPVUJMRTtcbiAgICAgIH1cbiAgICAgIHBsYWluID0gcGxhaW4gJiYgaXNQbGFpblNhZmUoY2hhciwgcHJldkNoYXIsIGluYmxvY2spO1xuICAgICAgcHJldkNoYXIgPSBjaGFyO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBDYXNlOiBibG9jayBzdHlsZXMgcGVybWl0dGVkLlxuICAgIGZvciAoaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBjaGFyID49IDB4MTAwMDAgPyBpICs9IDIgOiBpKyspIHtcbiAgICAgIGNoYXIgPSBjb2RlUG9pbnRBdChzdHJpbmcsIGkpO1xuICAgICAgaWYgKGNoYXIgPT09IENIQVJfTElORV9GRUVEKSB7XG4gICAgICAgIGhhc0xpbmVCcmVhayA9IHRydWU7XG4gICAgICAgIC8vIENoZWNrIGlmIGFueSBsaW5lIGNhbiBiZSBmb2xkZWQuXG4gICAgICAgIGlmIChzaG91bGRUcmFja1dpZHRoKSB7XG4gICAgICAgICAgaGFzRm9sZGFibGVMaW5lID0gaGFzRm9sZGFibGVMaW5lIHx8XG4gICAgICAgICAgICAvLyBGb2xkYWJsZSBsaW5lID0gdG9vIGxvbmcsIGFuZCBub3QgbW9yZS1pbmRlbnRlZC5cbiAgICAgICAgICAgIChpIC0gcHJldmlvdXNMaW5lQnJlYWsgLSAxID4gbGluZVdpZHRoICYmXG4gICAgICAgICAgICAgc3RyaW5nW3ByZXZpb3VzTGluZUJyZWFrICsgMV0gIT09ICcgJyk7XG4gICAgICAgICAgcHJldmlvdXNMaW5lQnJlYWsgPSBpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFpc1ByaW50YWJsZShjaGFyKSkge1xuICAgICAgICByZXR1cm4gU1RZTEVfRE9VQkxFO1xuICAgICAgfVxuICAgICAgcGxhaW4gPSBwbGFpbiAmJiBpc1BsYWluU2FmZShjaGFyLCBwcmV2Q2hhciwgaW5ibG9jayk7XG4gICAgICBwcmV2Q2hhciA9IGNoYXI7XG4gICAgfVxuICAgIC8vIGluIGNhc2UgdGhlIGVuZCBpcyBtaXNzaW5nIGEgXFxuXG4gICAgaGFzRm9sZGFibGVMaW5lID0gaGFzRm9sZGFibGVMaW5lIHx8IChzaG91bGRUcmFja1dpZHRoICYmXG4gICAgICAoaSAtIHByZXZpb3VzTGluZUJyZWFrIC0gMSA+IGxpbmVXaWR0aCAmJlxuICAgICAgIHN0cmluZ1twcmV2aW91c0xpbmVCcmVhayArIDFdICE9PSAnICcpKTtcbiAgfVxuICAvLyBBbHRob3VnaCBldmVyeSBzdHlsZSBjYW4gcmVwcmVzZW50IFxcbiB3aXRob3V0IGVzY2FwaW5nLCBwcmVmZXIgYmxvY2sgc3R5bGVzXG4gIC8vIGZvciBtdWx0aWxpbmUsIHNpbmNlIHRoZXkncmUgbW9yZSByZWFkYWJsZSBhbmQgdGhleSBkb24ndCBhZGQgZW1wdHkgbGluZXMuXG4gIC8vIEFsc28gcHJlZmVyIGZvbGRpbmcgYSBzdXBlci1sb25nIGxpbmUuXG4gIGlmICghaGFzTGluZUJyZWFrICYmICFoYXNGb2xkYWJsZUxpbmUpIHtcbiAgICAvLyBTdHJpbmdzIGludGVycHJldGFibGUgYXMgYW5vdGhlciB0eXBlIGhhdmUgdG8gYmUgcXVvdGVkO1xuICAgIC8vIGUuZy4gdGhlIHN0cmluZyAndHJ1ZScgdnMuIHRoZSBib29sZWFuIHRydWUuXG4gICAgaWYgKHBsYWluICYmICFmb3JjZVF1b3RlcyAmJiAhdGVzdEFtYmlndW91c1R5cGUoc3RyaW5nKSkge1xuICAgICAgcmV0dXJuIFNUWUxFX1BMQUlOO1xuICAgIH1cbiAgICByZXR1cm4gcXVvdGluZ1R5cGUgPT09IFFVT1RJTkdfVFlQRV9ET1VCTEUgPyBTVFlMRV9ET1VCTEUgOiBTVFlMRV9TSU5HTEU7XG4gIH1cbiAgLy8gRWRnZSBjYXNlOiBibG9jayBpbmRlbnRhdGlvbiBpbmRpY2F0b3IgY2FuIG9ubHkgaGF2ZSBvbmUgZGlnaXQuXG4gIGlmIChpbmRlbnRQZXJMZXZlbCA+IDkgJiYgbmVlZEluZGVudEluZGljYXRvcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIFNUWUxFX0RPVUJMRTtcbiAgfVxuICAvLyBBdCB0aGlzIHBvaW50IHdlIGtub3cgYmxvY2sgc3R5bGVzIGFyZSB2YWxpZC5cbiAgLy8gUHJlZmVyIGxpdGVyYWwgc3R5bGUgdW5sZXNzIHdlIHdhbnQgdG8gZm9sZC5cbiAgaWYgKCFmb3JjZVF1b3Rlcykge1xuICAgIHJldHVybiBoYXNGb2xkYWJsZUxpbmUgPyBTVFlMRV9GT0xERUQgOiBTVFlMRV9MSVRFUkFMO1xuICB9XG4gIHJldHVybiBxdW90aW5nVHlwZSA9PT0gUVVPVElOR19UWVBFX0RPVUJMRSA/IFNUWUxFX0RPVUJMRSA6IFNUWUxFX1NJTkdMRTtcbn1cblxuLy8gTm90ZTogbGluZSBicmVha2luZy9mb2xkaW5nIGlzIGltcGxlbWVudGVkIGZvciBvbmx5IHRoZSBmb2xkZWQgc3R5bGUuXG4vLyBOQi4gV2UgZHJvcCB0aGUgbGFzdCB0cmFpbGluZyBuZXdsaW5lIChpZiBhbnkpIG9mIGEgcmV0dXJuZWQgYmxvY2sgc2NhbGFyXG4vLyAgc2luY2UgdGhlIGR1bXBlciBhZGRzIGl0cyBvd24gbmV3bGluZS4gVGhpcyBhbHdheXMgd29ya3M6XG4vLyAgICDigKIgTm8gZW5kaW5nIG5ld2xpbmUgPT4gdW5hZmZlY3RlZDsgYWxyZWFkeSB1c2luZyBzdHJpcCBcIi1cIiBjaG9tcGluZy5cbi8vICAgIOKAoiBFbmRpbmcgbmV3bGluZSAgICA9PiByZW1vdmVkIHRoZW4gcmVzdG9yZWQuXG4vLyAgSW1wb3J0YW50bHksIHRoaXMga2VlcHMgdGhlIFwiK1wiIGNob21wIGluZGljYXRvciBmcm9tIGdhaW5pbmcgYW4gZXh0cmEgbGluZS5cbmZ1bmN0aW9uIHdyaXRlU2NhbGFyKHN0YXRlLCBzdHJpbmcsIGxldmVsLCBpc2tleSwgaW5ibG9jaykge1xuICBzdGF0ZS5kdW1wID0gKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc3RyaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHN0YXRlLnF1b3RpbmdUeXBlID09PSBRVU9USU5HX1RZUEVfRE9VQkxFID8gJ1wiXCInIDogXCInJ1wiO1xuICAgIH1cbiAgICBpZiAoIXN0YXRlLm5vQ29tcGF0TW9kZSkge1xuICAgICAgaWYgKERFUFJFQ0FURURfQk9PTEVBTlNfU1lOVEFYLmluZGV4T2Yoc3RyaW5nKSAhPT0gLTEgfHwgREVQUkVDQVRFRF9CQVNFNjBfU1lOVEFYLnRlc3Qoc3RyaW5nKSkge1xuICAgICAgICByZXR1cm4gc3RhdGUucXVvdGluZ1R5cGUgPT09IFFVT1RJTkdfVFlQRV9ET1VCTEUgPyAoJ1wiJyArIHN0cmluZyArICdcIicpIDogKFwiJ1wiICsgc3RyaW5nICsgXCInXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpbmRlbnQgPSBzdGF0ZS5pbmRlbnQgKiBNYXRoLm1heCgxLCBsZXZlbCk7IC8vIG5vIDAtaW5kZW50IHNjYWxhcnNcbiAgICAvLyBBcyBpbmRlbnRhdGlvbiBnZXRzIGRlZXBlciwgbGV0IHRoZSB3aWR0aCBkZWNyZWFzZSBtb25vdG9uaWNhbGx5XG4gICAgLy8gdG8gdGhlIGxvd2VyIGJvdW5kIG1pbihzdGF0ZS5saW5lV2lkdGgsIDQwKS5cbiAgICAvLyBOb3RlIHRoYXQgdGhpcyBpbXBsaWVzXG4gICAgLy8gIHN0YXRlLmxpbmVXaWR0aCDiiaQgNDAgKyBzdGF0ZS5pbmRlbnQ6IHdpZHRoIGlzIGZpeGVkIGF0IHRoZSBsb3dlciBib3VuZC5cbiAgICAvLyAgc3RhdGUubGluZVdpZHRoID4gNDAgKyBzdGF0ZS5pbmRlbnQ6IHdpZHRoIGRlY3JlYXNlcyB1bnRpbCB0aGUgbG93ZXIgYm91bmQuXG4gICAgLy8gVGhpcyBiZWhhdmVzIGJldHRlciB0aGFuIGEgY29uc3RhbnQgbWluaW11bSB3aWR0aCB3aGljaCBkaXNhbGxvd3MgbmFycm93ZXIgb3B0aW9ucyxcbiAgICAvLyBvciBhbiBpbmRlbnQgdGhyZXNob2xkIHdoaWNoIGNhdXNlcyB0aGUgd2lkdGggdG8gc3VkZGVubHkgaW5jcmVhc2UuXG4gICAgdmFyIGxpbmVXaWR0aCA9IHN0YXRlLmxpbmVXaWR0aCA9PT0gLTFcbiAgICAgID8gLTEgOiBNYXRoLm1heChNYXRoLm1pbihzdGF0ZS5saW5lV2lkdGgsIDQwKSwgc3RhdGUubGluZVdpZHRoIC0gaW5kZW50KTtcblxuICAgIC8vIFdpdGhvdXQga25vd2luZyBpZiBrZXlzIGFyZSBpbXBsaWNpdC9leHBsaWNpdCwgYXNzdW1lIGltcGxpY2l0IGZvciBzYWZldHkuXG4gICAgdmFyIHNpbmdsZUxpbmVPbmx5ID0gaXNrZXlcbiAgICAgIC8vIE5vIGJsb2NrIHN0eWxlcyBpbiBmbG93IG1vZGUuXG4gICAgICB8fCAoc3RhdGUuZmxvd0xldmVsID4gLTEgJiYgbGV2ZWwgPj0gc3RhdGUuZmxvd0xldmVsKTtcbiAgICBmdW5jdGlvbiB0ZXN0QW1iaWd1aXR5KHN0cmluZykge1xuICAgICAgcmV0dXJuIHRlc3RJbXBsaWNpdFJlc29sdmluZyhzdGF0ZSwgc3RyaW5nKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGNob29zZVNjYWxhclN0eWxlKHN0cmluZywgc2luZ2xlTGluZU9ubHksIHN0YXRlLmluZGVudCwgbGluZVdpZHRoLFxuICAgICAgdGVzdEFtYmlndWl0eSwgc3RhdGUucXVvdGluZ1R5cGUsIHN0YXRlLmZvcmNlUXVvdGVzICYmICFpc2tleSwgaW5ibG9jaykpIHtcblxuICAgICAgY2FzZSBTVFlMRV9QTEFJTjpcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIGNhc2UgU1RZTEVfU0lOR0xFOlxuICAgICAgICByZXR1cm4gXCInXCIgKyBzdHJpbmcucmVwbGFjZSgvJy9nLCBcIicnXCIpICsgXCInXCI7XG4gICAgICBjYXNlIFNUWUxFX0xJVEVSQUw6XG4gICAgICAgIHJldHVybiAnfCcgKyBibG9ja0hlYWRlcihzdHJpbmcsIHN0YXRlLmluZGVudClcbiAgICAgICAgICArIGRyb3BFbmRpbmdOZXdsaW5lKGluZGVudFN0cmluZyhzdHJpbmcsIGluZGVudCkpO1xuICAgICAgY2FzZSBTVFlMRV9GT0xERUQ6XG4gICAgICAgIHJldHVybiAnPicgKyBibG9ja0hlYWRlcihzdHJpbmcsIHN0YXRlLmluZGVudClcbiAgICAgICAgICArIGRyb3BFbmRpbmdOZXdsaW5lKGluZGVudFN0cmluZyhmb2xkU3RyaW5nKHN0cmluZywgbGluZVdpZHRoKSwgaW5kZW50KSk7XG4gICAgICBjYXNlIFNUWUxFX0RPVUJMRTpcbiAgICAgICAgcmV0dXJuICdcIicgKyBlc2NhcGVTdHJpbmcoc3RyaW5nLCBsaW5lV2lkdGgpICsgJ1wiJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdpbXBvc3NpYmxlIGVycm9yOiBpbnZhbGlkIHNjYWxhciBzdHlsZScpO1xuICAgIH1cbiAgfSgpKTtcbn1cblxuLy8gUHJlLWNvbmRpdGlvbnM6IHN0cmluZyBpcyB2YWxpZCBmb3IgYSBibG9jayBzY2FsYXIsIDEgPD0gaW5kZW50UGVyTGV2ZWwgPD0gOS5cbmZ1bmN0aW9uIGJsb2NrSGVhZGVyKHN0cmluZywgaW5kZW50UGVyTGV2ZWwpIHtcbiAgdmFyIGluZGVudEluZGljYXRvciA9IG5lZWRJbmRlbnRJbmRpY2F0b3Ioc3RyaW5nKSA/IFN0cmluZyhpbmRlbnRQZXJMZXZlbCkgOiAnJztcblxuICAvLyBub3RlIHRoZSBzcGVjaWFsIGNhc2U6IHRoZSBzdHJpbmcgJ1xcbicgY291bnRzIGFzIGEgXCJ0cmFpbGluZ1wiIGVtcHR5IGxpbmUuXG4gIHZhciBjbGlwID0gICAgICAgICAgc3RyaW5nW3N0cmluZy5sZW5ndGggLSAxXSA9PT0gJ1xcbic7XG4gIHZhciBrZWVwID0gY2xpcCAmJiAoc3RyaW5nW3N0cmluZy5sZW5ndGggLSAyXSA9PT0gJ1xcbicgfHwgc3RyaW5nID09PSAnXFxuJyk7XG4gIHZhciBjaG9tcCA9IGtlZXAgPyAnKycgOiAoY2xpcCA/ICcnIDogJy0nKTtcblxuICByZXR1cm4gaW5kZW50SW5kaWNhdG9yICsgY2hvbXAgKyAnXFxuJztcbn1cblxuLy8gKFNlZSB0aGUgbm90ZSBmb3Igd3JpdGVTY2FsYXIuKVxuZnVuY3Rpb24gZHJvcEVuZGluZ05ld2xpbmUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmdbc3RyaW5nLmxlbmd0aCAtIDFdID09PSAnXFxuJyA/IHN0cmluZy5zbGljZSgwLCAtMSkgOiBzdHJpbmc7XG59XG5cbi8vIE5vdGU6IGEgbG9uZyBsaW5lIHdpdGhvdXQgYSBzdWl0YWJsZSBicmVhayBwb2ludCB3aWxsIGV4Y2VlZCB0aGUgd2lkdGggbGltaXQuXG4vLyBQcmUtY29uZGl0aW9uczogZXZlcnkgY2hhciBpbiBzdHIgaXNQcmludGFibGUsIHN0ci5sZW5ndGggPiAwLCB3aWR0aCA+IDAuXG5mdW5jdGlvbiBmb2xkU3RyaW5nKHN0cmluZywgd2lkdGgpIHtcbiAgLy8gSW4gZm9sZGVkIHN0eWxlLCAkayQgY29uc2VjdXRpdmUgbmV3bGluZXMgb3V0cHV0IGFzICRrKzEkIG5ld2xpbmVz4oCUXG4gIC8vIHVubGVzcyB0aGV5J3JlIGJlZm9yZSBvciBhZnRlciBhIG1vcmUtaW5kZW50ZWQgbGluZSwgb3IgYXQgdGhlIHZlcnlcbiAgLy8gYmVnaW5uaW5nIG9yIGVuZCwgaW4gd2hpY2ggY2FzZSAkayQgbWFwcyB0byAkayQuXG4gIC8vIFRoZXJlZm9yZSwgcGFyc2UgZWFjaCBjaHVuayBhcyBuZXdsaW5lKHMpIGZvbGxvd2VkIGJ5IGEgY29udGVudCBsaW5lLlxuICB2YXIgbGluZVJlID0gLyhcXG4rKShbXlxcbl0qKS9nO1xuXG4gIC8vIGZpcnN0IGxpbmUgKHBvc3NpYmx5IGFuIGVtcHR5IGxpbmUpXG4gIHZhciByZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBuZXh0TEYgPSBzdHJpbmcuaW5kZXhPZignXFxuJyk7XG4gICAgbmV4dExGID0gbmV4dExGICE9PSAtMSA/IG5leHRMRiA6IHN0cmluZy5sZW5ndGg7XG4gICAgbGluZVJlLmxhc3RJbmRleCA9IG5leHRMRjtcbiAgICByZXR1cm4gZm9sZExpbmUoc3RyaW5nLnNsaWNlKDAsIG5leHRMRiksIHdpZHRoKTtcbiAgfSgpKTtcbiAgLy8gSWYgd2UgaGF2ZW4ndCByZWFjaGVkIHRoZSBmaXJzdCBjb250ZW50IGxpbmUgeWV0LCBkb24ndCBhZGQgYW4gZXh0cmEgXFxuLlxuICB2YXIgcHJldk1vcmVJbmRlbnRlZCA9IHN0cmluZ1swXSA9PT0gJ1xcbicgfHwgc3RyaW5nWzBdID09PSAnICc7XG4gIHZhciBtb3JlSW5kZW50ZWQ7XG5cbiAgLy8gcmVzdCBvZiB0aGUgbGluZXNcbiAgdmFyIG1hdGNoO1xuICB3aGlsZSAoKG1hdGNoID0gbGluZVJlLmV4ZWMoc3RyaW5nKSkpIHtcbiAgICB2YXIgcHJlZml4ID0gbWF0Y2hbMV0sIGxpbmUgPSBtYXRjaFsyXTtcbiAgICBtb3JlSW5kZW50ZWQgPSAobGluZVswXSA9PT0gJyAnKTtcbiAgICByZXN1bHQgKz0gcHJlZml4XG4gICAgICArICghcHJldk1vcmVJbmRlbnRlZCAmJiAhbW9yZUluZGVudGVkICYmIGxpbmUgIT09ICcnXG4gICAgICAgID8gJ1xcbicgOiAnJylcbiAgICAgICsgZm9sZExpbmUobGluZSwgd2lkdGgpO1xuICAgIHByZXZNb3JlSW5kZW50ZWQgPSBtb3JlSW5kZW50ZWQ7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBHcmVlZHkgbGluZSBicmVha2luZy5cbi8vIFBpY2tzIHRoZSBsb25nZXN0IGxpbmUgdW5kZXIgdGhlIGxpbWl0IGVhY2ggdGltZSxcbi8vIG90aGVyd2lzZSBzZXR0bGVzIGZvciB0aGUgc2hvcnRlc3QgbGluZSBvdmVyIHRoZSBsaW1pdC5cbi8vIE5CLiBNb3JlLWluZGVudGVkIGxpbmVzICpjYW5ub3QqIGJlIGZvbGRlZCwgYXMgdGhhdCB3b3VsZCBhZGQgYW4gZXh0cmEgXFxuLlxuZnVuY3Rpb24gZm9sZExpbmUobGluZSwgd2lkdGgpIHtcbiAgaWYgKGxpbmUgPT09ICcnIHx8IGxpbmVbMF0gPT09ICcgJykgcmV0dXJuIGxpbmU7XG5cbiAgLy8gU2luY2UgYSBtb3JlLWluZGVudGVkIGxpbmUgYWRkcyBhIFxcbiwgYnJlYWtzIGNhbid0IGJlIGZvbGxvd2VkIGJ5IGEgc3BhY2UuXG4gIHZhciBicmVha1JlID0gLyBbXiBdL2c7IC8vIG5vdGU6IHRoZSBtYXRjaCBpbmRleCB3aWxsIGFsd2F5cyBiZSA8PSBsZW5ndGgtMi5cbiAgdmFyIG1hdGNoO1xuICAvLyBzdGFydCBpcyBhbiBpbmNsdXNpdmUgaW5kZXguIGVuZCwgY3VyciwgYW5kIG5leHQgYXJlIGV4Y2x1c2l2ZS5cbiAgdmFyIHN0YXJ0ID0gMCwgZW5kLCBjdXJyID0gMCwgbmV4dCA9IDA7XG4gIHZhciByZXN1bHQgPSAnJztcblxuICAvLyBJbnZhcmlhbnRzOiAwIDw9IHN0YXJ0IDw9IGxlbmd0aC0xLlxuICAvLyAgIDAgPD0gY3VyciA8PSBuZXh0IDw9IG1heCgwLCBsZW5ndGgtMikuIGN1cnIgLSBzdGFydCA8PSB3aWR0aC5cbiAgLy8gSW5zaWRlIHRoZSBsb29wOlxuICAvLyAgIEEgbWF0Y2ggaW1wbGllcyBsZW5ndGggPj0gMiwgc28gY3VyciBhbmQgbmV4dCBhcmUgPD0gbGVuZ3RoLTIuXG4gIHdoaWxlICgobWF0Y2ggPSBicmVha1JlLmV4ZWMobGluZSkpKSB7XG4gICAgbmV4dCA9IG1hdGNoLmluZGV4O1xuICAgIC8vIG1haW50YWluIGludmFyaWFudDogY3VyciAtIHN0YXJ0IDw9IHdpZHRoXG4gICAgaWYgKG5leHQgLSBzdGFydCA+IHdpZHRoKSB7XG4gICAgICBlbmQgPSAoY3VyciA+IHN0YXJ0KSA/IGN1cnIgOiBuZXh0OyAvLyBkZXJpdmUgZW5kIDw9IGxlbmd0aC0yXG4gICAgICByZXN1bHQgKz0gJ1xcbicgKyBsaW5lLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgLy8gc2tpcCB0aGUgc3BhY2UgdGhhdCB3YXMgb3V0cHV0IGFzIFxcblxuICAgICAgc3RhcnQgPSBlbmQgKyAxOyAgICAgICAgICAgICAgICAgICAgLy8gZGVyaXZlIHN0YXJ0IDw9IGxlbmd0aC0xXG4gICAgfVxuICAgIGN1cnIgPSBuZXh0O1xuICB9XG5cbiAgLy8gQnkgdGhlIGludmFyaWFudHMsIHN0YXJ0IDw9IGxlbmd0aC0xLCBzbyB0aGVyZSBpcyBzb21ldGhpbmcgbGVmdCBvdmVyLlxuICAvLyBJdCBpcyBlaXRoZXIgdGhlIHdob2xlIHN0cmluZyBvciBhIHBhcnQgc3RhcnRpbmcgZnJvbSBub24td2hpdGVzcGFjZS5cbiAgcmVzdWx0ICs9ICdcXG4nO1xuICAvLyBJbnNlcnQgYSBicmVhayBpZiB0aGUgcmVtYWluZGVyIGlzIHRvbyBsb25nIGFuZCB0aGVyZSBpcyBhIGJyZWFrIGF2YWlsYWJsZS5cbiAgaWYgKGxpbmUubGVuZ3RoIC0gc3RhcnQgPiB3aWR0aCAmJiBjdXJyID4gc3RhcnQpIHtcbiAgICByZXN1bHQgKz0gbGluZS5zbGljZShzdGFydCwgY3VycikgKyAnXFxuJyArIGxpbmUuc2xpY2UoY3VyciArIDEpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCArPSBsaW5lLnNsaWNlKHN0YXJ0KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQuc2xpY2UoMSk7IC8vIGRyb3AgZXh0cmEgXFxuIGpvaW5lclxufVxuXG4vLyBFc2NhcGVzIGEgZG91YmxlLXF1b3RlZCBzdHJpbmcuXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmcoc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgdmFyIGNoYXIgPSAwO1xuICB2YXIgZXNjYXBlU2VxO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgY2hhciA+PSAweDEwMDAwID8gaSArPSAyIDogaSsrKSB7XG4gICAgY2hhciA9IGNvZGVQb2ludEF0KHN0cmluZywgaSk7XG4gICAgZXNjYXBlU2VxID0gRVNDQVBFX1NFUVVFTkNFU1tjaGFyXTtcblxuICAgIGlmICghZXNjYXBlU2VxICYmIGlzUHJpbnRhYmxlKGNoYXIpKSB7XG4gICAgICByZXN1bHQgKz0gc3RyaW5nW2ldO1xuICAgICAgaWYgKGNoYXIgPj0gMHgxMDAwMCkgcmVzdWx0ICs9IHN0cmluZ1tpICsgMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCArPSBlc2NhcGVTZXEgfHwgZW5jb2RlSGV4KGNoYXIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvd1NlcXVlbmNlKHN0YXRlLCBsZXZlbCwgb2JqZWN0KSB7XG4gIHZhciBfcmVzdWx0ID0gJycsXG4gICAgICBfdGFnICAgID0gc3RhdGUudGFnLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGgsXG4gICAgICB2YWx1ZTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICB2YWx1ZSA9IG9iamVjdFtpbmRleF07XG5cbiAgICBpZiAoc3RhdGUucmVwbGFjZXIpIHtcbiAgICAgIHZhbHVlID0gc3RhdGUucmVwbGFjZXIuY2FsbChvYmplY3QsIFN0cmluZyhpbmRleCksIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBXcml0ZSBvbmx5IHZhbGlkIGVsZW1lbnRzLCBwdXQgbnVsbCBpbnN0ZWFkIG9mIGludmFsaWQgZWxlbWVudHMuXG4gICAgaWYgKHdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwsIHZhbHVlLCBmYWxzZSwgZmFsc2UpIHx8XG4gICAgICAgICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICB3cml0ZU5vZGUoc3RhdGUsIGxldmVsLCBudWxsLCBmYWxzZSwgZmFsc2UpKSkge1xuXG4gICAgICBpZiAoX3Jlc3VsdCAhPT0gJycpIF9yZXN1bHQgKz0gJywnICsgKCFzdGF0ZS5jb25kZW5zZUZsb3cgPyAnICcgOiAnJyk7XG4gICAgICBfcmVzdWx0ICs9IHN0YXRlLmR1bXA7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUudGFnID0gX3RhZztcbiAgc3RhdGUuZHVtcCA9ICdbJyArIF9yZXN1bHQgKyAnXSc7XG59XG5cbmZ1bmN0aW9uIHdyaXRlQmxvY2tTZXF1ZW5jZShzdGF0ZSwgbGV2ZWwsIG9iamVjdCwgY29tcGFjdCkge1xuICB2YXIgX3Jlc3VsdCA9ICcnLFxuICAgICAgX3RhZyAgICA9IHN0YXRlLnRhZyxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoLFxuICAgICAgdmFsdWU7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgdmFsdWUgPSBvYmplY3RbaW5kZXhdO1xuXG4gICAgaWYgKHN0YXRlLnJlcGxhY2VyKSB7XG4gICAgICB2YWx1ZSA9IHN0YXRlLnJlcGxhY2VyLmNhbGwob2JqZWN0LCBTdHJpbmcoaW5kZXgpLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gV3JpdGUgb25seSB2YWxpZCBlbGVtZW50cywgcHV0IG51bGwgaW5zdGVhZCBvZiBpbnZhbGlkIGVsZW1lbnRzLlxuICAgIGlmICh3cml0ZU5vZGUoc3RhdGUsIGxldmVsICsgMSwgdmFsdWUsIHRydWUsIHRydWUsIGZhbHNlLCB0cnVlKSB8fFxuICAgICAgICAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCArIDEsIG51bGwsIHRydWUsIHRydWUsIGZhbHNlLCB0cnVlKSkpIHtcblxuICAgICAgaWYgKCFjb21wYWN0IHx8IF9yZXN1bHQgIT09ICcnKSB7XG4gICAgICAgIF9yZXN1bHQgKz0gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUuZHVtcCAmJiBDSEFSX0xJTkVfRkVFRCA9PT0gc3RhdGUuZHVtcC5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgIF9yZXN1bHQgKz0gJy0nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3Jlc3VsdCArPSAnLSAnO1xuICAgICAgfVxuXG4gICAgICBfcmVzdWx0ICs9IHN0YXRlLmR1bXA7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUudGFnID0gX3RhZztcbiAgc3RhdGUuZHVtcCA9IF9yZXN1bHQgfHwgJ1tdJzsgLy8gRW1wdHkgc2VxdWVuY2UgaWYgbm8gdmFsaWQgdmFsdWVzLlxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb3dNYXBwaW5nKHN0YXRlLCBsZXZlbCwgb2JqZWN0KSB7XG4gIHZhciBfcmVzdWx0ICAgICAgID0gJycsXG4gICAgICBfdGFnICAgICAgICAgID0gc3RhdGUudGFnLFxuICAgICAgb2JqZWN0S2V5TGlzdCA9IE9iamVjdC5rZXlzKG9iamVjdCksXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aCxcbiAgICAgIG9iamVjdEtleSxcbiAgICAgIG9iamVjdFZhbHVlLFxuICAgICAgcGFpckJ1ZmZlcjtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0S2V5TGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG5cbiAgICBwYWlyQnVmZmVyID0gJyc7XG4gICAgaWYgKF9yZXN1bHQgIT09ICcnKSBwYWlyQnVmZmVyICs9ICcsICc7XG5cbiAgICBpZiAoc3RhdGUuY29uZGVuc2VGbG93KSBwYWlyQnVmZmVyICs9ICdcIic7XG5cbiAgICBvYmplY3RLZXkgPSBvYmplY3RLZXlMaXN0W2luZGV4XTtcbiAgICBvYmplY3RWYWx1ZSA9IG9iamVjdFtvYmplY3RLZXldO1xuXG4gICAgaWYgKHN0YXRlLnJlcGxhY2VyKSB7XG4gICAgICBvYmplY3RWYWx1ZSA9IHN0YXRlLnJlcGxhY2VyLmNhbGwob2JqZWN0LCBvYmplY3RLZXksIG9iamVjdFZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoIXdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwsIG9iamVjdEtleSwgZmFsc2UsIGZhbHNlKSkge1xuICAgICAgY29udGludWU7IC8vIFNraXAgdGhpcyBwYWlyIGJlY2F1c2Ugb2YgaW52YWxpZCBrZXk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmR1bXAubGVuZ3RoID4gMTAyNCkgcGFpckJ1ZmZlciArPSAnPyAnO1xuXG4gICAgcGFpckJ1ZmZlciArPSBzdGF0ZS5kdW1wICsgKHN0YXRlLmNvbmRlbnNlRmxvdyA/ICdcIicgOiAnJykgKyAnOicgKyAoc3RhdGUuY29uZGVuc2VGbG93ID8gJycgOiAnICcpO1xuXG4gICAgaWYgKCF3cml0ZU5vZGUoc3RhdGUsIGxldmVsLCBvYmplY3RWYWx1ZSwgZmFsc2UsIGZhbHNlKSkge1xuICAgICAgY29udGludWU7IC8vIFNraXAgdGhpcyBwYWlyIGJlY2F1c2Ugb2YgaW52YWxpZCB2YWx1ZS5cbiAgICB9XG5cbiAgICBwYWlyQnVmZmVyICs9IHN0YXRlLmR1bXA7XG5cbiAgICAvLyBCb3RoIGtleSBhbmQgdmFsdWUgYXJlIHZhbGlkLlxuICAgIF9yZXN1bHQgKz0gcGFpckJ1ZmZlcjtcbiAgfVxuXG4gIHN0YXRlLnRhZyA9IF90YWc7XG4gIHN0YXRlLmR1bXAgPSAneycgKyBfcmVzdWx0ICsgJ30nO1xufVxuXG5mdW5jdGlvbiB3cml0ZUJsb2NrTWFwcGluZyhzdGF0ZSwgbGV2ZWwsIG9iamVjdCwgY29tcGFjdCkge1xuICB2YXIgX3Jlc3VsdCAgICAgICA9ICcnLFxuICAgICAgX3RhZyAgICAgICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIG9iamVjdEtleUxpc3QgPSBPYmplY3Qua2V5cyhvYmplY3QpLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGgsXG4gICAgICBvYmplY3RLZXksXG4gICAgICBvYmplY3RWYWx1ZSxcbiAgICAgIGV4cGxpY2l0UGFpcixcbiAgICAgIHBhaXJCdWZmZXI7XG5cbiAgLy8gQWxsb3cgc29ydGluZyBrZXlzIHNvIHRoYXQgdGhlIG91dHB1dCBmaWxlIGlzIGRldGVybWluaXN0aWNcbiAgaWYgKHN0YXRlLnNvcnRLZXlzID09PSB0cnVlKSB7XG4gICAgLy8gRGVmYXVsdCBzb3J0aW5nXG4gICAgb2JqZWN0S2V5TGlzdC5zb3J0KCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHN0YXRlLnNvcnRLZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gQ3VzdG9tIHNvcnQgZnVuY3Rpb25cbiAgICBvYmplY3RLZXlMaXN0LnNvcnQoc3RhdGUuc29ydEtleXMpO1xuICB9IGVsc2UgaWYgKHN0YXRlLnNvcnRLZXlzKSB7XG4gICAgLy8gU29tZXRoaW5nIGlzIHdyb25nXG4gICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ3NvcnRLZXlzIG11c3QgYmUgYSBib29sZWFuIG9yIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3RLZXlMaXN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyQnVmZmVyID0gJyc7XG5cbiAgICBpZiAoIWNvbXBhY3QgfHwgX3Jlc3VsdCAhPT0gJycpIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpO1xuICAgIH1cblxuICAgIG9iamVjdEtleSA9IG9iamVjdEtleUxpc3RbaW5kZXhdO1xuICAgIG9iamVjdFZhbHVlID0gb2JqZWN0W29iamVjdEtleV07XG5cbiAgICBpZiAoc3RhdGUucmVwbGFjZXIpIHtcbiAgICAgIG9iamVjdFZhbHVlID0gc3RhdGUucmVwbGFjZXIuY2FsbChvYmplY3QsIG9iamVjdEtleSwgb2JqZWN0VmFsdWUpO1xuICAgIH1cblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCArIDEsIG9iamVjdEtleSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSkpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRoaXMgcGFpciBiZWNhdXNlIG9mIGludmFsaWQga2V5LlxuICAgIH1cblxuICAgIGV4cGxpY2l0UGFpciA9IChzdGF0ZS50YWcgIT09IG51bGwgJiYgc3RhdGUudGFnICE9PSAnPycpIHx8XG4gICAgICAgICAgICAgICAgICAgKHN0YXRlLmR1bXAgJiYgc3RhdGUuZHVtcC5sZW5ndGggPiAxMDI0KTtcblxuICAgIGlmIChleHBsaWNpdFBhaXIpIHtcbiAgICAgIGlmIChzdGF0ZS5kdW1wICYmIENIQVJfTElORV9GRUVEID09PSBzdGF0ZS5kdW1wLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgcGFpckJ1ZmZlciArPSAnPyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYWlyQnVmZmVyICs9ICc/ICc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGFpckJ1ZmZlciArPSBzdGF0ZS5kdW1wO1xuXG4gICAgaWYgKGV4cGxpY2l0UGFpcikge1xuICAgICAgcGFpckJ1ZmZlciArPSBnZW5lcmF0ZU5leHRMaW5lKHN0YXRlLCBsZXZlbCk7XG4gICAgfVxuXG4gICAgaWYgKCF3cml0ZU5vZGUoc3RhdGUsIGxldmVsICsgMSwgb2JqZWN0VmFsdWUsIHRydWUsIGV4cGxpY2l0UGFpcikpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRoaXMgcGFpciBiZWNhdXNlIG9mIGludmFsaWQgdmFsdWUuXG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmR1bXAgJiYgQ0hBUl9MSU5FX0ZFRUQgPT09IHN0YXRlLmR1bXAuY2hhckNvZGVBdCgwKSkge1xuICAgICAgcGFpckJ1ZmZlciArPSAnOic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gJzogJztcbiAgICB9XG5cbiAgICBwYWlyQnVmZmVyICs9IHN0YXRlLmR1bXA7XG5cbiAgICAvLyBCb3RoIGtleSBhbmQgdmFsdWUgYXJlIHZhbGlkLlxuICAgIF9yZXN1bHQgKz0gcGFpckJ1ZmZlcjtcbiAgfVxuXG4gIHN0YXRlLnRhZyA9IF90YWc7XG4gIHN0YXRlLmR1bXAgPSBfcmVzdWx0IHx8ICd7fSc7IC8vIEVtcHR5IG1hcHBpbmcgaWYgbm8gdmFsaWQgcGFpcnMuXG59XG5cbmZ1bmN0aW9uIGRldGVjdFR5cGUoc3RhdGUsIG9iamVjdCwgZXhwbGljaXQpIHtcbiAgdmFyIF9yZXN1bHQsIHR5cGVMaXN0LCBpbmRleCwgbGVuZ3RoLCB0eXBlLCBzdHlsZTtcblxuICB0eXBlTGlzdCA9IGV4cGxpY2l0ID8gc3RhdGUuZXhwbGljaXRUeXBlcyA6IHN0YXRlLmltcGxpY2l0VHlwZXM7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHR5cGVMaXN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICB0eXBlID0gdHlwZUxpc3RbaW5kZXhdO1xuXG4gICAgaWYgKCh0eXBlLmluc3RhbmNlT2YgIHx8IHR5cGUucHJlZGljYXRlKSAmJlxuICAgICAgICAoIXR5cGUuaW5zdGFuY2VPZiB8fCAoKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnKSAmJiAob2JqZWN0IGluc3RhbmNlb2YgdHlwZS5pbnN0YW5jZU9mKSkpICYmXG4gICAgICAgICghdHlwZS5wcmVkaWNhdGUgIHx8IHR5cGUucHJlZGljYXRlKG9iamVjdCkpKSB7XG5cbiAgICAgIGlmIChleHBsaWNpdCkge1xuICAgICAgICBpZiAodHlwZS5tdWx0aSAmJiB0eXBlLnJlcHJlc2VudE5hbWUpIHtcbiAgICAgICAgICBzdGF0ZS50YWcgPSB0eXBlLnJlcHJlc2VudE5hbWUob2JqZWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS50YWcgPSB0eXBlLnRhZztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUudGFnID0gJz8nO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZS5yZXByZXNlbnQpIHtcbiAgICAgICAgc3R5bGUgPSBzdGF0ZS5zdHlsZU1hcFt0eXBlLnRhZ10gfHwgdHlwZS5kZWZhdWx0U3R5bGU7XG5cbiAgICAgICAgaWYgKF90b1N0cmluZy5jYWxsKHR5cGUucmVwcmVzZW50KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJykge1xuICAgICAgICAgIF9yZXN1bHQgPSB0eXBlLnJlcHJlc2VudChvYmplY3QsIHN0eWxlKTtcbiAgICAgICAgfSBlbHNlIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbCh0eXBlLnJlcHJlc2VudCwgc3R5bGUpKSB7XG4gICAgICAgICAgX3Jlc3VsdCA9IHR5cGUucmVwcmVzZW50W3N0eWxlXShvYmplY3QsIHN0eWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignITwnICsgdHlwZS50YWcgKyAnPiB0YWcgcmVzb2x2ZXIgYWNjZXB0cyBub3QgXCInICsgc3R5bGUgKyAnXCIgc3R5bGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmR1bXAgPSBfcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIFNlcmlhbGl6ZXMgYG9iamVjdGAgYW5kIHdyaXRlcyBpdCB0byBnbG9iYWwgYHJlc3VsdGAuXG4vLyBSZXR1cm5zIHRydWUgb24gc3VjY2Vzcywgb3IgZmFsc2Ugb24gaW52YWxpZCBvYmplY3QuXG4vL1xuZnVuY3Rpb24gd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0LCBibG9jaywgY29tcGFjdCwgaXNrZXksIGlzYmxvY2tzZXEpIHtcbiAgc3RhdGUudGFnID0gbnVsbDtcbiAgc3RhdGUuZHVtcCA9IG9iamVjdDtcblxuICBpZiAoIWRldGVjdFR5cGUoc3RhdGUsIG9iamVjdCwgZmFsc2UpKSB7XG4gICAgZGV0ZWN0VHlwZShzdGF0ZSwgb2JqZWN0LCB0cnVlKTtcbiAgfVxuXG4gIHZhciB0eXBlID0gX3RvU3RyaW5nLmNhbGwoc3RhdGUuZHVtcCk7XG4gIHZhciBpbmJsb2NrID0gYmxvY2s7XG4gIHZhciB0YWdTdHI7XG5cbiAgaWYgKGJsb2NrKSB7XG4gICAgYmxvY2sgPSAoc3RhdGUuZmxvd0xldmVsIDwgMCB8fCBzdGF0ZS5mbG93TGV2ZWwgPiBsZXZlbCk7XG4gIH1cblxuICB2YXIgb2JqZWN0T3JBcnJheSA9IHR5cGUgPT09ICdbb2JqZWN0IE9iamVjdF0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XScsXG4gICAgICBkdXBsaWNhdGVJbmRleCxcbiAgICAgIGR1cGxpY2F0ZTtcblxuICBpZiAob2JqZWN0T3JBcnJheSkge1xuICAgIGR1cGxpY2F0ZUluZGV4ID0gc3RhdGUuZHVwbGljYXRlcy5pbmRleE9mKG9iamVjdCk7XG4gICAgZHVwbGljYXRlID0gZHVwbGljYXRlSW5kZXggIT09IC0xO1xuICB9XG5cbiAgaWYgKChzdGF0ZS50YWcgIT09IG51bGwgJiYgc3RhdGUudGFnICE9PSAnPycpIHx8IGR1cGxpY2F0ZSB8fCAoc3RhdGUuaW5kZW50ICE9PSAyICYmIGxldmVsID4gMCkpIHtcbiAgICBjb21wYWN0ID0gZmFsc2U7XG4gIH1cblxuICBpZiAoZHVwbGljYXRlICYmIHN0YXRlLnVzZWREdXBsaWNhdGVzW2R1cGxpY2F0ZUluZGV4XSkge1xuICAgIHN0YXRlLmR1bXAgPSAnKnJlZl8nICsgZHVwbGljYXRlSW5kZXg7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG9iamVjdE9yQXJyYXkgJiYgZHVwbGljYXRlICYmICFzdGF0ZS51c2VkRHVwbGljYXRlc1tkdXBsaWNhdGVJbmRleF0pIHtcbiAgICAgIHN0YXRlLnVzZWREdXBsaWNhdGVzW2R1cGxpY2F0ZUluZGV4XSA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgaWYgKGJsb2NrICYmIChPYmplY3Qua2V5cyhzdGF0ZS5kdW1wKS5sZW5ndGggIT09IDApKSB7XG4gICAgICAgIHdyaXRlQmxvY2tNYXBwaW5nKHN0YXRlLCBsZXZlbCwgc3RhdGUuZHVtcCwgY29tcGFjdCk7XG4gICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5kdW1wID0gJyZyZWZfJyArIGR1cGxpY2F0ZUluZGV4ICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVGbG93TWFwcGluZyhzdGF0ZSwgbGV2ZWwsIHN0YXRlLmR1bXApO1xuICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgc3RhdGUuZHVtcCA9ICcmcmVmXycgKyBkdXBsaWNhdGVJbmRleCArICcgJyArIHN0YXRlLmR1bXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIGlmIChibG9jayAmJiAoc3RhdGUuZHVtcC5sZW5ndGggIT09IDApKSB7XG4gICAgICAgIGlmIChzdGF0ZS5ub0FycmF5SW5kZW50ICYmICFpc2Jsb2Nrc2VxICYmIGxldmVsID4gMCkge1xuICAgICAgICAgIHdyaXRlQmxvY2tTZXF1ZW5jZShzdGF0ZSwgbGV2ZWwgLSAxLCBzdGF0ZS5kdW1wLCBjb21wYWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3cml0ZUJsb2NrU2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBzdGF0ZS5kdW1wLCBjb21wYWN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgc3RhdGUuZHVtcCA9ICcmcmVmXycgKyBkdXBsaWNhdGVJbmRleCArIHN0YXRlLmR1bXA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlRmxvd1NlcXVlbmNlKHN0YXRlLCBsZXZlbCwgc3RhdGUuZHVtcCk7XG4gICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5kdW1wID0gJyZyZWZfJyArIGR1cGxpY2F0ZUluZGV4ICsgJyAnICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1tvYmplY3QgU3RyaW5nXScpIHtcbiAgICAgIGlmIChzdGF0ZS50YWcgIT09ICc/Jykge1xuICAgICAgICB3cml0ZVNjYWxhcihzdGF0ZSwgc3RhdGUuZHVtcCwgbGV2ZWwsIGlza2V5LCBpbmJsb2NrKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFVuZGVmaW5lZF0nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGF0ZS5za2lwSW52YWxpZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ3VuYWNjZXB0YWJsZSBraW5kIG9mIGFuIG9iamVjdCB0byBkdW1wICcgKyB0eXBlKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUudGFnICE9PSBudWxsICYmIHN0YXRlLnRhZyAhPT0gJz8nKSB7XG4gICAgICAvLyBOZWVkIHRvIGVuY29kZSBhbGwgY2hhcmFjdGVycyBleGNlcHQgdGhvc2UgYWxsb3dlZCBieSB0aGUgc3BlYzpcbiAgICAgIC8vXG4gICAgICAvLyBbMzVdIG5zLWRlYy1kaWdpdCAgICA6Oj0gIFsjeDMwLSN4MzldIC8qIDAtOSAqL1xuICAgICAgLy8gWzM2XSBucy1oZXgtZGlnaXQgICAgOjo9ICBucy1kZWMtZGlnaXRcbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIHwgWyN4NDEtI3g0Nl0gLyogQS1GICovIHwgWyN4NjEtI3g2Nl0gLyogYS1mICovXG4gICAgICAvLyBbMzddIG5zLWFzY2lpLWxldHRlciA6Oj0gIFsjeDQxLSN4NUFdIC8qIEEtWiAqLyB8IFsjeDYxLSN4N0FdIC8qIGEteiAqL1xuICAgICAgLy8gWzM4XSBucy13b3JkLWNoYXIgICAgOjo9ICBucy1kZWMtZGlnaXQgfCBucy1hc2NpaS1sZXR0ZXIgfCDigJwt4oCdXG4gICAgICAvLyBbMzldIG5zLXVyaS1jaGFyICAgICA6Oj0gIOKAnCXigJ0gbnMtaGV4LWRpZ2l0IG5zLWhleC1kaWdpdCB8IG5zLXdvcmQtY2hhciB8IOKAnCPigJ1cbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIHwg4oCcO+KAnSB8IOKAnC/igJ0gfCDigJw/4oCdIHwg4oCcOuKAnSB8IOKAnEDigJ0gfCDigJwm4oCdIHwg4oCcPeKAnSB8IOKAnCvigJ0gfCDigJwk4oCdIHwg4oCcLOKAnVxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgfCDigJxf4oCdIHwg4oCcLuKAnSB8IOKAnCHigJ0gfCDigJx+4oCdIHwg4oCcKuKAnSB8IOKAnCfigJ0gfCDigJwo4oCdIHwg4oCcKeKAnSB8IOKAnFvigJ0gfCDigJxd4oCdXG4gICAgICAvL1xuICAgICAgLy8gQWxzbyBuZWVkIHRvIGVuY29kZSAnIScgYmVjYXVzZSBpdCBoYXMgc3BlY2lhbCBtZWFuaW5nIChlbmQgb2YgdGFnIHByZWZpeCkuXG4gICAgICAvL1xuICAgICAgdGFnU3RyID0gZW5jb2RlVVJJKFxuICAgICAgICBzdGF0ZS50YWdbMF0gPT09ICchJyA/IHN0YXRlLnRhZy5zbGljZSgxKSA6IHN0YXRlLnRhZ1xuICAgICAgKS5yZXBsYWNlKC8hL2csICclMjEnKTtcblxuICAgICAgaWYgKHN0YXRlLnRhZ1swXSA9PT0gJyEnKSB7XG4gICAgICAgIHRhZ1N0ciA9ICchJyArIHRhZ1N0cjtcbiAgICAgIH0gZWxzZSBpZiAodGFnU3RyLnNsaWNlKDAsIDE4KSA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOicpIHtcbiAgICAgICAgdGFnU3RyID0gJyEhJyArIHRhZ1N0ci5zbGljZSgxOCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YWdTdHIgPSAnITwnICsgdGFnU3RyICsgJz4nO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZS5kdW1wID0gdGFnU3RyICsgJyAnICsgc3RhdGUuZHVtcDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0RHVwbGljYXRlUmVmZXJlbmNlcyhvYmplY3QsIHN0YXRlKSB7XG4gIHZhciBvYmplY3RzID0gW10sXG4gICAgICBkdXBsaWNhdGVzSW5kZXhlcyA9IFtdLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGg7XG5cbiAgaW5zcGVjdE5vZGUob2JqZWN0LCBvYmplY3RzLCBkdXBsaWNhdGVzSW5kZXhlcyk7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGR1cGxpY2F0ZXNJbmRleGVzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBzdGF0ZS5kdXBsaWNhdGVzLnB1c2gob2JqZWN0c1tkdXBsaWNhdGVzSW5kZXhlc1tpbmRleF1dKTtcbiAgfVxuICBzdGF0ZS51c2VkRHVwbGljYXRlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBpbnNwZWN0Tm9kZShvYmplY3QsIG9iamVjdHMsIGR1cGxpY2F0ZXNJbmRleGVzKSB7XG4gIHZhciBvYmplY3RLZXlMaXN0LFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGg7XG5cbiAgaWYgKG9iamVjdCAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0Jykge1xuICAgIGluZGV4ID0gb2JqZWN0cy5pbmRleE9mKG9iamVjdCk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgaWYgKGR1cGxpY2F0ZXNJbmRleGVzLmluZGV4T2YoaW5kZXgpID09PSAtMSkge1xuICAgICAgICBkdXBsaWNhdGVzSW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb2JqZWN0cy5wdXNoKG9iamVjdCk7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICAgICAgaW5zcGVjdE5vZGUob2JqZWN0W2luZGV4XSwgb2JqZWN0cywgZHVwbGljYXRlc0luZGV4ZXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmplY3RLZXlMaXN0ID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0S2V5TGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICAgICAgaW5zcGVjdE5vZGUob2JqZWN0W29iamVjdEtleUxpc3RbaW5kZXhdXSwgb2JqZWN0cywgZHVwbGljYXRlc0luZGV4ZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGR1bXAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIHN0YXRlID0gbmV3IFN0YXRlKG9wdGlvbnMpO1xuXG4gIGlmICghc3RhdGUubm9SZWZzKSBnZXREdXBsaWNhdGVSZWZlcmVuY2VzKGlucHV0LCBzdGF0ZSk7XG5cbiAgdmFyIHZhbHVlID0gaW5wdXQ7XG5cbiAgaWYgKHN0YXRlLnJlcGxhY2VyKSB7XG4gICAgdmFsdWUgPSBzdGF0ZS5yZXBsYWNlci5jYWxsKHsgJyc6IHZhbHVlIH0sICcnLCB2YWx1ZSk7XG4gIH1cblxuICBpZiAod3JpdGVOb2RlKHN0YXRlLCAwLCB2YWx1ZSwgdHJ1ZSwgdHJ1ZSkpIHJldHVybiBzdGF0ZS5kdW1wICsgJ1xcbic7XG5cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5kdW1wID0gZHVtcDtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgbG9hZGVyID0gcmVxdWlyZSgnLi9saWIvbG9hZGVyJyk7XG52YXIgZHVtcGVyID0gcmVxdWlyZSgnLi9saWIvZHVtcGVyJyk7XG5cblxuZnVuY3Rpb24gcmVuYW1lZChmcm9tLCB0bykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24geWFtbC4nICsgZnJvbSArICcgaXMgcmVtb3ZlZCBpbiBqcy15YW1sIDQuICcgK1xuICAgICAgJ1VzZSB5YW1sLicgKyB0byArICcgaW5zdGVhZCwgd2hpY2ggaXMgbm93IHNhZmUgYnkgZGVmYXVsdC4nKTtcbiAgfTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cy5UeXBlICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9saWIvdHlwZScpO1xubW9kdWxlLmV4cG9ydHMuU2NoZW1hICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vbGliL3NjaGVtYScpO1xubW9kdWxlLmV4cG9ydHMuRkFJTFNBRkVfU0NIRU1BICAgICA9IHJlcXVpcmUoJy4vbGliL3NjaGVtYS9mYWlsc2FmZScpO1xubW9kdWxlLmV4cG9ydHMuSlNPTl9TQ0hFTUEgICAgICAgICA9IHJlcXVpcmUoJy4vbGliL3NjaGVtYS9qc29uJyk7XG5tb2R1bGUuZXhwb3J0cy5DT1JFX1NDSEVNQSAgICAgICAgID0gcmVxdWlyZSgnLi9saWIvc2NoZW1hL2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzLkRFRkFVTFRfU0NIRU1BICAgICAgPSByZXF1aXJlKCcuL2xpYi9zY2hlbWEvZGVmYXVsdCcpO1xubW9kdWxlLmV4cG9ydHMubG9hZCAgICAgICAgICAgICAgICA9IGxvYWRlci5sb2FkO1xubW9kdWxlLmV4cG9ydHMubG9hZEFsbCAgICAgICAgICAgICA9IGxvYWRlci5sb2FkQWxsO1xubW9kdWxlLmV4cG9ydHMuZHVtcCAgICAgICAgICAgICAgICA9IGR1bXBlci5kdW1wO1xubW9kdWxlLmV4cG9ydHMuWUFNTEV4Y2VwdGlvbiAgICAgICA9IHJlcXVpcmUoJy4vbGliL2V4Y2VwdGlvbicpO1xuXG4vLyBSZS1leHBvcnQgYWxsIHR5cGVzIGluIGNhc2UgdXNlciB3YW50cyB0byBjcmVhdGUgY3VzdG9tIHNjaGVtYVxubW9kdWxlLmV4cG9ydHMudHlwZXMgPSB7XG4gIGJpbmFyeTogICAgcmVxdWlyZSgnLi9saWIvdHlwZS9iaW5hcnknKSxcbiAgZmxvYXQ6ICAgICByZXF1aXJlKCcuL2xpYi90eXBlL2Zsb2F0JyksXG4gIG1hcDogICAgICAgcmVxdWlyZSgnLi9saWIvdHlwZS9tYXAnKSxcbiAgbnVsbDogICAgICByZXF1aXJlKCcuL2xpYi90eXBlL251bGwnKSxcbiAgcGFpcnM6ICAgICByZXF1aXJlKCcuL2xpYi90eXBlL3BhaXJzJyksXG4gIHNldDogICAgICAgcmVxdWlyZSgnLi9saWIvdHlwZS9zZXQnKSxcbiAgdGltZXN0YW1wOiByZXF1aXJlKCcuL2xpYi90eXBlL3RpbWVzdGFtcCcpLFxuICBib29sOiAgICAgIHJlcXVpcmUoJy4vbGliL3R5cGUvYm9vbCcpLFxuICBpbnQ6ICAgICAgIHJlcXVpcmUoJy4vbGliL3R5cGUvaW50JyksXG4gIG1lcmdlOiAgICAgcmVxdWlyZSgnLi9saWIvdHlwZS9tZXJnZScpLFxuICBvbWFwOiAgICAgIHJlcXVpcmUoJy4vbGliL3R5cGUvb21hcCcpLFxuICBzZXE6ICAgICAgIHJlcXVpcmUoJy4vbGliL3R5cGUvc2VxJyksXG4gIHN0cjogICAgICAgcmVxdWlyZSgnLi9saWIvdHlwZS9zdHInKVxufTtcblxuLy8gUmVtb3ZlZCBmdW5jdGlvbnMgZnJvbSBKUy1ZQU1MIDMuMC54XG5tb2R1bGUuZXhwb3J0cy5zYWZlTG9hZCAgICAgICAgICAgID0gcmVuYW1lZCgnc2FmZUxvYWQnLCAnbG9hZCcpO1xubW9kdWxlLmV4cG9ydHMuc2FmZUxvYWRBbGwgICAgICAgICA9IHJlbmFtZWQoJ3NhZmVMb2FkQWxsJywgJ2xvYWRBbGwnKTtcbm1vZHVsZS5leHBvcnRzLnNhZmVEdW1wICAgICAgICAgICAgPSByZW5hbWVkKCdzYWZlRHVtcCcsICdkdW1wJyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGF6eSA9IHZvaWQgMDtcbmNsYXNzIExhenkge1xuICAgIGNvbnN0cnVjdG9yKGNyZWF0b3IpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLmNyZWF0b3IgPSBjcmVhdG9yO1xuICAgIH1cbiAgICBnZXQgaGFzVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0b3IgPT0gbnVsbDtcbiAgICB9XG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICBpZiAodGhpcy5jcmVhdG9yID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmNyZWF0b3IoKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHJlc3VsdDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuY3JlYXRvciA9IG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5MYXp5ID0gTGF6eTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1haW4uanMubWFwIiwiLy8gTm90ZTogdGhpcyBpcyB0aGUgc2VtdmVyLm9yZyB2ZXJzaW9uIG9mIHRoZSBzcGVjIHRoYXQgaXQgaW1wbGVtZW50c1xuLy8gTm90IG5lY2Vzc2FyaWx5IHRoZSBwYWNrYWdlIHZlcnNpb24gb2YgdGhpcyBjb2RlLlxuY29uc3QgU0VNVkVSX1NQRUNfVkVSU0lPTiA9ICcyLjAuMCdcblxuY29uc3QgTUFYX0xFTkdUSCA9IDI1NlxuY29uc3QgTUFYX1NBRkVfSU5URUdFUiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIDkwMDcxOTkyNTQ3NDA5OTFcblxuLy8gTWF4IHNhZmUgc2VnbWVudCBsZW5ndGggZm9yIGNvZXJjaW9uLlxuY29uc3QgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCA9IDE2XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBTRU1WRVJfU1BFQ19WRVJTSU9OLFxuICBNQVhfTEVOR1RILFxuICBNQVhfU0FGRV9JTlRFR0VSLFxuICBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIXG59XG4iLCJjb25zdCBkZWJ1ZyA9IChcbiAgdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmXG4gIHByb2Nlc3MuZW52ICYmXG4gIHByb2Nlc3MuZW52Lk5PREVfREVCVUcgJiZcbiAgL1xcYnNlbXZlclxcYi9pLnRlc3QocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRylcbikgPyAoLi4uYXJncykgPT4gY29uc29sZS5lcnJvcignU0VNVkVSJywgLi4uYXJncylcbiAgOiAoKSA9PiB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlYnVnXG4iLCJjb25zdCB7IE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEggfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnLi9kZWJ1ZycpXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB7fVxuXG4vLyBUaGUgYWN0dWFsIHJlZ2V4cHMgZ28gb24gZXhwb3J0cy5yZVxuY29uc3QgcmUgPSBleHBvcnRzLnJlID0gW11cbmNvbnN0IHNyYyA9IGV4cG9ydHMuc3JjID0gW11cbmNvbnN0IHQgPSBleHBvcnRzLnQgPSB7fVxubGV0IFIgPSAwXG5cbmNvbnN0IGNyZWF0ZVRva2VuID0gKG5hbWUsIHZhbHVlLCBpc0dsb2JhbCkgPT4ge1xuICBjb25zdCBpbmRleCA9IFIrK1xuICBkZWJ1ZyhpbmRleCwgdmFsdWUpXG4gIHRbbmFtZV0gPSBpbmRleFxuICBzcmNbaW5kZXhdID0gdmFsdWVcbiAgcmVbaW5kZXhdID0gbmV3IFJlZ0V4cCh2YWx1ZSwgaXNHbG9iYWwgPyAnZycgOiB1bmRlZmluZWQpXG59XG5cbi8vIFRoZSBmb2xsb3dpbmcgUmVndWxhciBFeHByZXNzaW9ucyBjYW4gYmUgdXNlZCBmb3IgdG9rZW5pemluZyxcbi8vIHZhbGlkYXRpbmcsIGFuZCBwYXJzaW5nIFNlbVZlciB2ZXJzaW9uIHN0cmluZ3MuXG5cbi8vICMjIE51bWVyaWMgSWRlbnRpZmllclxuLy8gQSBzaW5nbGUgYDBgLCBvciBhIG5vbi16ZXJvIGRpZ2l0IGZvbGxvd2VkIGJ5IHplcm8gb3IgbW9yZSBkaWdpdHMuXG5cbmNyZWF0ZVRva2VuKCdOVU1FUklDSURFTlRJRklFUicsICcwfFsxLTldXFxcXGQqJylcbmNyZWF0ZVRva2VuKCdOVU1FUklDSURFTlRJRklFUkxPT1NFJywgJ1swLTldKycpXG5cbi8vICMjIE5vbi1udW1lcmljIElkZW50aWZpZXJcbi8vIFplcm8gb3IgbW9yZSBkaWdpdHMsIGZvbGxvd2VkIGJ5IGEgbGV0dGVyIG9yIGh5cGhlbiwgYW5kIHRoZW4gemVybyBvclxuLy8gbW9yZSBsZXR0ZXJzLCBkaWdpdHMsIG9yIGh5cGhlbnMuXG5cbmNyZWF0ZVRva2VuKCdOT05OVU1FUklDSURFTlRJRklFUicsICdcXFxcZCpbYS16QS1aLV1bYS16QS1aMC05LV0qJylcblxuLy8gIyMgTWFpbiBWZXJzaW9uXG4vLyBUaHJlZSBkb3Qtc2VwYXJhdGVkIG51bWVyaWMgaWRlbnRpZmllcnMuXG5cbmNyZWF0ZVRva2VuKCdNQUlOVkVSU0lPTicsIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19KVxcXFwuYCArXG4gICAgICAgICAgICAgICAgICAgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfSlgKVxuXG5jcmVhdGVUb2tlbignTUFJTlZFUlNJT05MT09TRScsIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX0pYClcblxuLy8gIyMgUHJlLXJlbGVhc2UgVmVyc2lvbiBJZGVudGlmaWVyXG4vLyBBIG51bWVyaWMgaWRlbnRpZmllciwgb3IgYSBub24tbnVtZXJpYyBpZGVudGlmaWVyLlxuXG5jcmVhdGVUb2tlbignUFJFUkVMRUFTRUlERU5USUZJRVInLCBgKD86JHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl1cbn18JHtzcmNbdC5OT05OVU1FUklDSURFTlRJRklFUl19KWApXG5cbmNyZWF0ZVRva2VuKCdQUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFJywgYCg/OiR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV1cbn18JHtzcmNbdC5OT05OVU1FUklDSURFTlRJRklFUl19KWApXG5cbi8vICMjIFByZS1yZWxlYXNlIFZlcnNpb25cbi8vIEh5cGhlbiwgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgZG90LXNlcGFyYXRlZCBwcmUtcmVsZWFzZSB2ZXJzaW9uXG4vLyBpZGVudGlmaWVycy5cblxuY3JlYXRlVG9rZW4oJ1BSRVJFTEVBU0UnLCBgKD86LSgke3NyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSXVxufSg/OlxcXFwuJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUl19KSopKWApXG5cbmNyZWF0ZVRva2VuKCdQUkVSRUxFQVNFTE9PU0UnLCBgKD86LT8oJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXVxufSg/OlxcXFwuJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXX0pKikpYClcblxuLy8gIyMgQnVpbGQgTWV0YWRhdGEgSWRlbnRpZmllclxuLy8gQW55IGNvbWJpbmF0aW9uIG9mIGRpZ2l0cywgbGV0dGVycywgb3IgaHlwaGVucy5cblxuY3JlYXRlVG9rZW4oJ0JVSUxESURFTlRJRklFUicsICdbMC05QS1aYS16LV0rJylcblxuLy8gIyMgQnVpbGQgTWV0YWRhdGFcbi8vIFBsdXMgc2lnbiwgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgcGVyaW9kLXNlcGFyYXRlZCBidWlsZCBtZXRhZGF0YVxuLy8gaWRlbnRpZmllcnMuXG5cbmNyZWF0ZVRva2VuKCdCVUlMRCcsIGAoPzpcXFxcKygke3NyY1t0LkJVSUxESURFTlRJRklFUl1cbn0oPzpcXFxcLiR7c3JjW3QuQlVJTERJREVOVElGSUVSXX0pKikpYClcblxuLy8gIyMgRnVsbCBWZXJzaW9uIFN0cmluZ1xuLy8gQSBtYWluIHZlcnNpb24sIGZvbGxvd2VkIG9wdGlvbmFsbHkgYnkgYSBwcmUtcmVsZWFzZSB2ZXJzaW9uIGFuZFxuLy8gYnVpbGQgbWV0YWRhdGEuXG5cbi8vIE5vdGUgdGhhdCB0aGUgb25seSBtYWpvciwgbWlub3IsIHBhdGNoLCBhbmQgcHJlLXJlbGVhc2Ugc2VjdGlvbnMgb2Zcbi8vIHRoZSB2ZXJzaW9uIHN0cmluZyBhcmUgY2FwdHVyaW5nIGdyb3Vwcy4gIFRoZSBidWlsZCBtZXRhZGF0YSBpcyBub3QgYVxuLy8gY2FwdHVyaW5nIGdyb3VwLCBiZWNhdXNlIGl0IHNob3VsZCBub3QgZXZlciBiZSB1c2VkIGluIHZlcnNpb25cbi8vIGNvbXBhcmlzb24uXG5cbmNyZWF0ZVRva2VuKCdGVUxMUExBSU4nLCBgdj8ke3NyY1t0Lk1BSU5WRVJTSU9OXVxufSR7c3JjW3QuUFJFUkVMRUFTRV19PyR7XG4gIHNyY1t0LkJVSUxEXX0/YClcblxuY3JlYXRlVG9rZW4oJ0ZVTEwnLCBgXiR7c3JjW3QuRlVMTFBMQUlOXX0kYClcblxuLy8gbGlrZSBmdWxsLCBidXQgYWxsb3dzIHYxLjIuMyBhbmQgPTEuMi4zLCB3aGljaCBwZW9wbGUgZG8gc29tZXRpbWVzLlxuLy8gYWxzbywgMS4wLjBhbHBoYTEgKHByZXJlbGVhc2Ugd2l0aG91dCB0aGUgaHlwaGVuKSB3aGljaCBpcyBwcmV0dHlcbi8vIGNvbW1vbiBpbiB0aGUgbnBtIHJlZ2lzdHJ5LlxuY3JlYXRlVG9rZW4oJ0xPT1NFUExBSU4nLCBgW3Y9XFxcXHNdKiR7c3JjW3QuTUFJTlZFUlNJT05MT09TRV1cbn0ke3NyY1t0LlBSRVJFTEVBU0VMT09TRV19PyR7XG4gIHNyY1t0LkJVSUxEXX0/YClcblxuY3JlYXRlVG9rZW4oJ0xPT1NFJywgYF4ke3NyY1t0LkxPT1NFUExBSU5dfSRgKVxuXG5jcmVhdGVUb2tlbignR1RMVCcsICcoKD86PHw+KT89PyknKVxuXG4vLyBTb21ldGhpbmcgbGlrZSBcIjIuKlwiIG9yIFwiMS4yLnhcIi5cbi8vIE5vdGUgdGhhdCBcIngueFwiIGlzIGEgdmFsaWQgeFJhbmdlIGlkZW50aWZlciwgbWVhbmluZyBcImFueSB2ZXJzaW9uXCJcbi8vIE9ubHkgdGhlIGZpcnN0IGl0ZW0gaXMgc3RyaWN0bHkgcmVxdWlyZWQuXG5jcmVhdGVUb2tlbignWFJBTkdFSURFTlRJRklFUkxPT1NFJywgYCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV19fHh8WHxcXFxcKmApXG5jcmVhdGVUb2tlbignWFJBTkdFSURFTlRJRklFUicsIGAke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXX18eHxYfFxcXFwqYClcblxuY3JlYXRlVG9rZW4oJ1hSQU5HRVBMQUlOJywgYFt2PVxcXFxzXSooJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYCg/OlxcXFwuKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGAoPzpcXFxcLigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJdfSlgICtcbiAgICAgICAgICAgICAgICAgICBgKD86JHtzcmNbdC5QUkVSRUxFQVNFXX0pPyR7XG4gICAgICAgICAgICAgICAgICAgICBzcmNbdC5CVUlMRF19P2AgK1xuICAgICAgICAgICAgICAgICAgIGApPyk/YClcblxuY3JlYXRlVG9rZW4oJ1hSQU5HRVBMQUlOTE9PU0UnLCBgW3Y9XFxcXHNdKigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJMT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCg/OlxcXFwuKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoPzoke3NyY1t0LlBSRVJFTEVBU0VMT09TRV19KT8ke1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNbdC5CVUlMRF19P2AgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCk/KT9gKVxuXG5jcmVhdGVUb2tlbignWFJBTkdFJywgYF4ke3NyY1t0LkdUTFRdfVxcXFxzKiR7c3JjW3QuWFJBTkdFUExBSU5dfSRgKVxuY3JlYXRlVG9rZW4oJ1hSQU5HRUxPT1NFJywgYF4ke3NyY1t0LkdUTFRdfVxcXFxzKiR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19JGApXG5cbi8vIENvZXJjaW9uLlxuLy8gRXh0cmFjdCBhbnl0aGluZyB0aGF0IGNvdWxkIGNvbmNlaXZhYmx5IGJlIGEgcGFydCBvZiBhIHZhbGlkIHNlbXZlclxuY3JlYXRlVG9rZW4oJ0NPRVJDRScsIGAkeycoXnxbXlxcXFxkXSknICtcbiAgICAgICAgICAgICAgJyhcXFxcZHsxLCd9JHtNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIfX0pYCArXG4gICAgICAgICAgICAgIGAoPzpcXFxcLihcXFxcZHsxLCR7TUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSH19KSk/YCArXG4gICAgICAgICAgICAgIGAoPzpcXFxcLihcXFxcZHsxLCR7TUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSH19KSk/YCArXG4gICAgICAgICAgICAgIGAoPzokfFteXFxcXGRdKWApXG5jcmVhdGVUb2tlbignQ09FUkNFUlRMJywgc3JjW3QuQ09FUkNFXSwgdHJ1ZSlcblxuLy8gVGlsZGUgcmFuZ2VzLlxuLy8gTWVhbmluZyBpcyBcInJlYXNvbmFibHkgYXQgb3IgZ3JlYXRlciB0aGFuXCJcbmNyZWF0ZVRva2VuKCdMT05FVElMREUnLCAnKD86fj4/KScpXG5cbmNyZWF0ZVRva2VuKCdUSUxERVRSSU0nLCBgKFxcXFxzKikke3NyY1t0LkxPTkVUSUxERV19XFxcXHMrYCwgdHJ1ZSlcbmV4cG9ydHMudGlsZGVUcmltUmVwbGFjZSA9ICckMX4nXG5cbmNyZWF0ZVRva2VuKCdUSUxERScsIGBeJHtzcmNbdC5MT05FVElMREVdfSR7c3JjW3QuWFJBTkdFUExBSU5dfSRgKVxuY3JlYXRlVG9rZW4oJ1RJTERFTE9PU0UnLCBgXiR7c3JjW3QuTE9ORVRJTERFXX0ke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSRgKVxuXG4vLyBDYXJldCByYW5nZXMuXG4vLyBNZWFuaW5nIGlzIFwiYXQgbGVhc3QgYW5kIGJhY2t3YXJkcyBjb21wYXRpYmxlIHdpdGhcIlxuY3JlYXRlVG9rZW4oJ0xPTkVDQVJFVCcsICcoPzpcXFxcXiknKVxuXG5jcmVhdGVUb2tlbignQ0FSRVRUUklNJywgYChcXFxccyopJHtzcmNbdC5MT05FQ0FSRVRdfVxcXFxzK2AsIHRydWUpXG5leHBvcnRzLmNhcmV0VHJpbVJlcGxhY2UgPSAnJDFeJ1xuXG5jcmVhdGVUb2tlbignQ0FSRVQnLCBgXiR7c3JjW3QuTE9ORUNBUkVUXX0ke3NyY1t0LlhSQU5HRVBMQUlOXX0kYClcbmNyZWF0ZVRva2VuKCdDQVJFVExPT1NFJywgYF4ke3NyY1t0LkxPTkVDQVJFVF19JHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0kYClcblxuLy8gQSBzaW1wbGUgZ3QvbHQvZXEgdGhpbmcsIG9yIGp1c3QgXCJcIiB0byBpbmRpY2F0ZSBcImFueSB2ZXJzaW9uXCJcbmNyZWF0ZVRva2VuKCdDT01QQVJBVE9STE9PU0UnLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqKCR7c3JjW3QuTE9PU0VQTEFJTl19KSR8XiRgKVxuY3JlYXRlVG9rZW4oJ0NPTVBBUkFUT1InLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqKCR7c3JjW3QuRlVMTFBMQUlOXX0pJHxeJGApXG5cbi8vIEFuIGV4cHJlc3Npb24gdG8gc3RyaXAgYW55IHdoaXRlc3BhY2UgYmV0d2VlbiB0aGUgZ3RsdCBhbmQgdGhlIHRoaW5nXG4vLyBpdCBtb2RpZmllcywgc28gdGhhdCBgPiAxLjIuM2AgPT0+IGA+MS4yLjNgXG5jcmVhdGVUb2tlbignQ09NUEFSQVRPUlRSSU0nLCBgKFxcXFxzKikke3NyY1t0LkdUTFRdXG59XFxcXHMqKCR7c3JjW3QuTE9PU0VQTEFJTl19fCR7c3JjW3QuWFJBTkdFUExBSU5dfSlgLCB0cnVlKVxuZXhwb3J0cy5jb21wYXJhdG9yVHJpbVJlcGxhY2UgPSAnJDEkMiQzJ1xuXG4vLyBTb21ldGhpbmcgbGlrZSBgMS4yLjMgLSAxLjIuNGBcbi8vIE5vdGUgdGhhdCB0aGVzZSBhbGwgdXNlIHRoZSBsb29zZSBmb3JtLCBiZWNhdXNlIHRoZXknbGwgYmVcbi8vIGNoZWNrZWQgYWdhaW5zdCBlaXRoZXIgdGhlIHN0cmljdCBvciBsb29zZSBjb21wYXJhdG9yIGZvcm1cbi8vIGxhdGVyLlxuY3JlYXRlVG9rZW4oJ0hZUEhFTlJBTkdFJywgYF5cXFxccyooJHtzcmNbdC5YUkFOR0VQTEFJTl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGBcXFxccystXFxcXHMrYCArXG4gICAgICAgICAgICAgICAgICAgYCgke3NyY1t0LlhSQU5HRVBMQUlOXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYFxcXFxzKiRgKVxuXG5jcmVhdGVUb2tlbignSFlQSEVOUkFOR0VMT09TRScsIGBeXFxcXHMqKCR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYFxcXFxzKy1cXFxccytgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgXFxcXHMqJGApXG5cbi8vIFN0YXIgcmFuZ2VzIGJhc2ljYWxseSBqdXN0IGFsbG93IGFueXRoaW5nIGF0IGFsbC5cbmNyZWF0ZVRva2VuKCdTVEFSJywgJyg8fD4pPz0/XFxcXHMqXFxcXConKVxuLy8gPj0wLjAuMCBpcyBsaWtlIGEgc3RhclxuY3JlYXRlVG9rZW4oJ0dURTAnLCAnXlxcXFxzKj49XFxcXHMqMFxcLjBcXC4wXFxcXHMqJCcpXG5jcmVhdGVUb2tlbignR1RFMFBSRScsICdeXFxcXHMqPj1cXFxccyowXFwuMFxcLjAtMFxcXFxzKiQnKVxuIiwiLy8gcGFyc2Ugb3V0IGp1c3QgdGhlIG9wdGlvbnMgd2UgY2FyZSBhYm91dCBzbyB3ZSBhbHdheXMgZ2V0IGEgY29uc2lzdGVudFxuLy8gb2JqIHdpdGgga2V5cyBpbiBhIGNvbnNpc3RlbnQgb3JkZXIuXG5jb25zdCBvcHRzID0gWydpbmNsdWRlUHJlcmVsZWFzZScsICdsb29zZScsICdydGwnXVxuY29uc3QgcGFyc2VPcHRpb25zID0gb3B0aW9ucyA9PlxuICAhb3B0aW9ucyA/IHt9XG4gIDogdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnID8geyBsb29zZTogdHJ1ZSB9XG4gIDogb3B0cy5maWx0ZXIoayA9PiBvcHRpb25zW2tdKS5yZWR1Y2UoKG9wdGlvbnMsIGspID0+IHtcbiAgICBvcHRpb25zW2tdID0gdHJ1ZVxuICAgIHJldHVybiBvcHRpb25zXG4gIH0sIHt9KVxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZU9wdGlvbnNcbiIsImNvbnN0IG51bWVyaWMgPSAvXlswLTldKyQvXG5jb25zdCBjb21wYXJlSWRlbnRpZmllcnMgPSAoYSwgYikgPT4ge1xuICBjb25zdCBhbnVtID0gbnVtZXJpYy50ZXN0KGEpXG4gIGNvbnN0IGJudW0gPSBudW1lcmljLnRlc3QoYilcblxuICBpZiAoYW51bSAmJiBibnVtKSB7XG4gICAgYSA9ICthXG4gICAgYiA9ICtiXG4gIH1cblxuICByZXR1cm4gYSA9PT0gYiA/IDBcbiAgICA6IChhbnVtICYmICFibnVtKSA/IC0xXG4gICAgOiAoYm51bSAmJiAhYW51bSkgPyAxXG4gICAgOiBhIDwgYiA/IC0xXG4gICAgOiAxXG59XG5cbmNvbnN0IHJjb21wYXJlSWRlbnRpZmllcnMgPSAoYSwgYikgPT4gY29tcGFyZUlkZW50aWZpZXJzKGIsIGEpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb21wYXJlSWRlbnRpZmllcnMsXG4gIHJjb21wYXJlSWRlbnRpZmllcnNcbn1cbiIsImNvbnN0IGRlYnVnID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvZGVidWcnKVxuY29uc3QgeyBNQVhfTEVOR1RILCBNQVhfU0FGRV9JTlRFR0VSIH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9jb25zdGFudHMnKVxuY29uc3QgeyByZSwgdCB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcmUnKVxuXG5jb25zdCBwYXJzZU9wdGlvbnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9wYXJzZS1vcHRpb25zJylcbmNvbnN0IHsgY29tcGFyZUlkZW50aWZpZXJzIH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9pZGVudGlmaWVycycpXG5jbGFzcyBTZW1WZXIge1xuICBjb25zdHJ1Y3RvciAodmVyc2lvbiwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBwYXJzZU9wdGlvbnMob3B0aW9ucylcblxuICAgIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgICBpZiAodmVyc2lvbi5sb29zZSA9PT0gISFvcHRpb25zLmxvb3NlICYmXG4gICAgICAgICAgdmVyc2lvbi5pbmNsdWRlUHJlcmVsZWFzZSA9PT0gISFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKSB7XG4gICAgICAgIHJldHVybiB2ZXJzaW9uXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2ZXJzaW9uID0gdmVyc2lvbi52ZXJzaW9uXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmVyc2lvbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgVmVyc2lvbjogJHt2ZXJzaW9ufWApXG4gICAgfVxuXG4gICAgaWYgKHZlcnNpb24ubGVuZ3RoID4gTUFYX0xFTkdUSCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgYHZlcnNpb24gaXMgbG9uZ2VyIHRoYW4gJHtNQVhfTEVOR1RIfSBjaGFyYWN0ZXJzYFxuICAgICAgKVxuICAgIH1cblxuICAgIGRlYnVnKCdTZW1WZXInLCB2ZXJzaW9uLCBvcHRpb25zKVxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlXG4gICAgLy8gdGhpcyBpc24ndCBhY3R1YWxseSByZWxldmFudCBmb3IgdmVyc2lvbnMsIGJ1dCBrZWVwIGl0IHNvIHRoYXQgd2VcbiAgICAvLyBkb24ndCBydW4gaW50byB0cm91YmxlIHBhc3NpbmcgdGhpcy5vcHRpb25zIGFyb3VuZC5cbiAgICB0aGlzLmluY2x1ZGVQcmVyZWxlYXNlID0gISFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlXG5cbiAgICBjb25zdCBtID0gdmVyc2lvbi50cmltKCkubWF0Y2gob3B0aW9ucy5sb29zZSA/IHJlW3QuTE9PU0VdIDogcmVbdC5GVUxMXSlcblxuICAgIGlmICghbSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBWZXJzaW9uOiAke3ZlcnNpb259YClcbiAgICB9XG5cbiAgICB0aGlzLnJhdyA9IHZlcnNpb25cblxuICAgIC8vIHRoZXNlIGFyZSBhY3R1YWxseSBudW1iZXJzXG4gICAgdGhpcy5tYWpvciA9ICttWzFdXG4gICAgdGhpcy5taW5vciA9ICttWzJdXG4gICAgdGhpcy5wYXRjaCA9ICttWzNdXG5cbiAgICBpZiAodGhpcy5tYWpvciA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5tYWpvciA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbWFqb3IgdmVyc2lvbicpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWlub3IgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMubWlub3IgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG1pbm9yIHZlcnNpb24nKVxuICAgIH1cblxuICAgIGlmICh0aGlzLnBhdGNoID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLnBhdGNoIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBwYXRjaCB2ZXJzaW9uJylcbiAgICB9XG5cbiAgICAvLyBudW1iZXJpZnkgYW55IHByZXJlbGVhc2UgbnVtZXJpYyBpZHNcbiAgICBpZiAoIW1bNF0pIHtcbiAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJlcmVsZWFzZSA9IG1bNF0uc3BsaXQoJy4nKS5tYXAoKGlkKSA9PiB7XG4gICAgICAgIGlmICgvXlswLTldKyQvLnRlc3QoaWQpKSB7XG4gICAgICAgICAgY29uc3QgbnVtID0gK2lkXG4gICAgICAgICAgaWYgKG51bSA+PSAwICYmIG51bSA8IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRoaXMuYnVpbGQgPSBtWzVdID8gbVs1XS5zcGxpdCgnLicpIDogW11cbiAgICB0aGlzLmZvcm1hdCgpXG4gIH1cblxuICBmb3JtYXQgKCkge1xuICAgIHRoaXMudmVyc2lvbiA9IGAke3RoaXMubWFqb3J9LiR7dGhpcy5taW5vcn0uJHt0aGlzLnBhdGNofWBcbiAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgdGhpcy52ZXJzaW9uICs9IGAtJHt0aGlzLnByZXJlbGVhc2Uuam9pbignLicpfWBcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudmVyc2lvblxuICB9XG5cbiAgdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLnZlcnNpb25cbiAgfVxuXG4gIGNvbXBhcmUgKG90aGVyKSB7XG4gICAgZGVidWcoJ1NlbVZlci5jb21wYXJlJywgdGhpcy52ZXJzaW9uLCB0aGlzLm9wdGlvbnMsIG90aGVyKVxuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgICAgaWYgKHR5cGVvZiBvdGhlciA9PT0gJ3N0cmluZycgJiYgb3RoZXIgPT09IHRoaXMudmVyc2lvbikge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfVxuICAgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gICAgfVxuXG4gICAgaWYgKG90aGVyLnZlcnNpb24gPT09IHRoaXMudmVyc2lvbikge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jb21wYXJlTWFpbihvdGhlcikgfHwgdGhpcy5jb21wYXJlUHJlKG90aGVyKVxuICB9XG5cbiAgY29tcGFyZU1haW4gKG90aGVyKSB7XG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucylcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgY29tcGFyZUlkZW50aWZpZXJzKHRoaXMubWFqb3IsIG90aGVyLm1ham9yKSB8fFxuICAgICAgY29tcGFyZUlkZW50aWZpZXJzKHRoaXMubWlub3IsIG90aGVyLm1pbm9yKSB8fFxuICAgICAgY29tcGFyZUlkZW50aWZpZXJzKHRoaXMucGF0Y2gsIG90aGVyLnBhdGNoKVxuICAgIClcbiAgfVxuXG4gIGNvbXBhcmVQcmUgKG90aGVyKSB7XG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucylcbiAgICB9XG5cbiAgICAvLyBOT1QgaGF2aW5nIGEgcHJlcmVsZWFzZSBpcyA+IGhhdmluZyBvbmVcbiAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3RoZXIucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH0gZWxzZSBpZiAoIXRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgb3RoZXIucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAxXG4gICAgfSBlbHNlIGlmICghdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3RoZXIucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuXG4gICAgbGV0IGkgPSAwXG4gICAgZG8ge1xuICAgICAgY29uc3QgYSA9IHRoaXMucHJlcmVsZWFzZVtpXVxuICAgICAgY29uc3QgYiA9IG90aGVyLnByZXJlbGVhc2VbaV1cbiAgICAgIGRlYnVnKCdwcmVyZWxlYXNlIGNvbXBhcmUnLCBpLCBhLCBiKVxuICAgICAgaWYgKGEgPT09IHVuZGVmaW5lZCAmJiBiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAxXG4gICAgICB9IGVsc2UgaWYgKGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gYikge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVJZGVudGlmaWVycyhhLCBiKVxuICAgICAgfVxuICAgIH0gd2hpbGUgKCsraSlcbiAgfVxuXG4gIGNvbXBhcmVCdWlsZCAob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIGxldCBpID0gMFxuICAgIGRvIHtcbiAgICAgIGNvbnN0IGEgPSB0aGlzLmJ1aWxkW2ldXG4gICAgICBjb25zdCBiID0gb3RoZXIuYnVpbGRbaV1cbiAgICAgIGRlYnVnKCdwcmVyZWxlYXNlIGNvbXBhcmUnLCBpLCBhLCBiKVxuICAgICAgaWYgKGEgPT09IHVuZGVmaW5lZCAmJiBiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAxXG4gICAgICB9IGVsc2UgaWYgKGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gYikge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVJZGVudGlmaWVycyhhLCBiKVxuICAgICAgfVxuICAgIH0gd2hpbGUgKCsraSlcbiAgfVxuXG4gIC8vIHByZW1pbm9yIHdpbGwgYnVtcCB0aGUgdmVyc2lvbiB1cCB0byB0aGUgbmV4dCBtaW5vciByZWxlYXNlLCBhbmQgaW1tZWRpYXRlbHlcbiAgLy8gZG93biB0byBwcmUtcmVsZWFzZS4gcHJlbWFqb3IgYW5kIHByZXBhdGNoIHdvcmsgdGhlIHNhbWUgd2F5LlxuICBpbmMgKHJlbGVhc2UsIGlkZW50aWZpZXIpIHtcbiAgICBzd2l0Y2ggKHJlbGVhc2UpIHtcbiAgICAgIGNhc2UgJ3ByZW1ham9yJzpcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDBcbiAgICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgICAgdGhpcy5taW5vciA9IDBcbiAgICAgICAgdGhpcy5tYWpvcisrXG4gICAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncHJlbWlub3InOlxuICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMFxuICAgICAgICB0aGlzLnBhdGNoID0gMFxuICAgICAgICB0aGlzLm1pbm9yKytcbiAgICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdwcmVwYXRjaCc6XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYWxyZWFkeSBhIHByZXJlbGVhc2UsIGl0IHdpbGwgYnVtcCB0byB0aGUgbmV4dCB2ZXJzaW9uXG4gICAgICAgIC8vIGRyb3AgYW55IHByZXJlbGVhc2VzIHRoYXQgbWlnaHQgYWxyZWFkeSBleGlzdCwgc2luY2UgdGhleSBhcmUgbm90XG4gICAgICAgIC8vIHJlbGV2YW50IGF0IHRoaXMgcG9pbnQuXG4gICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwXG4gICAgICAgIHRoaXMuaW5jKCdwYXRjaCcsIGlkZW50aWZpZXIpXG4gICAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKVxuICAgICAgICBicmVha1xuICAgICAgLy8gSWYgdGhlIGlucHV0IGlzIGEgbm9uLXByZXJlbGVhc2UgdmVyc2lvbiwgdGhpcyBhY3RzIHRoZSBzYW1lIGFzXG4gICAgICAvLyBwcmVwYXRjaC5cbiAgICAgIGNhc2UgJ3ByZXJlbGVhc2UnOlxuICAgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuaW5jKCdwYXRjaCcsIGlkZW50aWZpZXIpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgJ21ham9yJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZS1tYWpvciB2ZXJzaW9uLCBidW1wIHVwIHRvIHRoZSBzYW1lIG1ham9yIHZlcnNpb24uXG4gICAgICAgIC8vIE90aGVyd2lzZSBpbmNyZW1lbnQgbWFqb3IuXG4gICAgICAgIC8vIDEuMC4wLTUgYnVtcHMgdG8gMS4wLjBcbiAgICAgICAgLy8gMS4xLjAgYnVtcHMgdG8gMi4wLjBcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMubWlub3IgIT09IDAgfHxcbiAgICAgICAgICB0aGlzLnBhdGNoICE9PSAwIHx8XG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMFxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLm1ham9yKytcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1pbm9yID0gMFxuICAgICAgICB0aGlzLnBhdGNoID0gMFxuICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnbWlub3InOlxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgcHJlLW1pbm9yIHZlcnNpb24sIGJ1bXAgdXAgdG8gdGhlIHNhbWUgbWlub3IgdmVyc2lvbi5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGluY3JlbWVudCBtaW5vci5cbiAgICAgICAgLy8gMS4yLjAtNSBidW1wcyB0byAxLjIuMFxuICAgICAgICAvLyAxLjIuMSBidW1wcyB0byAxLjMuMFxuICAgICAgICBpZiAodGhpcy5wYXRjaCAhPT0gMCB8fCB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5taW5vcisrXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3BhdGNoJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBub3QgYSBwcmUtcmVsZWFzZSB2ZXJzaW9uLCBpdCB3aWxsIGluY3JlbWVudCB0aGUgcGF0Y2guXG4gICAgICAgIC8vIElmIGl0IGlzIGEgcHJlLXJlbGVhc2UgaXQgd2lsbCBidW1wIHVwIHRvIHRoZSBzYW1lIHBhdGNoIHZlcnNpb24uXG4gICAgICAgIC8vIDEuMi4wLTUgcGF0Y2hlcyB0byAxLjIuMFxuICAgICAgICAvLyAxLjIuMCBwYXRjaGVzIHRvIDEuMi4xXG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5wYXRjaCsrXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICAgICAgYnJlYWtcbiAgICAgIC8vIFRoaXMgcHJvYmFibHkgc2hvdWxkbid0IGJlIHVzZWQgcHVibGljbHkuXG4gICAgICAvLyAxLjAuMCAncHJlJyB3b3VsZCBiZWNvbWUgMS4wLjAtMCB3aGljaCBpcyB0aGUgd3JvbmcgZGlyZWN0aW9uLlxuICAgICAgY2FzZSAncHJlJzpcbiAgICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbMF1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgaSA9IHRoaXMucHJlcmVsZWFzZS5sZW5ndGhcbiAgICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcmVyZWxlYXNlW2ldID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICB0aGlzLnByZXJlbGVhc2VbaV0rK1xuICAgICAgICAgICAgICBpID0gLTJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBkaWRuJ3QgaW5jcmVtZW50IGFueXRoaW5nXG4gICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UucHVzaCgwKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaWRlbnRpZmllcikge1xuICAgICAgICAgIC8vIDEuMi4wLWJldGEuMSBidW1wcyB0byAxLjIuMC1iZXRhLjIsXG4gICAgICAgICAgLy8gMS4yLjAtYmV0YS5mb29ibHogb3IgMS4yLjAtYmV0YSBidW1wcyB0byAxLjIuMC1iZXRhLjBcbiAgICAgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlWzBdID09PSBpZGVudGlmaWVyKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4odGhpcy5wcmVyZWxlYXNlWzFdKSkge1xuICAgICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbaWRlbnRpZmllciwgMF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW2lkZW50aWZpZXIsIDBdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbmNyZW1lbnQgYXJndW1lbnQ6ICR7cmVsZWFzZX1gKVxuICAgIH1cbiAgICB0aGlzLmZvcm1hdCgpXG4gICAgdGhpcy5yYXcgPSB0aGlzLnZlcnNpb25cbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VtVmVyXG4iLCJjb25zdCB7TUFYX0xFTkdUSH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9jb25zdGFudHMnKVxuY29uc3QgeyByZSwgdCB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcmUnKVxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuXG5jb25zdCBwYXJzZU9wdGlvbnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9wYXJzZS1vcHRpb25zJylcbmNvbnN0IHBhcnNlID0gKHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKVxuXG4gIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgcmV0dXJuIHZlcnNpb25cbiAgfVxuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgaWYgKHZlcnNpb24ubGVuZ3RoID4gTUFYX0xFTkdUSCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCByID0gb3B0aW9ucy5sb29zZSA/IHJlW3QuTE9PU0VdIDogcmVbdC5GVUxMXVxuICBpZiAoIXIudGVzdCh2ZXJzaW9uKSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBuZXcgU2VtVmVyKHZlcnNpb24sIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlXG4iLCJjb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgdmFsaWQgPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBjb25zdCB2ID0gcGFyc2UodmVyc2lvbiwgb3B0aW9ucylcbiAgcmV0dXJuIHYgPyB2LnZlcnNpb24gOiBudWxsXG59XG5tb2R1bGUuZXhwb3J0cyA9IHZhbGlkXG4iLCJjb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgY2xlYW4gPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBzID0gcGFyc2UodmVyc2lvbi50cmltKCkucmVwbGFjZSgvXls9dl0rLywgJycpLCBvcHRpb25zKVxuICByZXR1cm4gcyA/IHMudmVyc2lvbiA6IG51bGxcbn1cbm1vZHVsZS5leHBvcnRzID0gY2xlYW5cbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcblxuY29uc3QgaW5jID0gKHZlcnNpb24sIHJlbGVhc2UsIG9wdGlvbnMsIGlkZW50aWZpZXIpID0+IHtcbiAgaWYgKHR5cGVvZiAob3B0aW9ucykgPT09ICdzdHJpbmcnKSB7XG4gICAgaWRlbnRpZmllciA9IG9wdGlvbnNcbiAgICBvcHRpb25zID0gdW5kZWZpbmVkXG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBuZXcgU2VtVmVyKHZlcnNpb24sIG9wdGlvbnMpLmluYyhyZWxlYXNlLCBpZGVudGlmaWVyKS52ZXJzaW9uXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBpbmNcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IGNvbXBhcmUgPSAoYSwgYiwgbG9vc2UpID0+XG4gIG5ldyBTZW1WZXIoYSwgbG9vc2UpLmNvbXBhcmUobmV3IFNlbVZlcihiLCBsb29zZSkpXG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZVxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBlcSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgPT09IDBcbm1vZHVsZS5leHBvcnRzID0gZXFcbiIsImNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCBlcSA9IHJlcXVpcmUoJy4vZXEnKVxuXG5jb25zdCBkaWZmID0gKHZlcnNpb24xLCB2ZXJzaW9uMikgPT4ge1xuICBpZiAoZXEodmVyc2lvbjEsIHZlcnNpb24yKSkge1xuICAgIHJldHVybiBudWxsXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdjEgPSBwYXJzZSh2ZXJzaW9uMSlcbiAgICBjb25zdCB2MiA9IHBhcnNlKHZlcnNpb24yKVxuICAgIGNvbnN0IGhhc1ByZSA9IHYxLnByZXJlbGVhc2UubGVuZ3RoIHx8IHYyLnByZXJlbGVhc2UubGVuZ3RoXG4gICAgY29uc3QgcHJlZml4ID0gaGFzUHJlID8gJ3ByZScgOiAnJ1xuICAgIGNvbnN0IGRlZmF1bHRSZXN1bHQgPSBoYXNQcmUgPyAncHJlcmVsZWFzZScgOiAnJ1xuICAgIGZvciAoY29uc3Qga2V5IGluIHYxKSB7XG4gICAgICBpZiAoa2V5ID09PSAnbWFqb3InIHx8IGtleSA9PT0gJ21pbm9yJyB8fCBrZXkgPT09ICdwYXRjaCcpIHtcbiAgICAgICAgaWYgKHYxW2tleV0gIT09IHYyW2tleV0pIHtcbiAgICAgICAgICByZXR1cm4gcHJlZml4ICsga2V5XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRSZXN1bHQgLy8gbWF5IGJlIHVuZGVmaW5lZFxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGRpZmZcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IG1ham9yID0gKGEsIGxvb3NlKSA9PiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5tYWpvclxubW9kdWxlLmV4cG9ydHMgPSBtYWpvclxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgbWlub3IgPSAoYSwgbG9vc2UpID0+IG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1pbm9yXG5tb2R1bGUuZXhwb3J0cyA9IG1pbm9yXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBwYXRjaCA9IChhLCBsb29zZSkgPT4gbmV3IFNlbVZlcihhLCBsb29zZSkucGF0Y2hcbm1vZHVsZS5leHBvcnRzID0gcGF0Y2hcbiIsImNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCBwcmVyZWxlYXNlID0gKHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgcGFyc2VkID0gcGFyc2UodmVyc2lvbiwgb3B0aW9ucylcbiAgcmV0dXJuIChwYXJzZWQgJiYgcGFyc2VkLnByZXJlbGVhc2UubGVuZ3RoKSA/IHBhcnNlZC5wcmVyZWxlYXNlIDogbnVsbFxufVxubW9kdWxlLmV4cG9ydHMgPSBwcmVyZWxlYXNlXG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IHJjb21wYXJlID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGIsIGEsIGxvb3NlKVxubW9kdWxlLmV4cG9ydHMgPSByY29tcGFyZVxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBjb21wYXJlTG9vc2UgPSAoYSwgYikgPT4gY29tcGFyZShhLCBiLCB0cnVlKVxubW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlTG9vc2VcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IGNvbXBhcmVCdWlsZCA9IChhLCBiLCBsb29zZSkgPT4ge1xuICBjb25zdCB2ZXJzaW9uQSA9IG5ldyBTZW1WZXIoYSwgbG9vc2UpXG4gIGNvbnN0IHZlcnNpb25CID0gbmV3IFNlbVZlcihiLCBsb29zZSlcbiAgcmV0dXJuIHZlcnNpb25BLmNvbXBhcmUodmVyc2lvbkIpIHx8IHZlcnNpb25BLmNvbXBhcmVCdWlsZCh2ZXJzaW9uQilcbn1cbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZUJ1aWxkXG4iLCJjb25zdCBjb21wYXJlQnVpbGQgPSByZXF1aXJlKCcuL2NvbXBhcmUtYnVpbGQnKVxuY29uc3Qgc29ydCA9IChsaXN0LCBsb29zZSkgPT4gbGlzdC5zb3J0KChhLCBiKSA9PiBjb21wYXJlQnVpbGQoYSwgYiwgbG9vc2UpKVxubW9kdWxlLmV4cG9ydHMgPSBzb3J0XG4iLCJjb25zdCBjb21wYXJlQnVpbGQgPSByZXF1aXJlKCcuL2NvbXBhcmUtYnVpbGQnKVxuY29uc3QgcnNvcnQgPSAobGlzdCwgbG9vc2UpID0+IGxpc3Quc29ydCgoYSwgYikgPT4gY29tcGFyZUJ1aWxkKGIsIGEsIGxvb3NlKSlcbm1vZHVsZS5leHBvcnRzID0gcnNvcnRcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgZ3QgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpID4gMFxubW9kdWxlLmV4cG9ydHMgPSBndFxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBsdCA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgPCAwXG5tb2R1bGUuZXhwb3J0cyA9IGx0XG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IG5lcSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgIT09IDBcbm1vZHVsZS5leHBvcnRzID0gbmVxXG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGd0ZSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgPj0gMFxubW9kdWxlLmV4cG9ydHMgPSBndGVcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgbHRlID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA8PSAwXG5tb2R1bGUuZXhwb3J0cyA9IGx0ZVxuIiwiY29uc3QgZXEgPSByZXF1aXJlKCcuL2VxJylcbmNvbnN0IG5lcSA9IHJlcXVpcmUoJy4vbmVxJylcbmNvbnN0IGd0ID0gcmVxdWlyZSgnLi9ndCcpXG5jb25zdCBndGUgPSByZXF1aXJlKCcuL2d0ZScpXG5jb25zdCBsdCA9IHJlcXVpcmUoJy4vbHQnKVxuY29uc3QgbHRlID0gcmVxdWlyZSgnLi9sdGUnKVxuXG5jb25zdCBjbXAgPSAoYSwgb3AsIGIsIGxvb3NlKSA9PiB7XG4gIHN3aXRjaCAob3ApIHtcbiAgICBjYXNlICc9PT0nOlxuICAgICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JylcbiAgICAgICAgYSA9IGEudmVyc2lvblxuICAgICAgaWYgKHR5cGVvZiBiID09PSAnb2JqZWN0JylcbiAgICAgICAgYiA9IGIudmVyc2lvblxuICAgICAgcmV0dXJuIGEgPT09IGJcblxuICAgIGNhc2UgJyE9PSc6XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKVxuICAgICAgICBhID0gYS52ZXJzaW9uXG4gICAgICBpZiAodHlwZW9mIGIgPT09ICdvYmplY3QnKVxuICAgICAgICBiID0gYi52ZXJzaW9uXG4gICAgICByZXR1cm4gYSAhPT0gYlxuXG4gICAgY2FzZSAnJzpcbiAgICBjYXNlICc9JzpcbiAgICBjYXNlICc9PSc6XG4gICAgICByZXR1cm4gZXEoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICchPSc6XG4gICAgICByZXR1cm4gbmVxKGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPic6XG4gICAgICByZXR1cm4gZ3QoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICc+PSc6XG4gICAgICByZXR1cm4gZ3RlKGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPCc6XG4gICAgICByZXR1cm4gbHQoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICc8PSc6XG4gICAgICByZXR1cm4gbHRlKGEsIGIsIGxvb3NlKVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgb3BlcmF0b3I6ICR7b3B9YClcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBjbXBcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCB7cmUsIHR9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcmUnKVxuXG5jb25zdCBjb2VyY2UgPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcikge1xuICAgIHJldHVybiB2ZXJzaW9uXG4gIH1cblxuICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdudW1iZXInKSB7XG4gICAgdmVyc2lvbiA9IFN0cmluZyh2ZXJzaW9uKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIGxldCBtYXRjaCA9IG51bGxcbiAgaWYgKCFvcHRpb25zLnJ0bCkge1xuICAgIG1hdGNoID0gdmVyc2lvbi5tYXRjaChyZVt0LkNPRVJDRV0pXG4gIH0gZWxzZSB7XG4gICAgLy8gRmluZCB0aGUgcmlnaHQtbW9zdCBjb2VyY2libGUgc3RyaW5nIHRoYXQgZG9lcyBub3Qgc2hhcmVcbiAgICAvLyBhIHRlcm1pbnVzIHdpdGggYSBtb3JlIGxlZnQtd2FyZCBjb2VyY2libGUgc3RyaW5nLlxuICAgIC8vIEVnLCAnMS4yLjMuNCcgd2FudHMgdG8gY29lcmNlICcyLjMuNCcsIG5vdCAnMy40JyBvciAnNCdcbiAgICAvL1xuICAgIC8vIFdhbGsgdGhyb3VnaCB0aGUgc3RyaW5nIGNoZWNraW5nIHdpdGggYSAvZyByZWdleHBcbiAgICAvLyBNYW51YWxseSBzZXQgdGhlIGluZGV4IHNvIGFzIHRvIHBpY2sgdXAgb3ZlcmxhcHBpbmcgbWF0Y2hlcy5cbiAgICAvLyBTdG9wIHdoZW4gd2UgZ2V0IGEgbWF0Y2ggdGhhdCBlbmRzIGF0IHRoZSBzdHJpbmcgZW5kLCBzaW5jZSBub1xuICAgIC8vIGNvZXJjaWJsZSBzdHJpbmcgY2FuIGJlIG1vcmUgcmlnaHQtd2FyZCB3aXRob3V0IHRoZSBzYW1lIHRlcm1pbnVzLlxuICAgIGxldCBuZXh0XG4gICAgd2hpbGUgKChuZXh0ID0gcmVbdC5DT0VSQ0VSVExdLmV4ZWModmVyc2lvbikpICYmXG4gICAgICAgICghbWF0Y2ggfHwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggIT09IHZlcnNpb24ubGVuZ3RoKVxuICAgICkge1xuICAgICAgaWYgKCFtYXRjaCB8fFxuICAgICAgICAgICAgbmV4dC5pbmRleCArIG5leHRbMF0ubGVuZ3RoICE9PSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCkge1xuICAgICAgICBtYXRjaCA9IG5leHRcbiAgICAgIH1cbiAgICAgIHJlW3QuQ09FUkNFUlRMXS5sYXN0SW5kZXggPSBuZXh0LmluZGV4ICsgbmV4dFsxXS5sZW5ndGggKyBuZXh0WzJdLmxlbmd0aFxuICAgIH1cbiAgICAvLyBsZWF2ZSBpdCBpbiBhIGNsZWFuIHN0YXRlXG4gICAgcmVbdC5DT0VSQ0VSVExdLmxhc3RJbmRleCA9IC0xXG4gIH1cblxuICBpZiAobWF0Y2ggPT09IG51bGwpXG4gICAgcmV0dXJuIG51bGxcblxuICByZXR1cm4gcGFyc2UoYCR7bWF0Y2hbMl19LiR7bWF0Y2hbM10gfHwgJzAnfS4ke21hdGNoWzRdIHx8ICcwJ31gLCBvcHRpb25zKVxufVxubW9kdWxlLmV4cG9ydHMgPSBjb2VyY2VcbiIsIid1c2Ugc3RyaWN0J1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoWWFsbGlzdCkge1xuICBZYWxsaXN0LnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24qICgpIHtcbiAgICBmb3IgKGxldCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlcjsgd2Fsa2VyID0gd2Fsa2VyLm5leHQpIHtcbiAgICAgIHlpZWxkIHdhbGtlci52YWx1ZVxuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5tb2R1bGUuZXhwb3J0cyA9IFlhbGxpc3RcblxuWWFsbGlzdC5Ob2RlID0gTm9kZVxuWWFsbGlzdC5jcmVhdGUgPSBZYWxsaXN0XG5cbmZ1bmN0aW9uIFlhbGxpc3QgKGxpc3QpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghKHNlbGYgaW5zdGFuY2VvZiBZYWxsaXN0KSkge1xuICAgIHNlbGYgPSBuZXcgWWFsbGlzdCgpXG4gIH1cblxuICBzZWxmLnRhaWwgPSBudWxsXG4gIHNlbGYuaGVhZCA9IG51bGxcbiAgc2VsZi5sZW5ndGggPSAwXG5cbiAgaWYgKGxpc3QgJiYgdHlwZW9mIGxpc3QuZm9yRWFjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgc2VsZi5wdXNoKGl0ZW0pXG4gICAgfSlcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgc2VsZi5wdXNoKGFyZ3VtZW50c1tpXSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2VsZlxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZW1vdmVOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKG5vZGUubGlzdCAhPT0gdGhpcykge1xuICAgIHRocm93IG5ldyBFcnJvcigncmVtb3Zpbmcgbm9kZSB3aGljaCBkb2VzIG5vdCBiZWxvbmcgdG8gdGhpcyBsaXN0JylcbiAgfVxuXG4gIHZhciBuZXh0ID0gbm9kZS5uZXh0XG4gIHZhciBwcmV2ID0gbm9kZS5wcmV2XG5cbiAgaWYgKG5leHQpIHtcbiAgICBuZXh0LnByZXYgPSBwcmV2XG4gIH1cblxuICBpZiAocHJldikge1xuICAgIHByZXYubmV4dCA9IG5leHRcbiAgfVxuXG4gIGlmIChub2RlID09PSB0aGlzLmhlYWQpIHtcbiAgICB0aGlzLmhlYWQgPSBuZXh0XG4gIH1cbiAgaWYgKG5vZGUgPT09IHRoaXMudGFpbCkge1xuICAgIHRoaXMudGFpbCA9IHByZXZcbiAgfVxuXG4gIG5vZGUubGlzdC5sZW5ndGgtLVxuICBub2RlLm5leHQgPSBudWxsXG4gIG5vZGUucHJldiA9IG51bGxcbiAgbm9kZS5saXN0ID0gbnVsbFxuXG4gIHJldHVybiBuZXh0XG59XG5cbllhbGxpc3QucHJvdG90eXBlLnVuc2hpZnROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKG5vZGUgPT09IHRoaXMuaGVhZCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKG5vZGUubGlzdCkge1xuICAgIG5vZGUubGlzdC5yZW1vdmVOb2RlKG5vZGUpXG4gIH1cblxuICB2YXIgaGVhZCA9IHRoaXMuaGVhZFxuICBub2RlLmxpc3QgPSB0aGlzXG4gIG5vZGUubmV4dCA9IGhlYWRcbiAgaWYgKGhlYWQpIHtcbiAgICBoZWFkLnByZXYgPSBub2RlXG4gIH1cblxuICB0aGlzLmhlYWQgPSBub2RlXG4gIGlmICghdGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsID0gbm9kZVxuICB9XG4gIHRoaXMubGVuZ3RoKytcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucHVzaE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZSA9PT0gdGhpcy50YWlsKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAobm9kZS5saXN0KSB7XG4gICAgbm9kZS5saXN0LnJlbW92ZU5vZGUobm9kZSlcbiAgfVxuXG4gIHZhciB0YWlsID0gdGhpcy50YWlsXG4gIG5vZGUubGlzdCA9IHRoaXNcbiAgbm9kZS5wcmV2ID0gdGFpbFxuICBpZiAodGFpbCkge1xuICAgIHRhaWwubmV4dCA9IG5vZGVcbiAgfVxuXG4gIHRoaXMudGFpbCA9IG5vZGVcbiAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICB0aGlzLmhlYWQgPSBub2RlXG4gIH1cbiAgdGhpcy5sZW5ndGgrK1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBwdXNoKHRoaXMsIGFyZ3VtZW50c1tpXSlcbiAgfVxuICByZXR1cm4gdGhpcy5sZW5ndGhcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdW5zaGlmdCh0aGlzLCBhcmd1bWVudHNbaV0pXG4gIH1cbiAgcmV0dXJuIHRoaXMubGVuZ3RoXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLnRhaWwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICB2YXIgcmVzID0gdGhpcy50YWlsLnZhbHVlXG4gIHRoaXMudGFpbCA9IHRoaXMudGFpbC5wcmV2XG4gIGlmICh0aGlzLnRhaWwpIHtcbiAgICB0aGlzLnRhaWwubmV4dCA9IG51bGxcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmhlYWQgPSBudWxsXG4gIH1cbiAgdGhpcy5sZW5ndGgtLVxuICByZXR1cm4gcmVzXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuaGVhZCkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIHZhciByZXMgPSB0aGlzLmhlYWQudmFsdWVcbiAgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHRcbiAgaWYgKHRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZC5wcmV2ID0gbnVsbFxuICB9IGVsc2Uge1xuICAgIHRoaXMudGFpbCA9IG51bGxcbiAgfVxuICB0aGlzLmxlbmd0aC0tXG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMuaGVhZCwgaSA9IDA7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCBpLCB0aGlzKVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZm9yRWFjaFJldmVyc2UgPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLnRhaWwsIGkgPSB0aGlzLmxlbmd0aCAtIDE7IHdhbGtlciAhPT0gbnVsbDsgaS0tKSB7XG4gICAgZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCBpLCB0aGlzKVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG4pIHtcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBuOyBpKyspIHtcbiAgICAvLyBhYm9ydCBvdXQgb2YgdGhlIGxpc3QgZWFybHkgaWYgd2UgaGl0IGEgY3ljbGVcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG4gIGlmIChpID09PSBuICYmIHdhbGtlciAhPT0gbnVsbCkge1xuICAgIHJldHVybiB3YWxrZXIudmFsdWVcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5nZXRSZXZlcnNlID0gZnVuY3Rpb24gKG4pIHtcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBuOyBpKyspIHtcbiAgICAvLyBhYm9ydCBvdXQgb2YgdGhlIGxpc3QgZWFybHkgaWYgd2UgaGl0IGEgY3ljbGVcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIGlmIChpID09PSBuICYmIHdhbGtlciAhPT0gbnVsbCkge1xuICAgIHJldHVybiB3YWxrZXIudmFsdWVcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICB2YXIgcmVzID0gbmV3IFlhbGxpc3QoKVxuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICByZXMucHVzaChmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIHRoaXMpKVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5tYXBSZXZlcnNlID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgdmFyIHJlcyA9IG5ldyBZYWxsaXN0KClcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgcmVzLnB1c2goZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCB0aGlzKSlcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKGZuLCBpbml0aWFsKSB7XG4gIHZhciBhY2NcbiAgdmFyIHdhbGtlciA9IHRoaXMuaGVhZFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBhY2MgPSBpbml0aWFsXG4gIH0gZWxzZSBpZiAodGhpcy5oZWFkKSB7XG4gICAgd2Fsa2VyID0gdGhpcy5oZWFkLm5leHRcbiAgICBhY2MgPSB0aGlzLmhlYWQudmFsdWVcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgbGlzdCB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgYWNjID0gZm4oYWNjLCB3YWxrZXIudmFsdWUsIGkpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuXG4gIHJldHVybiBhY2Ncbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucmVkdWNlUmV2ZXJzZSA9IGZ1bmN0aW9uIChmbiwgaW5pdGlhbCkge1xuICB2YXIgYWNjXG4gIHZhciB3YWxrZXIgPSB0aGlzLnRhaWxcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgYWNjID0gaW5pdGlhbFxuICB9IGVsc2UgaWYgKHRoaXMudGFpbCkge1xuICAgIHdhbGtlciA9IHRoaXMudGFpbC5wcmV2XG4gICAgYWNjID0gdGhpcy50YWlsLnZhbHVlXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGxpc3Qgd2l0aCBubyBpbml0aWFsIHZhbHVlJylcbiAgfVxuXG4gIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IHdhbGtlciAhPT0gbnVsbDsgaS0tKSB7XG4gICAgYWNjID0gZm4oYWNjLCB3YWxrZXIudmFsdWUsIGkpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuXG4gIHJldHVybiBhY2Ncbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyciA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhcnJbaV0gPSB3YWxrZXIudmFsdWVcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG4gIHJldHVybiBhcnJcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudG9BcnJheVJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcnIgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgYXJyW2ldID0gd2Fsa2VyLnZhbHVlXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuICByZXR1cm4gYXJyXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gIHRvID0gdG8gfHwgdGhpcy5sZW5ndGhcbiAgaWYgKHRvIDwgMCkge1xuICAgIHRvICs9IHRoaXMubGVuZ3RoXG4gIH1cbiAgZnJvbSA9IGZyb20gfHwgMFxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tICs9IHRoaXMubGVuZ3RoXG4gIH1cbiAgdmFyIHJldCA9IG5ldyBZYWxsaXN0KClcbiAgaWYgKHRvIDwgZnJvbSB8fCB0byA8IDApIHtcbiAgICByZXR1cm4gcmV0XG4gIH1cbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgZnJvbSA9IDBcbiAgfVxuICBpZiAodG8gPiB0aGlzLmxlbmd0aCkge1xuICAgIHRvID0gdGhpcy5sZW5ndGhcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IGZyb207IGkrKykge1xuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgZm9yICg7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgdG87IGkrKywgd2Fsa2VyID0gd2Fsa2VyLm5leHQpIHtcbiAgICByZXQucHVzaCh3YWxrZXIudmFsdWUpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5zbGljZVJldmVyc2UgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgdG8gPSB0byB8fCB0aGlzLmxlbmd0aFxuICBpZiAodG8gPCAwKSB7XG4gICAgdG8gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICBmcm9tID0gZnJvbSB8fCAwXG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICB2YXIgcmV0ID0gbmV3IFlhbGxpc3QoKVxuICBpZiAodG8gPCBmcm9tIHx8IHRvIDwgMCkge1xuICAgIHJldHVybiByZXRcbiAgfVxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tID0gMFxuICB9XG4gIGlmICh0byA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdG8gPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCwgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGwgJiYgaSA+IHRvOyBpLS0pIHtcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIGZvciAoOyB3YWxrZXIgIT09IG51bGwgJiYgaSA+IGZyb207IGktLSwgd2Fsa2VyID0gd2Fsa2VyLnByZXYpIHtcbiAgICByZXQucHVzaCh3YWxrZXIudmFsdWUpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5zcGxpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGRlbGV0ZUNvdW50LCAuLi5ub2Rlcykge1xuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHN0YXJ0ID0gdGhpcy5sZW5ndGggLSAxXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gdGhpcy5sZW5ndGggKyBzdGFydDtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgc3RhcnQ7IGkrKykge1xuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cblxuICB2YXIgcmV0ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IHdhbGtlciAmJiBpIDwgZGVsZXRlQ291bnQ7IGkrKykge1xuICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSlcbiAgICB3YWxrZXIgPSB0aGlzLnJlbW92ZU5vZGUod2Fsa2VyKVxuICB9XG4gIGlmICh3YWxrZXIgPT09IG51bGwpIHtcbiAgICB3YWxrZXIgPSB0aGlzLnRhaWxcbiAgfVxuXG4gIGlmICh3YWxrZXIgIT09IHRoaXMuaGVhZCAmJiB3YWxrZXIgIT09IHRoaXMudGFpbCkge1xuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgd2Fsa2VyID0gaW5zZXJ0KHRoaXMsIHdhbGtlciwgbm9kZXNbaV0pXG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhlYWQgPSB0aGlzLmhlYWRcbiAgdmFyIHRhaWwgPSB0aGlzLnRhaWxcbiAgZm9yICh2YXIgd2Fsa2VyID0gaGVhZDsgd2Fsa2VyICE9PSBudWxsOyB3YWxrZXIgPSB3YWxrZXIucHJldikge1xuICAgIHZhciBwID0gd2Fsa2VyLnByZXZcbiAgICB3YWxrZXIucHJldiA9IHdhbGtlci5uZXh0XG4gICAgd2Fsa2VyLm5leHQgPSBwXG4gIH1cbiAgdGhpcy5oZWFkID0gdGFpbFxuICB0aGlzLnRhaWwgPSBoZWFkXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIGluc2VydCAoc2VsZiwgbm9kZSwgdmFsdWUpIHtcbiAgdmFyIGluc2VydGVkID0gbm9kZSA9PT0gc2VsZi5oZWFkID9cbiAgICBuZXcgTm9kZSh2YWx1ZSwgbnVsbCwgbm9kZSwgc2VsZikgOlxuICAgIG5ldyBOb2RlKHZhbHVlLCBub2RlLCBub2RlLm5leHQsIHNlbGYpXG5cbiAgaWYgKGluc2VydGVkLm5leHQgPT09IG51bGwpIHtcbiAgICBzZWxmLnRhaWwgPSBpbnNlcnRlZFxuICB9XG4gIGlmIChpbnNlcnRlZC5wcmV2ID09PSBudWxsKSB7XG4gICAgc2VsZi5oZWFkID0gaW5zZXJ0ZWRcbiAgfVxuXG4gIHNlbGYubGVuZ3RoKytcblxuICByZXR1cm4gaW5zZXJ0ZWRcbn1cblxuZnVuY3Rpb24gcHVzaCAoc2VsZiwgaXRlbSkge1xuICBzZWxmLnRhaWwgPSBuZXcgTm9kZShpdGVtLCBzZWxmLnRhaWwsIG51bGwsIHNlbGYpXG4gIGlmICghc2VsZi5oZWFkKSB7XG4gICAgc2VsZi5oZWFkID0gc2VsZi50YWlsXG4gIH1cbiAgc2VsZi5sZW5ndGgrK1xufVxuXG5mdW5jdGlvbiB1bnNoaWZ0IChzZWxmLCBpdGVtKSB7XG4gIHNlbGYuaGVhZCA9IG5ldyBOb2RlKGl0ZW0sIG51bGwsIHNlbGYuaGVhZCwgc2VsZilcbiAgaWYgKCFzZWxmLnRhaWwpIHtcbiAgICBzZWxmLnRhaWwgPSBzZWxmLmhlYWRcbiAgfVxuICBzZWxmLmxlbmd0aCsrXG59XG5cbmZ1bmN0aW9uIE5vZGUgKHZhbHVlLCBwcmV2LCBuZXh0LCBsaXN0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBOb2RlKSkge1xuICAgIHJldHVybiBuZXcgTm9kZSh2YWx1ZSwgcHJldiwgbmV4dCwgbGlzdClcbiAgfVxuXG4gIHRoaXMubGlzdCA9IGxpc3RcbiAgdGhpcy52YWx1ZSA9IHZhbHVlXG5cbiAgaWYgKHByZXYpIHtcbiAgICBwcmV2Lm5leHQgPSB0aGlzXG4gICAgdGhpcy5wcmV2ID0gcHJldlxuICB9IGVsc2Uge1xuICAgIHRoaXMucHJldiA9IG51bGxcbiAgfVxuXG4gIGlmIChuZXh0KSB7XG4gICAgbmV4dC5wcmV2ID0gdGhpc1xuICAgIHRoaXMubmV4dCA9IG5leHRcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm5leHQgPSBudWxsXG4gIH1cbn1cblxudHJ5IHtcbiAgLy8gYWRkIGlmIHN1cHBvcnQgZm9yIFN5bWJvbC5pdGVyYXRvciBpcyBwcmVzZW50XG4gIHJlcXVpcmUoJy4vaXRlcmF0b3IuanMnKShZYWxsaXN0KVxufSBjYXRjaCAoZXIpIHt9XG4iLCIndXNlIHN0cmljdCdcblxuLy8gQSBsaW5rZWQgbGlzdCB0byBrZWVwIHRyYWNrIG9mIHJlY2VudGx5LXVzZWQtbmVzc1xuY29uc3QgWWFsbGlzdCA9IHJlcXVpcmUoJ3lhbGxpc3QnKVxuXG5jb25zdCBNQVggPSBTeW1ib2woJ21heCcpXG5jb25zdCBMRU5HVEggPSBTeW1ib2woJ2xlbmd0aCcpXG5jb25zdCBMRU5HVEhfQ0FMQ1VMQVRPUiA9IFN5bWJvbCgnbGVuZ3RoQ2FsY3VsYXRvcicpXG5jb25zdCBBTExPV19TVEFMRSA9IFN5bWJvbCgnYWxsb3dTdGFsZScpXG5jb25zdCBNQVhfQUdFID0gU3ltYm9sKCdtYXhBZ2UnKVxuY29uc3QgRElTUE9TRSA9IFN5bWJvbCgnZGlzcG9zZScpXG5jb25zdCBOT19ESVNQT1NFX09OX1NFVCA9IFN5bWJvbCgnbm9EaXNwb3NlT25TZXQnKVxuY29uc3QgTFJVX0xJU1QgPSBTeW1ib2woJ2xydUxpc3QnKVxuY29uc3QgQ0FDSEUgPSBTeW1ib2woJ2NhY2hlJylcbmNvbnN0IFVQREFURV9BR0VfT05fR0VUID0gU3ltYm9sKCd1cGRhdGVBZ2VPbkdldCcpXG5cbmNvbnN0IG5haXZlTGVuZ3RoID0gKCkgPT4gMVxuXG4vLyBscnVMaXN0IGlzIGEgeWFsbGlzdCB3aGVyZSB0aGUgaGVhZCBpcyB0aGUgeW91bmdlc3Rcbi8vIGl0ZW0sIGFuZCB0aGUgdGFpbCBpcyB0aGUgb2xkZXN0LiAgdGhlIGxpc3QgY29udGFpbnMgdGhlIEhpdFxuLy8gb2JqZWN0cyBhcyB0aGUgZW50cmllcy5cbi8vIEVhY2ggSGl0IG9iamVjdCBoYXMgYSByZWZlcmVuY2UgdG8gaXRzIFlhbGxpc3QuTm9kZS4gIFRoaXNcbi8vIG5ldmVyIGNoYW5nZXMuXG4vL1xuLy8gY2FjaGUgaXMgYSBNYXAgKG9yIFBzZXVkb01hcCkgdGhhdCBtYXRjaGVzIHRoZSBrZXlzIHRvXG4vLyB0aGUgWWFsbGlzdC5Ob2RlIG9iamVjdC5cbmNsYXNzIExSVUNhY2hlIHtcbiAgY29uc3RydWN0b3IgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKVxuICAgICAgb3B0aW9ucyA9IHsgbWF4OiBvcHRpb25zIH1cblxuICAgIGlmICghb3B0aW9ucylcbiAgICAgIG9wdGlvbnMgPSB7fVxuXG4gICAgaWYgKG9wdGlvbnMubWF4ICYmICh0eXBlb2Ygb3B0aW9ucy5tYXggIT09ICdudW1iZXInIHx8IG9wdGlvbnMubWF4IDwgMCkpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXggbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXInKVxuICAgIC8vIEtpbmQgb2Ygd2VpcmQgdG8gaGF2ZSBhIGRlZmF1bHQgbWF4IG9mIEluZmluaXR5LCBidXQgb2ggd2VsbC5cbiAgICBjb25zdCBtYXggPSB0aGlzW01BWF0gPSBvcHRpb25zLm1heCB8fCBJbmZpbml0eVxuXG4gICAgY29uc3QgbGMgPSBvcHRpb25zLmxlbmd0aCB8fCBuYWl2ZUxlbmd0aFxuICAgIHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdID0gKHR5cGVvZiBsYyAhPT0gJ2Z1bmN0aW9uJykgPyBuYWl2ZUxlbmd0aCA6IGxjXG4gICAgdGhpc1tBTExPV19TVEFMRV0gPSBvcHRpb25zLnN0YWxlIHx8IGZhbHNlXG4gICAgaWYgKG9wdGlvbnMubWF4QWdlICYmIHR5cGVvZiBvcHRpb25zLm1heEFnZSAhPT0gJ251bWJlcicpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXhBZ2UgbXVzdCBiZSBhIG51bWJlcicpXG4gICAgdGhpc1tNQVhfQUdFXSA9IG9wdGlvbnMubWF4QWdlIHx8IDBcbiAgICB0aGlzW0RJU1BPU0VdID0gb3B0aW9ucy5kaXNwb3NlXG4gICAgdGhpc1tOT19ESVNQT1NFX09OX1NFVF0gPSBvcHRpb25zLm5vRGlzcG9zZU9uU2V0IHx8IGZhbHNlXG4gICAgdGhpc1tVUERBVEVfQUdFX09OX0dFVF0gPSBvcHRpb25zLnVwZGF0ZUFnZU9uR2V0IHx8IGZhbHNlXG4gICAgdGhpcy5yZXNldCgpXG4gIH1cblxuICAvLyByZXNpemUgdGhlIGNhY2hlIHdoZW4gdGhlIG1heCBjaGFuZ2VzLlxuICBzZXQgbWF4IChtTCkge1xuICAgIGlmICh0eXBlb2YgbUwgIT09ICdudW1iZXInIHx8IG1MIDwgMClcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcicpXG5cbiAgICB0aGlzW01BWF0gPSBtTCB8fCBJbmZpbml0eVxuICAgIHRyaW0odGhpcylcbiAgfVxuICBnZXQgbWF4ICgpIHtcbiAgICByZXR1cm4gdGhpc1tNQVhdXG4gIH1cblxuICBzZXQgYWxsb3dTdGFsZSAoYWxsb3dTdGFsZSkge1xuICAgIHRoaXNbQUxMT1dfU1RBTEVdID0gISFhbGxvd1N0YWxlXG4gIH1cbiAgZ2V0IGFsbG93U3RhbGUgKCkge1xuICAgIHJldHVybiB0aGlzW0FMTE9XX1NUQUxFXVxuICB9XG5cbiAgc2V0IG1heEFnZSAobUEpIHtcbiAgICBpZiAodHlwZW9mIG1BICE9PSAnbnVtYmVyJylcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heEFnZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcicpXG5cbiAgICB0aGlzW01BWF9BR0VdID0gbUFcbiAgICB0cmltKHRoaXMpXG4gIH1cbiAgZ2V0IG1heEFnZSAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTUFYX0FHRV1cbiAgfVxuXG4gIC8vIHJlc2l6ZSB0aGUgY2FjaGUgd2hlbiB0aGUgbGVuZ3RoQ2FsY3VsYXRvciBjaGFuZ2VzLlxuICBzZXQgbGVuZ3RoQ2FsY3VsYXRvciAobEMpIHtcbiAgICBpZiAodHlwZW9mIGxDICE9PSAnZnVuY3Rpb24nKVxuICAgICAgbEMgPSBuYWl2ZUxlbmd0aFxuXG4gICAgaWYgKGxDICE9PSB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSkge1xuICAgICAgdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0gPSBsQ1xuICAgICAgdGhpc1tMRU5HVEhdID0gMFxuICAgICAgdGhpc1tMUlVfTElTVF0uZm9yRWFjaChoaXQgPT4ge1xuICAgICAgICBoaXQubGVuZ3RoID0gdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0oaGl0LnZhbHVlLCBoaXQua2V5KVxuICAgICAgICB0aGlzW0xFTkdUSF0gKz0gaGl0Lmxlbmd0aFxuICAgICAgfSlcbiAgICB9XG4gICAgdHJpbSh0aGlzKVxuICB9XG4gIGdldCBsZW5ndGhDYWxjdWxhdG9yICgpIHsgcmV0dXJuIHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdIH1cblxuICBnZXQgbGVuZ3RoICgpIHsgcmV0dXJuIHRoaXNbTEVOR1RIXSB9XG4gIGdldCBpdGVtQ291bnQgKCkgeyByZXR1cm4gdGhpc1tMUlVfTElTVF0ubGVuZ3RoIH1cblxuICByZm9yRWFjaCAoZm4sIHRoaXNwKSB7XG4gICAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gICAgZm9yIChsZXQgd2Fsa2VyID0gdGhpc1tMUlVfTElTVF0udGFpbDsgd2Fsa2VyICE9PSBudWxsOykge1xuICAgICAgY29uc3QgcHJldiA9IHdhbGtlci5wcmV2XG4gICAgICBmb3JFYWNoU3RlcCh0aGlzLCBmbiwgd2Fsa2VyLCB0aGlzcClcbiAgICAgIHdhbGtlciA9IHByZXZcbiAgICB9XG4gIH1cblxuICBmb3JFYWNoIChmbiwgdGhpc3ApIHtcbiAgICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgICBmb3IgKGxldCB3YWxrZXIgPSB0aGlzW0xSVV9MSVNUXS5oZWFkOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgICBjb25zdCBuZXh0ID0gd2Fsa2VyLm5leHRcbiAgICAgIGZvckVhY2hTdGVwKHRoaXMsIGZuLCB3YWxrZXIsIHRoaXNwKVxuICAgICAgd2Fsa2VyID0gbmV4dFxuICAgIH1cbiAgfVxuXG4gIGtleXMgKCkge1xuICAgIHJldHVybiB0aGlzW0xSVV9MSVNUXS50b0FycmF5KCkubWFwKGsgPT4gay5rZXkpXG4gIH1cblxuICB2YWx1ZXMgKCkge1xuICAgIHJldHVybiB0aGlzW0xSVV9MSVNUXS50b0FycmF5KCkubWFwKGsgPT4gay52YWx1ZSlcbiAgfVxuXG4gIHJlc2V0ICgpIHtcbiAgICBpZiAodGhpc1tESVNQT1NFXSAmJlxuICAgICAgICB0aGlzW0xSVV9MSVNUXSAmJlxuICAgICAgICB0aGlzW0xSVV9MSVNUXS5sZW5ndGgpIHtcbiAgICAgIHRoaXNbTFJVX0xJU1RdLmZvckVhY2goaGl0ID0+IHRoaXNbRElTUE9TRV0oaGl0LmtleSwgaGl0LnZhbHVlKSlcbiAgICB9XG5cbiAgICB0aGlzW0NBQ0hFXSA9IG5ldyBNYXAoKSAvLyBoYXNoIG9mIGl0ZW1zIGJ5IGtleVxuICAgIHRoaXNbTFJVX0xJU1RdID0gbmV3IFlhbGxpc3QoKSAvLyBsaXN0IG9mIGl0ZW1zIGluIG9yZGVyIG9mIHVzZSByZWNlbmN5XG4gICAgdGhpc1tMRU5HVEhdID0gMCAvLyBsZW5ndGggb2YgaXRlbXMgaW4gdGhlIGxpc3RcbiAgfVxuXG4gIGR1bXAgKCkge1xuICAgIHJldHVybiB0aGlzW0xSVV9MSVNUXS5tYXAoaGl0ID0+XG4gICAgICBpc1N0YWxlKHRoaXMsIGhpdCkgPyBmYWxzZSA6IHtcbiAgICAgICAgazogaGl0LmtleSxcbiAgICAgICAgdjogaGl0LnZhbHVlLFxuICAgICAgICBlOiBoaXQubm93ICsgKGhpdC5tYXhBZ2UgfHwgMClcbiAgICAgIH0pLnRvQXJyYXkoKS5maWx0ZXIoaCA9PiBoKVxuICB9XG5cbiAgZHVtcExydSAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdXG4gIH1cblxuICBzZXQgKGtleSwgdmFsdWUsIG1heEFnZSkge1xuICAgIG1heEFnZSA9IG1heEFnZSB8fCB0aGlzW01BWF9BR0VdXG5cbiAgICBpZiAobWF4QWdlICYmIHR5cGVvZiBtYXhBZ2UgIT09ICdudW1iZXInKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4QWdlIG11c3QgYmUgYSBudW1iZXInKVxuXG4gICAgY29uc3Qgbm93ID0gbWF4QWdlID8gRGF0ZS5ub3coKSA6IDBcbiAgICBjb25zdCBsZW4gPSB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSh2YWx1ZSwga2V5KVxuXG4gICAgaWYgKHRoaXNbQ0FDSEVdLmhhcyhrZXkpKSB7XG4gICAgICBpZiAobGVuID4gdGhpc1tNQVhdKSB7XG4gICAgICAgIGRlbCh0aGlzLCB0aGlzW0NBQ0hFXS5nZXQoa2V5KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzW0NBQ0hFXS5nZXQoa2V5KVxuICAgICAgY29uc3QgaXRlbSA9IG5vZGUudmFsdWVcblxuICAgICAgLy8gZGlzcG9zZSBvZiB0aGUgb2xkIG9uZSBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgICAgIC8vIHNwbGl0IG91dCBpbnRvIDIgaWZzIGZvciBiZXR0ZXIgY292ZXJhZ2UgdHJhY2tpbmdcbiAgICAgIGlmICh0aGlzW0RJU1BPU0VdKSB7XG4gICAgICAgIGlmICghdGhpc1tOT19ESVNQT1NFX09OX1NFVF0pXG4gICAgICAgICAgdGhpc1tESVNQT1NFXShrZXksIGl0ZW0udmFsdWUpXG4gICAgICB9XG5cbiAgICAgIGl0ZW0ubm93ID0gbm93XG4gICAgICBpdGVtLm1heEFnZSA9IG1heEFnZVxuICAgICAgaXRlbS52YWx1ZSA9IHZhbHVlXG4gICAgICB0aGlzW0xFTkdUSF0gKz0gbGVuIC0gaXRlbS5sZW5ndGhcbiAgICAgIGl0ZW0ubGVuZ3RoID0gbGVuXG4gICAgICB0aGlzLmdldChrZXkpXG4gICAgICB0cmltKHRoaXMpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGNvbnN0IGhpdCA9IG5ldyBFbnRyeShrZXksIHZhbHVlLCBsZW4sIG5vdywgbWF4QWdlKVxuXG4gICAgLy8gb3ZlcnNpemVkIG9iamVjdHMgZmFsbCBvdXQgb2YgY2FjaGUgYXV0b21hdGljYWxseS5cbiAgICBpZiAoaGl0Lmxlbmd0aCA+IHRoaXNbTUFYXSkge1xuICAgICAgaWYgKHRoaXNbRElTUE9TRV0pXG4gICAgICAgIHRoaXNbRElTUE9TRV0oa2V5LCB2YWx1ZSlcblxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgdGhpc1tMRU5HVEhdICs9IGhpdC5sZW5ndGhcbiAgICB0aGlzW0xSVV9MSVNUXS51bnNoaWZ0KGhpdClcbiAgICB0aGlzW0NBQ0hFXS5zZXQoa2V5LCB0aGlzW0xSVV9MSVNUXS5oZWFkKVxuICAgIHRyaW0odGhpcylcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaGFzIChrZXkpIHtcbiAgICBpZiAoIXRoaXNbQ0FDSEVdLmhhcyhrZXkpKSByZXR1cm4gZmFsc2VcbiAgICBjb25zdCBoaXQgPSB0aGlzW0NBQ0hFXS5nZXQoa2V5KS52YWx1ZVxuICAgIHJldHVybiAhaXNTdGFsZSh0aGlzLCBoaXQpXG4gIH1cblxuICBnZXQgKGtleSkge1xuICAgIHJldHVybiBnZXQodGhpcywga2V5LCB0cnVlKVxuICB9XG5cbiAgcGVlayAoa2V5KSB7XG4gICAgcmV0dXJuIGdldCh0aGlzLCBrZXksIGZhbHNlKVxuICB9XG5cbiAgcG9wICgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpc1tMUlVfTElTVF0udGFpbFxuICAgIGlmICghbm9kZSlcbiAgICAgIHJldHVybiBudWxsXG5cbiAgICBkZWwodGhpcywgbm9kZSlcbiAgICByZXR1cm4gbm9kZS52YWx1ZVxuICB9XG5cbiAgZGVsIChrZXkpIHtcbiAgICBkZWwodGhpcywgdGhpc1tDQUNIRV0uZ2V0KGtleSkpXG4gIH1cblxuICBsb2FkIChhcnIpIHtcbiAgICAvLyByZXNldCB0aGUgY2FjaGVcbiAgICB0aGlzLnJlc2V0KClcblxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KClcbiAgICAvLyBBIHByZXZpb3VzIHNlcmlhbGl6ZWQgY2FjaGUgaGFzIHRoZSBtb3N0IHJlY2VudCBpdGVtcyBmaXJzdFxuICAgIGZvciAobGV0IGwgPSBhcnIubGVuZ3RoIC0gMTsgbCA+PSAwOyBsLS0pIHtcbiAgICAgIGNvbnN0IGhpdCA9IGFycltsXVxuICAgICAgY29uc3QgZXhwaXJlc0F0ID0gaGl0LmUgfHwgMFxuICAgICAgaWYgKGV4cGlyZXNBdCA9PT0gMClcbiAgICAgICAgLy8gdGhlIGl0ZW0gd2FzIGNyZWF0ZWQgd2l0aG91dCBleHBpcmF0aW9uIGluIGEgbm9uIGFnZWQgY2FjaGVcbiAgICAgICAgdGhpcy5zZXQoaGl0LmssIGhpdC52KVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG1heEFnZSA9IGV4cGlyZXNBdCAtIG5vd1xuICAgICAgICAvLyBkb250IGFkZCBhbHJlYWR5IGV4cGlyZWQgaXRlbXNcbiAgICAgICAgaWYgKG1heEFnZSA+IDApIHtcbiAgICAgICAgICB0aGlzLnNldChoaXQuaywgaGl0LnYsIG1heEFnZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHBydW5lICgpIHtcbiAgICB0aGlzW0NBQ0hFXS5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiBnZXQodGhpcywga2V5LCBmYWxzZSkpXG4gIH1cbn1cblxuY29uc3QgZ2V0ID0gKHNlbGYsIGtleSwgZG9Vc2UpID0+IHtcbiAgY29uc3Qgbm9kZSA9IHNlbGZbQ0FDSEVdLmdldChrZXkpXG4gIGlmIChub2RlKSB7XG4gICAgY29uc3QgaGl0ID0gbm9kZS52YWx1ZVxuICAgIGlmIChpc1N0YWxlKHNlbGYsIGhpdCkpIHtcbiAgICAgIGRlbChzZWxmLCBub2RlKVxuICAgICAgaWYgKCFzZWxmW0FMTE9XX1NUQUxFXSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZG9Vc2UpIHtcbiAgICAgICAgaWYgKHNlbGZbVVBEQVRFX0FHRV9PTl9HRVRdKVxuICAgICAgICAgIG5vZGUudmFsdWUubm93ID0gRGF0ZS5ub3coKVxuICAgICAgICBzZWxmW0xSVV9MSVNUXS51bnNoaWZ0Tm9kZShub2RlKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGl0LnZhbHVlXG4gIH1cbn1cblxuY29uc3QgaXNTdGFsZSA9IChzZWxmLCBoaXQpID0+IHtcbiAgaWYgKCFoaXQgfHwgKCFoaXQubWF4QWdlICYmICFzZWxmW01BWF9BR0VdKSlcbiAgICByZXR1cm4gZmFsc2VcblxuICBjb25zdCBkaWZmID0gRGF0ZS5ub3coKSAtIGhpdC5ub3dcbiAgcmV0dXJuIGhpdC5tYXhBZ2UgPyBkaWZmID4gaGl0Lm1heEFnZVxuICAgIDogc2VsZltNQVhfQUdFXSAmJiAoZGlmZiA+IHNlbGZbTUFYX0FHRV0pXG59XG5cbmNvbnN0IHRyaW0gPSBzZWxmID0+IHtcbiAgaWYgKHNlbGZbTEVOR1RIXSA+IHNlbGZbTUFYXSkge1xuICAgIGZvciAobGV0IHdhbGtlciA9IHNlbGZbTFJVX0xJU1RdLnRhaWw7XG4gICAgICBzZWxmW0xFTkdUSF0gPiBzZWxmW01BWF0gJiYgd2Fsa2VyICE9PSBudWxsOykge1xuICAgICAgLy8gV2Uga25vdyB0aGF0IHdlJ3JlIGFib3V0IHRvIGRlbGV0ZSB0aGlzIG9uZSwgYW5kIGFsc29cbiAgICAgIC8vIHdoYXQgdGhlIG5leHQgbGVhc3QgcmVjZW50bHkgdXNlZCBrZXkgd2lsbCBiZSwgc28ganVzdFxuICAgICAgLy8gZ28gYWhlYWQgYW5kIHNldCBpdCBub3cuXG4gICAgICBjb25zdCBwcmV2ID0gd2Fsa2VyLnByZXZcbiAgICAgIGRlbChzZWxmLCB3YWxrZXIpXG4gICAgICB3YWxrZXIgPSBwcmV2XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGRlbCA9IChzZWxmLCBub2RlKSA9PiB7XG4gIGlmIChub2RlKSB7XG4gICAgY29uc3QgaGl0ID0gbm9kZS52YWx1ZVxuICAgIGlmIChzZWxmW0RJU1BPU0VdKVxuICAgICAgc2VsZltESVNQT1NFXShoaXQua2V5LCBoaXQudmFsdWUpXG5cbiAgICBzZWxmW0xFTkdUSF0gLT0gaGl0Lmxlbmd0aFxuICAgIHNlbGZbQ0FDSEVdLmRlbGV0ZShoaXQua2V5KVxuICAgIHNlbGZbTFJVX0xJU1RdLnJlbW92ZU5vZGUobm9kZSlcbiAgfVxufVxuXG5jbGFzcyBFbnRyeSB7XG4gIGNvbnN0cnVjdG9yIChrZXksIHZhbHVlLCBsZW5ndGgsIG5vdywgbWF4QWdlKSB7XG4gICAgdGhpcy5rZXkgPSBrZXlcbiAgICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aFxuICAgIHRoaXMubm93ID0gbm93XG4gICAgdGhpcy5tYXhBZ2UgPSBtYXhBZ2UgfHwgMFxuICB9XG59XG5cbmNvbnN0IGZvckVhY2hTdGVwID0gKHNlbGYsIGZuLCBub2RlLCB0aGlzcCkgPT4ge1xuICBsZXQgaGl0ID0gbm9kZS52YWx1ZVxuICBpZiAoaXNTdGFsZShzZWxmLCBoaXQpKSB7XG4gICAgZGVsKHNlbGYsIG5vZGUpXG4gICAgaWYgKCFzZWxmW0FMTE9XX1NUQUxFXSlcbiAgICAgIGhpdCA9IHVuZGVmaW5lZFxuICB9XG4gIGlmIChoaXQpXG4gICAgZm4uY2FsbCh0aGlzcCwgaGl0LnZhbHVlLCBoaXQua2V5LCBzZWxmKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExSVUNhY2hlXG4iLCIvLyBob2lzdGVkIGNsYXNzIGZvciBjeWNsaWMgZGVwZW5kZW5jeVxuY2xhc3MgUmFuZ2Uge1xuICBjb25zdHJ1Y3RvciAocmFuZ2UsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkge1xuICAgICAgaWYgKFxuICAgICAgICByYW5nZS5sb29zZSA9PT0gISFvcHRpb25zLmxvb3NlICYmXG4gICAgICAgIHJhbmdlLmluY2x1ZGVQcmVyZWxlYXNlID09PSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2VcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gcmFuZ2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UucmF3LCBvcHRpb25zKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyYW5nZSBpbnN0YW5jZW9mIENvbXBhcmF0b3IpIHtcbiAgICAgIC8vIGp1c3QgcHV0IGl0IGluIHRoZSBzZXQgYW5kIHJldHVyblxuICAgICAgdGhpcy5yYXcgPSByYW5nZS52YWx1ZVxuICAgICAgdGhpcy5zZXQgPSBbW3JhbmdlXV1cbiAgICAgIHRoaXMuZm9ybWF0KClcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2VcbiAgICB0aGlzLmluY2x1ZGVQcmVyZWxlYXNlID0gISFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlXG5cbiAgICAvLyBGaXJzdCwgc3BsaXQgYmFzZWQgb24gYm9vbGVhbiBvciB8fFxuICAgIHRoaXMucmF3ID0gcmFuZ2VcbiAgICB0aGlzLnNldCA9IHJhbmdlXG4gICAgICAuc3BsaXQoL1xccypcXHxcXHxcXHMqLylcbiAgICAgIC8vIG1hcCB0aGUgcmFuZ2UgdG8gYSAyZCBhcnJheSBvZiBjb21wYXJhdG9yc1xuICAgICAgLm1hcChyYW5nZSA9PiB0aGlzLnBhcnNlUmFuZ2UocmFuZ2UudHJpbSgpKSlcbiAgICAgIC8vIHRocm93IG91dCBhbnkgY29tcGFyYXRvciBsaXN0cyB0aGF0IGFyZSBlbXB0eVxuICAgICAgLy8gdGhpcyBnZW5lcmFsbHkgbWVhbnMgdGhhdCBpdCB3YXMgbm90IGEgdmFsaWQgcmFuZ2UsIHdoaWNoIGlzIGFsbG93ZWRcbiAgICAgIC8vIGluIGxvb3NlIG1vZGUsIGJ1dCB3aWxsIHN0aWxsIHRocm93IGlmIHRoZSBXSE9MRSByYW5nZSBpcyBpbnZhbGlkLlxuICAgICAgLmZpbHRlcihjID0+IGMubGVuZ3RoKVxuXG4gICAgaWYgKCF0aGlzLnNldC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgU2VtVmVyIFJhbmdlOiAke3JhbmdlfWApXG4gICAgfVxuXG4gICAgLy8gaWYgd2UgaGF2ZSBhbnkgdGhhdCBhcmUgbm90IHRoZSBudWxsIHNldCwgdGhyb3cgb3V0IG51bGwgc2V0cy5cbiAgICBpZiAodGhpcy5zZXQubGVuZ3RoID4gMSkge1xuICAgICAgLy8ga2VlcCB0aGUgZmlyc3Qgb25lLCBpbiBjYXNlIHRoZXkncmUgYWxsIG51bGwgc2V0c1xuICAgICAgY29uc3QgZmlyc3QgPSB0aGlzLnNldFswXVxuICAgICAgdGhpcy5zZXQgPSB0aGlzLnNldC5maWx0ZXIoYyA9PiAhaXNOdWxsU2V0KGNbMF0pKVxuICAgICAgaWYgKHRoaXMuc2V0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgdGhpcy5zZXQgPSBbZmlyc3RdXG4gICAgICBlbHNlIGlmICh0aGlzLnNldC5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIGlmIHdlIGhhdmUgYW55IHRoYXQgYXJlICosIHRoZW4gdGhlIHJhbmdlIGlzIGp1c3QgKlxuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgdGhpcy5zZXQpIHtcbiAgICAgICAgICBpZiAoYy5sZW5ndGggPT09IDEgJiYgaXNBbnkoY1swXSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0ID0gW2NdXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZm9ybWF0KClcbiAgfVxuXG4gIGZvcm1hdCAoKSB7XG4gICAgdGhpcy5yYW5nZSA9IHRoaXMuc2V0XG4gICAgICAubWFwKChjb21wcykgPT4ge1xuICAgICAgICByZXR1cm4gY29tcHMuam9pbignICcpLnRyaW0oKVxuICAgICAgfSlcbiAgICAgIC5qb2luKCd8fCcpXG4gICAgICAudHJpbSgpXG4gICAgcmV0dXJuIHRoaXMucmFuZ2VcbiAgfVxuXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy5yYW5nZVxuICB9XG5cbiAgcGFyc2VSYW5nZSAocmFuZ2UpIHtcbiAgICByYW5nZSA9IHJhbmdlLnRyaW0oKVxuXG4gICAgLy8gbWVtb2l6ZSByYW5nZSBwYXJzaW5nIGZvciBwZXJmb3JtYW5jZS5cbiAgICAvLyB0aGlzIGlzIGEgdmVyeSBob3QgcGF0aCwgYW5kIGZ1bGx5IGRldGVybWluaXN0aWMuXG4gICAgY29uc3QgbWVtb09wdHMgPSBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMpLmpvaW4oJywnKVxuICAgIGNvbnN0IG1lbW9LZXkgPSBgcGFyc2VSYW5nZToke21lbW9PcHRzfToke3JhbmdlfWBcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQobWVtb0tleSlcbiAgICBpZiAoY2FjaGVkKVxuICAgICAgcmV0dXJuIGNhY2hlZFxuXG4gICAgY29uc3QgbG9vc2UgPSB0aGlzLm9wdGlvbnMubG9vc2VcbiAgICAvLyBgMS4yLjMgLSAxLjIuNGAgPT4gYD49MS4yLjMgPD0xLjIuNGBcbiAgICBjb25zdCBociA9IGxvb3NlID8gcmVbdC5IWVBIRU5SQU5HRUxPT1NFXSA6IHJlW3QuSFlQSEVOUkFOR0VdXG4gICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKGhyLCBoeXBoZW5SZXBsYWNlKHRoaXMub3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkpXG4gICAgZGVidWcoJ2h5cGhlbiByZXBsYWNlJywgcmFuZ2UpXG4gICAgLy8gYD4gMS4yLjMgPCAxLjIuNWAgPT4gYD4xLjIuMyA8MS4yLjVgXG4gICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW3QuQ09NUEFSQVRPUlRSSU1dLCBjb21wYXJhdG9yVHJpbVJlcGxhY2UpXG4gICAgZGVidWcoJ2NvbXBhcmF0b3IgdHJpbScsIHJhbmdlLCByZVt0LkNPTVBBUkFUT1JUUklNXSlcblxuICAgIC8vIGB+IDEuMi4zYCA9PiBgfjEuMi4zYFxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVt0LlRJTERFVFJJTV0sIHRpbGRlVHJpbVJlcGxhY2UpXG5cbiAgICAvLyBgXiAxLjIuM2AgPT4gYF4xLjIuM2BcbiAgICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbdC5DQVJFVFRSSU1dLCBjYXJldFRyaW1SZXBsYWNlKVxuXG4gICAgLy8gbm9ybWFsaXplIHNwYWNlc1xuICAgIHJhbmdlID0gcmFuZ2Uuc3BsaXQoL1xccysvKS5qb2luKCcgJylcblxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSByYW5nZSBpcyBjb21wbGV0ZWx5IHRyaW1tZWQgYW5kXG4gICAgLy8gcmVhZHkgdG8gYmUgc3BsaXQgaW50byBjb21wYXJhdG9ycy5cblxuICAgIGNvbnN0IGNvbXBSZSA9IGxvb3NlID8gcmVbdC5DT01QQVJBVE9STE9PU0VdIDogcmVbdC5DT01QQVJBVE9SXVxuICAgIGNvbnN0IHJhbmdlTGlzdCA9IHJhbmdlXG4gICAgICAuc3BsaXQoJyAnKVxuICAgICAgLm1hcChjb21wID0+IHBhcnNlQ29tcGFyYXRvcihjb21wLCB0aGlzLm9wdGlvbnMpKVxuICAgICAgLmpvaW4oJyAnKVxuICAgICAgLnNwbGl0KC9cXHMrLylcbiAgICAgIC8vID49MC4wLjAgaXMgZXF1aXZhbGVudCB0byAqXG4gICAgICAubWFwKGNvbXAgPT4gcmVwbGFjZUdURTAoY29tcCwgdGhpcy5vcHRpb25zKSlcbiAgICAgIC8vIGluIGxvb3NlIG1vZGUsIHRocm93IG91dCBhbnkgdGhhdCBhcmUgbm90IHZhbGlkIGNvbXBhcmF0b3JzXG4gICAgICAuZmlsdGVyKHRoaXMub3B0aW9ucy5sb29zZSA/IGNvbXAgPT4gISFjb21wLm1hdGNoKGNvbXBSZSkgOiAoKSA9PiB0cnVlKVxuICAgICAgLm1hcChjb21wID0+IG5ldyBDb21wYXJhdG9yKGNvbXAsIHRoaXMub3B0aW9ucykpXG5cbiAgICAvLyBpZiBhbnkgY29tcGFyYXRvcnMgYXJlIHRoZSBudWxsIHNldCwgdGhlbiByZXBsYWNlIHdpdGggSlVTVCBudWxsIHNldFxuICAgIC8vIGlmIG1vcmUgdGhhbiBvbmUgY29tcGFyYXRvciwgcmVtb3ZlIGFueSAqIGNvbXBhcmF0b3JzXG4gICAgLy8gYWxzbywgZG9uJ3QgaW5jbHVkZSB0aGUgc2FtZSBjb21wYXJhdG9yIG1vcmUgdGhhbiBvbmNlXG4gICAgY29uc3QgbCA9IHJhbmdlTGlzdC5sZW5ndGhcbiAgICBjb25zdCByYW5nZU1hcCA9IG5ldyBNYXAoKVxuICAgIGZvciAoY29uc3QgY29tcCBvZiByYW5nZUxpc3QpIHtcbiAgICAgIGlmIChpc051bGxTZXQoY29tcCkpXG4gICAgICAgIHJldHVybiBbY29tcF1cbiAgICAgIHJhbmdlTWFwLnNldChjb21wLnZhbHVlLCBjb21wKVxuICAgIH1cbiAgICBpZiAocmFuZ2VNYXAuc2l6ZSA+IDEgJiYgcmFuZ2VNYXAuaGFzKCcnKSlcbiAgICAgIHJhbmdlTWFwLmRlbGV0ZSgnJylcblxuICAgIGNvbnN0IHJlc3VsdCA9IFsuLi5yYW5nZU1hcC52YWx1ZXMoKV1cbiAgICBjYWNoZS5zZXQobWVtb0tleSwgcmVzdWx0KVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGludGVyc2VjdHMgKHJhbmdlLCBvcHRpb25zKSB7XG4gICAgaWYgKCEocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2EgUmFuZ2UgaXMgcmVxdWlyZWQnKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNldC5zb21lKCh0aGlzQ29tcGFyYXRvcnMpID0+IHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGlzU2F0aXNmaWFibGUodGhpc0NvbXBhcmF0b3JzLCBvcHRpb25zKSAmJlxuICAgICAgICByYW5nZS5zZXQuc29tZSgocmFuZ2VDb21wYXJhdG9ycykgPT4ge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBpc1NhdGlzZmlhYmxlKHJhbmdlQ29tcGFyYXRvcnMsIG9wdGlvbnMpICYmXG4gICAgICAgICAgICB0aGlzQ29tcGFyYXRvcnMuZXZlcnkoKHRoaXNDb21wYXJhdG9yKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiByYW5nZUNvbXBhcmF0b3JzLmV2ZXJ5KChyYW5nZUNvbXBhcmF0b3IpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc0NvbXBhcmF0b3IuaW50ZXJzZWN0cyhyYW5nZUNvbXBhcmF0b3IsIG9wdGlvbnMpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIClcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9KVxuICB9XG5cbiAgLy8gaWYgQU5ZIG9mIHRoZSBzZXRzIG1hdGNoIEFMTCBvZiBpdHMgY29tcGFyYXRvcnMsIHRoZW4gcGFzc1xuICB0ZXN0ICh2ZXJzaW9uKSB7XG4gICAgaWYgKCF2ZXJzaW9uKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCB0aGlzLm9wdGlvbnMpXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGVzdFNldCh0aGlzLnNldFtpXSwgdmVyc2lvbiwgdGhpcy5vcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBSYW5nZVxuXG5jb25zdCBMUlUgPSByZXF1aXJlKCdscnUtY2FjaGUnKVxuY29uc3QgY2FjaGUgPSBuZXcgTFJVKHsgbWF4OiAxMDAwIH0pXG5cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3BhcnNlLW9wdGlvbnMnKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4vY29tcGFyYXRvcicpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2RlYnVnJylcbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4vc2VtdmVyJylcbmNvbnN0IHtcbiAgcmUsXG4gIHQsXG4gIGNvbXBhcmF0b3JUcmltUmVwbGFjZSxcbiAgdGlsZGVUcmltUmVwbGFjZSxcbiAgY2FyZXRUcmltUmVwbGFjZVxufSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcblxuY29uc3QgaXNOdWxsU2V0ID0gYyA9PiBjLnZhbHVlID09PSAnPDAuMC4wLTAnXG5jb25zdCBpc0FueSA9IGMgPT4gYy52YWx1ZSA9PT0gJydcblxuLy8gdGFrZSBhIHNldCBvZiBjb21wYXJhdG9ycyBhbmQgZGV0ZXJtaW5lIHdoZXRoZXIgdGhlcmVcbi8vIGV4aXN0cyBhIHZlcnNpb24gd2hpY2ggY2FuIHNhdGlzZnkgaXRcbmNvbnN0IGlzU2F0aXNmaWFibGUgPSAoY29tcGFyYXRvcnMsIG9wdGlvbnMpID0+IHtcbiAgbGV0IHJlc3VsdCA9IHRydWVcbiAgY29uc3QgcmVtYWluaW5nQ29tcGFyYXRvcnMgPSBjb21wYXJhdG9ycy5zbGljZSgpXG4gIGxldCB0ZXN0Q29tcGFyYXRvciA9IHJlbWFpbmluZ0NvbXBhcmF0b3JzLnBvcCgpXG5cbiAgd2hpbGUgKHJlc3VsdCAmJiByZW1haW5pbmdDb21wYXJhdG9ycy5sZW5ndGgpIHtcbiAgICByZXN1bHQgPSByZW1haW5pbmdDb21wYXJhdG9ycy5ldmVyeSgob3RoZXJDb21wYXJhdG9yKSA9PiB7XG4gICAgICByZXR1cm4gdGVzdENvbXBhcmF0b3IuaW50ZXJzZWN0cyhvdGhlckNvbXBhcmF0b3IsIG9wdGlvbnMpXG4gICAgfSlcblxuICAgIHRlc3RDb21wYXJhdG9yID0gcmVtYWluaW5nQ29tcGFyYXRvcnMucG9wKClcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLy8gY29tcHJpc2VkIG9mIHhyYW5nZXMsIHRpbGRlcywgc3RhcnMsIGFuZCBndGx0J3MgYXQgdGhpcyBwb2ludC5cbi8vIGFscmVhZHkgcmVwbGFjZWQgdGhlIGh5cGhlbiByYW5nZXNcbi8vIHR1cm4gaW50byBhIHNldCBvZiBKVVNUIGNvbXBhcmF0b3JzLlxuY29uc3QgcGFyc2VDb21wYXJhdG9yID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgZGVidWcoJ2NvbXAnLCBjb21wLCBvcHRpb25zKVxuICBjb21wID0gcmVwbGFjZUNhcmV0cyhjb21wLCBvcHRpb25zKVxuICBkZWJ1ZygnY2FyZXQnLCBjb21wKVxuICBjb21wID0gcmVwbGFjZVRpbGRlcyhjb21wLCBvcHRpb25zKVxuICBkZWJ1ZygndGlsZGVzJywgY29tcClcbiAgY29tcCA9IHJlcGxhY2VYUmFuZ2VzKGNvbXAsIG9wdGlvbnMpXG4gIGRlYnVnKCd4cmFuZ2UnLCBjb21wKVxuICBjb21wID0gcmVwbGFjZVN0YXJzKGNvbXAsIG9wdGlvbnMpXG4gIGRlYnVnKCdzdGFycycsIGNvbXApXG4gIHJldHVybiBjb21wXG59XG5cbmNvbnN0IGlzWCA9IGlkID0+ICFpZCB8fCBpZC50b0xvd2VyQ2FzZSgpID09PSAneCcgfHwgaWQgPT09ICcqJ1xuXG4vLyB+LCB+PiAtLT4gKiAoYW55LCBraW5kYSBzaWxseSlcbi8vIH4yLCB+Mi54LCB+Mi54LngsIH4+Miwgfj4yLnggfj4yLngueCAtLT4gPj0yLjAuMCA8My4wLjAtMFxuLy8gfjIuMCwgfjIuMC54LCB+PjIuMCwgfj4yLjAueCAtLT4gPj0yLjAuMCA8Mi4xLjAtMFxuLy8gfjEuMiwgfjEuMi54LCB+PjEuMiwgfj4xLjIueCAtLT4gPj0xLjIuMCA8MS4zLjAtMFxuLy8gfjEuMi4zLCB+PjEuMi4zIC0tPiA+PTEuMi4zIDwxLjMuMC0wXG4vLyB+MS4yLjAsIH4+MS4yLjAgLS0+ID49MS4yLjAgPDEuMy4wLTBcbmNvbnN0IHJlcGxhY2VUaWxkZXMgPSAoY29tcCwgb3B0aW9ucykgPT5cbiAgY29tcC50cmltKCkuc3BsaXQoL1xccysvKS5tYXAoKGNvbXApID0+IHtcbiAgICByZXR1cm4gcmVwbGFjZVRpbGRlKGNvbXAsIG9wdGlvbnMpXG4gIH0pLmpvaW4oJyAnKVxuXG5jb25zdCByZXBsYWNlVGlsZGUgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBjb25zdCByID0gb3B0aW9ucy5sb29zZSA/IHJlW3QuVElMREVMT09TRV0gOiByZVt0LlRJTERFXVxuICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIChfLCBNLCBtLCBwLCBwcikgPT4ge1xuICAgIGRlYnVnKCd0aWxkZScsIGNvbXAsIF8sIE0sIG0sIHAsIHByKVxuICAgIGxldCByZXRcblxuICAgIGlmIChpc1goTSkpIHtcbiAgICAgIHJldCA9ICcnXG4gICAgfSBlbHNlIGlmIChpc1gobSkpIHtcbiAgICAgIHJldCA9IGA+PSR7TX0uMC4wIDwkeytNICsgMX0uMC4wLTBgXG4gICAgfSBlbHNlIGlmIChpc1gocCkpIHtcbiAgICAgIC8vIH4xLjIgPT0gPj0xLjIuMCA8MS4zLjAtMFxuICAgICAgcmV0ID0gYD49JHtNfS4ke219LjAgPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9IGVsc2UgaWYgKHByKSB7XG4gICAgICBkZWJ1ZygncmVwbGFjZVRpbGRlIHByJywgcHIpXG4gICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwfS0ke3ByXG4gICAgICB9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIH4xLjIuMyA9PSA+PTEuMi4zIDwxLjMuMC0wXG4gICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwXG4gICAgICB9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgfVxuXG4gICAgZGVidWcoJ3RpbGRlIHJldHVybicsIHJldClcbiAgICByZXR1cm4gcmV0XG4gIH0pXG59XG5cbi8vIF4gLS0+ICogKGFueSwga2luZGEgc2lsbHkpXG4vLyBeMiwgXjIueCwgXjIueC54IC0tPiA+PTIuMC4wIDwzLjAuMC0wXG4vLyBeMi4wLCBeMi4wLnggLS0+ID49Mi4wLjAgPDMuMC4wLTBcbi8vIF4xLjIsIF4xLjIueCAtLT4gPj0xLjIuMCA8Mi4wLjAtMFxuLy8gXjEuMi4zIC0tPiA+PTEuMi4zIDwyLjAuMC0wXG4vLyBeMS4yLjAgLS0+ID49MS4yLjAgPDIuMC4wLTBcbmNvbnN0IHJlcGxhY2VDYXJldHMgPSAoY29tcCwgb3B0aW9ucykgPT5cbiAgY29tcC50cmltKCkuc3BsaXQoL1xccysvKS5tYXAoKGNvbXApID0+IHtcbiAgICByZXR1cm4gcmVwbGFjZUNhcmV0KGNvbXAsIG9wdGlvbnMpXG4gIH0pLmpvaW4oJyAnKVxuXG5jb25zdCByZXBsYWNlQ2FyZXQgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBkZWJ1ZygnY2FyZXQnLCBjb21wLCBvcHRpb25zKVxuICBjb25zdCByID0gb3B0aW9ucy5sb29zZSA/IHJlW3QuQ0FSRVRMT09TRV0gOiByZVt0LkNBUkVUXVxuICBjb25zdCB6ID0gb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/ICctMCcgOiAnJ1xuICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIChfLCBNLCBtLCBwLCBwcikgPT4ge1xuICAgIGRlYnVnKCdjYXJldCcsIGNvbXAsIF8sIE0sIG0sIHAsIHByKVxuICAgIGxldCByZXRcblxuICAgIGlmIChpc1goTSkpIHtcbiAgICAgIHJldCA9ICcnXG4gICAgfSBlbHNlIGlmIChpc1gobSkpIHtcbiAgICAgIHJldCA9IGA+PSR7TX0uMC4wJHt6fSA8JHsrTSArIDF9LjAuMC0wYFxuICAgIH0gZWxzZSBpZiAoaXNYKHApKSB7XG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4wJHt6fSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LjAke3p9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcikge1xuICAgICAgZGVidWcoJ3JlcGxhY2VDYXJldCBwcicsIHByKVxuICAgICAgaWYgKE0gPT09ICcwJykge1xuICAgICAgICBpZiAobSA9PT0gJzAnKSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cH0tJHtwclxuICAgICAgICAgIH0gPCR7TX0uJHttfS4keytwICsgMX0tMGBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwfS0ke3ByXG4gICAgICAgICAgfSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwfS0ke3ByXG4gICAgICAgIH0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ25vIHByJylcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgaWYgKG0gPT09ICcwJykge1xuICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgICAgICB9JHt6fSA8JHtNfS4ke219LiR7K3AgKyAxfS0wYFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgICAgICB9JHt6fSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwXG4gICAgICAgIH0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZWJ1ZygnY2FyZXQgcmV0dXJuJywgcmV0KVxuICAgIHJldHVybiByZXRcbiAgfSlcbn1cblxuY29uc3QgcmVwbGFjZVhSYW5nZXMgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBkZWJ1ZygncmVwbGFjZVhSYW5nZXMnLCBjb21wLCBvcHRpb25zKVxuICByZXR1cm4gY29tcC5zcGxpdCgvXFxzKy8pLm1hcCgoY29tcCkgPT4ge1xuICAgIHJldHVybiByZXBsYWNlWFJhbmdlKGNvbXAsIG9wdGlvbnMpXG4gIH0pLmpvaW4oJyAnKVxufVxuXG5jb25zdCByZXBsYWNlWFJhbmdlID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgY29tcCA9IGNvbXAudHJpbSgpXG4gIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5YUkFOR0VMT09TRV0gOiByZVt0LlhSQU5HRV1cbiAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCAocmV0LCBndGx0LCBNLCBtLCBwLCBwcikgPT4ge1xuICAgIGRlYnVnKCd4UmFuZ2UnLCBjb21wLCByZXQsIGd0bHQsIE0sIG0sIHAsIHByKVxuICAgIGNvbnN0IHhNID0gaXNYKE0pXG4gICAgY29uc3QgeG0gPSB4TSB8fCBpc1gobSlcbiAgICBjb25zdCB4cCA9IHhtIHx8IGlzWChwKVxuICAgIGNvbnN0IGFueVggPSB4cFxuXG4gICAgaWYgKGd0bHQgPT09ICc9JyAmJiBhbnlYKSB7XG4gICAgICBndGx0ID0gJydcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSdyZSBpbmNsdWRpbmcgcHJlcmVsZWFzZXMgaW4gdGhlIG1hdGNoLCB0aGVuIHdlIG5lZWRcbiAgICAvLyB0byBmaXggdGhpcyB0byAtMCwgdGhlIGxvd2VzdCBwb3NzaWJsZSBwcmVyZWxlYXNlIHZhbHVlXG4gICAgcHIgPSBvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlID8gJy0wJyA6ICcnXG5cbiAgICBpZiAoeE0pIHtcbiAgICAgIGlmIChndGx0ID09PSAnPicgfHwgZ3RsdCA9PT0gJzwnKSB7XG4gICAgICAgIC8vIG5vdGhpbmcgaXMgYWxsb3dlZFxuICAgICAgICByZXQgPSAnPDAuMC4wLTAnXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBub3RoaW5nIGlzIGZvcmJpZGRlblxuICAgICAgICByZXQgPSAnKidcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGd0bHQgJiYgYW55WCkge1xuICAgICAgLy8gd2Uga25vdyBwYXRjaCBpcyBhbiB4LCBiZWNhdXNlIHdlIGhhdmUgYW55IHggYXQgYWxsLlxuICAgICAgLy8gcmVwbGFjZSBYIHdpdGggMFxuICAgICAgaWYgKHhtKSB7XG4gICAgICAgIG0gPSAwXG4gICAgICB9XG4gICAgICBwID0gMFxuXG4gICAgICBpZiAoZ3RsdCA9PT0gJz4nKSB7XG4gICAgICAgIC8vID4xID0+ID49Mi4wLjBcbiAgICAgICAgLy8gPjEuMiA9PiA+PTEuMy4wXG4gICAgICAgIGd0bHQgPSAnPj0nXG4gICAgICAgIGlmICh4bSkge1xuICAgICAgICAgIE0gPSArTSArIDFcbiAgICAgICAgICBtID0gMFxuICAgICAgICAgIHAgPSAwXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbSA9ICttICsgMVxuICAgICAgICAgIHAgPSAwXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZ3RsdCA9PT0gJzw9Jykge1xuICAgICAgICAvLyA8PTAuNy54IGlzIGFjdHVhbGx5IDwwLjguMCwgc2luY2UgYW55IDAuNy54IHNob3VsZFxuICAgICAgICAvLyBwYXNzLiAgU2ltaWxhcmx5LCA8PTcueCBpcyBhY3R1YWxseSA8OC4wLjAsIGV0Yy5cbiAgICAgICAgZ3RsdCA9ICc8J1xuICAgICAgICBpZiAoeG0pIHtcbiAgICAgICAgICBNID0gK00gKyAxXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbSA9ICttICsgMVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChndGx0ID09PSAnPCcpXG4gICAgICAgIHByID0gJy0wJ1xuXG4gICAgICByZXQgPSBgJHtndGx0ICsgTX0uJHttfS4ke3B9JHtwcn1gXG4gICAgfSBlbHNlIGlmICh4bSkge1xuICAgICAgcmV0ID0gYD49JHtNfS4wLjAke3ByfSA8JHsrTSArIDF9LjAuMC0wYFxuICAgIH0gZWxzZSBpZiAoeHApIHtcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4wJHtwclxuICAgICAgfSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgIH1cblxuICAgIGRlYnVnKCd4UmFuZ2UgcmV0dXJuJywgcmV0KVxuXG4gICAgcmV0dXJuIHJldFxuICB9KVxufVxuXG4vLyBCZWNhdXNlICogaXMgQU5ELWVkIHdpdGggZXZlcnl0aGluZyBlbHNlIGluIHRoZSBjb21wYXJhdG9yLFxuLy8gYW5kICcnIG1lYW5zIFwiYW55IHZlcnNpb25cIiwganVzdCByZW1vdmUgdGhlICpzIGVudGlyZWx5LlxuY29uc3QgcmVwbGFjZVN0YXJzID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgZGVidWcoJ3JlcGxhY2VTdGFycycsIGNvbXAsIG9wdGlvbnMpXG4gIC8vIExvb3NlbmVzcyBpcyBpZ25vcmVkIGhlcmUuICBzdGFyIGlzIGFsd2F5cyBhcyBsb29zZSBhcyBpdCBnZXRzIVxuICByZXR1cm4gY29tcC50cmltKCkucmVwbGFjZShyZVt0LlNUQVJdLCAnJylcbn1cblxuY29uc3QgcmVwbGFjZUdURTAgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBkZWJ1ZygncmVwbGFjZUdURTAnLCBjb21wLCBvcHRpb25zKVxuICByZXR1cm4gY29tcC50cmltKClcbiAgICAucmVwbGFjZShyZVtvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlID8gdC5HVEUwUFJFIDogdC5HVEUwXSwgJycpXG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgcGFzc2VkIHRvIHN0cmluZy5yZXBsYWNlKHJlW3QuSFlQSEVOUkFOR0VdKVxuLy8gTSwgbSwgcGF0Y2gsIHByZXJlbGVhc2UsIGJ1aWxkXG4vLyAxLjIgLSAzLjQuNSA9PiA+PTEuMi4wIDw9My40LjVcbi8vIDEuMi4zIC0gMy40ID0+ID49MS4yLjAgPDMuNS4wLTAgQW55IDMuNC54IHdpbGwgZG9cbi8vIDEuMiAtIDMuNCA9PiA+PTEuMi4wIDwzLjUuMC0wXG5jb25zdCBoeXBoZW5SZXBsYWNlID0gaW5jUHIgPT4gKCQwLFxuICBmcm9tLCBmTSwgZm0sIGZwLCBmcHIsIGZiLFxuICB0bywgdE0sIHRtLCB0cCwgdHByLCB0YikgPT4ge1xuICBpZiAoaXNYKGZNKSkge1xuICAgIGZyb20gPSAnJ1xuICB9IGVsc2UgaWYgKGlzWChmbSkpIHtcbiAgICBmcm9tID0gYD49JHtmTX0uMC4wJHtpbmNQciA/ICctMCcgOiAnJ31gXG4gIH0gZWxzZSBpZiAoaXNYKGZwKSkge1xuICAgIGZyb20gPSBgPj0ke2ZNfS4ke2ZtfS4wJHtpbmNQciA/ICctMCcgOiAnJ31gXG4gIH0gZWxzZSBpZiAoZnByKSB7XG4gICAgZnJvbSA9IGA+PSR7ZnJvbX1gXG4gIH0gZWxzZSB7XG4gICAgZnJvbSA9IGA+PSR7ZnJvbX0ke2luY1ByID8gJy0wJyA6ICcnfWBcbiAgfVxuXG4gIGlmIChpc1godE0pKSB7XG4gICAgdG8gPSAnJ1xuICB9IGVsc2UgaWYgKGlzWCh0bSkpIHtcbiAgICB0byA9IGA8JHsrdE0gKyAxfS4wLjAtMGBcbiAgfSBlbHNlIGlmIChpc1godHApKSB7XG4gICAgdG8gPSBgPCR7dE19LiR7K3RtICsgMX0uMC0wYFxuICB9IGVsc2UgaWYgKHRwcikge1xuICAgIHRvID0gYDw9JHt0TX0uJHt0bX0uJHt0cH0tJHt0cHJ9YFxuICB9IGVsc2UgaWYgKGluY1ByKSB7XG4gICAgdG8gPSBgPCR7dE19LiR7dG19LiR7K3RwICsgMX0tMGBcbiAgfSBlbHNlIHtcbiAgICB0byA9IGA8PSR7dG99YFxuICB9XG5cbiAgcmV0dXJuIChgJHtmcm9tfSAke3RvfWApLnRyaW0oKVxufVxuXG5jb25zdCB0ZXN0U2V0ID0gKHNldCwgdmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgIGlmICghc2V0W2ldLnRlc3QodmVyc2lvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGlmICh2ZXJzaW9uLnByZXJlbGVhc2UubGVuZ3RoICYmICFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKSB7XG4gICAgLy8gRmluZCB0aGUgc2V0IG9mIHZlcnNpb25zIHRoYXQgYXJlIGFsbG93ZWQgdG8gaGF2ZSBwcmVyZWxlYXNlc1xuICAgIC8vIEZvciBleGFtcGxlLCBeMS4yLjMtcHIuMSBkZXN1Z2FycyB0byA+PTEuMi4zLXByLjEgPDIuMC4wXG4gICAgLy8gVGhhdCBzaG91bGQgYWxsb3cgYDEuMi4zLXByLjJgIHRvIHBhc3MuXG4gICAgLy8gSG93ZXZlciwgYDEuMi40LWFscGhhLm5vdHJlYWR5YCBzaG91bGQgTk9UIGJlIGFsbG93ZWQsXG4gICAgLy8gZXZlbiB0aG91Z2ggaXQncyB3aXRoaW4gdGhlIHJhbmdlIHNldCBieSB0aGUgY29tcGFyYXRvcnMuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlYnVnKHNldFtpXS5zZW12ZXIpXG4gICAgICBpZiAoc2V0W2ldLnNlbXZlciA9PT0gQ29tcGFyYXRvci5BTlkpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgaWYgKHNldFtpXS5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGFsbG93ZWQgPSBzZXRbaV0uc2VtdmVyXG4gICAgICAgIGlmIChhbGxvd2VkLm1ham9yID09PSB2ZXJzaW9uLm1ham9yICYmXG4gICAgICAgICAgICBhbGxvd2VkLm1pbm9yID09PSB2ZXJzaW9uLm1pbm9yICYmXG4gICAgICAgICAgICBhbGxvd2VkLnBhdGNoID09PSB2ZXJzaW9uLnBhdGNoKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFZlcnNpb24gaGFzIGEgLXByZSwgYnV0IGl0J3Mgbm90IG9uZSBvZiB0aGUgb25lcyB3ZSBsaWtlLlxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsImNvbnN0IEFOWSA9IFN5bWJvbCgnU2VtVmVyIEFOWScpXG4vLyBob2lzdGVkIGNsYXNzIGZvciBjeWNsaWMgZGVwZW5kZW5jeVxuY2xhc3MgQ29tcGFyYXRvciB7XG4gIHN0YXRpYyBnZXQgQU5ZICgpIHtcbiAgICByZXR1cm4gQU5ZXG4gIH1cbiAgY29uc3RydWN0b3IgKGNvbXAsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgICBpZiAoY29tcCBpbnN0YW5jZW9mIENvbXBhcmF0b3IpIHtcbiAgICAgIGlmIChjb21wLmxvb3NlID09PSAhIW9wdGlvbnMubG9vc2UpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXAgPSBjb21wLnZhbHVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVidWcoJ2NvbXBhcmF0b3InLCBjb21wLCBvcHRpb25zKVxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlXG4gICAgdGhpcy5wYXJzZShjb21wKVxuXG4gICAgaWYgKHRoaXMuc2VtdmVyID09PSBBTlkpIHtcbiAgICAgIHRoaXMudmFsdWUgPSAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy5vcGVyYXRvciArIHRoaXMuc2VtdmVyLnZlcnNpb25cbiAgICB9XG5cbiAgICBkZWJ1ZygnY29tcCcsIHRoaXMpXG4gIH1cblxuICBwYXJzZSAoY29tcCkge1xuICAgIGNvbnN0IHIgPSB0aGlzLm9wdGlvbnMubG9vc2UgPyByZVt0LkNPTVBBUkFUT1JMT09TRV0gOiByZVt0LkNPTVBBUkFUT1JdXG4gICAgY29uc3QgbSA9IGNvbXAubWF0Y2gocilcblxuICAgIGlmICghbSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBjb21wYXJhdG9yOiAke2NvbXB9YClcbiAgICB9XG5cbiAgICB0aGlzLm9wZXJhdG9yID0gbVsxXSAhPT0gdW5kZWZpbmVkID8gbVsxXSA6ICcnXG4gICAgaWYgKHRoaXMub3BlcmF0b3IgPT09ICc9Jykge1xuICAgICAgdGhpcy5vcGVyYXRvciA9ICcnXG4gICAgfVxuXG4gICAgLy8gaWYgaXQgbGl0ZXJhbGx5IGlzIGp1c3QgJz4nIG9yICcnIHRoZW4gYWxsb3cgYW55dGhpbmcuXG4gICAgaWYgKCFtWzJdKSB7XG4gICAgICB0aGlzLnNlbXZlciA9IEFOWVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbXZlciA9IG5ldyBTZW1WZXIobVsyXSwgdGhpcy5vcHRpb25zLmxvb3NlKVxuICAgIH1cbiAgfVxuXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZVxuICB9XG5cbiAgdGVzdCAodmVyc2lvbikge1xuICAgIGRlYnVnKCdDb21wYXJhdG9yLnRlc3QnLCB2ZXJzaW9uLCB0aGlzLm9wdGlvbnMubG9vc2UpXG5cbiAgICBpZiAodGhpcy5zZW12ZXIgPT09IEFOWSB8fCB2ZXJzaW9uID09PSBBTlkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgdGhpcy5vcHRpb25zKVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNtcCh2ZXJzaW9uLCB0aGlzLm9wZXJhdG9yLCB0aGlzLnNlbXZlciwgdGhpcy5vcHRpb25zKVxuICB9XG5cbiAgaW50ZXJzZWN0cyAoY29tcCwgb3B0aW9ucykge1xuICAgIGlmICghKGNvbXAgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYSBDb21wYXJhdG9yIGlzIHJlcXVpcmVkJylcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICBsb29zZTogISFvcHRpb25zLFxuICAgICAgICBpbmNsdWRlUHJlcmVsZWFzZTogZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcGVyYXRvciA9PT0gJycpIHtcbiAgICAgIGlmICh0aGlzLnZhbHVlID09PSAnJykge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBSYW5nZShjb21wLnZhbHVlLCBvcHRpb25zKS50ZXN0KHRoaXMudmFsdWUpXG4gICAgfSBlbHNlIGlmIChjb21wLm9wZXJhdG9yID09PSAnJykge1xuICAgICAgaWYgKGNvbXAudmFsdWUgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFJhbmdlKHRoaXMudmFsdWUsIG9wdGlvbnMpLnRlc3QoY29tcC5zZW12ZXIpXG4gICAgfVxuXG4gICAgY29uc3Qgc2FtZURpcmVjdGlvbkluY3JlYXNpbmcgPVxuICAgICAgKHRoaXMub3BlcmF0b3IgPT09ICc+PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJz4nKSAmJlxuICAgICAgKGNvbXAub3BlcmF0b3IgPT09ICc+PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJz4nKVxuICAgIGNvbnN0IHNhbWVEaXJlY3Rpb25EZWNyZWFzaW5nID1cbiAgICAgICh0aGlzLm9wZXJhdG9yID09PSAnPD0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc8JykgJiZcbiAgICAgIChjb21wLm9wZXJhdG9yID09PSAnPD0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc8JylcbiAgICBjb25zdCBzYW1lU2VtVmVyID0gdGhpcy5zZW12ZXIudmVyc2lvbiA9PT0gY29tcC5zZW12ZXIudmVyc2lvblxuICAgIGNvbnN0IGRpZmZlcmVudERpcmVjdGlvbnNJbmNsdXNpdmUgPVxuICAgICAgKHRoaXMub3BlcmF0b3IgPT09ICc+PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJzw9JykgJiZcbiAgICAgIChjb21wLm9wZXJhdG9yID09PSAnPj0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc8PScpXG4gICAgY29uc3Qgb3Bwb3NpdGVEaXJlY3Rpb25zTGVzc1RoYW4gPVxuICAgICAgY21wKHRoaXMuc2VtdmVyLCAnPCcsIGNvbXAuc2VtdmVyLCBvcHRpb25zKSAmJlxuICAgICAgKHRoaXMub3BlcmF0b3IgPT09ICc+PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJz4nKSAmJlxuICAgICAgICAoY29tcC5vcGVyYXRvciA9PT0gJzw9JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPCcpXG4gICAgY29uc3Qgb3Bwb3NpdGVEaXJlY3Rpb25zR3JlYXRlclRoYW4gPVxuICAgICAgY21wKHRoaXMuc2VtdmVyLCAnPicsIGNvbXAuc2VtdmVyLCBvcHRpb25zKSAmJlxuICAgICAgKHRoaXMub3BlcmF0b3IgPT09ICc8PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJzwnKSAmJlxuICAgICAgICAoY29tcC5vcGVyYXRvciA9PT0gJz49JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPicpXG5cbiAgICByZXR1cm4gKFxuICAgICAgc2FtZURpcmVjdGlvbkluY3JlYXNpbmcgfHxcbiAgICAgIHNhbWVEaXJlY3Rpb25EZWNyZWFzaW5nIHx8XG4gICAgICAoc2FtZVNlbVZlciAmJiBkaWZmZXJlbnREaXJlY3Rpb25zSW5jbHVzaXZlKSB8fFxuICAgICAgb3Bwb3NpdGVEaXJlY3Rpb25zTGVzc1RoYW4gfHxcbiAgICAgIG9wcG9zaXRlRGlyZWN0aW9uc0dyZWF0ZXJUaGFuXG4gICAgKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcGFyYXRvclxuXG5jb25zdCBwYXJzZU9wdGlvbnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9wYXJzZS1vcHRpb25zJylcbmNvbnN0IHtyZSwgdH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5jb25zdCBjbXAgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvY21wJylcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvZGVidWcnKVxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi9zZW12ZXInKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuL3JhbmdlJylcbiIsImNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBzYXRpc2ZpZXMgPSAodmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgdHJ5IHtcbiAgICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gcmFuZ2UudGVzdCh2ZXJzaW9uKVxufVxubW9kdWxlLmV4cG9ydHMgPSBzYXRpc2ZpZXNcbiIsImNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5cbi8vIE1vc3RseSBqdXN0IGZvciB0ZXN0aW5nIGFuZCBsZWdhY3kgQVBJIHJlYXNvbnNcbmNvbnN0IHRvQ29tcGFyYXRvcnMgPSAocmFuZ2UsIG9wdGlvbnMpID0+XG4gIG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucykuc2V0XG4gICAgLm1hcChjb21wID0+IGNvbXAubWFwKGMgPT4gYy52YWx1ZSkuam9pbignICcpLnRyaW0oKS5zcGxpdCgnICcpKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvQ29tcGFyYXRvcnNcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5cbmNvbnN0IG1heFNhdGlzZnlpbmcgPSAodmVyc2lvbnMsIHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gIGxldCBtYXggPSBudWxsXG4gIGxldCBtYXhTViA9IG51bGxcbiAgbGV0IHJhbmdlT2JqID0gbnVsbFxuICB0cnkge1xuICAgIHJhbmdlT2JqID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgdmVyc2lvbnMuZm9yRWFjaCgodikgPT4ge1xuICAgIGlmIChyYW5nZU9iai50ZXN0KHYpKSB7XG4gICAgICAvLyBzYXRpc2ZpZXModiwgcmFuZ2UsIG9wdGlvbnMpXG4gICAgICBpZiAoIW1heCB8fCBtYXhTVi5jb21wYXJlKHYpID09PSAtMSkge1xuICAgICAgICAvLyBjb21wYXJlKG1heCwgdiwgdHJ1ZSlcbiAgICAgICAgbWF4ID0gdlxuICAgICAgICBtYXhTViA9IG5ldyBTZW1WZXIobWF4LCBvcHRpb25zKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIG1heFxufVxubW9kdWxlLmV4cG9ydHMgPSBtYXhTYXRpc2Z5aW5nXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3QgbWluU2F0aXNmeWluZyA9ICh2ZXJzaW9ucywgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgbGV0IG1pbiA9IG51bGxcbiAgbGV0IG1pblNWID0gbnVsbFxuICBsZXQgcmFuZ2VPYmogPSBudWxsXG4gIHRyeSB7XG4gICAgcmFuZ2VPYmogPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICB2ZXJzaW9ucy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgaWYgKHJhbmdlT2JqLnRlc3QodikpIHtcbiAgICAgIC8vIHNhdGlzZmllcyh2LCByYW5nZSwgb3B0aW9ucylcbiAgICAgIGlmICghbWluIHx8IG1pblNWLmNvbXBhcmUodikgPT09IDEpIHtcbiAgICAgICAgLy8gY29tcGFyZShtaW4sIHYsIHRydWUpXG4gICAgICAgIG1pbiA9IHZcbiAgICAgICAgbWluU1YgPSBuZXcgU2VtVmVyKG1pbiwgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBtaW5cbn1cbm1vZHVsZS5leHBvcnRzID0gbWluU2F0aXNmeWluZ1xuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IGd0ID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2d0JylcblxuY29uc3QgbWluVmVyc2lvbiA9IChyYW5nZSwgbG9vc2UpID0+IHtcbiAgcmFuZ2UgPSBuZXcgUmFuZ2UocmFuZ2UsIGxvb3NlKVxuXG4gIGxldCBtaW52ZXIgPSBuZXcgU2VtVmVyKCcwLjAuMCcpXG4gIGlmIChyYW5nZS50ZXN0KG1pbnZlcikpIHtcbiAgICByZXR1cm4gbWludmVyXG4gIH1cblxuICBtaW52ZXIgPSBuZXcgU2VtVmVyKCcwLjAuMC0wJylcbiAgaWYgKHJhbmdlLnRlc3QobWludmVyKSkge1xuICAgIHJldHVybiBtaW52ZXJcbiAgfVxuXG4gIG1pbnZlciA9IG51bGxcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZS5zZXQubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBjb21wYXJhdG9ycyA9IHJhbmdlLnNldFtpXVxuXG4gICAgbGV0IHNldE1pbiA9IG51bGxcbiAgICBjb21wYXJhdG9ycy5mb3JFYWNoKChjb21wYXJhdG9yKSA9PiB7XG4gICAgICAvLyBDbG9uZSB0byBhdm9pZCBtYW5pcHVsYXRpbmcgdGhlIGNvbXBhcmF0b3IncyBzZW12ZXIgb2JqZWN0LlxuICAgICAgY29uc3QgY29tcHZlciA9IG5ldyBTZW1WZXIoY29tcGFyYXRvci5zZW12ZXIudmVyc2lvbilcbiAgICAgIHN3aXRjaCAoY29tcGFyYXRvci5vcGVyYXRvcikge1xuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICBpZiAoY29tcHZlci5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29tcHZlci5wYXRjaCsrXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXB2ZXIucHJlcmVsZWFzZS5wdXNoKDApXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbXB2ZXIucmF3ID0gY29tcHZlci5mb3JtYXQoKVxuICAgICAgICAgIC8qIGZhbGx0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJyc6XG4gICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICBpZiAoIXNldE1pbiB8fCBndChjb21wdmVyLCBzZXRNaW4pKSB7XG4gICAgICAgICAgICBzZXRNaW4gPSBjb21wdmVyXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgLyogSWdub3JlIG1heGltdW0gdmVyc2lvbnMgKi9cbiAgICAgICAgICBicmVha1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBvcGVyYXRpb246ICR7Y29tcGFyYXRvci5vcGVyYXRvcn1gKVxuICAgICAgfVxuICAgIH0pXG4gICAgaWYgKHNldE1pbiAmJiAoIW1pbnZlciB8fCBndChtaW52ZXIsIHNldE1pbikpKVxuICAgICAgbWludmVyID0gc2V0TWluXG4gIH1cblxuICBpZiAobWludmVyICYmIHJhbmdlLnRlc3QobWludmVyKSkge1xuICAgIHJldHVybiBtaW52ZXJcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5tb2R1bGUuZXhwb3J0cyA9IG1pblZlcnNpb25cbiIsImNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCB2YWxpZFJhbmdlID0gKHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gIHRyeSB7XG4gICAgLy8gUmV0dXJuICcqJyBpbnN0ZWFkIG9mICcnIHNvIHRoYXQgdHJ1dGhpbmVzcyB3b3Jrcy5cbiAgICAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgaXQncyBpbnZhbGlkIGFueXdheVxuICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpLnJhbmdlIHx8ICcqJ1xuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gdmFsaWRSYW5nZVxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvY29tcGFyYXRvcicpXG5jb25zdCB7QU5ZfSA9IENvbXBhcmF0b3JcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBzYXRpc2ZpZXMgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvc2F0aXNmaWVzJylcbmNvbnN0IGd0ID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2d0JylcbmNvbnN0IGx0ID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2x0JylcbmNvbnN0IGx0ZSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9sdGUnKVxuY29uc3QgZ3RlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2d0ZScpXG5cbmNvbnN0IG91dHNpZGUgPSAodmVyc2lvbiwgcmFuZ2UsIGhpbG8sIG9wdGlvbnMpID0+IHtcbiAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgb3B0aW9ucylcbiAgcmFuZ2UgPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpXG5cbiAgbGV0IGd0Zm4sIGx0ZWZuLCBsdGZuLCBjb21wLCBlY29tcFxuICBzd2l0Y2ggKGhpbG8pIHtcbiAgICBjYXNlICc+JzpcbiAgICAgIGd0Zm4gPSBndFxuICAgICAgbHRlZm4gPSBsdGVcbiAgICAgIGx0Zm4gPSBsdFxuICAgICAgY29tcCA9ICc+J1xuICAgICAgZWNvbXAgPSAnPj0nXG4gICAgICBicmVha1xuICAgIGNhc2UgJzwnOlxuICAgICAgZ3RmbiA9IGx0XG4gICAgICBsdGVmbiA9IGd0ZVxuICAgICAgbHRmbiA9IGd0XG4gICAgICBjb21wID0gJzwnXG4gICAgICBlY29tcCA9ICc8PSdcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ011c3QgcHJvdmlkZSBhIGhpbG8gdmFsIG9mIFwiPFwiIG9yIFwiPlwiJylcbiAgfVxuXG4gIC8vIElmIGl0IHNhdGlzZmllcyB0aGUgcmFuZ2UgaXQgaXMgbm90IG91dHNpZGVcbiAgaWYgKHNhdGlzZmllcyh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIEZyb20gbm93IG9uLCB2YXJpYWJsZSB0ZXJtcyBhcmUgYXMgaWYgd2UncmUgaW4gXCJndHJcIiBtb2RlLlxuICAvLyBidXQgbm90ZSB0aGF0IGV2ZXJ5dGhpbmcgaXMgZmxpcHBlZCBmb3IgdGhlIFwibHRyXCIgZnVuY3Rpb24uXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZS5zZXQubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBjb21wYXJhdG9ycyA9IHJhbmdlLnNldFtpXVxuXG4gICAgbGV0IGhpZ2ggPSBudWxsXG4gICAgbGV0IGxvdyA9IG51bGxcblxuICAgIGNvbXBhcmF0b3JzLmZvckVhY2goKGNvbXBhcmF0b3IpID0+IHtcbiAgICAgIGlmIChjb21wYXJhdG9yLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgICAgIGNvbXBhcmF0b3IgPSBuZXcgQ29tcGFyYXRvcignPj0wLjAuMCcpXG4gICAgICB9XG4gICAgICBoaWdoID0gaGlnaCB8fCBjb21wYXJhdG9yXG4gICAgICBsb3cgPSBsb3cgfHwgY29tcGFyYXRvclxuICAgICAgaWYgKGd0Zm4oY29tcGFyYXRvci5zZW12ZXIsIGhpZ2guc2VtdmVyLCBvcHRpb25zKSkge1xuICAgICAgICBoaWdoID0gY29tcGFyYXRvclxuICAgICAgfSBlbHNlIGlmIChsdGZuKGNvbXBhcmF0b3Iuc2VtdmVyLCBsb3cuc2VtdmVyLCBvcHRpb25zKSkge1xuICAgICAgICBsb3cgPSBjb21wYXJhdG9yXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIElmIHRoZSBlZGdlIHZlcnNpb24gY29tcGFyYXRvciBoYXMgYSBvcGVyYXRvciB0aGVuIG91ciB2ZXJzaW9uXG4gICAgLy8gaXNuJ3Qgb3V0c2lkZSBpdFxuICAgIGlmIChoaWdoLm9wZXJhdG9yID09PSBjb21wIHx8IGhpZ2gub3BlcmF0b3IgPT09IGVjb21wKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgbG93ZXN0IHZlcnNpb24gY29tcGFyYXRvciBoYXMgYW4gb3BlcmF0b3IgYW5kIG91ciB2ZXJzaW9uXG4gICAgLy8gaXMgbGVzcyB0aGFuIGl0IHRoZW4gaXQgaXNuJ3QgaGlnaGVyIHRoYW4gdGhlIHJhbmdlXG4gICAgaWYgKCghbG93Lm9wZXJhdG9yIHx8IGxvdy5vcGVyYXRvciA9PT0gY29tcCkgJiZcbiAgICAgICAgbHRlZm4odmVyc2lvbiwgbG93LnNlbXZlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSBpZiAobG93Lm9wZXJhdG9yID09PSBlY29tcCAmJiBsdGZuKHZlcnNpb24sIGxvdy5zZW12ZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdXRzaWRlXG4iLCIvLyBEZXRlcm1pbmUgaWYgdmVyc2lvbiBpcyBncmVhdGVyIHRoYW4gYWxsIHRoZSB2ZXJzaW9ucyBwb3NzaWJsZSBpbiB0aGUgcmFuZ2UuXG5jb25zdCBvdXRzaWRlID0gcmVxdWlyZSgnLi9vdXRzaWRlJylcbmNvbnN0IGd0ciA9ICh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykgPT4gb3V0c2lkZSh2ZXJzaW9uLCByYW5nZSwgJz4nLCBvcHRpb25zKVxubW9kdWxlLmV4cG9ydHMgPSBndHJcbiIsImNvbnN0IG91dHNpZGUgPSByZXF1aXJlKCcuL291dHNpZGUnKVxuLy8gRGV0ZXJtaW5lIGlmIHZlcnNpb24gaXMgbGVzcyB0aGFuIGFsbCB0aGUgdmVyc2lvbnMgcG9zc2libGUgaW4gdGhlIHJhbmdlXG5jb25zdCBsdHIgPSAodmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpID0+IG91dHNpZGUodmVyc2lvbiwgcmFuZ2UsICc8Jywgb3B0aW9ucylcbm1vZHVsZS5leHBvcnRzID0gbHRyXG4iLCJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3QgaW50ZXJzZWN0cyA9IChyMSwgcjIsIG9wdGlvbnMpID0+IHtcbiAgcjEgPSBuZXcgUmFuZ2UocjEsIG9wdGlvbnMpXG4gIHIyID0gbmV3IFJhbmdlKHIyLCBvcHRpb25zKVxuICByZXR1cm4gcjEuaW50ZXJzZWN0cyhyMilcbn1cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJzZWN0c1xuIiwiLy8gZ2l2ZW4gYSBzZXQgb2YgdmVyc2lvbnMgYW5kIGEgcmFuZ2UsIGNyZWF0ZSBhIFwic2ltcGxpZmllZFwiIHJhbmdlXG4vLyB0aGF0IGluY2x1ZGVzIHRoZSBzYW1lIHZlcnNpb25zIHRoYXQgdGhlIG9yaWdpbmFsIHJhbmdlIGRvZXNcbi8vIElmIHRoZSBvcmlnaW5hbCByYW5nZSBpcyBzaG9ydGVyIHRoYW4gdGhlIHNpbXBsaWZpZWQgb25lLCByZXR1cm4gdGhhdC5cbmNvbnN0IHNhdGlzZmllcyA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9zYXRpc2ZpZXMuanMnKVxuY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9jb21wYXJlLmpzJylcbm1vZHVsZS5leHBvcnRzID0gKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBzZXQgPSBbXVxuICBsZXQgbWluID0gbnVsbFxuICBsZXQgcHJldiA9IG51bGxcbiAgY29uc3QgdiA9IHZlcnNpb25zLnNvcnQoKGEsIGIpID0+IGNvbXBhcmUoYSwgYiwgb3B0aW9ucykpXG4gIGZvciAoY29uc3QgdmVyc2lvbiBvZiB2KSB7XG4gICAgY29uc3QgaW5jbHVkZWQgPSBzYXRpc2ZpZXModmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpXG4gICAgaWYgKGluY2x1ZGVkKSB7XG4gICAgICBwcmV2ID0gdmVyc2lvblxuICAgICAgaWYgKCFtaW4pXG4gICAgICAgIG1pbiA9IHZlcnNpb25cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgc2V0LnB1c2goW21pbiwgcHJldl0pXG4gICAgICB9XG4gICAgICBwcmV2ID0gbnVsbFxuICAgICAgbWluID0gbnVsbFxuICAgIH1cbiAgfVxuICBpZiAobWluKVxuICAgIHNldC5wdXNoKFttaW4sIG51bGxdKVxuXG4gIGNvbnN0IHJhbmdlcyA9IFtdXG4gIGZvciAoY29uc3QgW21pbiwgbWF4XSBvZiBzZXQpIHtcbiAgICBpZiAobWluID09PSBtYXgpXG4gICAgICByYW5nZXMucHVzaChtaW4pXG4gICAgZWxzZSBpZiAoIW1heCAmJiBtaW4gPT09IHZbMF0pXG4gICAgICByYW5nZXMucHVzaCgnKicpXG4gICAgZWxzZSBpZiAoIW1heClcbiAgICAgIHJhbmdlcy5wdXNoKGA+PSR7bWlufWApXG4gICAgZWxzZSBpZiAobWluID09PSB2WzBdKVxuICAgICAgcmFuZ2VzLnB1c2goYDw9JHttYXh9YClcbiAgICBlbHNlXG4gICAgICByYW5nZXMucHVzaChgJHttaW59IC0gJHttYXh9YClcbiAgfVxuICBjb25zdCBzaW1wbGlmaWVkID0gcmFuZ2VzLmpvaW4oJyB8fCAnKVxuICBjb25zdCBvcmlnaW5hbCA9IHR5cGVvZiByYW5nZS5yYXcgPT09ICdzdHJpbmcnID8gcmFuZ2UucmF3IDogU3RyaW5nKHJhbmdlKVxuICByZXR1cm4gc2ltcGxpZmllZC5sZW5ndGggPCBvcmlnaW5hbC5sZW5ndGggPyBzaW1wbGlmaWVkIDogcmFuZ2Vcbn1cbiIsImNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZS5qcycpXG5jb25zdCBDb21wYXJhdG9yID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9jb21wYXJhdG9yLmpzJylcbmNvbnN0IHsgQU5ZIH0gPSBDb21wYXJhdG9yXG5jb25zdCBzYXRpc2ZpZXMgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvc2F0aXNmaWVzLmpzJylcbmNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvY29tcGFyZS5qcycpXG5cbi8vIENvbXBsZXggcmFuZ2UgYHIxIHx8IHIyIHx8IC4uLmAgaXMgYSBzdWJzZXQgb2YgYFIxIHx8IFIyIHx8IC4uLmAgaWZmOlxuLy8gLSBFdmVyeSBzaW1wbGUgcmFuZ2UgYHIxLCByMiwgLi4uYCBpcyBhIG51bGwgc2V0LCBPUlxuLy8gLSBFdmVyeSBzaW1wbGUgcmFuZ2UgYHIxLCByMiwgLi4uYCB3aGljaCBpcyBub3QgYSBudWxsIHNldCBpcyBhIHN1YnNldCBvZlxuLy8gICBzb21lIGBSMSwgUjIsIC4uLmBcbi8vXG4vLyBTaW1wbGUgcmFuZ2UgYGMxIGMyIC4uLmAgaXMgYSBzdWJzZXQgb2Ygc2ltcGxlIHJhbmdlIGBDMSBDMiAuLi5gIGlmZjpcbi8vIC0gSWYgYyBpcyBvbmx5IHRoZSBBTlkgY29tcGFyYXRvclxuLy8gICAtIElmIEMgaXMgb25seSB0aGUgQU5ZIGNvbXBhcmF0b3IsIHJldHVybiB0cnVlXG4vLyAgIC0gRWxzZSBpZiBpbiBwcmVyZWxlYXNlIG1vZGUsIHJldHVybiBmYWxzZVxuLy8gICAtIGVsc2UgcmVwbGFjZSBjIHdpdGggYFs+PTAuMC4wXWBcbi8vIC0gSWYgQyBpcyBvbmx5IHRoZSBBTlkgY29tcGFyYXRvclxuLy8gICAtIGlmIGluIHByZXJlbGVhc2UgbW9kZSwgcmV0dXJuIHRydWVcbi8vICAgLSBlbHNlIHJlcGxhY2UgQyB3aXRoIGBbPj0wLjAuMF1gXG4vLyAtIExldCBFUSBiZSB0aGUgc2V0IG9mID0gY29tcGFyYXRvcnMgaW4gY1xuLy8gLSBJZiBFUSBpcyBtb3JlIHRoYW4gb25lLCByZXR1cm4gdHJ1ZSAobnVsbCBzZXQpXG4vLyAtIExldCBHVCBiZSB0aGUgaGlnaGVzdCA+IG9yID49IGNvbXBhcmF0b3IgaW4gY1xuLy8gLSBMZXQgTFQgYmUgdGhlIGxvd2VzdCA8IG9yIDw9IGNvbXBhcmF0b3IgaW4gY1xuLy8gLSBJZiBHVCBhbmQgTFQsIGFuZCBHVC5zZW12ZXIgPiBMVC5zZW12ZXIsIHJldHVybiB0cnVlIChudWxsIHNldClcbi8vIC0gSWYgYW55IEMgaXMgYSA9IHJhbmdlLCBhbmQgR1Qgb3IgTFQgYXJlIHNldCwgcmV0dXJuIGZhbHNlXG4vLyAtIElmIEVRXG4vLyAgIC0gSWYgR1QsIGFuZCBFUSBkb2VzIG5vdCBzYXRpc2Z5IEdULCByZXR1cm4gdHJ1ZSAobnVsbCBzZXQpXG4vLyAgIC0gSWYgTFQsIGFuZCBFUSBkb2VzIG5vdCBzYXRpc2Z5IExULCByZXR1cm4gdHJ1ZSAobnVsbCBzZXQpXG4vLyAgIC0gSWYgRVEgc2F0aXNmaWVzIGV2ZXJ5IEMsIHJldHVybiB0cnVlXG4vLyAgIC0gRWxzZSByZXR1cm4gZmFsc2Vcbi8vIC0gSWYgR1Rcbi8vICAgLSBJZiBHVC5zZW12ZXIgaXMgbG93ZXIgdGhhbiBhbnkgPiBvciA+PSBjb21wIGluIEMsIHJldHVybiBmYWxzZVxuLy8gICAtIElmIEdUIGlzID49LCBhbmQgR1Quc2VtdmVyIGRvZXMgbm90IHNhdGlzZnkgZXZlcnkgQywgcmV0dXJuIGZhbHNlXG4vLyAgIC0gSWYgR1Quc2VtdmVyIGhhcyBhIHByZXJlbGVhc2UsIGFuZCBub3QgaW4gcHJlcmVsZWFzZSBtb2RlXG4vLyAgICAgLSBJZiBubyBDIGhhcyBhIHByZXJlbGVhc2UgYW5kIHRoZSBHVC5zZW12ZXIgdHVwbGUsIHJldHVybiBmYWxzZVxuLy8gLSBJZiBMVFxuLy8gICAtIElmIExULnNlbXZlciBpcyBncmVhdGVyIHRoYW4gYW55IDwgb3IgPD0gY29tcCBpbiBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBMVCBpcyA8PSwgYW5kIExULnNlbXZlciBkb2VzIG5vdCBzYXRpc2Z5IGV2ZXJ5IEMsIHJldHVybiBmYWxzZVxuLy8gICAtIElmIEdULnNlbXZlciBoYXMgYSBwcmVyZWxlYXNlLCBhbmQgbm90IGluIHByZXJlbGVhc2UgbW9kZVxuLy8gICAgIC0gSWYgbm8gQyBoYXMgYSBwcmVyZWxlYXNlIGFuZCB0aGUgTFQuc2VtdmVyIHR1cGxlLCByZXR1cm4gZmFsc2Vcbi8vIC0gRWxzZSByZXR1cm4gdHJ1ZVxuXG5jb25zdCBzdWJzZXQgPSAoc3ViLCBkb20sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBpZiAoc3ViID09PSBkb20pXG4gICAgcmV0dXJuIHRydWVcblxuICBzdWIgPSBuZXcgUmFuZ2Uoc3ViLCBvcHRpb25zKVxuICBkb20gPSBuZXcgUmFuZ2UoZG9tLCBvcHRpb25zKVxuICBsZXQgc2F3Tm9uTnVsbCA9IGZhbHNlXG5cbiAgT1VURVI6IGZvciAoY29uc3Qgc2ltcGxlU3ViIG9mIHN1Yi5zZXQpIHtcbiAgICBmb3IgKGNvbnN0IHNpbXBsZURvbSBvZiBkb20uc2V0KSB7XG4gICAgICBjb25zdCBpc1N1YiA9IHNpbXBsZVN1YnNldChzaW1wbGVTdWIsIHNpbXBsZURvbSwgb3B0aW9ucylcbiAgICAgIHNhd05vbk51bGwgPSBzYXdOb25OdWxsIHx8IGlzU3ViICE9PSBudWxsXG4gICAgICBpZiAoaXNTdWIpXG4gICAgICAgIGNvbnRpbnVlIE9VVEVSXG4gICAgfVxuICAgIC8vIHRoZSBudWxsIHNldCBpcyBhIHN1YnNldCBvZiBldmVyeXRoaW5nLCBidXQgbnVsbCBzaW1wbGUgcmFuZ2VzIGluXG4gICAgLy8gYSBjb21wbGV4IHJhbmdlIHNob3VsZCBiZSBpZ25vcmVkLiAgc28gaWYgd2Ugc2F3IGEgbm9uLW51bGwgcmFuZ2UsXG4gICAgLy8gdGhlbiB3ZSBrbm93IHRoaXMgaXNuJ3QgYSBzdWJzZXQsIGJ1dCBpZiBFVkVSWSBzaW1wbGUgcmFuZ2Ugd2FzIG51bGwsXG4gICAgLy8gdGhlbiBpdCBpcyBhIHN1YnNldC5cbiAgICBpZiAoc2F3Tm9uTnVsbClcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbmNvbnN0IHNpbXBsZVN1YnNldCA9IChzdWIsIGRvbSwgb3B0aW9ucykgPT4ge1xuICBpZiAoc3ViID09PSBkb20pXG4gICAgcmV0dXJuIHRydWVcblxuICBpZiAoc3ViLmxlbmd0aCA9PT0gMSAmJiBzdWJbMF0uc2VtdmVyID09PSBBTlkpIHtcbiAgICBpZiAoZG9tLmxlbmd0aCA9PT0gMSAmJiBkb21bMF0uc2VtdmVyID09PSBBTlkpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGVsc2UgaWYgKG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpXG4gICAgICBzdWIgPSBbIG5ldyBDb21wYXJhdG9yKCc+PTAuMC4wLTAnKSBdXG4gICAgZWxzZVxuICAgICAgc3ViID0gWyBuZXcgQ29tcGFyYXRvcignPj0wLjAuMCcpIF1cbiAgfVxuXG4gIGlmIChkb20ubGVuZ3RoID09PSAxICYmIGRvbVswXS5zZW12ZXIgPT09IEFOWSkge1xuICAgIGlmIChvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICBlbHNlXG4gICAgICBkb20gPSBbIG5ldyBDb21wYXJhdG9yKCc+PTAuMC4wJykgXVxuICB9XG5cbiAgY29uc3QgZXFTZXQgPSBuZXcgU2V0KClcbiAgbGV0IGd0LCBsdFxuICBmb3IgKGNvbnN0IGMgb2Ygc3ViKSB7XG4gICAgaWYgKGMub3BlcmF0b3IgPT09ICc+JyB8fCBjLm9wZXJhdG9yID09PSAnPj0nKVxuICAgICAgZ3QgPSBoaWdoZXJHVChndCwgYywgb3B0aW9ucylcbiAgICBlbHNlIGlmIChjLm9wZXJhdG9yID09PSAnPCcgfHwgYy5vcGVyYXRvciA9PT0gJzw9JylcbiAgICAgIGx0ID0gbG93ZXJMVChsdCwgYywgb3B0aW9ucylcbiAgICBlbHNlXG4gICAgICBlcVNldC5hZGQoYy5zZW12ZXIpXG4gIH1cblxuICBpZiAoZXFTZXQuc2l6ZSA+IDEpXG4gICAgcmV0dXJuIG51bGxcblxuICBsZXQgZ3RsdENvbXBcbiAgaWYgKGd0ICYmIGx0KSB7XG4gICAgZ3RsdENvbXAgPSBjb21wYXJlKGd0LnNlbXZlciwgbHQuc2VtdmVyLCBvcHRpb25zKVxuICAgIGlmIChndGx0Q29tcCA+IDApXG4gICAgICByZXR1cm4gbnVsbFxuICAgIGVsc2UgaWYgKGd0bHRDb21wID09PSAwICYmIChndC5vcGVyYXRvciAhPT0gJz49JyB8fCBsdC5vcGVyYXRvciAhPT0gJzw9JykpXG4gICAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gd2lsbCBpdGVyYXRlIG9uZSBvciB6ZXJvIHRpbWVzXG4gIGZvciAoY29uc3QgZXEgb2YgZXFTZXQpIHtcbiAgICBpZiAoZ3QgJiYgIXNhdGlzZmllcyhlcSwgU3RyaW5nKGd0KSwgb3B0aW9ucykpXG4gICAgICByZXR1cm4gbnVsbFxuXG4gICAgaWYgKGx0ICYmICFzYXRpc2ZpZXMoZXEsIFN0cmluZyhsdCksIG9wdGlvbnMpKVxuICAgICAgcmV0dXJuIG51bGxcblxuICAgIGZvciAoY29uc3QgYyBvZiBkb20pIHtcbiAgICAgIGlmICghc2F0aXNmaWVzKGVxLCBTdHJpbmcoYyksIG9wdGlvbnMpKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgbGV0IGhpZ2hlciwgbG93ZXJcbiAgbGV0IGhhc0RvbUxULCBoYXNEb21HVFxuICAvLyBpZiB0aGUgc3Vic2V0IGhhcyBhIHByZXJlbGVhc2UsIHdlIG5lZWQgYSBjb21wYXJhdG9yIGluIHRoZSBzdXBlcnNldFxuICAvLyB3aXRoIHRoZSBzYW1lIHR1cGxlIGFuZCBhIHByZXJlbGVhc2UsIG9yIGl0J3Mgbm90IGEgc3Vic2V0XG4gIGxldCBuZWVkRG9tTFRQcmUgPSBsdCAmJlxuICAgICFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlICYmXG4gICAgbHQuc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID8gbHQuc2VtdmVyIDogZmFsc2VcbiAgbGV0IG5lZWREb21HVFByZSA9IGd0ICYmXG4gICAgIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgJiZcbiAgICBndC5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggPyBndC5zZW12ZXIgOiBmYWxzZVxuICAvLyBleGNlcHRpb246IDwxLjIuMy0wIGlzIHRoZSBzYW1lIGFzIDwxLjIuM1xuICBpZiAobmVlZERvbUxUUHJlICYmIG5lZWREb21MVFByZS5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgbHQub3BlcmF0b3IgPT09ICc8JyAmJiBuZWVkRG9tTFRQcmUucHJlcmVsZWFzZVswXSA9PT0gMCkge1xuICAgIG5lZWREb21MVFByZSA9IGZhbHNlXG4gIH1cblxuICBmb3IgKGNvbnN0IGMgb2YgZG9tKSB7XG4gICAgaGFzRG9tR1QgPSBoYXNEb21HVCB8fCBjLm9wZXJhdG9yID09PSAnPicgfHwgYy5vcGVyYXRvciA9PT0gJz49J1xuICAgIGhhc0RvbUxUID0gaGFzRG9tTFQgfHwgYy5vcGVyYXRvciA9PT0gJzwnIHx8IGMub3BlcmF0b3IgPT09ICc8PSdcbiAgICBpZiAoZ3QpIHtcbiAgICAgIGlmIChuZWVkRG9tR1RQcmUpIHtcbiAgICAgICAgaWYgKGMuc2VtdmVyLnByZXJlbGVhc2UgJiYgYy5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLm1ham9yID09PSBuZWVkRG9tR1RQcmUubWFqb3IgJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLm1pbm9yID09PSBuZWVkRG9tR1RQcmUubWlub3IgJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLnBhdGNoID09PSBuZWVkRG9tR1RQcmUucGF0Y2gpIHtcbiAgICAgICAgICBuZWVkRG9tR1RQcmUgPSBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYy5vcGVyYXRvciA9PT0gJz4nIHx8IGMub3BlcmF0b3IgPT09ICc+PScpIHtcbiAgICAgICAgaGlnaGVyID0gaGlnaGVyR1QoZ3QsIGMsIG9wdGlvbnMpXG4gICAgICAgIGlmIChoaWdoZXIgPT09IGMgJiYgaGlnaGVyICE9PSBndClcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH0gZWxzZSBpZiAoZ3Qub3BlcmF0b3IgPT09ICc+PScgJiYgIXNhdGlzZmllcyhndC5zZW12ZXIsIFN0cmluZyhjKSwgb3B0aW9ucykpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAobHQpIHtcbiAgICAgIGlmIChuZWVkRG9tTFRQcmUpIHtcbiAgICAgICAgaWYgKGMuc2VtdmVyLnByZXJlbGVhc2UgJiYgYy5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLm1ham9yID09PSBuZWVkRG9tTFRQcmUubWFqb3IgJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLm1pbm9yID09PSBuZWVkRG9tTFRQcmUubWlub3IgJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLnBhdGNoID09PSBuZWVkRG9tTFRQcmUucGF0Y2gpIHtcbiAgICAgICAgICBuZWVkRG9tTFRQcmUgPSBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYy5vcGVyYXRvciA9PT0gJzwnIHx8IGMub3BlcmF0b3IgPT09ICc8PScpIHtcbiAgICAgICAgbG93ZXIgPSBsb3dlckxUKGx0LCBjLCBvcHRpb25zKVxuICAgICAgICBpZiAobG93ZXIgPT09IGMgJiYgbG93ZXIgIT09IGx0KVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfSBlbHNlIGlmIChsdC5vcGVyYXRvciA9PT0gJzw9JyAmJiAhc2F0aXNmaWVzKGx0LnNlbXZlciwgU3RyaW5nKGMpLCBvcHRpb25zKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmICghYy5vcGVyYXRvciAmJiAobHQgfHwgZ3QpICYmIGd0bHRDb21wICE9PSAwKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBpZiB0aGVyZSB3YXMgYSA8IG9yID4sIGFuZCBub3RoaW5nIGluIHRoZSBkb20sIHRoZW4gbXVzdCBiZSBmYWxzZVxuICAvLyBVTkxFU1MgaXQgd2FzIGxpbWl0ZWQgYnkgYW5vdGhlciByYW5nZSBpbiB0aGUgb3RoZXIgZGlyZWN0aW9uLlxuICAvLyBFZywgPjEuMC4wIDwxLjAuMSBpcyBzdGlsbCBhIHN1YnNldCBvZiA8Mi4wLjBcbiAgaWYgKGd0ICYmIGhhc0RvbUxUICYmICFsdCAmJiBndGx0Q29tcCAhPT0gMClcbiAgICByZXR1cm4gZmFsc2VcblxuICBpZiAobHQgJiYgaGFzRG9tR1QgJiYgIWd0ICYmIGd0bHRDb21wICE9PSAwKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIC8vIHdlIG5lZWRlZCBhIHByZXJlbGVhc2UgcmFuZ2UgaW4gYSBzcGVjaWZpYyB0dXBsZSwgYnV0IGRpZG4ndCBnZXQgb25lXG4gIC8vIHRoZW4gdGhpcyBpc24ndCBhIHN1YnNldC4gIGVnID49MS4yLjMtcHJlIGlzIG5vdCBhIHN1YnNldCBvZiA+PTEuMC4wLFxuICAvLyBiZWNhdXNlIGl0IGluY2x1ZGVzIHByZXJlbGVhc2VzIGluIHRoZSAxLjIuMyB0dXBsZVxuICBpZiAobmVlZERvbUdUUHJlIHx8IG5lZWREb21MVFByZSlcbiAgICByZXR1cm4gZmFsc2VcblxuICByZXR1cm4gdHJ1ZVxufVxuXG4vLyA+PTEuMi4zIGlzIGxvd2VyIHRoYW4gPjEuMi4zXG5jb25zdCBoaWdoZXJHVCA9IChhLCBiLCBvcHRpb25zKSA9PiB7XG4gIGlmICghYSlcbiAgICByZXR1cm4gYlxuICBjb25zdCBjb21wID0gY29tcGFyZShhLnNlbXZlciwgYi5zZW12ZXIsIG9wdGlvbnMpXG4gIHJldHVybiBjb21wID4gMCA/IGFcbiAgICA6IGNvbXAgPCAwID8gYlxuICAgIDogYi5vcGVyYXRvciA9PT0gJz4nICYmIGEub3BlcmF0b3IgPT09ICc+PScgPyBiXG4gICAgOiBhXG59XG5cbi8vIDw9MS4yLjMgaXMgaGlnaGVyIHRoYW4gPDEuMi4zXG5jb25zdCBsb3dlckxUID0gKGEsIGIsIG9wdGlvbnMpID0+IHtcbiAgaWYgKCFhKVxuICAgIHJldHVybiBiXG4gIGNvbnN0IGNvbXAgPSBjb21wYXJlKGEuc2VtdmVyLCBiLnNlbXZlciwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXAgPCAwID8gYVxuICAgIDogY29tcCA+IDAgPyBiXG4gICAgOiBiLm9wZXJhdG9yID09PSAnPCcgJiYgYS5vcGVyYXRvciA9PT0gJzw9JyA/IGJcbiAgICA6IGFcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdWJzZXRcbiIsIi8vIGp1c3QgcHJlLWxvYWQgYWxsIHRoZSBzdHVmZiB0aGF0IGluZGV4LmpzIGxhemlseSBleHBvcnRzXG5jb25zdCBpbnRlcm5hbFJlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9yZScpXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcmU6IGludGVybmFsUmUucmUsXG4gIHNyYzogaW50ZXJuYWxSZS5zcmMsXG4gIHRva2VuczogaW50ZXJuYWxSZS50LFxuICBTRU1WRVJfU1BFQ19WRVJTSU9OOiByZXF1aXJlKCcuL2ludGVybmFsL2NvbnN0YW50cycpLlNFTVZFUl9TUEVDX1ZFUlNJT04sXG4gIFNlbVZlcjogcmVxdWlyZSgnLi9jbGFzc2VzL3NlbXZlcicpLFxuICBjb21wYXJlSWRlbnRpZmllcnM6IHJlcXVpcmUoJy4vaW50ZXJuYWwvaWRlbnRpZmllcnMnKS5jb21wYXJlSWRlbnRpZmllcnMsXG4gIHJjb21wYXJlSWRlbnRpZmllcnM6IHJlcXVpcmUoJy4vaW50ZXJuYWwvaWRlbnRpZmllcnMnKS5yY29tcGFyZUlkZW50aWZpZXJzLFxuICBwYXJzZTogcmVxdWlyZSgnLi9mdW5jdGlvbnMvcGFyc2UnKSxcbiAgdmFsaWQ6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3ZhbGlkJyksXG4gIGNsZWFuOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jbGVhbicpLFxuICBpbmM6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2luYycpLFxuICBkaWZmOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9kaWZmJyksXG4gIG1ham9yOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9tYWpvcicpLFxuICBtaW5vcjogcmVxdWlyZSgnLi9mdW5jdGlvbnMvbWlub3InKSxcbiAgcGF0Y2g6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3BhdGNoJyksXG4gIHByZXJlbGVhc2U6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3ByZXJlbGVhc2UnKSxcbiAgY29tcGFyZTogcmVxdWlyZSgnLi9mdW5jdGlvbnMvY29tcGFyZScpLFxuICByY29tcGFyZTogcmVxdWlyZSgnLi9mdW5jdGlvbnMvcmNvbXBhcmUnKSxcbiAgY29tcGFyZUxvb3NlOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jb21wYXJlLWxvb3NlJyksXG4gIGNvbXBhcmVCdWlsZDogcmVxdWlyZSgnLi9mdW5jdGlvbnMvY29tcGFyZS1idWlsZCcpLFxuICBzb3J0OiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9zb3J0JyksXG4gIHJzb3J0OiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9yc29ydCcpLFxuICBndDogcmVxdWlyZSgnLi9mdW5jdGlvbnMvZ3QnKSxcbiAgbHQ6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2x0JyksXG4gIGVxOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9lcScpLFxuICBuZXE6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL25lcScpLFxuICBndGU6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2d0ZScpLFxuICBsdGU6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2x0ZScpLFxuICBjbXA6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NtcCcpLFxuICBjb2VyY2U6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NvZXJjZScpLFxuICBDb21wYXJhdG9yOiByZXF1aXJlKCcuL2NsYXNzZXMvY29tcGFyYXRvcicpLFxuICBSYW5nZTogcmVxdWlyZSgnLi9jbGFzc2VzL3JhbmdlJyksXG4gIHNhdGlzZmllczogcmVxdWlyZSgnLi9mdW5jdGlvbnMvc2F0aXNmaWVzJyksXG4gIHRvQ29tcGFyYXRvcnM6IHJlcXVpcmUoJy4vcmFuZ2VzL3RvLWNvbXBhcmF0b3JzJyksXG4gIG1heFNhdGlzZnlpbmc6IHJlcXVpcmUoJy4vcmFuZ2VzL21heC1zYXRpc2Z5aW5nJyksXG4gIG1pblNhdGlzZnlpbmc6IHJlcXVpcmUoJy4vcmFuZ2VzL21pbi1zYXRpc2Z5aW5nJyksXG4gIG1pblZlcnNpb246IHJlcXVpcmUoJy4vcmFuZ2VzL21pbi12ZXJzaW9uJyksXG4gIHZhbGlkUmFuZ2U6IHJlcXVpcmUoJy4vcmFuZ2VzL3ZhbGlkJyksXG4gIG91dHNpZGU6IHJlcXVpcmUoJy4vcmFuZ2VzL291dHNpZGUnKSxcbiAgZ3RyOiByZXF1aXJlKCcuL3Jhbmdlcy9ndHInKSxcbiAgbHRyOiByZXF1aXJlKCcuL3Jhbmdlcy9sdHInKSxcbiAgaW50ZXJzZWN0czogcmVxdWlyZSgnLi9yYW5nZXMvaW50ZXJzZWN0cycpLFxuICBzaW1wbGlmeVJhbmdlOiByZXF1aXJlKCcuL3Jhbmdlcy9zaW1wbGlmeScpLFxuICBzdWJzZXQ6IHJlcXVpcmUoJy4vcmFuZ2VzL3N1YnNldCcpLFxufVxuIiwiLyoqXG4gKiBMb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanMuZm91bmRhdGlvbi8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbi8qKlxuICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgU3ltYm9sID0gcm9vdC5TeW1ib2wsXG4gICAgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheSxcbiAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlLFxuICAgIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gICAgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKSxcbiAgICBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpLFxuICAgIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKSxcbiAgICBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpLFxuICAgIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKSxcbiAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzID09IG51bGwgPyAwIDogdmFsdWVzLmxlbmd0aDtcblxuICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHRoaXMuYWRkKHZhbHVlc1tpbmRleF0pO1xuICB9XG59XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgYWRkXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBhbGlhcyBwdXNoXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAqIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBVbm9yZGVyZWQgY29tcGFyaXNvblxuICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgfVxuICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICBvYmpJc09iaiA9IGZhbHNlO1xuICB9XG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJlxuICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbi8qKlxuICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZVxuICogZXF1aXZhbGVudC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsXG4gKiBkYXRlIG9iamVjdHMsIGVycm9yIG9iamVjdHMsIG1hcHMsIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsXG4gKiBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWQgYXJyYXlzLiBgT2JqZWN0YCBvYmplY3RzIGFyZSBjb21wYXJlZFxuICogYnkgdGhlaXIgb3duLCBub3QgaW5oZXJpdGVkLCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuIEZ1bmN0aW9ucyBhbmQgRE9NXG4gKiBub2RlcyBhcmUgY29tcGFyZWQgYnkgc3RyaWN0IGVxdWFsaXR5LCBpLmUuIGA9PT1gLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmlzRXF1YWwob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogb2JqZWN0ID09PSBvdGhlcjtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRXF1YWwodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRXF1YWw7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlVGVtcFVwZGF0ZUZpbGUgPSBleHBvcnRzLkRvd25sb2FkZWRVcGRhdGVIZWxwZXIgPSB2b2lkIDA7XG5jb25zdCBjcnlwdG9fMSA9IHJlcXVpcmUoXCJjcnlwdG9cIik7XG5jb25zdCBmc18xID0gcmVxdWlyZShcImZzXCIpO1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgaXNFcXVhbCA9IHJlcXVpcmUoXCJsb2Rhc2guaXNlcXVhbFwiKTtcbmNvbnN0IGZzX2V4dHJhXzEgPSByZXF1aXJlKFwiZnMtZXh0cmFcIik7XG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG4vKiogQHByaXZhdGUgKiovXG5jbGFzcyBEb3dubG9hZGVkVXBkYXRlSGVscGVyIHtcbiAgICBjb25zdHJ1Y3RvcihjYWNoZURpcikge1xuICAgICAgICB0aGlzLmNhY2hlRGlyID0gY2FjaGVEaXI7XG4gICAgICAgIHRoaXMuX2ZpbGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9wYWNrYWdlRmlsZSA9IG51bGw7XG4gICAgICAgIHRoaXMudmVyc2lvbkluZm8gPSBudWxsO1xuICAgICAgICB0aGlzLmZpbGVJbmZvID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZG93bmxvYWRlZEZpbGVJbmZvID0gbnVsbDtcbiAgICB9XG4gICAgZ2V0IGRvd25sb2FkZWRGaWxlSW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rvd25sb2FkZWRGaWxlSW5mbztcbiAgICB9XG4gICAgZ2V0IGZpbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWxlO1xuICAgIH1cbiAgICBnZXQgcGFja2FnZUZpbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYWNrYWdlRmlsZTtcbiAgICB9XG4gICAgZ2V0IGNhY2hlRGlyRm9yUGVuZGluZ1VwZGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGguam9pbih0aGlzLmNhY2hlRGlyLCBcInBlbmRpbmdcIik7XG4gICAgfVxuICAgIGFzeW5jIHZhbGlkYXRlRG93bmxvYWRlZFBhdGgodXBkYXRlRmlsZSwgdXBkYXRlSW5mbywgZmlsZUluZm8sIGxvZ2dlcikge1xuICAgICAgICBpZiAodGhpcy52ZXJzaW9uSW5mbyAhPSBudWxsICYmIHRoaXMuZmlsZSA9PT0gdXBkYXRlRmlsZSAmJiB0aGlzLmZpbGVJbmZvICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBoYXMgYWxyZWFkeSBiZWVuIGRvd25sb2FkZWQgZnJvbSB0aGlzIHJ1bm5pbmcgaW5zdGFuY2VcbiAgICAgICAgICAgIC8vIGNoZWNrIGhlcmUgb25seSBleGlzdGVuY2UsIG5vdCBjaGVja3N1bVxuICAgICAgICAgICAgaWYgKGlzRXF1YWwodGhpcy52ZXJzaW9uSW5mbywgdXBkYXRlSW5mbykgJiYgaXNFcXVhbCh0aGlzLmZpbGVJbmZvLmluZm8sIGZpbGVJbmZvLmluZm8pICYmIChhd2FpdCBmc19leHRyYV8xLnBhdGhFeGlzdHModXBkYXRlRmlsZSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUZpbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB1cGRhdGUgaGFzIGFscmVhZHkgYmVlbiBkb3dubG9hZGVkIGZyb20gc29tZSBwcmV2aW91cyBhcHAgbGF1bmNoXG4gICAgICAgIGNvbnN0IGNhY2hlZFVwZGF0ZUZpbGUgPSBhd2FpdCB0aGlzLmdldFZhbGlkQ2FjaGVkVXBkYXRlRmlsZShmaWxlSW5mbywgbG9nZ2VyKTtcbiAgICAgICAgaWYgKGNhY2hlZFVwZGF0ZUZpbGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5pbmZvKGBVcGRhdGUgaGFzIGFscmVhZHkgYmVlbiBkb3dubG9hZGVkIHRvICR7dXBkYXRlRmlsZX0pLmApO1xuICAgICAgICB0aGlzLl9maWxlID0gY2FjaGVkVXBkYXRlRmlsZTtcbiAgICAgICAgcmV0dXJuIGNhY2hlZFVwZGF0ZUZpbGU7XG4gICAgfVxuICAgIGFzeW5jIHNldERvd25sb2FkZWRGaWxlKGRvd25sb2FkZWRGaWxlLCBwYWNrYWdlRmlsZSwgdmVyc2lvbkluZm8sIGZpbGVJbmZvLCB1cGRhdGVGaWxlTmFtZSwgaXNTYXZlQ2FjaGUpIHtcbiAgICAgICAgdGhpcy5fZmlsZSA9IGRvd25sb2FkZWRGaWxlO1xuICAgICAgICB0aGlzLl9wYWNrYWdlRmlsZSA9IHBhY2thZ2VGaWxlO1xuICAgICAgICB0aGlzLnZlcnNpb25JbmZvID0gdmVyc2lvbkluZm87XG4gICAgICAgIHRoaXMuZmlsZUluZm8gPSBmaWxlSW5mbztcbiAgICAgICAgdGhpcy5fZG93bmxvYWRlZEZpbGVJbmZvID0ge1xuICAgICAgICAgICAgZmlsZU5hbWU6IHVwZGF0ZUZpbGVOYW1lLFxuICAgICAgICAgICAgc2hhNTEyOiBmaWxlSW5mby5pbmZvLnNoYTUxMixcbiAgICAgICAgICAgIGlzQWRtaW5SaWdodHNSZXF1aXJlZDogZmlsZUluZm8uaW5mby5pc0FkbWluUmlnaHRzUmVxdWlyZWQgPT09IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChpc1NhdmVDYWNoZSkge1xuICAgICAgICAgICAgYXdhaXQgZnNfZXh0cmFfMS5vdXRwdXRKc29uKHRoaXMuZ2V0VXBkYXRlSW5mb0ZpbGUoKSwgdGhpcy5fZG93bmxvYWRlZEZpbGVJbmZvKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5fZmlsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BhY2thZ2VGaWxlID0gbnVsbDtcbiAgICAgICAgdGhpcy52ZXJzaW9uSW5mbyA9IG51bGw7XG4gICAgICAgIHRoaXMuZmlsZUluZm8gPSBudWxsO1xuICAgICAgICBhd2FpdCB0aGlzLmNsZWFuQ2FjaGVEaXJGb3JQZW5kaW5nVXBkYXRlKCk7XG4gICAgfVxuICAgIGFzeW5jIGNsZWFuQ2FjaGVEaXJGb3JQZW5kaW5nVXBkYXRlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHN0YWxlIGRhdGFcbiAgICAgICAgICAgIGF3YWl0IGZzX2V4dHJhXzEuZW1wdHlEaXIodGhpcy5jYWNoZURpckZvclBlbmRpbmdVcGRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChpZ25vcmUpIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgXCJ1cGRhdGUtaW5mby5qc29uXCIgd2hpY2ggaXMgY3JlYXRlZCBpbiB0aGUgdXBkYXRlIGNhY2hlIGRpcmVjdG9yeSdzIFwicGVuZGluZ1wiIHN1YmZvbGRlciBhZnRlciB0aGUgZmlyc3QgdXBkYXRlIGlzIGRvd25sb2FkZWQuICBJZiB0aGUgdXBkYXRlIGZpbGUgZG9lcyBub3QgZXhpc3QgdGhlbiB0aGUgY2FjaGUgaXMgY2xlYXJlZCBhbmQgcmVjcmVhdGVkLiAgSWYgdGhlIHVwZGF0ZSBmaWxlIGV4aXN0cyB0aGVuIGl0cyBwcm9wZXJ0aWVzIGFyZSB2YWxpZGF0ZWQuXG4gICAgICogQHBhcmFtIGZpbGVJbmZvXG4gICAgICogQHBhcmFtIGxvZ2dlclxuICAgICAqL1xuICAgIGFzeW5jIGdldFZhbGlkQ2FjaGVkVXBkYXRlRmlsZShmaWxlSW5mbywgbG9nZ2VyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgdXBkYXRlSW5mb0ZpbGVQYXRoID0gdGhpcy5nZXRVcGRhdGVJbmZvRmlsZSgpO1xuICAgICAgICBjb25zdCBkb2VzVXBkYXRlSW5mb0ZpbGVFeGlzdCA9IGF3YWl0IGZzX2V4dHJhXzEucGF0aEV4aXN0cyh1cGRhdGVJbmZvRmlsZVBhdGgpO1xuICAgICAgICBpZiAoIWRvZXNVcGRhdGVJbmZvRmlsZUV4aXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2FjaGVkSW5mbztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNhY2hlZEluZm8gPSBhd2FpdCBmc19leHRyYV8xLnJlYWRKc29uKHVwZGF0ZUluZm9GaWxlUGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZSA9IGBObyBjYWNoZWQgdXBkYXRlIGluZm8gYXZhaWxhYmxlYDtcbiAgICAgICAgICAgIGlmIChlcnJvci5jb2RlICE9PSBcIkVOT0VOVFwiKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jbGVhbkNhY2hlRGlyRm9yUGVuZGluZ1VwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gYCAoZXJyb3Igb24gcmVhZDogJHtlcnJvci5tZXNzYWdlfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmluZm8obWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0NhY2hlZEluZm9GaWxlTmFtZVZhbGlkID0gKF9hID0gKGNhY2hlZEluZm8gPT09IG51bGwgfHwgY2FjaGVkSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FjaGVkSW5mby5maWxlTmFtZSkgIT09IG51bGwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xuICAgICAgICBpZiAoIWlzQ2FjaGVkSW5mb0ZpbGVOYW1lVmFsaWQpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBDYWNoZWQgdXBkYXRlIGluZm8gaXMgY29ycnVwdGVkOiBubyBmaWxlTmFtZSwgZGlyZWN0b3J5IGZvciBjYWNoZWQgdXBkYXRlIHdpbGwgYmUgY2xlYW5lZGApO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jbGVhbkNhY2hlRGlyRm9yUGVuZGluZ1VwZGF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbGVJbmZvLmluZm8uc2hhNTEyICE9PSBjYWNoZWRJbmZvLnNoYTUxMikge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oYENhY2hlZCB1cGRhdGUgc2hhNTEyIGNoZWNrc3VtIGRvZXNuJ3QgbWF0Y2ggdGhlIGxhdGVzdCBhdmFpbGFibGUgdXBkYXRlLiBOZXcgdXBkYXRlIG11c3QgYmUgZG93bmxvYWRlZC4gQ2FjaGVkOiAke2NhY2hlZEluZm8uc2hhNTEyfSwgZXhwZWN0ZWQ6ICR7ZmlsZUluZm8uaW5mby5zaGE1MTJ9LiBEaXJlY3RvcnkgZm9yIGNhY2hlZCB1cGRhdGUgd2lsbCBiZSBjbGVhbmVkYCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNsZWFuQ2FjaGVEaXJGb3JQZW5kaW5nVXBkYXRlKCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGRhdGVGaWxlID0gcGF0aC5qb2luKHRoaXMuY2FjaGVEaXJGb3JQZW5kaW5nVXBkYXRlLCBjYWNoZWRJbmZvLmZpbGVOYW1lKTtcbiAgICAgICAgaWYgKCEoYXdhaXQgZnNfZXh0cmFfMS5wYXRoRXhpc3RzKHVwZGF0ZUZpbGUpKSkge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oXCJDYWNoZWQgdXBkYXRlIGZpbGUgZG9lc24ndCBleGlzdFwiKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNoYTUxMiA9IGF3YWl0IGhhc2hGaWxlKHVwZGF0ZUZpbGUpO1xuICAgICAgICBpZiAoZmlsZUluZm8uaW5mby5zaGE1MTIgIT09IHNoYTUxMikge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYFNoYTUxMiBjaGVja3N1bSBkb2Vzbid0IG1hdGNoIHRoZSBsYXRlc3QgYXZhaWxhYmxlIHVwZGF0ZS4gTmV3IHVwZGF0ZSBtdXN0IGJlIGRvd25sb2FkZWQuIENhY2hlZDogJHtzaGE1MTJ9LCBleHBlY3RlZDogJHtmaWxlSW5mby5pbmZvLnNoYTUxMn1gKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY2xlYW5DYWNoZURpckZvclBlbmRpbmdVcGRhdGUoKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Rvd25sb2FkZWRGaWxlSW5mbyA9IGNhY2hlZEluZm87XG4gICAgICAgIHJldHVybiB1cGRhdGVGaWxlO1xuICAgIH1cbiAgICBnZXRVcGRhdGVJbmZvRmlsZSgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGguam9pbih0aGlzLmNhY2hlRGlyRm9yUGVuZGluZ1VwZGF0ZSwgXCJ1cGRhdGUtaW5mby5qc29uXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuRG93bmxvYWRlZFVwZGF0ZUhlbHBlciA9IERvd25sb2FkZWRVcGRhdGVIZWxwZXI7XG5mdW5jdGlvbiBoYXNoRmlsZShmaWxlLCBhbGdvcml0aG0gPSBcInNoYTUxMlwiLCBlbmNvZGluZyA9IFwiYmFzZTY0XCIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBoYXNoID0gY3J5cHRvXzEuY3JlYXRlSGFzaChhbGdvcml0aG0pO1xuICAgICAgICBoYXNoLm9uKFwiZXJyb3JcIiwgcmVqZWN0KS5zZXRFbmNvZGluZyhlbmNvZGluZyk7XG4gICAgICAgIGZzXzEuY3JlYXRlUmVhZFN0cmVhbShmaWxlLCB7IC4uLm9wdGlvbnMsIGhpZ2hXYXRlck1hcms6IDEwMjQgKiAxMDI0IC8qIGJldHRlciB0byB1c2UgbW9yZSBtZW1vcnkgYnV0IGhhc2ggZmFzdGVyICovIH0pXG4gICAgICAgICAgICAub24oXCJlcnJvclwiLCByZWplY3QpXG4gICAgICAgICAgICAub24oXCJlbmRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgaGFzaC5lbmQoKTtcbiAgICAgICAgICAgIHJlc29sdmUoaGFzaC5yZWFkKCkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnBpcGUoaGFzaCwgeyBlbmQ6IGZhbHNlIH0pO1xuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlVGVtcFVwZGF0ZUZpbGUobmFtZSwgY2FjaGVEaXIsIGxvZykge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGVjdHJvbi11c2VybGFuZC9lbGVjdHJvbi1idWlsZGVyL3B1bGwvMjQ3NCNpc3N1ZWNvbW1lbnQtMzY2NDgxOTEyXG4gICAgbGV0IG5hbWVDb3VudGVyID0gMDtcbiAgICBsZXQgcmVzdWx0ID0gcGF0aC5qb2luKGNhY2hlRGlyLCBuYW1lKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgZnNfZXh0cmFfMS51bmxpbmsocmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlLmNvZGUgPT09IFwiRU5PRU5UXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nLndhcm4oYEVycm9yIG9uIHJlbW92ZSB0ZW1wIHVwZGF0ZSBmaWxlOiAke2V9YCk7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXRoLmpvaW4oY2FjaGVEaXIsIGAke25hbWVDb3VudGVyKyt9LSR7bmFtZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5jcmVhdGVUZW1wVXBkYXRlRmlsZSA9IGNyZWF0ZVRlbXBVcGRhdGVGaWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RG93bmxvYWRlZFVwZGF0ZUhlbHBlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0QXBwQ2FjaGVEaXIgPSB2b2lkIDA7XG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCBvc18xID0gcmVxdWlyZShcIm9zXCIpO1xuZnVuY3Rpb24gZ2V0QXBwQ2FjaGVEaXIoKSB7XG4gICAgY29uc3QgaG9tZWRpciA9IG9zXzEuaG9tZWRpcigpO1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGVjdHJvbi9lbGVjdHJvbi9pc3N1ZXMvMTQwNCNpc3N1ZWNvbW1lbnQtMTk0MzkxMjQ3XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiKSB7XG4gICAgICAgIHJlc3VsdCA9IHByb2Nlc3MuZW52W1wiTE9DQUxBUFBEQVRBXCJdIHx8IHBhdGguam9pbihob21lZGlyLCBcIkFwcERhdGFcIiwgXCJMb2NhbFwiKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJkYXJ3aW5cIikge1xuICAgICAgICByZXN1bHQgPSBwYXRoLmpvaW4oaG9tZWRpciwgXCJMaWJyYXJ5XCIsIFwiQXBwbGljYXRpb24gU3VwcG9ydFwiLCBcIkNhY2hlc1wiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHByb2Nlc3MuZW52W1wiWERHX0NBQ0hFX0hPTUVcIl0gfHwgcGF0aC5qb2luKGhvbWVkaXIsIFwiLmNhY2hlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5nZXRBcHBDYWNoZURpciA9IGdldEFwcENhY2hlRGlyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXBwQWRhcHRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRWxlY3Ryb25BcHBBZGFwdGVyID0gdm9pZCAwO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgQXBwQWRhcHRlcl8xID0gcmVxdWlyZShcIi4vQXBwQWRhcHRlclwiKTtcbmNsYXNzIEVsZWN0cm9uQXBwQWRhcHRlciB7XG4gICAgY29uc3RydWN0b3IoYXBwID0gcmVxdWlyZShcImVsZWN0cm9uXCIpLmFwcCkge1xuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcbiAgICB9XG4gICAgd2hlblJlYWR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHAud2hlblJlYWR5KCk7XG4gICAgfVxuICAgIGdldCB2ZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHAuZ2V0VmVyc2lvbigpO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwLmdldE5hbWUoKTtcbiAgICB9XG4gICAgZ2V0IGlzUGFja2FnZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcC5pc1BhY2thZ2VkID09PSB0cnVlO1xuICAgIH1cbiAgICBnZXQgYXBwVXBkYXRlQ29uZmlnUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNQYWNrYWdlZCA/IHBhdGguam9pbihwcm9jZXNzLnJlc291cmNlc1BhdGgsIFwiYXBwLXVwZGF0ZS55bWxcIikgOiBwYXRoLmpvaW4odGhpcy5hcHAuZ2V0QXBwUGF0aCgpLCBcImRldi1hcHAtdXBkYXRlLnltbFwiKTtcbiAgICB9XG4gICAgZ2V0IHVzZXJEYXRhUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwLmdldFBhdGgoXCJ1c2VyRGF0YVwiKTtcbiAgICB9XG4gICAgZ2V0IGJhc2VDYWNoZVBhdGgoKSB7XG4gICAgICAgIHJldHVybiBBcHBBZGFwdGVyXzEuZ2V0QXBwQ2FjaGVEaXIoKTtcbiAgICB9XG4gICAgcXVpdCgpIHtcbiAgICAgICAgdGhpcy5hcHAucXVpdCgpO1xuICAgIH1cbiAgICBvblF1aXQoaGFuZGxlcikge1xuICAgICAgICB0aGlzLmFwcC5vbmNlKFwicXVpdFwiLCAoXywgZXhpdENvZGUpID0+IGhhbmRsZXIoZXhpdENvZGUpKTtcbiAgICB9XG59XG5leHBvcnRzLkVsZWN0cm9uQXBwQWRhcHRlciA9IEVsZWN0cm9uQXBwQWRhcHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVsZWN0cm9uQXBwQWRhcHRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRWxlY3Ryb25IdHRwRXhlY3V0b3IgPSBleHBvcnRzLmdldE5ldFNlc3Npb24gPSBleHBvcnRzLk5FVF9TRVNTSU9OX05BTUUgPSB2b2lkIDA7XG5jb25zdCBidWlsZGVyX3V0aWxfcnVudGltZV8xID0gcmVxdWlyZShcImJ1aWxkZXItdXRpbC1ydW50aW1lXCIpO1xuZXhwb3J0cy5ORVRfU0VTU0lPTl9OQU1FID0gXCJlbGVjdHJvbi11cGRhdGVyXCI7XG5mdW5jdGlvbiBnZXROZXRTZXNzaW9uKCkge1xuICAgIHJldHVybiByZXF1aXJlKFwiZWxlY3Ryb25cIikuc2Vzc2lvbi5mcm9tUGFydGl0aW9uKGV4cG9ydHMuTkVUX1NFU1NJT05fTkFNRSwge1xuICAgICAgICBjYWNoZTogZmFsc2UsXG4gICAgfSk7XG59XG5leHBvcnRzLmdldE5ldFNlc3Npb24gPSBnZXROZXRTZXNzaW9uO1xuY2xhc3MgRWxlY3Ryb25IdHRwRXhlY3V0b3IgZXh0ZW5kcyBidWlsZGVyX3V0aWxfcnVudGltZV8xLkh0dHBFeGVjdXRvciB7XG4gICAgY29uc3RydWN0b3IocHJveHlMb2dpbkNhbGxiYWNrKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucHJveHlMb2dpbkNhbGxiYWNrID0gcHJveHlMb2dpbkNhbGxiYWNrO1xuICAgICAgICB0aGlzLmNhY2hlZFNlc3Npb24gPSBudWxsO1xuICAgIH1cbiAgICBhc3luYyBkb3dubG9hZCh1cmwsIGRlc3RpbmF0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBvcHRpb25zLmNhbmNlbGxhdGlvblRva2VuLmNyZWF0ZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCwgb25DYW5jZWwpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVycyB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcmVkaXJlY3Q6IFwibWFudWFsXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5jb25maWd1cmVSZXF1ZXN0VXJsKHVybCwgcmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICAgICAgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5jb25maWd1cmVSZXF1ZXN0T3B0aW9ucyhyZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLmRvRG93bmxvYWQocmVxdWVzdE9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgIG9uQ2FuY2VsLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlSGFuZGxlcjogbnVsbCxcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY3JlYXRlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICAvLyBmaXggKG5vZGUgNyspIGZvciBtYWtpbmcgZWxlY3Ryb24gdXBkYXRlciB3b3JrIHdoZW4gdXNpbmcgQVdTIHByaXZhdGUgYnVja2V0cywgY2hlY2sgaWYgaGVhZGVycyBjb250YWluIEhvc3QgcHJvcGVydHlcbiAgICAgICAgaWYgKG9wdGlvbnMuaGVhZGVycyAmJiBvcHRpb25zLmhlYWRlcnMuSG9zdCkge1xuICAgICAgICAgICAgLy8gc2V0IGhvc3QgdmFsdWUgZnJvbSBoZWFkZXJzLkhvc3RcbiAgICAgICAgICAgIG9wdGlvbnMuaG9zdCA9IG9wdGlvbnMuaGVhZGVycy5Ib3N0O1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGhlYWRlciBwcm9wZXJ0eSAnSG9zdCcsIGlmIG5vdCByZW1vdmVkIGNhdXNlcyBuZXQ6OkVSUl9JTlZBTElEX0FSR1VNRU5UIGV4Y2VwdGlvblxuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuaGVhZGVycy5Ib3N0O1xuICAgICAgICB9XG4gICAgICAgIC8vIGRpZmZlcmVudGlhbCBkb3dubG9hZGVyIGNhbiBjYWxsIHRoaXMgbWV0aG9kIHZlcnkgb2Z0ZW4sIHNvLCBiZXR0ZXIgdG8gY2FjaGUgc2Vzc2lvblxuICAgICAgICBpZiAodGhpcy5jYWNoZWRTZXNzaW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkU2Vzc2lvbiA9IGdldE5ldFNlc3Npb24oKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gcmVxdWlyZShcImVsZWN0cm9uXCIpLm5ldC5yZXF1ZXN0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBzZXNzaW9uOiB0aGlzLmNhY2hlZFNlc3Npb24sXG4gICAgICAgIH0pO1xuICAgICAgICByZXF1ZXN0Lm9uKFwicmVzcG9uc2VcIiwgY2FsbGJhY2spO1xuICAgICAgICBpZiAodGhpcy5wcm94eUxvZ2luQ2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVxdWVzdC5vbihcImxvZ2luXCIsIHRoaXMucHJveHlMb2dpbkNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9XG4gICAgYWRkUmVkaXJlY3RIYW5kbGVycyhyZXF1ZXN0LCBvcHRpb25zLCByZWplY3QsIHJlZGlyZWN0Q291bnQsIGhhbmRsZXIpIHtcbiAgICAgICAgcmVxdWVzdC5vbihcInJlZGlyZWN0XCIsIChzdGF0dXNDb2RlLCBtZXRob2QsIHJlZGlyZWN0VXJsKSA9PiB7XG4gICAgICAgICAgICAvLyBubyB3YXkgdG8gbW9kaWZ5IHJlcXVlc3Qgb3B0aW9ucywgYWJvcnQgb2xkIGFuZCBtYWtlIGEgbmV3IG9uZVxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2VsZWN0cm9uL2VsZWN0cm9uL2lzc3Vlcy8xMTUwNVxuICAgICAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICAgICAgaWYgKHJlZGlyZWN0Q291bnQgPiB0aGlzLm1heFJlZGlyZWN0cykge1xuICAgICAgICAgICAgICAgIHJlamVjdCh0aGlzLmNyZWF0ZU1heFJlZGlyZWN0RXJyb3IoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyKGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuSHR0cEV4ZWN1dG9yLnByZXBhcmVSZWRpcmVjdFVybE9wdGlvbnMocmVkaXJlY3RVcmwsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5FbGVjdHJvbkh0dHBFeGVjdXRvciA9IEVsZWN0cm9uSHR0cEV4ZWN1dG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWxlY3Ryb25IdHRwRXhlY3V0b3IuanMubWFwIiwiLyoqXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZyxcbiAgICByZUhhc1JlZ0V4cENoYXIgPSBSZWdFeHAocmVSZWdFeHBDaGFyLnNvdXJjZSk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG4vKipcbiAqIEVzY2FwZXMgdGhlIGBSZWdFeHBgIHNwZWNpYWwgY2hhcmFjdGVycyBcIl5cIiwgXCIkXCIsIFwiXFxcIiwgXCIuXCIsIFwiKlwiLCBcIitcIixcbiAqIFwiP1wiLCBcIihcIiwgXCIpXCIsIFwiW1wiLCBcIl1cIiwgXCJ7XCIsIFwifVwiLCBhbmQgXCJ8XCIgaW4gYHN0cmluZ2AuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZXNjYXBlUmVnRXhwKCdbbG9kYXNoXShodHRwczovL2xvZGFzaC5jb20vKScpO1xuICogLy8gPT4gJ1xcW2xvZGFzaFxcXVxcKGh0dHBzOi8vbG9kYXNoXFwuY29tL1xcKSdcbiAqL1xuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICByZXR1cm4gKHN0cmluZyAmJiByZUhhc1JlZ0V4cENoYXIudGVzdChzdHJpbmcpKVxuICAgID8gc3RyaW5nLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgICA6IHN0cmluZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlc2NhcGVSZWdFeHA7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYmxvY2ttYXBGaWxlcyA9IGV4cG9ydHMuZ2V0Q2hhbm5lbEZpbGVuYW1lID0gZXhwb3J0cy5uZXdVcmxGcm9tQmFzZSA9IGV4cG9ydHMubmV3QmFzZVVybCA9IHZvaWQgMDtcbi8vIGlmIGJhc2VVcmwgcGF0aCBkb2Vzbid0IGVuZHMgd2l0aCAvLCB0aGlzIHBhdGggd2lsbCBiZSBub3QgcHJlcGVuZGVkIHRvIHBhc3NlZCBwYXRobmFtZSBmb3IgbmV3IFVSTChpbnB1dCwgYmFzZSlcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcInVybFwiKTtcbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGVzY2FwZVJlZ0V4cCA9IHJlcXVpcmUoXCJsb2Rhc2guZXNjYXBlcmVnZXhwXCIpO1xuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gbmV3QmFzZVVybCh1cmwpIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgdXJsXzEuVVJMKHVybCk7XG4gICAgaWYgKCFyZXN1bHQucGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgICAgIHJlc3VsdC5wYXRobmFtZSArPSBcIi9cIjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMubmV3QmFzZVVybCA9IG5ld0Jhc2VVcmw7XG4vLyBhZGRSYW5kb21RdWVyeVRvQXZvaWRDYWNoaW5nIGlzIGZhbHNlIGJ5IGRlZmF1bHQgYmVjYXVzZSBpbiBtb3N0IGNhc2VzIFVSTCBhbHJlYWR5IGNvbnRhaW5zIHZlcnNpb24gbnVtYmVyLFxuLy8gc28sIGl0IG1ha2VzIHNlbnNlIG9ubHkgZm9yIEdlbmVyaWMgUHJvdmlkZXIgZm9yIGNoYW5uZWwgZmlsZXNcbmZ1bmN0aW9uIG5ld1VybEZyb21CYXNlKHBhdGhuYW1lLCBiYXNlVXJsLCBhZGRSYW5kb21RdWVyeVRvQXZvaWRDYWNoaW5nID0gZmFsc2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgdXJsXzEuVVJMKHBhdGhuYW1lLCBiYXNlVXJsKTtcbiAgICAvLyBzZWFyY2ggaXMgbm90IHByb3BhZ2F0ZWQgKHNlYXJjaCBpcyBhbiBlbXB0eSBzdHJpbmcgaWYgbm90IHNwZWNpZmllZClcbiAgICBjb25zdCBzZWFyY2ggPSBiYXNlVXJsLnNlYXJjaDtcbiAgICBpZiAoc2VhcmNoICE9IG51bGwgJiYgc2VhcmNoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICByZXN1bHQuc2VhcmNoID0gc2VhcmNoO1xuICAgIH1cbiAgICBlbHNlIGlmIChhZGRSYW5kb21RdWVyeVRvQXZvaWRDYWNoaW5nKSB7XG4gICAgICAgIHJlc3VsdC5zZWFyY2ggPSBgbm9DYWNoZT0ke0RhdGUubm93KCkudG9TdHJpbmcoMzIpfWA7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLm5ld1VybEZyb21CYXNlID0gbmV3VXJsRnJvbUJhc2U7XG5mdW5jdGlvbiBnZXRDaGFubmVsRmlsZW5hbWUoY2hhbm5lbCkge1xuICAgIHJldHVybiBgJHtjaGFubmVsfS55bWxgO1xufVxuZXhwb3J0cy5nZXRDaGFubmVsRmlsZW5hbWUgPSBnZXRDaGFubmVsRmlsZW5hbWU7XG5mdW5jdGlvbiBibG9ja21hcEZpbGVzKGJhc2VVcmwsIG9sZFZlcnNpb24sIG5ld1ZlcnNpb24pIHtcbiAgICBjb25zdCBuZXdCbG9ja01hcFVybCA9IG5ld1VybEZyb21CYXNlKGAke2Jhc2VVcmwucGF0aG5hbWV9LmJsb2NrbWFwYCwgYmFzZVVybCk7XG4gICAgY29uc3Qgb2xkQmxvY2tNYXBVcmwgPSBuZXdVcmxGcm9tQmFzZShgJHtiYXNlVXJsLnBhdGhuYW1lLnJlcGxhY2UobmV3IFJlZ0V4cChlc2NhcGVSZWdFeHAobmV3VmVyc2lvbiksIFwiZ1wiKSwgb2xkVmVyc2lvbil9LmJsb2NrbWFwYCwgYmFzZVVybCk7XG4gICAgcmV0dXJuIFtvbGRCbG9ja01hcFVybCwgbmV3QmxvY2tNYXBVcmxdO1xufVxuZXhwb3J0cy5ibG9ja21hcEZpbGVzID0gYmxvY2ttYXBGaWxlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlc29sdmVGaWxlcyA9IGV4cG9ydHMuZ2V0RmlsZUxpc3QgPSBleHBvcnRzLnBhcnNlVXBkYXRlSW5mbyA9IGV4cG9ydHMuZmluZEZpbGUgPSBleHBvcnRzLlByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3QgYnVpbGRlcl91dGlsX3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZVwiKTtcbmNvbnN0IGpzX3lhbWxfMSA9IHJlcXVpcmUoXCJqcy15YW1sXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5jbGFzcyBQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IocnVudGltZU9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5ydW50aW1lT3B0aW9ucyA9IHJ1bnRpbWVPcHRpb25zO1xuICAgICAgICB0aGlzLnJlcXVlc3RIZWFkZXJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5leGVjdXRvciA9IHJ1bnRpbWVPcHRpb25zLmV4ZWN1dG9yO1xuICAgIH1cbiAgICBnZXQgaXNVc2VNdWx0aXBsZVJhbmdlUmVxdWVzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucnVudGltZU9wdGlvbnMuaXNVc2VNdWx0aXBsZVJhbmdlUmVxdWVzdCAhPT0gZmFsc2U7XG4gICAgfVxuICAgIGdldENoYW5uZWxGaWxlUHJlZml4KCkge1xuICAgICAgICBpZiAodGhpcy5ydW50aW1lT3B0aW9ucy5wbGF0Zm9ybSA9PT0gXCJsaW51eFwiKSB7XG4gICAgICAgICAgICBjb25zdCBhcmNoID0gcHJvY2Vzcy5lbnZbXCJURVNUX1VQREFURVJfQVJDSFwiXSB8fCBwcm9jZXNzLmFyY2g7XG4gICAgICAgICAgICBjb25zdCBhcmNoU3VmZml4ID0gYXJjaCA9PT0gXCJ4NjRcIiA/IFwiXCIgOiBgLSR7YXJjaH1gO1xuICAgICAgICAgICAgcmV0dXJuIFwiLWxpbnV4XCIgKyBhcmNoU3VmZml4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnVudGltZU9wdGlvbnMucGxhdGZvcm0gPT09IFwiZGFyd2luXCIgPyBcIi1tYWNcIiA6IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZHVlIHRvIGhpc3RvcmljYWwgcmVhc29ucyBmb3Igd2luZG93cyB3ZSB1c2UgY2hhbm5lbCBuYW1lIHdpdGhvdXQgcGxhdGZvcm0gc3BlY2lmaWVyXG4gICAgZ2V0RGVmYXVsdENoYW5uZWxOYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXN0b21DaGFubmVsTmFtZShcImxhdGVzdFwiKTtcbiAgICB9XG4gICAgZ2V0Q3VzdG9tQ2hhbm5lbE5hbWUoY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gYCR7Y2hhbm5lbH0ke3RoaXMuZ2V0Q2hhbm5lbEZpbGVQcmVmaXgoKX1gO1xuICAgIH1cbiAgICBnZXQgZmlsZUV4dHJhRG93bmxvYWRIZWFkZXJzKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc2V0UmVxdWVzdEhlYWRlcnModmFsdWUpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0SGVhZGVycyA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gcGVyZm9ybSBBUEkgcmVxdWVzdCBvbmx5IHRvIHJlc29sdmUgdXBkYXRlIGluZm8sIGJ1dCBub3QgdG8gZG93bmxvYWQgdXBkYXRlLlxuICAgICAqL1xuICAgIGh0dHBSZXF1ZXN0KHVybCwgaGVhZGVycywgY2FuY2VsbGF0aW9uVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0b3IucmVxdWVzdCh0aGlzLmNyZWF0ZVJlcXVlc3RPcHRpb25zKHVybCwgaGVhZGVycyksIGNhbmNlbGxhdGlvblRva2VuKTtcbiAgICB9XG4gICAgY3JlYXRlUmVxdWVzdE9wdGlvbnModXJsLCBoZWFkZXJzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0SGVhZGVycyA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoaGVhZGVycyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LmhlYWRlcnMgPSBoZWFkZXJzID09IG51bGwgPyB0aGlzLnJlcXVlc3RIZWFkZXJzIDogeyAuLi50aGlzLnJlcXVlc3RIZWFkZXJzLCAuLi5oZWFkZXJzIH07XG4gICAgICAgIH1cbiAgICAgICAgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5jb25maWd1cmVSZXF1ZXN0VXJsKHVybCwgcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5leHBvcnRzLlByb3ZpZGVyID0gUHJvdmlkZXI7XG5mdW5jdGlvbiBmaW5kRmlsZShmaWxlcywgZXh0ZW5zaW9uLCBub3QpIHtcbiAgICBpZiAoZmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IoXCJObyBmaWxlcyBwcm92aWRlZFwiLCBcIkVSUl9VUERBVEVSX05PX0ZJTEVTX1BST1ZJREVEXCIpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBmaWxlcy5maW5kKGl0ID0+IGl0LnVybC5wYXRobmFtZS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKGAuJHtleHRlbnNpb259YCkpO1xuICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBlbHNlIGlmIChub3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmlsZXNbMF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmlsZXMuZmluZChmaWxlSW5mbyA9PiAhbm90LnNvbWUoZXh0ID0+IGZpbGVJbmZvLnVybC5wYXRobmFtZS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKGAuJHtleHR9YCkpKTtcbiAgICB9XG59XG5leHBvcnRzLmZpbmRGaWxlID0gZmluZEZpbGU7XG5mdW5jdGlvbiBwYXJzZVVwZGF0ZUluZm8ocmF3RGF0YSwgY2hhbm5lbEZpbGUsIGNoYW5uZWxGaWxlVXJsKSB7XG4gICAgaWYgKHJhd0RhdGEgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBidWlsZGVyX3V0aWxfcnVudGltZV8xLm5ld0Vycm9yKGBDYW5ub3QgcGFyc2UgdXBkYXRlIGluZm8gZnJvbSAke2NoYW5uZWxGaWxlfSBpbiB0aGUgbGF0ZXN0IHJlbGVhc2UgYXJ0aWZhY3RzICgke2NoYW5uZWxGaWxlVXJsfSk6IHJhd0RhdGE6IG51bGxgLCBcIkVSUl9VUERBVEVSX0lOVkFMSURfVVBEQVRFX0lORk9cIik7XG4gICAgfVxuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0ganNfeWFtbF8xLmxvYWQocmF3RGF0YSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IoYENhbm5vdCBwYXJzZSB1cGRhdGUgaW5mbyBmcm9tICR7Y2hhbm5lbEZpbGV9IGluIHRoZSBsYXRlc3QgcmVsZWFzZSBhcnRpZmFjdHMgKCR7Y2hhbm5lbEZpbGVVcmx9KTogJHtlLnN0YWNrIHx8IGUubWVzc2FnZX0sIHJhd0RhdGE6ICR7cmF3RGF0YX1gLCBcIkVSUl9VUERBVEVSX0lOVkFMSURfVVBEQVRFX0lORk9cIik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnBhcnNlVXBkYXRlSW5mbyA9IHBhcnNlVXBkYXRlSW5mbztcbmZ1bmN0aW9uIGdldEZpbGVMaXN0KHVwZGF0ZUluZm8pIHtcbiAgICBjb25zdCBmaWxlcyA9IHVwZGF0ZUluZm8uZmlsZXM7XG4gICAgaWYgKGZpbGVzICE9IG51bGwgJiYgZmlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gZmlsZXM7XG4gICAgfVxuICAgIC8vIG5vaW5zcGVjdGlvbiBKU0RlcHJlY2F0ZWRTeW1ib2xzXG4gICAgaWYgKHVwZGF0ZUluZm8ucGF0aCAhPSBudWxsKSB7XG4gICAgICAgIC8vIG5vaW5zcGVjdGlvbiBKU0RlcHJlY2F0ZWRTeW1ib2xzXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdXJsOiB1cGRhdGVJbmZvLnBhdGgsXG4gICAgICAgICAgICAgICAgc2hhMjogdXBkYXRlSW5mby5zaGEyLFxuICAgICAgICAgICAgICAgIHNoYTUxMjogdXBkYXRlSW5mby5zaGE1MTIsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5uZXdFcnJvcihgTm8gZmlsZXMgcHJvdmlkZWQ6ICR7YnVpbGRlcl91dGlsX3J1bnRpbWVfMS5zYWZlU3RyaW5naWZ5SnNvbih1cGRhdGVJbmZvKX1gLCBcIkVSUl9VUERBVEVSX05PX0ZJTEVTX1BST1ZJREVEXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0RmlsZUxpc3QgPSBnZXRGaWxlTGlzdDtcbmZ1bmN0aW9uIHJlc29sdmVGaWxlcyh1cGRhdGVJbmZvLCBiYXNlVXJsLCBwYXRoVHJhbnNmb3JtZXIgPSAocCkgPT4gcCkge1xuICAgIGNvbnN0IGZpbGVzID0gZ2V0RmlsZUxpc3QodXBkYXRlSW5mbyk7XG4gICAgY29uc3QgcmVzdWx0ID0gZmlsZXMubWFwKGZpbGVJbmZvID0+IHtcbiAgICAgICAgaWYgKGZpbGVJbmZvLnNoYTIgPT0gbnVsbCAmJiBmaWxlSW5mby5zaGE1MTIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5uZXdFcnJvcihgVXBkYXRlIGluZm8gZG9lc24ndCBjb250YWluIG5vciBzaGEyNTYgbmVpdGhlciBzaGE1MTIgY2hlY2tzdW06ICR7YnVpbGRlcl91dGlsX3J1bnRpbWVfMS5zYWZlU3RyaW5naWZ5SnNvbihmaWxlSW5mbyl9YCwgXCJFUlJfVVBEQVRFUl9OT19DSEVDS1NVTVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXJsOiB1dGlsXzEubmV3VXJsRnJvbUJhc2UocGF0aFRyYW5zZm9ybWVyKGZpbGVJbmZvLnVybCksIGJhc2VVcmwpLFxuICAgICAgICAgICAgaW5mbzogZmlsZUluZm8sXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgcGFja2FnZXMgPSB1cGRhdGVJbmZvLnBhY2thZ2VzO1xuICAgIGNvbnN0IHBhY2thZ2VJbmZvID0gcGFja2FnZXMgPT0gbnVsbCA/IG51bGwgOiBwYWNrYWdlc1twcm9jZXNzLmFyY2hdIHx8IHBhY2thZ2VzLmlhMzI7XG4gICAgaWYgKHBhY2thZ2VJbmZvICE9IG51bGwpIHtcbiAgICAgICAgO1xuICAgICAgICByZXN1bHRbMF0ucGFja2FnZUluZm8gPSB7XG4gICAgICAgICAgICAuLi5wYWNrYWdlSW5mbyxcbiAgICAgICAgICAgIHBhdGg6IHV0aWxfMS5uZXdVcmxGcm9tQmFzZShwYXRoVHJhbnNmb3JtZXIocGFja2FnZUluZm8ucGF0aCksIGJhc2VVcmwpLmhyZWYsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnJlc29sdmVGaWxlcyA9IHJlc29sdmVGaWxlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVByb3ZpZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5HZW5lcmljUHJvdmlkZXIgPSB2b2lkIDA7XG5jb25zdCBidWlsZGVyX3V0aWxfcnVudGltZV8xID0gcmVxdWlyZShcImJ1aWxkZXItdXRpbC1ydW50aW1lXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5jb25zdCBQcm92aWRlcl8xID0gcmVxdWlyZShcIi4vUHJvdmlkZXJcIik7XG5jbGFzcyBHZW5lcmljUHJvdmlkZXIgZXh0ZW5kcyBQcm92aWRlcl8xLlByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uLCB1cGRhdGVyLCBydW50aW1lT3B0aW9ucykge1xuICAgICAgICBzdXBlcihydW50aW1lT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IGNvbmZpZ3VyYXRpb247XG4gICAgICAgIHRoaXMudXBkYXRlciA9IHVwZGF0ZXI7XG4gICAgICAgIHRoaXMuYmFzZVVybCA9IHV0aWxfMS5uZXdCYXNlVXJsKHRoaXMuY29uZmlndXJhdGlvbi51cmwpO1xuICAgIH1cbiAgICBnZXQgY2hhbm5lbCgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy51cGRhdGVyLmNoYW5uZWwgfHwgdGhpcy5jb25maWd1cmF0aW9uLmNoYW5uZWw7XG4gICAgICAgIHJldHVybiByZXN1bHQgPT0gbnVsbCA/IHRoaXMuZ2V0RGVmYXVsdENoYW5uZWxOYW1lKCkgOiB0aGlzLmdldEN1c3RvbUNoYW5uZWxOYW1lKHJlc3VsdCk7XG4gICAgfVxuICAgIGFzeW5jIGdldExhdGVzdFZlcnNpb24oKSB7XG4gICAgICAgIGNvbnN0IGNoYW5uZWxGaWxlID0gdXRpbF8xLmdldENoYW5uZWxGaWxlbmFtZSh0aGlzLmNoYW5uZWwpO1xuICAgICAgICBjb25zdCBjaGFubmVsVXJsID0gdXRpbF8xLm5ld1VybEZyb21CYXNlKGNoYW5uZWxGaWxlLCB0aGlzLmJhc2VVcmwsIHRoaXMudXBkYXRlci5pc0FkZE5vQ2FjaGVRdWVyeSk7XG4gICAgICAgIGZvciAobGV0IGF0dGVtcHROdW1iZXIgPSAwOzsgYXR0ZW1wdE51bWJlcisrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm92aWRlcl8xLnBhcnNlVXBkYXRlSW5mbyhhd2FpdCB0aGlzLmh0dHBSZXF1ZXN0KGNoYW5uZWxVcmwpLCBjaGFubmVsRmlsZSwgY2hhbm5lbFVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5IdHRwRXJyb3IgJiYgZS5zdGF0dXNDb2RlID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5uZXdFcnJvcihgQ2Fubm90IGZpbmQgY2hhbm5lbCBcIiR7Y2hhbm5lbEZpbGV9XCIgdXBkYXRlIGluZm86ICR7ZS5zdGFjayB8fCBlLm1lc3NhZ2V9YCwgXCJFUlJfVVBEQVRFUl9DSEFOTkVMX0ZJTEVfTk9UX0ZPVU5EXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlLmNvZGUgPT09IFwiRUNPTk5SRUZVU0VEXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dGVtcHROdW1iZXIgPCAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCAxMDAwICogYXR0ZW1wdE51bWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzb2x2ZUZpbGVzKHVwZGF0ZUluZm8pIHtcbiAgICAgICAgcmV0dXJuIFByb3ZpZGVyXzEucmVzb2x2ZUZpbGVzKHVwZGF0ZUluZm8sIHRoaXMuYmFzZVVybCk7XG4gICAgfVxufVxuZXhwb3J0cy5HZW5lcmljUHJvdmlkZXIgPSBHZW5lcmljUHJvdmlkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HZW5lcmljUHJvdmlkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJpbnRyYXlDbGllbnQgPSB2b2lkIDA7XG5jb25zdCBodHRwRXhlY3V0b3JfMSA9IHJlcXVpcmUoXCIuL2h0dHBFeGVjdXRvclwiKTtcbmNsYXNzIEJpbnRyYXlDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGh0dHBFeGVjdXRvciwgY2FuY2VsbGF0aW9uVG9rZW4sIGFwaUtleSkge1xuICAgICAgICB0aGlzLmh0dHBFeGVjdXRvciA9IGh0dHBFeGVjdXRvcjtcbiAgICAgICAgdGhpcy5jYW5jZWxsYXRpb25Ub2tlbiA9IGNhbmNlbGxhdGlvblRva2VuO1xuICAgICAgICB0aGlzLnJlcXVlc3RIZWFkZXJzID0gbnVsbDtcbiAgICAgICAgaWYgKG9wdGlvbnMub3duZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3duZXIgaXMgbm90IHNwZWNpZmllZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5wYWNrYWdlID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInBhY2thZ2UgaXMgbm90IHNwZWNpZmllZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcG8gPSBvcHRpb25zLnJlcG8gfHwgXCJnZW5lcmljXCI7XG4gICAgICAgIHRoaXMucGFja2FnZU5hbWUgPSBvcHRpb25zLnBhY2thZ2U7XG4gICAgICAgIHRoaXMub3duZXIgPSBvcHRpb25zLm93bmVyO1xuICAgICAgICB0aGlzLnVzZXIgPSBvcHRpb25zLnVzZXIgfHwgb3B0aW9ucy5vd25lcjtcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBvcHRpb25zLmNvbXBvbmVudCB8fCBudWxsO1xuICAgICAgICB0aGlzLmRpc3RyaWJ1dGlvbiA9IG9wdGlvbnMuZGlzdHJpYnV0aW9uIHx8IFwic3RhYmxlXCI7XG4gICAgICAgIHRoaXMuYXV0aCA9IGFwaUtleSA9PSBudWxsID8gbnVsbCA6IGBCYXNpYyAke0J1ZmZlci5mcm9tKGAke3RoaXMudXNlcn06JHthcGlLZXl9YCkudG9TdHJpbmcoXCJiYXNlNjRcIil9YDtcbiAgICAgICAgdGhpcy5iYXNlUGF0aCA9IGAvcGFja2FnZXMvJHt0aGlzLm93bmVyfS8ke3RoaXMucmVwb30vJHt0aGlzLnBhY2thZ2VOYW1lfWA7XG4gICAgfVxuICAgIHNldFJlcXVlc3RIZWFkZXJzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdEhlYWRlcnMgPSB2YWx1ZTtcbiAgICB9XG4gICAgYmludHJheVJlcXVlc3QocGF0aCwgYXV0aCwgZGF0YSA9IG51bGwsIGNhbmNlbGxhdGlvblRva2VuLCBtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGh0dHBFeGVjdXRvcl8xLnBhcnNlSnNvbih0aGlzLmh0dHBFeGVjdXRvci5yZXF1ZXN0KGh0dHBFeGVjdXRvcl8xLmNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zKHsgaG9zdG5hbWU6IFwiYXBpLmJpbnRyYXkuY29tXCIsIHBhdGgsIGhlYWRlcnM6IHRoaXMucmVxdWVzdEhlYWRlcnMgfHwgdW5kZWZpbmVkIH0sIGF1dGgsIG1ldGhvZCksIGNhbmNlbGxhdGlvblRva2VuLCBkYXRhKSk7XG4gICAgfVxuICAgIGdldFZlcnNpb24odmVyc2lvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5iaW50cmF5UmVxdWVzdChgJHt0aGlzLmJhc2VQYXRofS92ZXJzaW9ucy8ke3ZlcnNpb259YCwgdGhpcy5hdXRoLCBudWxsLCB0aGlzLmNhbmNlbGxhdGlvblRva2VuKTtcbiAgICB9XG4gICAgZ2V0VmVyc2lvbkZpbGVzKHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmludHJheVJlcXVlc3QoYCR7dGhpcy5iYXNlUGF0aH0vdmVyc2lvbnMvJHt2ZXJzaW9ufS9maWxlc2AsIHRoaXMuYXV0aCwgbnVsbCwgdGhpcy5jYW5jZWxsYXRpb25Ub2tlbik7XG4gICAgfVxuICAgIGNyZWF0ZVZlcnNpb24odmVyc2lvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5iaW50cmF5UmVxdWVzdChgJHt0aGlzLmJhc2VQYXRofS92ZXJzaW9uc2AsIHRoaXMuYXV0aCwge1xuICAgICAgICAgICAgbmFtZTogdmVyc2lvbixcbiAgICAgICAgfSwgdGhpcy5jYW5jZWxsYXRpb25Ub2tlbik7XG4gICAgfVxuICAgIGRlbGV0ZVZlcnNpb24odmVyc2lvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5iaW50cmF5UmVxdWVzdChgJHt0aGlzLmJhc2VQYXRofS92ZXJzaW9ucy8ke3ZlcnNpb259YCwgdGhpcy5hdXRoLCBudWxsLCB0aGlzLmNhbmNlbGxhdGlvblRva2VuLCBcIkRFTEVURVwiKTtcbiAgICB9XG59XG5leHBvcnRzLkJpbnRyYXlDbGllbnQgPSBCaW50cmF5Q2xpZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmludHJheS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmludHJheVByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3QgYnVpbGRlcl91dGlsX3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZVwiKTtcbmNvbnN0IGJpbnRyYXlfMSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZS9vdXQvYmludHJheVwiKTtcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcInVybFwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuY29uc3QgUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL1Byb3ZpZGVyXCIpO1xuY2xhc3MgQmludHJheVByb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXJfMS5Qcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvbiwgcnVudGltZU9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIocnVudGltZU9wdGlvbnMpO1xuICAgICAgICB0aGlzLmNsaWVudCA9IG5ldyBiaW50cmF5XzEuQmludHJheUNsaWVudChjb25maWd1cmF0aW9uLCBydW50aW1lT3B0aW9ucy5leGVjdXRvciwgbmV3IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuQ2FuY2VsbGF0aW9uVG9rZW4oKSk7XG4gICAgICAgIHRoaXMuYmFzZVVybCA9IHV0aWxfMS5uZXdCYXNlVXJsKGBodHRwczovL2RsLmJpbnRyYXkuY29tLyR7dGhpcy5jbGllbnQub3duZXJ9LyR7dGhpcy5jbGllbnQucmVwb31gKTtcbiAgICB9XG4gICAgc2V0UmVxdWVzdEhlYWRlcnModmFsdWUpIHtcbiAgICAgICAgc3VwZXIuc2V0UmVxdWVzdEhlYWRlcnModmFsdWUpO1xuICAgICAgICB0aGlzLmNsaWVudC5zZXRSZXF1ZXN0SGVhZGVycyh2YWx1ZSk7XG4gICAgfVxuICAgIGFzeW5jIGdldExhdGVzdFZlcnNpb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5jbGllbnQuZ2V0VmVyc2lvbihcIl9sYXRlc3RcIik7XG4gICAgICAgICAgICBjb25zdCBjaGFubmVsRmlsZW5hbWUgPSB1dGlsXzEuZ2V0Q2hhbm5lbEZpbGVuYW1lKHRoaXMuZ2V0RGVmYXVsdENoYW5uZWxOYW1lKCkpO1xuICAgICAgICAgICAgY29uc3QgZmlsZXMgPSBhd2FpdCB0aGlzLmNsaWVudC5nZXRWZXJzaW9uRmlsZXMoZGF0YS5uYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5uZWxGaWxlID0gZmlsZXMuZmluZChpdCA9PiBpdC5uYW1lLmVuZHNXaXRoKGBfJHtjaGFubmVsRmlsZW5hbWV9YCkgfHwgaXQubmFtZS5lbmRzV2l0aChgLSR7Y2hhbm5lbEZpbGVuYW1lfWApKTtcbiAgICAgICAgICAgIGlmIChjaGFubmVsRmlsZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gbm9pbnNwZWN0aW9uIEV4Y2VwdGlvbkNhdWdodExvY2FsbHlKU1xuICAgICAgICAgICAgICAgIHRocm93IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IoYENhbm5vdCBmaW5kIGNoYW5uZWwgZmlsZSBcIiR7Y2hhbm5lbEZpbGVuYW1lfVwiLCBleGlzdGluZyBmaWxlczpcXG4ke2ZpbGVzLm1hcChpdCA9PiBKU09OLnN0cmluZ2lmeShpdCwgbnVsbCwgMikpLmpvaW4oXCIsXFxuXCIpfWAsIFwiRVJSX1VQREFURVJfQ0hBTk5FTF9GSUxFX05PVF9GT1VORFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNoYW5uZWxGaWxlVXJsID0gbmV3IHVybF8xLlVSTChgaHR0cHM6Ly9kbC5iaW50cmF5LmNvbS8ke3RoaXMuY2xpZW50Lm93bmVyfS8ke3RoaXMuY2xpZW50LnJlcG99LyR7Y2hhbm5lbEZpbGUubmFtZX1gKTtcbiAgICAgICAgICAgIHJldHVybiBQcm92aWRlcl8xLnBhcnNlVXBkYXRlSW5mbyhhd2FpdCB0aGlzLmh0dHBSZXF1ZXN0KGNoYW5uZWxGaWxlVXJsKSwgY2hhbm5lbEZpbGVuYW1lLCBjaGFubmVsRmlsZVVybCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChcInN0YXR1c0NvZGVcIiBpbiBlICYmIGUuc3RhdHVzQ29kZSA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5uZXdFcnJvcihgTm8gbGF0ZXN0IHZlcnNpb24sIHBsZWFzZSBlbnN1cmUgdGhhdCB1c2VyLCBwYWNrYWdlIGFuZCByZXBvc2l0b3J5IGNvcnJlY3RseSBjb25maWd1cmVkLiBPciBhdCBsZWFzdCBvbmUgdmVyc2lvbiBpcyBwdWJsaXNoZWQuICR7ZS5zdGFjayB8fCBlLm1lc3NhZ2V9YCwgXCJFUlJfVVBEQVRFUl9MQVRFU1RfVkVSU0lPTl9OT1RfRk9VTkRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc29sdmVGaWxlcyh1cGRhdGVJbmZvKSB7XG4gICAgICAgIHJldHVybiBQcm92aWRlcl8xLnJlc29sdmVGaWxlcyh1cGRhdGVJbmZvLCB0aGlzLmJhc2VVcmwpO1xuICAgIH1cbn1cbmV4cG9ydHMuQmludHJheVByb3ZpZGVyID0gQmludHJheVByb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmludHJheVByb3ZpZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb21wdXRlUmVsZWFzZU5vdGVzID0gZXhwb3J0cy5HaXRIdWJQcm92aWRlciA9IGV4cG9ydHMuQmFzZUdpdEh1YlByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3QgYnVpbGRlcl91dGlsX3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZVwiKTtcbmNvbnN0IHNlbXZlciA9IHJlcXVpcmUoXCJzZW12ZXJcIik7XG5jb25zdCB1cmxfMSA9IHJlcXVpcmUoXCJ1cmxcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IFByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9Qcm92aWRlclwiKTtcbmNvbnN0IGhyZWZSZWdFeHAgPSAvXFwvdGFnXFwvKFteL10rKSQvO1xuY2xhc3MgQmFzZUdpdEh1YlByb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXJfMS5Qcm92aWRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgZGVmYXVsdEhvc3QsIHJ1bnRpbWVPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIC4uLnJ1bnRpbWVPcHRpb25zLFxuICAgICAgICAgICAgLyogYmVjYXVzZSBHaXRIaWIgdXNlcyBTMyAqL1xuICAgICAgICAgICAgaXNVc2VNdWx0aXBsZVJhbmdlUmVxdWVzdDogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmJhc2VVcmwgPSB1dGlsXzEubmV3QmFzZVVybChidWlsZGVyX3V0aWxfcnVudGltZV8xLmdpdGh1YlVybChvcHRpb25zLCBkZWZhdWx0SG9zdCkpO1xuICAgICAgICBjb25zdCBhcGlIb3N0ID0gZGVmYXVsdEhvc3QgPT09IFwiZ2l0aHViLmNvbVwiID8gXCJhcGkuZ2l0aHViLmNvbVwiIDogZGVmYXVsdEhvc3Q7XG4gICAgICAgIHRoaXMuYmFzZUFwaVVybCA9IHV0aWxfMS5uZXdCYXNlVXJsKGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuZ2l0aHViVXJsKG9wdGlvbnMsIGFwaUhvc3QpKTtcbiAgICB9XG4gICAgY29tcHV0ZUdpdGh1YkJhc2VQYXRoKHJlc3VsdCkge1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZWxlY3Ryb24tdXNlcmxhbmQvZWxlY3Ryb24tYnVpbGRlci9pc3N1ZXMvMTkwMyNpc3N1ZWNvbW1lbnQtMzIwODgxMjExXG4gICAgICAgIGNvbnN0IGhvc3QgPSB0aGlzLm9wdGlvbnMuaG9zdDtcbiAgICAgICAgcmV0dXJuIGhvc3QgIT0gbnVsbCAmJiBob3N0ICE9PSBcImdpdGh1Yi5jb21cIiAmJiBob3N0ICE9PSBcImFwaS5naXRodWIuY29tXCIgPyBgL2FwaS92MyR7cmVzdWx0fWAgOiByZXN1bHQ7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlR2l0SHViUHJvdmlkZXIgPSBCYXNlR2l0SHViUHJvdmlkZXI7XG5jbGFzcyBHaXRIdWJQcm92aWRlciBleHRlbmRzIEJhc2VHaXRIdWJQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgdXBkYXRlciwgcnVudGltZU9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucywgXCJnaXRodWIuY29tXCIsIHJ1bnRpbWVPcHRpb25zKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy51cGRhdGVyID0gdXBkYXRlcjtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TGF0ZXN0VmVyc2lvbigpIHtcbiAgICAgICAgY29uc3QgY2FuY2VsbGF0aW9uVG9rZW4gPSBuZXcgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5DYW5jZWxsYXRpb25Ub2tlbigpO1xuICAgICAgICBjb25zdCBmZWVkWG1sID0gKGF3YWl0IHRoaXMuaHR0cFJlcXVlc3QodXRpbF8xLm5ld1VybEZyb21CYXNlKGAke3RoaXMuYmFzZVBhdGh9LmF0b21gLCB0aGlzLmJhc2VVcmwpLCB7XG4gICAgICAgICAgICBhY2NlcHQ6IFwiYXBwbGljYXRpb24veG1sLCBhcHBsaWNhdGlvbi9hdG9tK3htbCwgdGV4dC94bWwsICovKlwiLFxuICAgICAgICB9LCBjYW5jZWxsYXRpb25Ub2tlbikpO1xuICAgICAgICBjb25zdCBmZWVkID0gYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5wYXJzZVhtbChmZWVkWG1sKTtcbiAgICAgICAgLy8gbm9pbnNwZWN0aW9uIFR5cGVTY3JpcHRWYWxpZGF0ZUpTVHlwZXNcbiAgICAgICAgbGV0IGxhdGVzdFJlbGVhc2UgPSBmZWVkLmVsZW1lbnQoXCJlbnRyeVwiLCBmYWxzZSwgYE5vIHB1Ymxpc2hlZCB2ZXJzaW9ucyBvbiBHaXRIdWJgKTtcbiAgICAgICAgbGV0IHRhZztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnVwZGF0ZXIuYWxsb3dQcmVyZWxlYXNlKSB7XG4gICAgICAgICAgICAgICAgLy8gbm9pbnNwZWN0aW9uIFR5cGVTY3JpcHRWYWxpZGF0ZUpTVHlwZXNcbiAgICAgICAgICAgICAgICB0YWcgPSBocmVmUmVnRXhwLmV4ZWMobGF0ZXN0UmVsZWFzZS5lbGVtZW50KFwibGlua1wiKS5hdHRyaWJ1dGUoXCJocmVmXCIpKVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhZyA9IGF3YWl0IHRoaXMuZ2V0TGF0ZXN0VGFnTmFtZShjYW5jZWxsYXRpb25Ub2tlbik7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGZlZWQuZ2V0RWxlbWVudHMoXCJlbnRyeVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBub2luc3BlY3Rpb24gVHlwZVNjcmlwdFZhbGlkYXRlSlNUeXBlc1xuICAgICAgICAgICAgICAgICAgICBpZiAoaHJlZlJlZ0V4cC5leGVjKGVsZW1lbnQuZWxlbWVudChcImxpbmtcIikuYXR0cmlidXRlKFwiaHJlZlwiKSlbMV0gPT09IHRhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF0ZXN0UmVsZWFzZSA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5uZXdFcnJvcihgQ2Fubm90IHBhcnNlIHJlbGVhc2VzIGZlZWQ6ICR7ZS5zdGFjayB8fCBlLm1lc3NhZ2V9LFxcblhNTDpcXG4ke2ZlZWRYbWx9YCwgXCJFUlJfVVBEQVRFUl9JTlZBTElEX1JFTEVBU0VfRkVFRFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IoYE5vIHB1Ymxpc2hlZCB2ZXJzaW9ucyBvbiBHaXRIdWJgLCBcIkVSUl9VUERBVEVSX05PX1BVQkxJU0hFRF9WRVJTSU9OU1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGFubmVsRmlsZSA9IHV0aWxfMS5nZXRDaGFubmVsRmlsZW5hbWUodGhpcy5nZXREZWZhdWx0Q2hhbm5lbE5hbWUoKSk7XG4gICAgICAgIGNvbnN0IGNoYW5uZWxGaWxlVXJsID0gdXRpbF8xLm5ld1VybEZyb21CYXNlKHRoaXMuZ2V0QmFzZURvd25sb2FkUGF0aCh0YWcsIGNoYW5uZWxGaWxlKSwgdGhpcy5iYXNlVXJsKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSB0aGlzLmNyZWF0ZVJlcXVlc3RPcHRpb25zKGNoYW5uZWxGaWxlVXJsKTtcbiAgICAgICAgbGV0IHJhd0RhdGE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByYXdEYXRhID0gKGF3YWl0IHRoaXMuZXhlY3V0b3IucmVxdWVzdChyZXF1ZXN0T3B0aW9ucywgY2FuY2VsbGF0aW9uVG9rZW4pKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnVwZGF0ZXIuYWxsb3dQcmVyZWxlYXNlICYmIGUgaW5zdGFuY2VvZiBidWlsZGVyX3V0aWxfcnVudGltZV8xLkh0dHBFcnJvciAmJiBlLnN0YXR1c0NvZGUgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgIHRocm93IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IoYENhbm5vdCBmaW5kICR7Y2hhbm5lbEZpbGV9IGluIHRoZSBsYXRlc3QgcmVsZWFzZSBhcnRpZmFjdHMgKCR7Y2hhbm5lbEZpbGVVcmx9KTogJHtlLnN0YWNrIHx8IGUubWVzc2FnZX1gLCBcIkVSUl9VUERBVEVSX0NIQU5ORUxfRklMRV9OT1RfRk9VTkRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFByb3ZpZGVyXzEucGFyc2VVcGRhdGVJbmZvKHJhd0RhdGEsIGNoYW5uZWxGaWxlLCBjaGFubmVsRmlsZVVybCk7XG4gICAgICAgIGlmIChyZXN1bHQucmVsZWFzZU5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LnJlbGVhc2VOYW1lID0gbGF0ZXN0UmVsZWFzZS5lbGVtZW50VmFsdWVPckVtcHR5KFwidGl0bGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5yZWxlYXNlTm90ZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LnJlbGVhc2VOb3RlcyA9IGNvbXB1dGVSZWxlYXNlTm90ZXModGhpcy51cGRhdGVyLmN1cnJlbnRWZXJzaW9uLCB0aGlzLnVwZGF0ZXIuZnVsbENoYW5nZWxvZywgZmVlZCwgbGF0ZXN0UmVsZWFzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRhZzogdGFnLFxuICAgICAgICAgICAgLi4ucmVzdWx0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBnZXRMYXRlc3RUYWdOYW1lKGNhbmNlbGxhdGlvblRva2VuKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIC8vIGRvIG5vdCB1c2UgQVBJIGZvciBHaXRIdWIgdG8gYXZvaWQgbGltaXQsIG9ubHkgZm9yIGN1c3RvbSBob3N0IG9yIEdpdEh1YiBFbnRlcnByaXNlXG4gICAgICAgIGNvbnN0IHVybCA9IG9wdGlvbnMuaG9zdCA9PSBudWxsIHx8IG9wdGlvbnMuaG9zdCA9PT0gXCJnaXRodWIuY29tXCJcbiAgICAgICAgICAgID8gdXRpbF8xLm5ld1VybEZyb21CYXNlKGAke3RoaXMuYmFzZVBhdGh9L2xhdGVzdGAsIHRoaXMuYmFzZVVybClcbiAgICAgICAgICAgIDogbmV3IHVybF8xLlVSTChgJHt0aGlzLmNvbXB1dGVHaXRodWJCYXNlUGF0aChgL3JlcG9zLyR7b3B0aW9ucy5vd25lcn0vJHtvcHRpb25zLnJlcG99L3JlbGVhc2VzYCl9L2xhdGVzdGAsIHRoaXMuYmFzZUFwaVVybCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByYXdEYXRhID0gYXdhaXQgdGhpcy5odHRwUmVxdWVzdCh1cmwsIHsgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LCBjYW5jZWxsYXRpb25Ub2tlbik7XG4gICAgICAgICAgICBpZiAocmF3RGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZWxlYXNlSW5mbyA9IEpTT04ucGFyc2UocmF3RGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gcmVsZWFzZUluZm8udGFnX25hbWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IoYFVuYWJsZSB0byBmaW5kIGxhdGVzdCB2ZXJzaW9uIG9uIEdpdEh1YiAoJHt1cmx9KSwgcGxlYXNlIGVuc3VyZSBhIHByb2R1Y3Rpb24gcmVsZWFzZSBleGlzdHM6ICR7ZS5zdGFjayB8fCBlLm1lc3NhZ2V9YCwgXCJFUlJfVVBEQVRFUl9MQVRFU1RfVkVSU0lPTl9OT1RfRk9VTkRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGJhc2VQYXRoKCkge1xuICAgICAgICByZXR1cm4gYC8ke3RoaXMub3B0aW9ucy5vd25lcn0vJHt0aGlzLm9wdGlvbnMucmVwb30vcmVsZWFzZXNgO1xuICAgIH1cbiAgICByZXNvbHZlRmlsZXModXBkYXRlSW5mbykge1xuICAgICAgICAvLyBzdGlsbCByZXBsYWNlIHNwYWNlIHRvIC0gZHVlIHRvIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgICAgcmV0dXJuIFByb3ZpZGVyXzEucmVzb2x2ZUZpbGVzKHVwZGF0ZUluZm8sIHRoaXMuYmFzZVVybCwgcCA9PiB0aGlzLmdldEJhc2VEb3dubG9hZFBhdGgodXBkYXRlSW5mby50YWcsIHAucmVwbGFjZSgvIC9nLCBcIi1cIikpKTtcbiAgICB9XG4gICAgZ2V0QmFzZURvd25sb2FkUGF0aCh0YWcsIGZpbGVOYW1lKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmJhc2VQYXRofS9kb3dubG9hZC8ke3RhZ30vJHtmaWxlTmFtZX1gO1xuICAgIH1cbn1cbmV4cG9ydHMuR2l0SHViUHJvdmlkZXIgPSBHaXRIdWJQcm92aWRlcjtcbmZ1bmN0aW9uIGdldE5vdGVWYWx1ZShwYXJlbnQpIHtcbiAgICBjb25zdCByZXN1bHQgPSBwYXJlbnQuZWxlbWVudFZhbHVlT3JFbXB0eShcImNvbnRlbnRcIik7XG4gICAgLy8gR2l0SHViIHJlcG9ydHMgZW1wdHkgbm90ZXMgYXMgPGNvbnRlbnQ+Tm8gY29udGVudC48L2NvbnRlbnQ+XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gXCJObyBjb250ZW50LlwiID8gXCJcIiA6IHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVSZWxlYXNlTm90ZXMoY3VycmVudFZlcnNpb24sIGlzRnVsbENoYW5nZWxvZywgZmVlZCwgbGF0ZXN0UmVsZWFzZSkge1xuICAgIGlmICghaXNGdWxsQ2hhbmdlbG9nKSB7XG4gICAgICAgIHJldHVybiBnZXROb3RlVmFsdWUobGF0ZXN0UmVsZWFzZSk7XG4gICAgfVxuICAgIGNvbnN0IHJlbGVhc2VOb3RlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgcmVsZWFzZSBvZiBmZWVkLmdldEVsZW1lbnRzKFwiZW50cnlcIikpIHtcbiAgICAgICAgLy8gbm9pbnNwZWN0aW9uIFR5cGVTY3JpcHRWYWxpZGF0ZUpTVHlwZXNcbiAgICAgICAgY29uc3QgdmVyc2lvblJlbGVhc2UgPSAvXFwvdGFnXFwvdj8oW14vXSspJC8uZXhlYyhyZWxlYXNlLmVsZW1lbnQoXCJsaW5rXCIpLmF0dHJpYnV0ZShcImhyZWZcIikpWzFdO1xuICAgICAgICBpZiAoc2VtdmVyLmx0KGN1cnJlbnRWZXJzaW9uLCB2ZXJzaW9uUmVsZWFzZSkpIHtcbiAgICAgICAgICAgIHJlbGVhc2VOb3Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uUmVsZWFzZSxcbiAgICAgICAgICAgICAgICBub3RlOiBnZXROb3RlVmFsdWUocmVsZWFzZSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVsZWFzZU5vdGVzLnNvcnQoKGEsIGIpID0+IHNlbXZlci5yY29tcGFyZShhLnZlcnNpb24sIGIudmVyc2lvbikpO1xufVxuZXhwb3J0cy5jb21wdXRlUmVsZWFzZU5vdGVzID0gY29tcHV0ZVJlbGVhc2VOb3Rlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdpdEh1YlByb3ZpZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5LZXlnZW5Qcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEgPSByZXF1aXJlKFwiYnVpbGRlci11dGlsLXJ1bnRpbWVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IFByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9Qcm92aWRlclwiKTtcbmNsYXNzIEtleWdlblByb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXJfMS5Qcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvbiwgdXBkYXRlciwgcnVudGltZU9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgLi4ucnVudGltZU9wdGlvbnMsXG4gICAgICAgICAgICBpc1VzZU11bHRpcGxlUmFuZ2VSZXF1ZXN0OiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IGNvbmZpZ3VyYXRpb247XG4gICAgICAgIHRoaXMudXBkYXRlciA9IHVwZGF0ZXI7XG4gICAgICAgIHRoaXMuYmFzZVVybCA9IHV0aWxfMS5uZXdCYXNlVXJsKGBodHRwczovL2FwaS5rZXlnZW4uc2gvdjEvYWNjb3VudHMvJHt0aGlzLmNvbmZpZ3VyYXRpb24uYWNjb3VudH0vYXJ0aWZhY3RzYCk7XG4gICAgfVxuICAgIGdldCBjaGFubmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVyLmNoYW5uZWwgfHwgdGhpcy5jb25maWd1cmF0aW9uLmNoYW5uZWwgfHwgXCJzdGFibGVcIjtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TGF0ZXN0VmVyc2lvbigpIHtcbiAgICAgICAgY29uc3QgY2FuY2VsbGF0aW9uVG9rZW4gPSBuZXcgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5DYW5jZWxsYXRpb25Ub2tlbigpO1xuICAgICAgICBjb25zdCBjaGFubmVsRmlsZSA9IHV0aWxfMS5nZXRDaGFubmVsRmlsZW5hbWUodGhpcy5nZXRDdXN0b21DaGFubmVsTmFtZSh0aGlzLmNoYW5uZWwpKTtcbiAgICAgICAgY29uc3QgY2hhbm5lbFVybCA9IHV0aWxfMS5uZXdVcmxGcm9tQmFzZShjaGFubmVsRmlsZSwgdGhpcy5iYXNlVXJsLCB0aGlzLnVwZGF0ZXIuaXNBZGROb0NhY2hlUXVlcnkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlSW5mbyA9IGF3YWl0IHRoaXMuaHR0cFJlcXVlc3QoY2hhbm5lbFVybCwge1xuICAgICAgICAgICAgICAgIEFjY2VwdDogXCJhcHBsaWNhdGlvbi92bmQuYXBpK2pzb25cIixcbiAgICAgICAgICAgIH0sIGNhbmNlbGxhdGlvblRva2VuKTtcbiAgICAgICAgICAgIHJldHVybiBQcm92aWRlcl8xLnBhcnNlVXBkYXRlSW5mbyh1cGRhdGVJbmZvLCBjaGFubmVsRmlsZSwgY2hhbm5lbFVybCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IoYFVuYWJsZSB0byBmaW5kIGxhdGVzdCB2ZXJzaW9uIG9uICR7dGhpcy50b1N0cmluZygpfSwgcGxlYXNlIGVuc3VyZSByZWxlYXNlIGV4aXN0czogJHtlLnN0YWNrIHx8IGUubWVzc2FnZX1gLCBcIkVSUl9VUERBVEVSX0xBVEVTVF9WRVJTSU9OX05PVF9GT1VORFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNvbHZlRmlsZXModXBkYXRlSW5mbykge1xuICAgICAgICByZXR1cm4gUHJvdmlkZXJfMS5yZXNvbHZlRmlsZXModXBkYXRlSW5mbywgdGhpcy5iYXNlVXJsKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IHsgYWNjb3VudCwgcHJvZHVjdCwgcGxhdGZvcm0gfSA9IHRoaXMuY29uZmlndXJhdGlvbjtcbiAgICAgICAgcmV0dXJuIGBLZXlnZW4gKGFjY291bnQ6ICR7YWNjb3VudH0sIHByb2R1Y3Q6ICR7cHJvZHVjdH0sIHBsYXRmb3JtOiAke3BsYXRmb3JtfSwgY2hhbm5lbDogJHt0aGlzLmNoYW5uZWx9KWA7XG4gICAgfVxufVxuZXhwb3J0cy5LZXlnZW5Qcm92aWRlciA9IEtleWdlblByb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9S2V5Z2VuUHJvdmlkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlByaXZhdGVHaXRIdWJQcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEgPSByZXF1aXJlKFwiYnVpbGRlci11dGlsLXJ1bnRpbWVcIik7XG5jb25zdCBqc195YW1sXzEgPSByZXF1aXJlKFwianMteWFtbFwiKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcInVybFwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuY29uc3QgR2l0SHViUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL0dpdEh1YlByb3ZpZGVyXCIpO1xuY29uc3QgUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL1Byb3ZpZGVyXCIpO1xuY2xhc3MgUHJpdmF0ZUdpdEh1YlByb3ZpZGVyIGV4dGVuZHMgR2l0SHViUHJvdmlkZXJfMS5CYXNlR2l0SHViUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIHVwZGF0ZXIsIHRva2VuLCBydW50aW1lT3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zLCBcImFwaS5naXRodWIuY29tXCIsIHJ1bnRpbWVPcHRpb25zKTtcbiAgICAgICAgdGhpcy51cGRhdGVyID0gdXBkYXRlcjtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgIH1cbiAgICBjcmVhdGVSZXF1ZXN0T3B0aW9ucyh1cmwsIGhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc3VwZXIuY3JlYXRlUmVxdWVzdE9wdGlvbnModXJsLCBoZWFkZXJzKTtcbiAgICAgICAgcmVzdWx0LnJlZGlyZWN0ID0gXCJtYW51YWxcIjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TGF0ZXN0VmVyc2lvbigpIHtcbiAgICAgICAgY29uc3QgY2FuY2VsbGF0aW9uVG9rZW4gPSBuZXcgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5DYW5jZWxsYXRpb25Ub2tlbigpO1xuICAgICAgICBjb25zdCBjaGFubmVsRmlsZSA9IHV0aWxfMS5nZXRDaGFubmVsRmlsZW5hbWUodGhpcy5nZXREZWZhdWx0Q2hhbm5lbE5hbWUoKSk7XG4gICAgICAgIGNvbnN0IHJlbGVhc2VJbmZvID0gYXdhaXQgdGhpcy5nZXRMYXRlc3RWZXJzaW9uSW5mbyhjYW5jZWxsYXRpb25Ub2tlbik7XG4gICAgICAgIGNvbnN0IGFzc2V0ID0gcmVsZWFzZUluZm8uYXNzZXRzLmZpbmQoaXQgPT4gaXQubmFtZSA9PT0gY2hhbm5lbEZpbGUpO1xuICAgICAgICBpZiAoYXNzZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gaHRtbF91cmwgbXVzdCBiZSBhbHdheXMsIGJ1dCBqdXN0IHRvIGJlIHN1cmVcbiAgICAgICAgICAgIHRocm93IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IoYENhbm5vdCBmaW5kICR7Y2hhbm5lbEZpbGV9IGluIHRoZSByZWxlYXNlICR7cmVsZWFzZUluZm8uaHRtbF91cmwgfHwgcmVsZWFzZUluZm8ubmFtZX1gLCBcIkVSUl9VUERBVEVSX0NIQU5ORUxfRklMRV9OT1RfRk9VTkRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsID0gbmV3IHVybF8xLlVSTChhc3NldC51cmwpO1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0ganNfeWFtbF8xLmxvYWQoKGF3YWl0IHRoaXMuaHR0cFJlcXVlc3QodXJsLCB0aGlzLmNvbmZpZ3VyZUhlYWRlcnMoXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIiksIGNhbmNlbGxhdGlvblRva2VuKSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuSHR0cEVycm9yICYmIGUuc3RhdHVzQ29kZSA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5uZXdFcnJvcihgQ2Fubm90IGZpbmQgJHtjaGFubmVsRmlsZX0gaW4gdGhlIGxhdGVzdCByZWxlYXNlIGFydGlmYWN0cyAoJHt1cmx9KTogJHtlLnN0YWNrIHx8IGUubWVzc2FnZX1gLCBcIkVSUl9VUERBVEVSX0NIQU5ORUxfRklMRV9OT1RfRk9VTkRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgcmVzdWx0LmFzc2V0cyA9IHJlbGVhc2VJbmZvLmFzc2V0cztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZ2V0IGZpbGVFeHRyYURvd25sb2FkSGVhZGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJlSGVhZGVycyhcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1mdW5jdGlvbi1yZXR1cm4tdHlwZVxuICAgIGNvbmZpZ3VyZUhlYWRlcnMoYWNjZXB0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhY2NlcHQsXG4gICAgICAgICAgICBhdXRob3JpemF0aW9uOiBgdG9rZW4gJHt0aGlzLnRva2VufWAsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGdldExhdGVzdFZlcnNpb25JbmZvKGNhbmNlbGxhdGlvblRva2VuKSB7XG4gICAgICAgIGNvbnN0IGFsbG93UHJlcmVsZWFzZSA9IHRoaXMudXBkYXRlci5hbGxvd1ByZXJlbGVhc2U7XG4gICAgICAgIGxldCBiYXNlUGF0aCA9IHRoaXMuYmFzZVBhdGg7XG4gICAgICAgIGlmICghYWxsb3dQcmVyZWxlYXNlKSB7XG4gICAgICAgICAgICBiYXNlUGF0aCA9IGAke2Jhc2VQYXRofS9sYXRlc3RgO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVybCA9IHV0aWxfMS5uZXdVcmxGcm9tQmFzZShiYXNlUGF0aCwgdGhpcy5iYXNlVXJsKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSBKU09OLnBhcnNlKChhd2FpdCB0aGlzLmh0dHBSZXF1ZXN0KHVybCwgdGhpcy5jb25maWd1cmVIZWFkZXJzKFwiYXBwbGljYXRpb24vdm5kLmdpdGh1Yi52Mytqc29uXCIpLCBjYW5jZWxsYXRpb25Ub2tlbikpKTtcbiAgICAgICAgICAgIGlmIChhbGxvd1ByZXJlbGVhc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmVyc2lvbi5maW5kKGl0ID0+IGl0LnByZXJlbGVhc2UpIHx8IHZlcnNpb25bMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmVyc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5uZXdFcnJvcihgVW5hYmxlIHRvIGZpbmQgbGF0ZXN0IHZlcnNpb24gb24gR2l0SHViICgke3VybH0pLCBwbGVhc2UgZW5zdXJlIGEgcHJvZHVjdGlvbiByZWxlYXNlIGV4aXN0czogJHtlLnN0YWNrIHx8IGUubWVzc2FnZX1gLCBcIkVSUl9VUERBVEVSX0xBVEVTVF9WRVJTSU9OX05PVF9GT1VORFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgYmFzZVBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVHaXRodWJCYXNlUGF0aChgL3JlcG9zLyR7dGhpcy5vcHRpb25zLm93bmVyfS8ke3RoaXMub3B0aW9ucy5yZXBvfS9yZWxlYXNlc2ApO1xuICAgIH1cbiAgICByZXNvbHZlRmlsZXModXBkYXRlSW5mbykge1xuICAgICAgICByZXR1cm4gUHJvdmlkZXJfMS5nZXRGaWxlTGlzdCh1cGRhdGVJbmZvKS5tYXAoaXQgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHBhdGgucG9zaXguYmFzZW5hbWUoaXQudXJsKS5yZXBsYWNlKC8gL2csIFwiLVwiKTtcbiAgICAgICAgICAgIGNvbnN0IGFzc2V0ID0gdXBkYXRlSW5mby5hc3NldHMuZmluZChpdCA9PiBpdCAhPSBudWxsICYmIGl0Lm5hbWUgPT09IG5hbWUpO1xuICAgICAgICAgICAgaWYgKGFzc2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBidWlsZGVyX3V0aWxfcnVudGltZV8xLm5ld0Vycm9yKGBDYW5ub3QgZmluZCBhc3NldCBcIiR7bmFtZX1cIiBpbjogJHtKU09OLnN0cmluZ2lmeSh1cGRhdGVJbmZvLmFzc2V0cywgbnVsbCwgMil9YCwgXCJFUlJfVVBEQVRFUl9BU1NFVF9OT1RfRk9VTkRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogbmV3IHVybF8xLlVSTChhc3NldC51cmwpLFxuICAgICAgICAgICAgICAgIGluZm86IGl0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5Qcml2YXRlR2l0SHViUHJvdmlkZXIgPSBQcml2YXRlR2l0SHViUHJvdmlkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qcml2YXRlR2l0SHViUHJvdmlkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUNsaWVudCA9IGV4cG9ydHMuaXNVcmxQcm9iYWJseVN1cHBvcnRNdWx0aVJhbmdlUmVxdWVzdHMgPSB2b2lkIDA7XG5jb25zdCBidWlsZGVyX3V0aWxfcnVudGltZV8xID0gcmVxdWlyZShcImJ1aWxkZXItdXRpbC1ydW50aW1lXCIpO1xuY29uc3QgQmludHJheVByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlcnMvQmludHJheVByb3ZpZGVyXCIpO1xuY29uc3QgR2VuZXJpY1Byb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlcnMvR2VuZXJpY1Byb3ZpZGVyXCIpO1xuY29uc3QgR2l0SHViUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVycy9HaXRIdWJQcm92aWRlclwiKTtcbmNvbnN0IEtleWdlblByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlcnMvS2V5Z2VuUHJvdmlkZXJcIik7XG5jb25zdCBQcml2YXRlR2l0SHViUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVycy9Qcml2YXRlR2l0SHViUHJvdmlkZXJcIik7XG5mdW5jdGlvbiBpc1VybFByb2JhYmx5U3VwcG9ydE11bHRpUmFuZ2VSZXF1ZXN0cyh1cmwpIHtcbiAgICByZXR1cm4gIXVybC5pbmNsdWRlcyhcInMzLmFtYXpvbmF3cy5jb21cIik7XG59XG5leHBvcnRzLmlzVXJsUHJvYmFibHlTdXBwb3J0TXVsdGlSYW5nZVJlcXVlc3RzID0gaXNVcmxQcm9iYWJseVN1cHBvcnRNdWx0aVJhbmdlUmVxdWVzdHM7XG5mdW5jdGlvbiBjcmVhdGVDbGllbnQoZGF0YSwgdXBkYXRlciwgcnVudGltZU9wdGlvbnMpIHtcbiAgICAvLyBub2luc3BlY3Rpb24gU3VzcGljaW91c1R5cGVPZkd1YXJkXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IoXCJQbGVhc2UgcGFzcyBQdWJsaXNoQ29uZmlndXJhdGlvbiBvYmplY3RcIiwgXCJFUlJfVVBEQVRFUl9JTlZBTElEX1BST1ZJREVSX0NPTkZJR1VSQVRJT05cIik7XG4gICAgfVxuICAgIGNvbnN0IHByb3ZpZGVyID0gZGF0YS5wcm92aWRlcjtcbiAgICBzd2l0Y2ggKHByb3ZpZGVyKSB7XG4gICAgICAgIGNhc2UgXCJnaXRodWJcIjoge1xuICAgICAgICAgICAgY29uc3QgZ2l0aHViT3B0aW9ucyA9IGRhdGE7XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IChnaXRodWJPcHRpb25zLnByaXZhdGUgPyBwcm9jZXNzLmVudltcIkdIX1RPS0VOXCJdIHx8IHByb2Nlc3MuZW52W1wiR0lUSFVCX1RPS0VOXCJdIDogbnVsbCkgfHwgZ2l0aHViT3B0aW9ucy50b2tlbjtcbiAgICAgICAgICAgIGlmICh0b2tlbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBHaXRIdWJQcm92aWRlcl8xLkdpdEh1YlByb3ZpZGVyKGdpdGh1Yk9wdGlvbnMsIHVwZGF0ZXIsIHJ1bnRpbWVPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJpdmF0ZUdpdEh1YlByb3ZpZGVyXzEuUHJpdmF0ZUdpdEh1YlByb3ZpZGVyKGdpdGh1Yk9wdGlvbnMsIHVwZGF0ZXIsIHRva2VuLCBydW50aW1lT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImtleWdlblwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBLZXlnZW5Qcm92aWRlcl8xLktleWdlblByb3ZpZGVyKGRhdGEsIHVwZGF0ZXIsIHJ1bnRpbWVPcHRpb25zKTtcbiAgICAgICAgY2FzZSBcInMzXCI6XG4gICAgICAgIGNhc2UgXCJzcGFjZXNcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgR2VuZXJpY1Byb3ZpZGVyXzEuR2VuZXJpY1Byb3ZpZGVyKHtcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogXCJnZW5lcmljXCIsXG4gICAgICAgICAgICAgICAgdXJsOiBidWlsZGVyX3V0aWxfcnVudGltZV8xLmdldFMzTGlrZVByb3ZpZGVyQmFzZVVybChkYXRhKSxcbiAgICAgICAgICAgICAgICBjaGFubmVsOiBkYXRhLmNoYW5uZWwgfHwgbnVsbCxcbiAgICAgICAgICAgIH0sIHVwZGF0ZXIsIHtcbiAgICAgICAgICAgICAgICAuLi5ydW50aW1lT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWluaW8vbWluaW8vaXNzdWVzLzUyODUjaXNzdWVjb21tZW50LTM1MDQyODk1NVxuICAgICAgICAgICAgICAgIGlzVXNlTXVsdGlwbGVSYW5nZVJlcXVlc3Q6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgXCJnZW5lcmljXCI6IHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBkYXRhO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmljUHJvdmlkZXJfMS5HZW5lcmljUHJvdmlkZXIob3B0aW9ucywgdXBkYXRlciwge1xuICAgICAgICAgICAgICAgIC4uLnJ1bnRpbWVPcHRpb25zLFxuICAgICAgICAgICAgICAgIGlzVXNlTXVsdGlwbGVSYW5nZVJlcXVlc3Q6IG9wdGlvbnMudXNlTXVsdGlwbGVSYW5nZVJlcXVlc3QgIT09IGZhbHNlICYmIGlzVXJsUHJvYmFibHlTdXBwb3J0TXVsdGlSYW5nZVJlcXVlc3RzKG9wdGlvbnMudXJsKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJiaW50cmF5XCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpbnRyYXlQcm92aWRlcl8xLkJpbnRyYXlQcm92aWRlcihkYXRhLCBydW50aW1lT3B0aW9ucyk7XG4gICAgICAgIGNhc2UgXCJjdXN0b21cIjoge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGRhdGE7XG4gICAgICAgICAgICBjb25zdCBjb25zdHJ1Y3RvciA9IG9wdGlvbnMudXBkYXRlUHJvdmlkZXI7XG4gICAgICAgICAgICBpZiAoIWNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5uZXdFcnJvcihcIkN1c3RvbSBwcm92aWRlciBub3Qgc3BlY2lmaWVkXCIsIFwiRVJSX1VQREFURVJfSU5WQUxJRF9QUk9WSURFUl9DT05GSUdVUkFUSU9OXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBjb25zdHJ1Y3RvcihvcHRpb25zLCB1cGRhdGVyLCBydW50aW1lT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IoYFVuc3VwcG9ydGVkIHByb3ZpZGVyOiAke3Byb3ZpZGVyfWAsIFwiRVJSX1VQREFURVJfVU5TVVBQT1JURURfUFJPVklERVJcIik7XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVDbGllbnQgPSBjcmVhdGVDbGllbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlckZhY3RvcnkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5vT3BMb2dnZXIgPSBleHBvcnRzLkFwcFVwZGF0ZXIgPSB2b2lkIDA7XG5jb25zdCBidWlsZGVyX3V0aWxfcnVudGltZV8xID0gcmVxdWlyZShcImJ1aWxkZXItdXRpbC1ydW50aW1lXCIpO1xuY29uc3QgY3J5cHRvXzEgPSByZXF1aXJlKFwiY3J5cHRvXCIpO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3QgZnNfZXh0cmFfMSA9IHJlcXVpcmUoXCJmcy1leHRyYVwiKTtcbmNvbnN0IHByb21pc2VzXzEgPSByZXF1aXJlKFwiZnMvcHJvbWlzZXNcIik7XG5jb25zdCBqc195YW1sXzEgPSByZXF1aXJlKFwianMteWFtbFwiKTtcbmNvbnN0IGxhenlfdmFsXzEgPSByZXF1aXJlKFwibGF6eS12YWxcIik7XG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCBzZW12ZXJfMSA9IHJlcXVpcmUoXCJzZW12ZXJcIik7XG5jb25zdCBEb3dubG9hZGVkVXBkYXRlSGVscGVyXzEgPSByZXF1aXJlKFwiLi9Eb3dubG9hZGVkVXBkYXRlSGVscGVyXCIpO1xuY29uc3QgRWxlY3Ryb25BcHBBZGFwdGVyXzEgPSByZXF1aXJlKFwiLi9FbGVjdHJvbkFwcEFkYXB0ZXJcIik7XG5jb25zdCBlbGVjdHJvbkh0dHBFeGVjdXRvcl8xID0gcmVxdWlyZShcIi4vZWxlY3Ryb25IdHRwRXhlY3V0b3JcIik7XG5jb25zdCBHZW5lcmljUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVycy9HZW5lcmljUHJvdmlkZXJcIik7XG5jb25zdCBtYWluXzEgPSByZXF1aXJlKFwiLi9tYWluXCIpO1xuY29uc3QgcHJvdmlkZXJGYWN0b3J5XzEgPSByZXF1aXJlKFwiLi9wcm92aWRlckZhY3RvcnlcIik7XG5jbGFzcyBBcHBVcGRhdGVyIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBhcHApIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdG8gYXV0b21hdGljYWxseSBkb3dubG9hZCBhbiB1cGRhdGUgd2hlbiBpdCBpcyBmb3VuZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXV0b0Rvd25sb2FkID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdG8gYXV0b21hdGljYWxseSBpbnN0YWxsIGEgZG93bmxvYWRlZCB1cGRhdGUgb24gYXBwIHF1aXQgKGlmIGBxdWl0QW5kSW5zdGFsbGAgd2FzIG5vdCBjYWxsZWQgYmVmb3JlKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXV0b0luc3RhbGxPbkFwcFF1aXQgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogKkdpdEh1YiBwcm92aWRlciBvbmx5LiogV2hldGhlciB0byBhbGxvdyB1cGRhdGUgdG8gcHJlLXJlbGVhc2UgdmVyc2lvbnMuIERlZmF1bHRzIHRvIGB0cnVlYCBpZiBhcHBsaWNhdGlvbiB2ZXJzaW9uIGNvbnRhaW5zIHByZXJlbGVhc2UgY29tcG9uZW50cyAoZS5nLiBgMC4xMi4xLWFscGhhLjFgLCBoZXJlIGBhbHBoYWAgaXMgYSBwcmVyZWxlYXNlIGNvbXBvbmVudCksIG90aGVyd2lzZSBgZmFsc2VgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBgdHJ1ZWAsIGRvd25ncmFkZSB3aWxsIGJlIGFsbG93ZWQgKGBhbGxvd0Rvd25ncmFkZWAgd2lsbCBiZSBzZXQgdG8gYHRydWVgKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWxsb3dQcmVyZWxlYXNlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAqR2l0SHViIHByb3ZpZGVyIG9ubHkuKiBHZXQgYWxsIHJlbGVhc2Ugbm90ZXMgKGZyb20gY3VycmVudCB2ZXJzaW9uIHRvIGxhdGVzdCksIG5vdCBqdXN0IHRoZSBsYXRlc3QuXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZ1bGxDaGFuZ2Vsb2cgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdG8gYWxsb3cgdmVyc2lvbiBkb3duZ3JhZGUgKHdoZW4gYSB1c2VyIGZyb20gdGhlIGJldGEgY2hhbm5lbCB3YW50cyB0byBnbyBiYWNrIHRvIHRoZSBzdGFibGUgY2hhbm5lbCkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRha2VuIGluIGFjY291bnQgb25seSBpZiBjaGFubmVsIGRpZmZlcnMgKHByZS1yZWxlYXNlIHZlcnNpb24gY29tcG9uZW50IGluIHRlcm1zIG9mIHNlbWFudGljIHZlcnNpb25pbmcpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbGxvd0Rvd25ncmFkZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jaGFubmVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5kb3dubG9hZGVkVXBkYXRlSGVscGVyID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqICBUaGUgcmVxdWVzdCBoZWFkZXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXF1ZXN0SGVhZGVycyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xvZ2dlciA9IGNvbnNvbGU7XG4gICAgICAgIC8vIG5vaW5zcGVjdGlvbiBKU1VudXNlZEdsb2JhbFN5bWJvbHNcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvciB0eXBlIHNhZmV0eSB5b3UgY2FuIHVzZSBzaWduYWxzLCBlLmcuIGBhdXRvVXBkYXRlci5zaWduYWxzLnVwZGF0ZURvd25sb2FkZWQoKCkgPT4ge30pYCBpbnN0ZWFkIG9mIGBhdXRvVXBkYXRlci5vbigndXBkYXRlLWF2YWlsYWJsZScsICgpID0+IHt9KWBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2lnbmFscyA9IG5ldyBtYWluXzEuVXBkYXRlclNpZ25hbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fYXBwVXBkYXRlQ29uZmlnUGF0aCA9IG51bGw7XG4gICAgICAgIHRoaXMuY2xpZW50UHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhZ2luZ1VzZXJJZFByb21pc2UgPSBuZXcgbGF6eV92YWxfMS5MYXp5KCgpID0+IHRoaXMuZ2V0T3JDcmVhdGVTdGFnaW5nVXNlcklkKCkpO1xuICAgICAgICAvLyBwdWJsaWMsIGFsbG93IHRvIHJlYWQgb2xkIGNvbmZpZyBmb3IgYW55b25lXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5jb25maWdPbkRpc2sgPSBuZXcgbGF6eV92YWxfMS5MYXp5KCgpID0+IHRoaXMubG9hZFVwZGF0ZUNvbmZpZygpKTtcbiAgICAgICAgdGhpcy5jaGVja0ZvclVwZGF0ZXNQcm9taXNlID0gbnVsbDtcbiAgICAgICAgdGhpcy51cGRhdGVJbmZvQW5kUHJvdmlkZXIgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90ZXN0T25seU9wdGlvbnMgPSBudWxsO1xuICAgICAgICB0aGlzLm9uKFwiZXJyb3JcIiwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoYEVycm9yOiAke2Vycm9yLnN0YWNrIHx8IGVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYXBwID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwID0gbmV3IEVsZWN0cm9uQXBwQWRhcHRlcl8xLkVsZWN0cm9uQXBwQWRhcHRlcigpO1xuICAgICAgICAgICAgdGhpcy5odHRwRXhlY3V0b3IgPSBuZXcgZWxlY3Ryb25IdHRwRXhlY3V0b3JfMS5FbGVjdHJvbkh0dHBFeGVjdXRvcigoYXV0aEluZm8sIGNhbGxiYWNrKSA9PiB0aGlzLmVtaXQoXCJsb2dpblwiLCBhdXRoSW5mbywgY2FsbGJhY2spKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXBwID0gYXBwO1xuICAgICAgICAgICAgdGhpcy5odHRwRXhlY3V0b3IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRWZXJzaW9uU3RyaW5nID0gdGhpcy5hcHAudmVyc2lvbjtcbiAgICAgICAgY29uc3QgY3VycmVudFZlcnNpb24gPSBzZW12ZXJfMS5wYXJzZShjdXJyZW50VmVyc2lvblN0cmluZyk7XG4gICAgICAgIGlmIChjdXJyZW50VmVyc2lvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBidWlsZGVyX3V0aWxfcnVudGltZV8xLm5ld0Vycm9yKGBBcHAgdmVyc2lvbiBpcyBub3QgYSB2YWxpZCBzZW12ZXIgdmVyc2lvbjogXCIke2N1cnJlbnRWZXJzaW9uU3RyaW5nfVwiYCwgXCJFUlJfVVBEQVRFUl9JTlZBTElEX1ZFUlNJT05cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50VmVyc2lvbiA9IGN1cnJlbnRWZXJzaW9uO1xuICAgICAgICB0aGlzLmFsbG93UHJlcmVsZWFzZSA9IGhhc1ByZXJlbGVhc2VDb21wb25lbnRzKGN1cnJlbnRWZXJzaW9uKTtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zZXRGZWVkVVJMKG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSBcInN0cmluZ1wiICYmIG9wdGlvbnMucmVxdWVzdEhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RIZWFkZXJzID0gb3B0aW9ucy5yZXF1ZXN0SGVhZGVycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHVwZGF0ZSBjaGFubmVsLiBOb3QgYXBwbGljYWJsZSBmb3IgR2l0SHViLiBEb2Vzbid0IHJldHVybiBgY2hhbm5lbGAgZnJvbSB0aGUgdXBkYXRlIGNvbmZpZ3VyYXRpb24sIG9ubHkgaWYgd2FzIHByZXZpb3VzbHkgc2V0LlxuICAgICAqL1xuICAgIGdldCBjaGFubmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hhbm5lbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB1cGRhdGUgY2hhbm5lbC4gTm90IGFwcGxpY2FibGUgZm9yIEdpdEh1Yi4gT3ZlcnJpZGVzIGBjaGFubmVsYCBpbiB0aGUgdXBkYXRlIGNvbmZpZ3VyYXRpb24uXG4gICAgICpcbiAgICAgKiBgYWxsb3dEb3duZ3JhZGVgIHdpbGwgYmUgYXV0b21hdGljYWxseSBzZXQgdG8gYHRydWVgLiBJZiB0aGlzIGJlaGF2aW9yIGlzIG5vdCBzdWl0YWJsZSBmb3IgeW91LCBzaW1wbGUgc2V0IGBhbGxvd0Rvd25ncmFkZWAgZXhwbGljaXRseSBhZnRlci5cbiAgICAgKi9cbiAgICBzZXQgY2hhbm5lbCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fY2hhbm5lbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBub2luc3BlY3Rpb24gU3VzcGljaW91c1R5cGVPZkd1YXJkXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5uZXdFcnJvcihgQ2hhbm5lbCBtdXN0IGJlIGEgc3RyaW5nLCBidXQgZ290OiAke3ZhbHVlfWAsIFwiRVJSX1VQREFURVJfSU5WQUxJRF9DSEFOTkVMXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5uZXdFcnJvcihgQ2hhbm5lbCBtdXN0IGJlIG5vdCBhbiBlbXB0eSBzdHJpbmdgLCBcIkVSUl9VUERBVEVSX0lOVkFMSURfQ0hBTk5FTFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jaGFubmVsID0gdmFsdWU7XG4gICAgICAgIHRoaXMuYWxsb3dEb3duZ3JhZGUgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU2hvcnRjdXQgZm9yIGV4cGxpY2l0bHkgYWRkaW5nIGF1dGggdG9rZW5zIHRvIHJlcXVlc3QgaGVhZGVyc1xuICAgICAqL1xuICAgIGFkZEF1dGhIZWFkZXIodG9rZW4pIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0SGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMucmVxdWVzdEhlYWRlcnMsIHtcbiAgICAgICAgICAgIGF1dGhvcml6YXRpb246IHRva2VuLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gbm9pbnNwZWN0aW9uIEpTTWV0aG9kQ2FuQmVTdGF0aWMsSlNVbnVzZWRHbG9iYWxTeW1ib2xzXG4gICAgZ2V0IG5ldFNlc3Npb24oKSB7XG4gICAgICAgIHJldHVybiBlbGVjdHJvbkh0dHBFeGVjdXRvcl8xLmdldE5ldFNlc3Npb24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGxvZ2dlci4gWW91IGNhbiBwYXNzIFtlbGVjdHJvbi1sb2ddKGh0dHBzOi8vZ2l0aHViLmNvbS9tZWdhaGVydHovZWxlY3Ryb24tbG9nKSwgW3dpbnN0b25dKGh0dHBzOi8vZ2l0aHViLmNvbS93aW5zdG9uanMvd2luc3Rvbikgb3IgYW5vdGhlciBsb2dnZXIgd2l0aCB0aGUgZm9sbG93aW5nIGludGVyZmFjZTogYHsgaW5mbygpLCB3YXJuKCksIGVycm9yKCkgfWAuXG4gICAgICogU2V0IGl0IHRvIGBudWxsYCBpZiB5b3Ugd291bGQgbGlrZSB0byBkaXNhYmxlIGEgbG9nZ2luZyBmZWF0dXJlLlxuICAgICAqL1xuICAgIGdldCBsb2dnZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dnZXI7XG4gICAgfVxuICAgIHNldCBsb2dnZXIodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fbG9nZ2VyID0gdmFsdWUgPT0gbnVsbCA/IG5ldyBOb09wTG9nZ2VyKCkgOiB2YWx1ZTtcbiAgICB9XG4gICAgLy8gbm9pbnNwZWN0aW9uIEpTVW51c2VkR2xvYmFsU3ltYm9sc1xuICAgIC8qKlxuICAgICAqIHRlc3Qgb25seVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc2V0IHVwZGF0ZUNvbmZpZ1BhdGgodmFsdWUpIHtcbiAgICAgICAgdGhpcy5jbGllbnRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYXBwVXBkYXRlQ29uZmlnUGF0aCA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNvbmZpZ09uRGlzayA9IG5ldyBsYXp5X3ZhbF8xLkxhenkoKCkgPT4gdGhpcy5sb2FkVXBkYXRlQ29uZmlnKCkpO1xuICAgIH1cbiAgICAvL25vaW5zcGVjdGlvbiBKU01ldGhvZENhbkJlU3RhdGljLEpTVW51c2VkR2xvYmFsU3ltYm9sc1xuICAgIGdldEZlZWRVUkwoKSB7XG4gICAgICAgIHJldHVybiBcIkRlcHJlY2F0ZWQuIERvIG5vdCB1c2UgaXQuXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZSB1cGRhdGUgcHJvdmlkZXIuIElmIHZhbHVlIGlzIGBzdHJpbmdgLCBbR2VuZXJpY1NlcnZlck9wdGlvbnNdKC9jb25maWd1cmF0aW9uL3B1Ymxpc2gjZ2VuZXJpY3NlcnZlcm9wdGlvbnMpIHdpbGwgYmUgc2V0IHdpdGggdmFsdWUgYXMgYHVybGAuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgSWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgY29uZmlndXJhdGlvbiBpbiB0aGUgYGFwcC11cGRhdGUueW1sYC5cbiAgICAgKi9cbiAgICBzZXRGZWVkVVJMKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcnVudGltZU9wdGlvbnMgPSB0aGlzLmNyZWF0ZVByb3ZpZGVyUnVudGltZU9wdGlvbnMoKTtcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2VsZWN0cm9uLXVzZXJsYW5kL2VsZWN0cm9uLWJ1aWxkZXIvaXNzdWVzLzExMDVcbiAgICAgICAgbGV0IHByb3ZpZGVyO1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHByb3ZpZGVyID0gbmV3IEdlbmVyaWNQcm92aWRlcl8xLkdlbmVyaWNQcm92aWRlcih7IHByb3ZpZGVyOiBcImdlbmVyaWNcIiwgdXJsOiBvcHRpb25zIH0sIHRoaXMsIHtcbiAgICAgICAgICAgICAgICAuLi5ydW50aW1lT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBpc1VzZU11bHRpcGxlUmFuZ2VSZXF1ZXN0OiBwcm92aWRlckZhY3RvcnlfMS5pc1VybFByb2JhYmx5U3VwcG9ydE11bHRpUmFuZ2VSZXF1ZXN0cyhvcHRpb25zKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJvdmlkZXIgPSBwcm92aWRlckZhY3RvcnlfMS5jcmVhdGVDbGllbnQob3B0aW9ucywgdGhpcywgcnVudGltZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xpZW50UHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShwcm92aWRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFza3MgdGhlIHNlcnZlciB3aGV0aGVyIHRoZXJlIGlzIGFuIHVwZGF0ZS5cbiAgICAgKi9cbiAgICBjaGVja0ZvclVwZGF0ZXMoKSB7XG4gICAgICAgIGxldCBjaGVja0ZvclVwZGF0ZXNQcm9taXNlID0gdGhpcy5jaGVja0ZvclVwZGF0ZXNQcm9taXNlO1xuICAgICAgICBpZiAoY2hlY2tGb3JVcGRhdGVzUHJvbWlzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIkNoZWNraW5nIGZvciB1cGRhdGUgKGFscmVhZHkgaW4gcHJvZ3Jlc3MpXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrRm9yVXBkYXRlc1Byb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbnVsbGl6ZVByb21pc2UgPSAoKSA9PiAodGhpcy5jaGVja0ZvclVwZGF0ZXNQcm9taXNlID0gbnVsbCk7XG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiQ2hlY2tpbmcgZm9yIHVwZGF0ZVwiKTtcbiAgICAgICAgY2hlY2tGb3JVcGRhdGVzUHJvbWlzZSA9IHRoaXMuZG9DaGVja0ZvclVwZGF0ZXMoKVxuICAgICAgICAgICAgLnRoZW4oaXQgPT4ge1xuICAgICAgICAgICAgbnVsbGl6ZVByb21pc2UoKTtcbiAgICAgICAgICAgIHJldHVybiBpdDtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChlID0+IHtcbiAgICAgICAgICAgIG51bGxpemVQcm9taXNlKCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlLCBgQ2Fubm90IGNoZWNrIGZvciB1cGRhdGVzOiAkeyhlLnN0YWNrIHx8IGUpLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jaGVja0ZvclVwZGF0ZXNQcm9taXNlID0gY2hlY2tGb3JVcGRhdGVzUHJvbWlzZTtcbiAgICAgICAgcmV0dXJuIGNoZWNrRm9yVXBkYXRlc1Byb21pc2U7XG4gICAgfVxuICAgIGlzVXBkYXRlckFjdGl2ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFwcC5pc1BhY2thZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIlNraXAgY2hlY2tGb3JVcGRhdGVzQW5kTm90aWZ5IGJlY2F1c2UgYXBwbGljYXRpb24gaXMgbm90IHBhY2tlZFwiKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gbm9pbnNwZWN0aW9uIEpTVW51c2VkR2xvYmFsU3ltYm9sc1xuICAgIGNoZWNrRm9yVXBkYXRlc0FuZE5vdGlmeShkb3dubG9hZE5vdGlmaWNhdGlvbikge1xuICAgICAgICBpZiAoIXRoaXMuaXNVcGRhdGVyQWN0aXZlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tGb3JVcGRhdGVzKCkudGhlbihpdCA9PiB7XG4gICAgICAgICAgICBjb25zdCBkb3dubG9hZFByb21pc2UgPSBpdC5kb3dubG9hZFByb21pc2U7XG4gICAgICAgICAgICBpZiAoZG93bmxvYWRQcm9taXNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbG9nZ2VyLmRlYnVnICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwiY2hlY2tGb3JVcGRhdGVzQW5kTm90aWZ5IGNhbGxlZCwgZG93bmxvYWRQcm9taXNlIGlzIG51bGxcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZvaWQgZG93bmxvYWRQcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbkNvbnRlbnQgPSBBcHBVcGRhdGVyLmZvcm1hdERvd25sb2FkTm90aWZpY2F0aW9uKGl0LnVwZGF0ZUluZm8udmVyc2lvbiwgdGhpcy5hcHAubmFtZSwgZG93bmxvYWROb3RpZmljYXRpb24pO1xuICAgICAgICAgICAgICAgIG5ldyAocmVxdWlyZShcImVsZWN0cm9uXCIpLk5vdGlmaWNhdGlvbikobm90aWZpY2F0aW9uQ29udGVudCkuc2hvdygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gaXQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZm9ybWF0RG93bmxvYWROb3RpZmljYXRpb24odmVyc2lvbiwgYXBwTmFtZSwgZG93bmxvYWROb3RpZmljYXRpb24pIHtcbiAgICAgICAgaWYgKGRvd25sb2FkTm90aWZpY2F0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIGRvd25sb2FkTm90aWZpY2F0aW9uID0ge1xuICAgICAgICAgICAgICAgIHRpdGxlOiBcIkEgbmV3IHVwZGF0ZSBpcyByZWFkeSB0byBpbnN0YWxsXCIsXG4gICAgICAgICAgICAgICAgYm9keTogYHthcHBOYW1lfSB2ZXJzaW9uIHt2ZXJzaW9ufSBoYXMgYmVlbiBkb3dubG9hZGVkIGFuZCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgaW5zdGFsbGVkIG9uIGV4aXRgLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBkb3dubG9hZE5vdGlmaWNhdGlvbiA9IHtcbiAgICAgICAgICAgIHRpdGxlOiBkb3dubG9hZE5vdGlmaWNhdGlvbi50aXRsZS5yZXBsYWNlKFwie2FwcE5hbWV9XCIsIGFwcE5hbWUpLnJlcGxhY2UoXCJ7dmVyc2lvbn1cIiwgdmVyc2lvbiksXG4gICAgICAgICAgICBib2R5OiBkb3dubG9hZE5vdGlmaWNhdGlvbi5ib2R5LnJlcGxhY2UoXCJ7YXBwTmFtZX1cIiwgYXBwTmFtZSkucmVwbGFjZShcInt2ZXJzaW9ufVwiLCB2ZXJzaW9uKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGRvd25sb2FkTm90aWZpY2F0aW9uO1xuICAgIH1cbiAgICBhc3luYyBpc1N0YWdpbmdNYXRjaCh1cGRhdGVJbmZvKSB7XG4gICAgICAgIGNvbnN0IHJhd1N0YWdpbmdQZXJjZW50YWdlID0gdXBkYXRlSW5mby5zdGFnaW5nUGVyY2VudGFnZTtcbiAgICAgICAgbGV0IHN0YWdpbmdQZXJjZW50YWdlID0gcmF3U3RhZ2luZ1BlcmNlbnRhZ2U7XG4gICAgICAgIGlmIChzdGFnaW5nUGVyY2VudGFnZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBzdGFnaW5nUGVyY2VudGFnZSA9IHBhcnNlSW50KHN0YWdpbmdQZXJjZW50YWdlLCAxMCk7XG4gICAgICAgIGlmIChpc05hTihzdGFnaW5nUGVyY2VudGFnZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKGBTdGFnaW5nIHBlcmNlbnRhZ2UgaXMgTmFOOiAke3Jhd1N0YWdpbmdQZXJjZW50YWdlfWApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29udmVydCBmcm9tIHVzZXIgMC0xMDAgdG8gaW50ZXJuYWwgMC0xXG4gICAgICAgIHN0YWdpbmdQZXJjZW50YWdlID0gc3RhZ2luZ1BlcmNlbnRhZ2UgLyAxMDA7XG4gICAgICAgIGNvbnN0IHN0YWdpbmdVc2VySWQgPSBhd2FpdCB0aGlzLnN0YWdpbmdVc2VySWRQcm9taXNlLnZhbHVlO1xuICAgICAgICBjb25zdCB2YWwgPSBidWlsZGVyX3V0aWxfcnVudGltZV8xLlVVSUQucGFyc2Uoc3RhZ2luZ1VzZXJJZCkucmVhZFVJbnQzMkJFKDEyKTtcbiAgICAgICAgY29uc3QgcGVyY2VudGFnZSA9IHZhbCAvIDB4ZmZmZmZmZmY7XG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKGBTdGFnaW5nIHBlcmNlbnRhZ2U6ICR7c3RhZ2luZ1BlcmNlbnRhZ2V9LCBwZXJjZW50YWdlOiAke3BlcmNlbnRhZ2V9LCB1c2VyIGlkOiAke3N0YWdpbmdVc2VySWR9YCk7XG4gICAgICAgIHJldHVybiBwZXJjZW50YWdlIDwgc3RhZ2luZ1BlcmNlbnRhZ2U7XG4gICAgfVxuICAgIGNvbXB1dGVGaW5hbEhlYWRlcnMoaGVhZGVycykge1xuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0SGVhZGVycyAhPSBudWxsKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGhlYWRlcnMsIHRoaXMucmVxdWVzdEhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbiAgICBhc3luYyBpc1VwZGF0ZUF2YWlsYWJsZSh1cGRhdGVJbmZvKSB7XG4gICAgICAgIGNvbnN0IGxhdGVzdFZlcnNpb24gPSBzZW12ZXJfMS5wYXJzZSh1cGRhdGVJbmZvLnZlcnNpb24pO1xuICAgICAgICBpZiAobGF0ZXN0VmVyc2lvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBidWlsZGVyX3V0aWxfcnVudGltZV8xLm5ld0Vycm9yKGBUaGlzIGZpbGUgY291bGQgbm90IGJlIGRvd25sb2FkZWQsIG9yIHRoZSBsYXRlc3QgdmVyc2lvbiAoZnJvbSB1cGRhdGUgc2VydmVyKSBkb2VzIG5vdCBoYXZlIGEgdmFsaWQgc2VtdmVyIHZlcnNpb246IFwiJHt1cGRhdGVJbmZvLnZlcnNpb259XCJgLCBcIkVSUl9VUERBVEVSX0lOVkFMSURfVkVSU0lPTlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50VmVyc2lvbiA9IHRoaXMuY3VycmVudFZlcnNpb247XG4gICAgICAgIGlmIChzZW12ZXJfMS5lcShsYXRlc3RWZXJzaW9uLCBjdXJyZW50VmVyc2lvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc1N0YWdpbmdNYXRjaCA9IGF3YWl0IHRoaXMuaXNTdGFnaW5nTWF0Y2godXBkYXRlSW5mbyk7XG4gICAgICAgIGlmICghaXNTdGFnaW5nTWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZWxlY3Ryb24tdXNlcmxhbmQvZWxlY3Ryb24tYnVpbGRlci9wdWxsLzMxMTEjaXNzdWVjb21tZW50LTQwNTAzMzIyN1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZWxlY3Ryb24tdXNlcmxhbmQvZWxlY3Ryb24tYnVpbGRlci9wdWxsLzMxMTEjaXNzdWVjb21tZW50LTQwNTAzMDc5N1xuICAgICAgICBjb25zdCBpc0xhdGVzdFZlcnNpb25OZXdlciA9IHNlbXZlcl8xLmd0KGxhdGVzdFZlcnNpb24sIGN1cnJlbnRWZXJzaW9uKTtcbiAgICAgICAgY29uc3QgaXNMYXRlc3RWZXJzaW9uT2xkZXIgPSBzZW12ZXJfMS5sdChsYXRlc3RWZXJzaW9uLCBjdXJyZW50VmVyc2lvbik7XG4gICAgICAgIGlmIChpc0xhdGVzdFZlcnNpb25OZXdlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsb3dEb3duZ3JhZGUgJiYgaXNMYXRlc3RWZXJzaW9uT2xkZXI7XG4gICAgfVxuICAgIGFzeW5jIGdldFVwZGF0ZUluZm9BbmRQcm92aWRlcigpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5hcHAud2hlblJlYWR5KCk7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudFByb21pc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jbGllbnRQcm9taXNlID0gdGhpcy5jb25maWdPbkRpc2sudmFsdWUudGhlbihpdCA9PiBwcm92aWRlckZhY3RvcnlfMS5jcmVhdGVDbGllbnQoaXQsIHRoaXMsIHRoaXMuY3JlYXRlUHJvdmlkZXJSdW50aW1lT3B0aW9ucygpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5jbGllbnRQcm9taXNlO1xuICAgICAgICBjb25zdCBzdGFnaW5nVXNlcklkID0gYXdhaXQgdGhpcy5zdGFnaW5nVXNlcklkUHJvbWlzZS52YWx1ZTtcbiAgICAgICAgY2xpZW50LnNldFJlcXVlc3RIZWFkZXJzKHRoaXMuY29tcHV0ZUZpbmFsSGVhZGVycyh7IFwieC11c2VyLXN0YWdpbmctaWRcIjogc3RhZ2luZ1VzZXJJZCB9KSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbmZvOiBhd2FpdCBjbGllbnQuZ2V0TGF0ZXN0VmVyc2lvbigpLFxuICAgICAgICAgICAgcHJvdmlkZXI6IGNsaWVudCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1mdW5jdGlvbi1yZXR1cm4tdHlwZVxuICAgIGNyZWF0ZVByb3ZpZGVyUnVudGltZU9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc1VzZU11bHRpcGxlUmFuZ2VSZXF1ZXN0OiB0cnVlLFxuICAgICAgICAgICAgcGxhdGZvcm06IHRoaXMuX3Rlc3RPbmx5T3B0aW9ucyA9PSBudWxsID8gcHJvY2Vzcy5wbGF0Zm9ybSA6IHRoaXMuX3Rlc3RPbmx5T3B0aW9ucy5wbGF0Zm9ybSxcbiAgICAgICAgICAgIGV4ZWN1dG9yOiB0aGlzLmh0dHBFeGVjdXRvcixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgZG9DaGVja0ZvclVwZGF0ZXMoKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImNoZWNraW5nLWZvci11cGRhdGVcIik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZ2V0VXBkYXRlSW5mb0FuZFByb3ZpZGVyKCk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZUluZm8gPSByZXN1bHQuaW5mbztcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5pc1VwZGF0ZUF2YWlsYWJsZSh1cGRhdGVJbmZvKSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKGBVcGRhdGUgZm9yIHZlcnNpb24gJHt0aGlzLmN1cnJlbnRWZXJzaW9ufSBpcyBub3QgYXZhaWxhYmxlIChsYXRlc3QgdmVyc2lvbjogJHt1cGRhdGVJbmZvLnZlcnNpb259LCBkb3duZ3JhZGUgaXMgJHt0aGlzLmFsbG93RG93bmdyYWRlID8gXCJhbGxvd2VkXCIgOiBcImRpc2FsbG93ZWRcIn0pLmApO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwidXBkYXRlLW5vdC1hdmFpbGFibGVcIiwgdXBkYXRlSW5mbyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZlcnNpb25JbmZvOiB1cGRhdGVJbmZvLFxuICAgICAgICAgICAgICAgIHVwZGF0ZUluZm8sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlSW5mb0FuZFByb3ZpZGVyID0gcmVzdWx0O1xuICAgICAgICB0aGlzLm9uVXBkYXRlQXZhaWxhYmxlKHVwZGF0ZUluZm8pO1xuICAgICAgICBjb25zdCBjYW5jZWxsYXRpb25Ub2tlbiA9IG5ldyBidWlsZGVyX3V0aWxfcnVudGltZV8xLkNhbmNlbGxhdGlvblRva2VuKCk7XG4gICAgICAgIC8vbm9pbnNwZWN0aW9uIEVTNk1pc3NpbmdBd2FpdFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmVyc2lvbkluZm86IHVwZGF0ZUluZm8sXG4gICAgICAgICAgICB1cGRhdGVJbmZvLFxuICAgICAgICAgICAgY2FuY2VsbGF0aW9uVG9rZW4sXG4gICAgICAgICAgICBkb3dubG9hZFByb21pc2U6IHRoaXMuYXV0b0Rvd25sb2FkID8gdGhpcy5kb3dubG9hZFVwZGF0ZShjYW5jZWxsYXRpb25Ub2tlbikgOiBudWxsLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBvblVwZGF0ZUF2YWlsYWJsZSh1cGRhdGVJbmZvKSB7XG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKGBGb3VuZCB2ZXJzaW9uICR7dXBkYXRlSW5mby52ZXJzaW9ufSAodXJsOiAke2J1aWxkZXJfdXRpbF9ydW50aW1lXzEuYXNBcnJheSh1cGRhdGVJbmZvLmZpbGVzKVxuICAgICAgICAgICAgLm1hcChpdCA9PiBpdC51cmwpXG4gICAgICAgICAgICAuam9pbihcIiwgXCIpfSlgKTtcbiAgICAgICAgdGhpcy5lbWl0KFwidXBkYXRlLWF2YWlsYWJsZVwiLCB1cGRhdGVJbmZvKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgZG93bmxvYWRpbmcgdXBkYXRlIG1hbnVhbGx5LiBZb3UgY2FuIHVzZSB0aGlzIG1ldGhvZCBpZiBgYXV0b0Rvd25sb2FkYCBvcHRpb24gaXMgc2V0IHRvIGBmYWxzZWAuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gUGF0aCB0byBkb3dubG9hZGVkIGZpbGUuXG4gICAgICovXG4gICAgZG93bmxvYWRVcGRhdGUoY2FuY2VsbGF0aW9uVG9rZW4gPSBuZXcgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5DYW5jZWxsYXRpb25Ub2tlbigpKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZUluZm9BbmRQcm92aWRlciA9IHRoaXMudXBkYXRlSW5mb0FuZFByb3ZpZGVyO1xuICAgICAgICBpZiAodXBkYXRlSW5mb0FuZFByb3ZpZGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFwiUGxlYXNlIGNoZWNrIHVwZGF0ZSBmaXJzdFwiKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFcnJvcihlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKGBEb3dubG9hZGluZyB1cGRhdGUgZnJvbSAke2J1aWxkZXJfdXRpbF9ydW50aW1lXzEuYXNBcnJheSh1cGRhdGVJbmZvQW5kUHJvdmlkZXIuaW5mby5maWxlcylcbiAgICAgICAgICAgIC5tYXAoaXQgPT4gaXQudXJsKVxuICAgICAgICAgICAgLmpvaW4oXCIsIFwiKX1gKTtcbiAgICAgICAgY29uc3QgZXJyb3JIYW5kbGVyID0gKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGVjdHJvbi11c2VybGFuZC9lbGVjdHJvbi1idWlsZGVyL2lzc3Vlcy8xMTUwI2lzc3VlY29tbWVudC00MzY4OTExNTlcbiAgICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBidWlsZGVyX3V0aWxfcnVudGltZV8xLkNhbmNlbGxhdGlvbkVycm9yKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFcnJvcihlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKG5lc3RlZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKGBDYW5ub3QgZGlzcGF0Y2ggZXJyb3IgZXZlbnQ6ICR7bmVzdGVkRXJyb3Iuc3RhY2sgfHwgbmVzdGVkRXJyb3J9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb0Rvd25sb2FkVXBkYXRlKHtcbiAgICAgICAgICAgICAgICB1cGRhdGVJbmZvQW5kUHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgcmVxdWVzdEhlYWRlcnM6IHRoaXMuY29tcHV0ZVJlcXVlc3RIZWFkZXJzKHVwZGF0ZUluZm9BbmRQcm92aWRlci5wcm92aWRlciksXG4gICAgICAgICAgICAgICAgY2FuY2VsbGF0aW9uVG9rZW4sXG4gICAgICAgICAgICB9KS5jYXRjaChlID0+IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvckhhbmRsZXIoZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9ySGFuZGxlcihlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzcGF0Y2hFcnJvcihlKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGUsIChlLnN0YWNrIHx8IGUpLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBkaXNwYXRjaFVwZGF0ZURvd25sb2FkZWQoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5lbWl0KG1haW5fMS5VUERBVEVfRE9XTkxPQURFRCwgZXZlbnQpO1xuICAgIH1cbiAgICBhc3luYyBsb2FkVXBkYXRlQ29uZmlnKCkge1xuICAgICAgICBpZiAodGhpcy5fYXBwVXBkYXRlQ29uZmlnUGF0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9hcHBVcGRhdGVDb25maWdQYXRoID0gdGhpcy5hcHAuYXBwVXBkYXRlQ29uZmlnUGF0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNfeWFtbF8xLmxvYWQoYXdhaXQgcHJvbWlzZXNfMS5yZWFkRmlsZSh0aGlzLl9hcHBVcGRhdGVDb25maWdQYXRoLCBcInV0Zi04XCIpKTtcbiAgICB9XG4gICAgY29tcHV0ZVJlcXVlc3RIZWFkZXJzKHByb3ZpZGVyKSB7XG4gICAgICAgIGNvbnN0IGZpbGVFeHRyYURvd25sb2FkSGVhZGVycyA9IHByb3ZpZGVyLmZpbGVFeHRyYURvd25sb2FkSGVhZGVycztcbiAgICAgICAgaWYgKGZpbGVFeHRyYURvd25sb2FkSGVhZGVycyAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0SGVhZGVycyA9IHRoaXMucmVxdWVzdEhlYWRlcnM7XG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdEhlYWRlcnMgPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gZmlsZUV4dHJhRG93bmxvYWRIZWFkZXJzXG4gICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmZpbGVFeHRyYURvd25sb2FkSGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgLi4ucmVxdWVzdEhlYWRlcnMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlRmluYWxIZWFkZXJzKHsgYWNjZXB0OiBcIiovKlwiIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXRPckNyZWF0ZVN0YWdpbmdVc2VySWQoKSB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSBwYXRoLmpvaW4odGhpcy5hcHAudXNlckRhdGFQYXRoLCBcIi51cGRhdGVySWRcIik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IGF3YWl0IHByb21pc2VzXzEucmVhZEZpbGUoZmlsZSwgXCJ1dGYtOFwiKTtcbiAgICAgICAgICAgIGlmIChidWlsZGVyX3V0aWxfcnVudGltZV8xLlVVSUQuY2hlY2soaWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oYFN0YWdpbmcgdXNlciBpZCBmaWxlIGV4aXN0cywgYnV0IGNvbnRlbnQgd2FzIGludmFsaWQ6ICR7aWR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlLmNvZGUgIT09IFwiRU5PRU5UXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIud2FybihgQ291bGRuJ3QgcmVhZCBzdGFnaW5nIHVzZXIgSUQsIGNyZWF0aW5nIGEgYmxhbmsgb25lOiAke2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWQgPSBidWlsZGVyX3V0aWxfcnVudGltZV8xLlVVSUQudjUoY3J5cHRvXzEucmFuZG9tQnl0ZXMoNDA5NiksIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuVVVJRC5PSUQpO1xuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhgR2VuZXJhdGVkIG5ldyBzdGFnaW5nIHVzZXIgSUQ6ICR7aWR9YCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBmc19leHRyYV8xLm91dHB1dEZpbGUoZmlsZSwgaWQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIud2FybihgQ291bGRuJ3Qgd3JpdGUgb3V0IHN0YWdpbmcgdXNlciBJRDogJHtlfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGdldCBpc0FkZE5vQ2FjaGVRdWVyeSgpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMucmVxdWVzdEhlYWRlcnM7XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGVjdHJvbi11c2VybGFuZC9lbGVjdHJvbi1idWlsZGVyL2lzc3Vlcy8zMDIxXG4gICAgICAgIGlmIChoZWFkZXJzID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgaGVhZGVyTmFtZSBvZiBPYmplY3Qua2V5cyhoZWFkZXJzKSkge1xuICAgICAgICAgICAgY29uc3QgcyA9IGhlYWRlck5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChzID09PSBcImF1dGhvcml6YXRpb25cIiB8fCBzID09PSBcInByaXZhdGUtdG9rZW5cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0T3JDcmVhdGVEb3dubG9hZEhlbHBlcigpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuZG93bmxvYWRlZFVwZGF0ZUhlbHBlcjtcbiAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBkaXJOYW1lID0gKGF3YWl0IHRoaXMuY29uZmlnT25EaXNrLnZhbHVlKS51cGRhdGVyQ2FjaGVEaXJOYW1lO1xuICAgICAgICAgICAgY29uc3QgbG9nZ2VyID0gdGhpcy5fbG9nZ2VyO1xuICAgICAgICAgICAgaWYgKGRpck5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcInVwZGF0ZXJDYWNoZURpck5hbWUgaXMgbm90IHNwZWNpZmllZCBpbiBhcHAtdXBkYXRlLnltbCBXYXMgYXBwIGJ1aWxkIHVzaW5nIGF0IGxlYXN0IGVsZWN0cm9uLWJ1aWxkZXIgMjAuMzQuMD9cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjYWNoZURpciA9IHBhdGguam9pbih0aGlzLmFwcC5iYXNlQ2FjaGVQYXRoLCBkaXJOYW1lIHx8IHRoaXMuYXBwLm5hbWUpO1xuICAgICAgICAgICAgaWYgKGxvZ2dlci5kZWJ1ZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGB1cGRhdGVyIGNhY2hlIGRpcjogJHtjYWNoZURpcn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBEb3dubG9hZGVkVXBkYXRlSGVscGVyXzEuRG93bmxvYWRlZFVwZGF0ZUhlbHBlcihjYWNoZURpcik7XG4gICAgICAgICAgICB0aGlzLmRvd25sb2FkZWRVcGRhdGVIZWxwZXIgPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgZXhlY3V0ZURvd25sb2FkKHRhc2tPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGZpbGVJbmZvID0gdGFza09wdGlvbnMuZmlsZUluZm87XG4gICAgICAgIGNvbnN0IGRvd25sb2FkT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHRhc2tPcHRpb25zLmRvd25sb2FkVXBkYXRlT3B0aW9ucy5yZXF1ZXN0SGVhZGVycyxcbiAgICAgICAgICAgIGNhbmNlbGxhdGlvblRva2VuOiB0YXNrT3B0aW9ucy5kb3dubG9hZFVwZGF0ZU9wdGlvbnMuY2FuY2VsbGF0aW9uVG9rZW4sXG4gICAgICAgICAgICBzaGEyOiBmaWxlSW5mby5pbmZvLnNoYTIsXG4gICAgICAgICAgICBzaGE1MTI6IGZpbGVJbmZvLmluZm8uc2hhNTEyLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5saXN0ZW5lckNvdW50KG1haW5fMS5ET1dOTE9BRF9QUk9HUkVTUykgPiAwKSB7XG4gICAgICAgICAgICBkb3dubG9hZE9wdGlvbnMub25Qcm9ncmVzcyA9IGl0ID0+IHRoaXMuZW1pdChtYWluXzEuRE9XTkxPQURfUFJPR1JFU1MsIGl0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGRhdGVJbmZvID0gdGFza09wdGlvbnMuZG93bmxvYWRVcGRhdGVPcHRpb25zLnVwZGF0ZUluZm9BbmRQcm92aWRlci5pbmZvO1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gdXBkYXRlSW5mby52ZXJzaW9uO1xuICAgICAgICBjb25zdCBwYWNrYWdlSW5mbyA9IGZpbGVJbmZvLnBhY2thZ2VJbmZvO1xuICAgICAgICBmdW5jdGlvbiBnZXRDYWNoZVVwZGF0ZUZpbGVOYW1lKCkge1xuICAgICAgICAgICAgLy8gTm9kZUpTIFVSTCBkb2Vzbid0IGRlY29kZSBhdXRvbWF0aWNhbGx5XG4gICAgICAgICAgICBjb25zdCB1cmxQYXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KHRhc2tPcHRpb25zLmZpbGVJbmZvLnVybC5wYXRobmFtZSk7XG4gICAgICAgICAgICBpZiAodXJsUGF0aC5lbmRzV2l0aChgLiR7dGFza09wdGlvbnMuZmlsZUV4dGVuc2lvbn1gKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoLnBvc2l4LmJhc2VuYW1lKHVybFBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdXJsIGxpa2UgL2xhdGVzdCwgZ2VuZXJhdGUgbmFtZVxuICAgICAgICAgICAgICAgIHJldHVybiBgdXBkYXRlLiR7dGFza09wdGlvbnMuZmlsZUV4dGVuc2lvbn1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvd25sb2FkZWRVcGRhdGVIZWxwZXIgPSBhd2FpdCB0aGlzLmdldE9yQ3JlYXRlRG93bmxvYWRIZWxwZXIoKTtcbiAgICAgICAgY29uc3QgY2FjaGVEaXIgPSBkb3dubG9hZGVkVXBkYXRlSGVscGVyLmNhY2hlRGlyRm9yUGVuZGluZ1VwZGF0ZTtcbiAgICAgICAgYXdhaXQgcHJvbWlzZXNfMS5ta2RpcihjYWNoZURpciwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZUZpbGVOYW1lID0gZ2V0Q2FjaGVVcGRhdGVGaWxlTmFtZSgpO1xuICAgICAgICBsZXQgdXBkYXRlRmlsZSA9IHBhdGguam9pbihjYWNoZURpciwgdXBkYXRlRmlsZU5hbWUpO1xuICAgICAgICBjb25zdCBwYWNrYWdlRmlsZSA9IHBhY2thZ2VJbmZvID09IG51bGwgPyBudWxsIDogcGF0aC5qb2luKGNhY2hlRGlyLCBgcGFja2FnZS0ke3ZlcnNpb259JHtwYXRoLmV4dG5hbWUocGFja2FnZUluZm8ucGF0aCkgfHwgXCIuN3pcIn1gKTtcbiAgICAgICAgY29uc3QgZG9uZSA9IGFzeW5jIChpc1NhdmVDYWNoZSkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgZG93bmxvYWRlZFVwZGF0ZUhlbHBlci5zZXREb3dubG9hZGVkRmlsZSh1cGRhdGVGaWxlLCBwYWNrYWdlRmlsZSwgdXBkYXRlSW5mbywgZmlsZUluZm8sIHVwZGF0ZUZpbGVOYW1lLCBpc1NhdmVDYWNoZSk7XG4gICAgICAgICAgICBhd2FpdCB0YXNrT3B0aW9ucy5kb25lKHtcbiAgICAgICAgICAgICAgICAuLi51cGRhdGVJbmZvLFxuICAgICAgICAgICAgICAgIGRvd25sb2FkZWRGaWxlOiB1cGRhdGVGaWxlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGFja2FnZUZpbGUgPT0gbnVsbCA/IFt1cGRhdGVGaWxlXSA6IFt1cGRhdGVGaWxlLCBwYWNrYWdlRmlsZV07XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGxvZyA9IHRoaXMuX2xvZ2dlcjtcbiAgICAgICAgY29uc3QgY2FjaGVkVXBkYXRlRmlsZSA9IGF3YWl0IGRvd25sb2FkZWRVcGRhdGVIZWxwZXIudmFsaWRhdGVEb3dubG9hZGVkUGF0aCh1cGRhdGVGaWxlLCB1cGRhdGVJbmZvLCBmaWxlSW5mbywgbG9nKTtcbiAgICAgICAgaWYgKGNhY2hlZFVwZGF0ZUZpbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXBkYXRlRmlsZSA9IGNhY2hlZFVwZGF0ZUZpbGU7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgZG9uZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVtb3ZlRmlsZUlmQW55ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgZG93bmxvYWRlZFVwZGF0ZUhlbHBlci5jbGVhcigpLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByb21pc2VzXzEudW5saW5rKHVwZGF0ZUZpbGUpLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB0ZW1wVXBkYXRlRmlsZSA9IGF3YWl0IERvd25sb2FkZWRVcGRhdGVIZWxwZXJfMS5jcmVhdGVUZW1wVXBkYXRlRmlsZShgdGVtcC0ke3VwZGF0ZUZpbGVOYW1lfWAsIGNhY2hlRGlyLCBsb2cpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGFza09wdGlvbnMudGFzayh0ZW1wVXBkYXRlRmlsZSwgZG93bmxvYWRPcHRpb25zLCBwYWNrYWdlRmlsZSwgcmVtb3ZlRmlsZUlmQW55KTtcbiAgICAgICAgICAgIGF3YWl0IHByb21pc2VzXzEucmVuYW1lKHRlbXBVcGRhdGVGaWxlLCB1cGRhdGVGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgYXdhaXQgcmVtb3ZlRmlsZUlmQW55KCk7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuQ2FuY2VsbGF0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsb2cuaW5mbyhcImNhbmNlbGxlZFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGUtY2FuY2VsbGVkXCIsIHVwZGF0ZUluZm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBsb2cuaW5mbyhgTmV3IHZlcnNpb24gJHt2ZXJzaW9ufSBoYXMgYmVlbiBkb3dubG9hZGVkIHRvICR7dXBkYXRlRmlsZX1gKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGRvbmUodHJ1ZSk7XG4gICAgfVxufVxuZXhwb3J0cy5BcHBVcGRhdGVyID0gQXBwVXBkYXRlcjtcbmZ1bmN0aW9uIGhhc1ByZXJlbGVhc2VDb21wb25lbnRzKHZlcnNpb24pIHtcbiAgICBjb25zdCB2ZXJzaW9uUHJlcmVsZWFzZUNvbXBvbmVudCA9IHNlbXZlcl8xLnByZXJlbGVhc2UodmVyc2lvbik7XG4gICAgcmV0dXJuIHZlcnNpb25QcmVyZWxlYXNlQ29tcG9uZW50ICE9IG51bGwgJiYgdmVyc2lvblByZXJlbGVhc2VDb21wb25lbnQubGVuZ3RoID4gMDtcbn1cbi8qKiBAcHJpdmF0ZSAqL1xuY2xhc3MgTm9PcExvZ2dlciB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGluZm8obWVzc2FnZSkge1xuICAgICAgICAvLyBpZ25vcmVcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIHdhcm4obWVzc2FnZSkge1xuICAgICAgICAvLyBpZ25vcmVcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgLy8gaWdub3JlXG4gICAgfVxufVxuZXhwb3J0cy5Ob09wTG9nZ2VyID0gTm9PcExvZ2dlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFwcFVwZGF0ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJhc2VVcGRhdGVyID0gdm9pZCAwO1xuY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCBBcHBVcGRhdGVyXzEgPSByZXF1aXJlKFwiLi9BcHBVcGRhdGVyXCIpO1xuY2xhc3MgQmFzZVVwZGF0ZXIgZXh0ZW5kcyBBcHBVcGRhdGVyXzEuQXBwVXBkYXRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgYXBwKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMsIGFwcCk7XG4gICAgICAgIHRoaXMucXVpdEFuZEluc3RhbGxDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5xdWl0SGFuZGxlckFkZGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHF1aXRBbmRJbnN0YWxsKGlzU2lsZW50ID0gZmFsc2UsIGlzRm9yY2VSdW5BZnRlciA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKGBJbnN0YWxsIG9uIGV4cGxpY2l0IHF1aXRBbmRJbnN0YWxsYCk7XG4gICAgICAgIGNvbnN0IGlzSW5zdGFsbGVkID0gdGhpcy5pbnN0YWxsKGlzU2lsZW50LCBpc1NpbGVudCA/IGlzRm9yY2VSdW5BZnRlciA6IHRydWUpO1xuICAgICAgICBpZiAoaXNJbnN0YWxsZWQpIHtcbiAgICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHAucXVpdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnF1aXRBbmRJbnN0YWxsQ2FsbGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXhlY3V0ZURvd25sb2FkKHRhc2tPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5leGVjdXRlRG93bmxvYWQoe1xuICAgICAgICAgICAgLi4udGFza09wdGlvbnMsXG4gICAgICAgICAgICBkb25lOiBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFVwZGF0ZURvd25sb2FkZWQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkUXVpdEhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gbXVzdCBiZSBzeW5jIChiZWNhdXNlIHF1aXQgZXZlbiBoYW5kbGVyIGlzIG5vdCBhc3luYylcbiAgICBpbnN0YWxsKGlzU2lsZW50LCBpc0ZvcmNlUnVuQWZ0ZXIpIHtcbiAgICAgICAgaWYgKHRoaXMucXVpdEFuZEluc3RhbGxDYWxsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKFwiaW5zdGFsbCBjYWxsIGlnbm9yZWQ6IHF1aXRBbmRJbnN0YWxsQ2FsbGVkIGlzIHNldCB0byB0cnVlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvd25sb2FkZWRVcGRhdGVIZWxwZXIgPSB0aGlzLmRvd25sb2FkZWRVcGRhdGVIZWxwZXI7XG4gICAgICAgIGNvbnN0IGluc3RhbGxlclBhdGggPSBkb3dubG9hZGVkVXBkYXRlSGVscGVyID09IG51bGwgPyBudWxsIDogZG93bmxvYWRlZFVwZGF0ZUhlbHBlci5maWxlO1xuICAgICAgICBjb25zdCBkb3dubG9hZGVkRmlsZUluZm8gPSBkb3dubG9hZGVkVXBkYXRlSGVscGVyID09IG51bGwgPyBudWxsIDogZG93bmxvYWRlZFVwZGF0ZUhlbHBlci5kb3dubG9hZGVkRmlsZUluZm87XG4gICAgICAgIGlmIChpbnN0YWxsZXJQYXRoID09IG51bGwgfHwgZG93bmxvYWRlZEZpbGVJbmZvID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFcnJvcihuZXcgRXJyb3IoXCJObyB2YWxpZCB1cGRhdGUgYXZhaWxhYmxlLCBjYW4ndCBxdWl0IGFuZCBpbnN0YWxsXCIpKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwcmV2ZW50IGNhbGxpbmcgc2V2ZXJhbCB0aW1lc1xuICAgICAgICB0aGlzLnF1aXRBbmRJbnN0YWxsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBpbnN0YWxsUGF0aFJlcXVpcmVzRWxldmF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWNjZXNzVGVzdFBhdGggPSBwYXRoLmpvaW4ocGF0aC5kaXJuYW1lKHByb2Nlc3MuZXhlY1BhdGgpLCBgYWNjZXNzLSR7TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwKX0udG1wYCk7XG4gICAgICAgICAgICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmMoYWNjZXNzVGVzdFBhdGgsIFwiIFwiKTtcbiAgICAgICAgICAgICAgICAgICAgZnMucm1TeW5jKGFjY2Vzc1Rlc3RQYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXF1aXJlIGFkbWluIHJpZ2h0cyBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFsbFBhdGhSZXF1aXJlc0VsZXZhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oYEluc3RhbGw6IGlzU2lsZW50OiAke2lzU2lsZW50fSwgaXNGb3JjZVJ1bkFmdGVyOiAke2lzRm9yY2VSdW5BZnRlcn0sIGluc3RhbGxQYXRoUmVxdWlyZXNFbGV2YXRpb246ICR7aW5zdGFsbFBhdGhSZXF1aXJlc0VsZXZhdGlvbn1gKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvSW5zdGFsbCh7XG4gICAgICAgICAgICAgICAgaW5zdGFsbGVyUGF0aCxcbiAgICAgICAgICAgICAgICBpc1NpbGVudCxcbiAgICAgICAgICAgICAgICBpc0ZvcmNlUnVuQWZ0ZXIsXG4gICAgICAgICAgICAgICAgaXNBZG1pblJpZ2h0c1JlcXVpcmVkOiBpbnN0YWxsUGF0aFJlcXVpcmVzRWxldmF0aW9uIHx8IGRvd25sb2FkZWRGaWxlSW5mby5pc0FkbWluUmlnaHRzUmVxdWlyZWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEVycm9yKGUpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFF1aXRIYW5kbGVyKCkge1xuICAgICAgICBpZiAodGhpcy5xdWl0SGFuZGxlckFkZGVkIHx8ICF0aGlzLmF1dG9JbnN0YWxsT25BcHBRdWl0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5xdWl0SGFuZGxlckFkZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hcHAub25RdWl0KGV4aXRDb2RlID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnF1aXRBbmRJbnN0YWxsQ2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCJVcGRhdGUgaW5zdGFsbGVyIGhhcyBhbHJlYWR5IGJlZW4gdHJpZ2dlcmVkLiBRdWl0dGluZyBhcHBsaWNhdGlvbi5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmF1dG9JbnN0YWxsT25BcHBRdWl0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCJVcGRhdGUgd2lsbCBub3QgYmUgaW5zdGFsbGVkIG9uIHF1aXQgYmVjYXVzZSBhdXRvSW5zdGFsbE9uQXBwUXVpdCBpcyBzZXQgdG8gZmFsc2UuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleGl0Q29kZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKGBVcGRhdGUgd2lsbCBiZSBub3QgaW5zdGFsbGVkIG9uIHF1aXQgYmVjYXVzZSBhcHBsaWNhdGlvbiBpcyBxdWl0dGluZyB3aXRoIGV4aXQgY29kZSAke2V4aXRDb2RlfWApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiQXV0byBpbnN0YWxsIHVwZGF0ZSBvbiBxdWl0XCIpO1xuICAgICAgICAgICAgdGhpcy5pbnN0YWxsKHRydWUsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlVXBkYXRlciA9IEJhc2VVcGRhdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFzZVVwZGF0ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbXB1dGVPcGVyYXRpb25zID0gZXhwb3J0cy5PcGVyYXRpb25LaW5kID0gdm9pZCAwO1xudmFyIE9wZXJhdGlvbktpbmQ7XG4oZnVuY3Rpb24gKE9wZXJhdGlvbktpbmQpIHtcbiAgICBPcGVyYXRpb25LaW5kW09wZXJhdGlvbktpbmRbXCJDT1BZXCJdID0gMF0gPSBcIkNPUFlcIjtcbiAgICBPcGVyYXRpb25LaW5kW09wZXJhdGlvbktpbmRbXCJET1dOTE9BRFwiXSA9IDFdID0gXCJET1dOTE9BRFwiO1xufSkoT3BlcmF0aW9uS2luZCA9IGV4cG9ydHMuT3BlcmF0aW9uS2luZCB8fCAoZXhwb3J0cy5PcGVyYXRpb25LaW5kID0ge30pKTtcbmZ1bmN0aW9uIGNvbXB1dGVPcGVyYXRpb25zKG9sZEJsb2NrTWFwLCBuZXdCbG9ja01hcCwgbG9nZ2VyKSB7XG4gICAgY29uc3QgbmFtZVRvT2xkQmxvY2tzID0gYnVpbGRCbG9ja0ZpbGVNYXAob2xkQmxvY2tNYXAuZmlsZXMpO1xuICAgIGNvbnN0IG5hbWVUb05ld0Jsb2NrcyA9IGJ1aWxkQmxvY2tGaWxlTWFwKG5ld0Jsb2NrTWFwLmZpbGVzKTtcbiAgICBsZXQgbGFzdE9wZXJhdGlvbiA9IG51bGw7XG4gICAgLy8gZm9yIG5vdyBvbmx5IG9uZSBmaWxlIGlzIHN1cHBvcnRlZCBpbiBibG9jayBtYXBcbiAgICBjb25zdCBibG9ja01hcEZpbGUgPSBuZXdCbG9ja01hcC5maWxlc1swXTtcbiAgICBjb25zdCBvcGVyYXRpb25zID0gW107XG4gICAgY29uc3QgbmFtZSA9IGJsb2NrTWFwRmlsZS5uYW1lO1xuICAgIGNvbnN0IG9sZEVudHJ5ID0gbmFtZVRvT2xkQmxvY2tzLmdldChuYW1lKTtcbiAgICBpZiAob2xkRW50cnkgPT0gbnVsbCkge1xuICAgICAgICAvLyBuZXcgZmlsZSAodW5yZWFsaXN0aWMgY2FzZSBmb3Igbm93LCBiZWNhdXNlIGluIGFueSBjYXNlIGJvdGggYmxvY2ttYXAgY29udGFpbiB0aGUgb25seSBmaWxlIG5hbWVkIGFzIFwiZmlsZVwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vIGZpbGUgJHtuYW1lfSBpbiBvbGQgYmxvY2ttYXBgKTtcbiAgICB9XG4gICAgY29uc3QgbmV3RmlsZSA9IG5hbWVUb05ld0Jsb2Nrcy5nZXQobmFtZSk7XG4gICAgbGV0IGNoYW5nZWRCbG9ja0NvdW50ID0gMDtcbiAgICBjb25zdCB7IGNoZWNrc3VtVG9PZmZzZXQ6IGNoZWNrc3VtVG9PbGRPZmZzZXQsIGNoZWNrc3VtVG9PbGRTaXplIH0gPSBidWlsZENoZWNrc3VtTWFwKG5hbWVUb09sZEJsb2Nrcy5nZXQobmFtZSksIG9sZEVudHJ5Lm9mZnNldCwgbG9nZ2VyKTtcbiAgICBsZXQgbmV3T2Zmc2V0ID0gYmxvY2tNYXBGaWxlLm9mZnNldDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld0ZpbGUuY2hlY2tzdW1zLmxlbmd0aDsgbmV3T2Zmc2V0ICs9IG5ld0ZpbGUuc2l6ZXNbaV0sIGkrKykge1xuICAgICAgICBjb25zdCBibG9ja1NpemUgPSBuZXdGaWxlLnNpemVzW2ldO1xuICAgICAgICBjb25zdCBjaGVja3N1bSA9IG5ld0ZpbGUuY2hlY2tzdW1zW2ldO1xuICAgICAgICBsZXQgb2xkT2Zmc2V0ID0gY2hlY2tzdW1Ub09sZE9mZnNldC5nZXQoY2hlY2tzdW0pO1xuICAgICAgICBpZiAob2xkT2Zmc2V0ICE9IG51bGwgJiYgY2hlY2tzdW1Ub09sZFNpemUuZ2V0KGNoZWNrc3VtKSAhPT0gYmxvY2tTaXplKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihgQ2hlY2tzdW0gKFwiJHtjaGVja3N1bX1cIikgbWF0Y2hlcywgYnV0IHNpemUgZGlmZmVycyAob2xkOiAke2NoZWNrc3VtVG9PbGRTaXplLmdldChjaGVja3N1bSl9LCBuZXc6ICR7YmxvY2tTaXplfSlgKTtcbiAgICAgICAgICAgIG9sZE9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2xkT2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGRvd25sb2FkIGRhdGEgZnJvbSBuZXcgZmlsZVxuICAgICAgICAgICAgY2hhbmdlZEJsb2NrQ291bnQrKztcbiAgICAgICAgICAgIGlmIChsYXN0T3BlcmF0aW9uICE9IG51bGwgJiYgbGFzdE9wZXJhdGlvbi5raW5kID09PSBPcGVyYXRpb25LaW5kLkRPV05MT0FEICYmIGxhc3RPcGVyYXRpb24uZW5kID09PSBuZXdPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBsYXN0T3BlcmF0aW9uLmVuZCArPSBibG9ja1NpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsYXN0T3BlcmF0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBPcGVyYXRpb25LaW5kLkRPV05MT0FELFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogbmV3T2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IG5ld09mZnNldCArIGJsb2NrU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gb2xkQmxvY2tzOiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFsaWRhdGVBbmRBZGQobGFzdE9wZXJhdGlvbiwgb3BlcmF0aW9ucywgY2hlY2tzdW0sIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcmV1c2UgZGF0YSBmcm9tIG9sZCBmaWxlXG4gICAgICAgICAgICBpZiAobGFzdE9wZXJhdGlvbiAhPSBudWxsICYmIGxhc3RPcGVyYXRpb24ua2luZCA9PT0gT3BlcmF0aW9uS2luZC5DT1BZICYmIGxhc3RPcGVyYXRpb24uZW5kID09PSBvbGRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBsYXN0T3BlcmF0aW9uLmVuZCArPSBibG9ja1NpemU7XG4gICAgICAgICAgICAgICAgLy8gbGFzdE9wZXJhdGlvbi5vbGRCbG9ja3MhIS5wdXNoKGNoZWNrc3VtKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFzdE9wZXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogT3BlcmF0aW9uS2luZC5DT1BZLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogb2xkT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IG9sZE9mZnNldCArIGJsb2NrU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gb2xkQmxvY2tzOiBbY2hlY2tzdW1dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZUFuZEFkZChsYXN0T3BlcmF0aW9uLCBvcGVyYXRpb25zLCBjaGVja3N1bSwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNoYW5nZWRCbG9ja0NvdW50ID4gMCkge1xuICAgICAgICBsb2dnZXIuaW5mbyhgRmlsZSR7YmxvY2tNYXBGaWxlLm5hbWUgPT09IFwiZmlsZVwiID8gXCJcIiA6IFwiIFwiICsgYmxvY2tNYXBGaWxlLm5hbWV9IGhhcyAke2NoYW5nZWRCbG9ja0NvdW50fSBjaGFuZ2VkIGJsb2Nrc2ApO1xuICAgIH1cbiAgICByZXR1cm4gb3BlcmF0aW9ucztcbn1cbmV4cG9ydHMuY29tcHV0ZU9wZXJhdGlvbnMgPSBjb21wdXRlT3BlcmF0aW9ucztcbmNvbnN0IGlzVmFsaWRhdGVPcGVyYXRpb25SYW5nZSA9IHByb2Nlc3MuZW52W1wiRElGRkVSRU5USUFMX0RPV05MT0FEX1BMQU5fQlVJTERFUl9WQUxJREFURV9SQU5HRVNcIl0gPT09IFwidHJ1ZVwiO1xuZnVuY3Rpb24gdmFsaWRhdGVBbmRBZGQob3BlcmF0aW9uLCBvcGVyYXRpb25zLCBjaGVja3N1bSwgaW5kZXgpIHtcbiAgICBpZiAoaXNWYWxpZGF0ZU9wZXJhdGlvblJhbmdlICYmIG9wZXJhdGlvbnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGNvbnN0IGxhc3RPcGVyYXRpb24gPSBvcGVyYXRpb25zW29wZXJhdGlvbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChsYXN0T3BlcmF0aW9uLmtpbmQgPT09IG9wZXJhdGlvbi5raW5kICYmIG9wZXJhdGlvbi5zdGFydCA8IGxhc3RPcGVyYXRpb24uZW5kICYmIG9wZXJhdGlvbi5zdGFydCA+IGxhc3RPcGVyYXRpb24uc3RhcnQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1pbiA9IFtsYXN0T3BlcmF0aW9uLnN0YXJ0LCBsYXN0T3BlcmF0aW9uLmVuZCwgb3BlcmF0aW9uLnN0YXJ0LCBvcGVyYXRpb24uZW5kXS5yZWR1Y2UoKHAsIHYpID0+IChwIDwgdiA/IHAgOiB2KSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG9wZXJhdGlvbiAoYmxvY2sgaW5kZXg6ICR7aW5kZXh9LCBjaGVja3N1bTogJHtjaGVja3N1bX0sIGtpbmQ6ICR7T3BlcmF0aW9uS2luZFtvcGVyYXRpb24ua2luZF19KSBvdmVybGFwcyBwcmV2aW91cyBvcGVyYXRpb24gKGNoZWNrc3VtOiAke2NoZWNrc3VtfSk6XFxuYCArXG4gICAgICAgICAgICAgICAgYGFiczogJHtsYXN0T3BlcmF0aW9uLnN0YXJ0fSB1bnRpbCAke2xhc3RPcGVyYXRpb24uZW5kfSBhbmQgJHtvcGVyYXRpb24uc3RhcnR9IHVudGlsICR7b3BlcmF0aW9uLmVuZH1cXG5gICtcbiAgICAgICAgICAgICAgICBgcmVsOiAke2xhc3RPcGVyYXRpb24uc3RhcnQgLSBtaW59IHVudGlsICR7bGFzdE9wZXJhdGlvbi5lbmQgLSBtaW59IGFuZCAke29wZXJhdGlvbi5zdGFydCAtIG1pbn0gdW50aWwgJHtvcGVyYXRpb24uZW5kIC0gbWlufWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9wZXJhdGlvbnMucHVzaChvcGVyYXRpb24pO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1mdW5jdGlvbi1yZXR1cm4tdHlwZVxuZnVuY3Rpb24gYnVpbGRDaGVja3N1bU1hcChmaWxlLCBmaWxlT2Zmc2V0LCBsb2dnZXIpIHtcbiAgICBjb25zdCBjaGVja3N1bVRvT2Zmc2V0ID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGNoZWNrc3VtVG9TaXplID0gbmV3IE1hcCgpO1xuICAgIGxldCBvZmZzZXQgPSBmaWxlT2Zmc2V0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZS5jaGVja3N1bXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hlY2tzdW0gPSBmaWxlLmNoZWNrc3Vtc1tpXTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGZpbGUuc2l6ZXNbaV07XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gY2hlY2tzdW1Ub1NpemUuZ2V0KGNoZWNrc3VtKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoZWNrc3VtVG9PZmZzZXQuc2V0KGNoZWNrc3VtLCBvZmZzZXQpO1xuICAgICAgICAgICAgY2hlY2tzdW1Ub1NpemUuc2V0KGNoZWNrc3VtLCBzaXplKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsb2dnZXIuZGVidWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3Qgc2l6ZUV4cGxhbmF0aW9uID0gZXhpc3RpbmcgPT09IHNpemUgPyBcIihzYW1lIHNpemUpXCIgOiBgKHNpemU6ICR7ZXhpc3Rpbmd9LCB0aGlzIHNpemU6ICR7c2l6ZX0pYDtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgJHtjaGVja3N1bX0gZHVwbGljYXRlZCBpbiBibG9ja21hcCAke3NpemVFeHBsYW5hdGlvbn0sIGl0IGRvZXNuJ3QgbGVhZCB0byBicm9rZW4gZGlmZmVyZW50aWFsIGRvd25sb2FkZXIsIGp1c3QgY29ycmVzcG9uZGluZyBibG9jayB3aWxsIGJlIHNraXBwZWQpYCk7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ICs9IHNpemU7XG4gICAgfVxuICAgIHJldHVybiB7IGNoZWNrc3VtVG9PZmZzZXQsIGNoZWNrc3VtVG9PbGRTaXplOiBjaGVja3N1bVRvU2l6ZSB9O1xufVxuZnVuY3Rpb24gYnVpbGRCbG9ja0ZpbGVNYXAobGlzdCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgbGlzdCkge1xuICAgICAgICByZXN1bHQuc2V0KGl0ZW0ubmFtZSwgaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kb3dubG9hZFBsYW5CdWlsZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EYXRhU3BsaXR0ZXIgPSBleHBvcnRzLmNvcHlEYXRhID0gdm9pZCAwO1xuY29uc3QgYnVpbGRlcl91dGlsX3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZVwiKTtcbmNvbnN0IGZzXzEgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCBzdHJlYW1fMSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG5jb25zdCBkb3dubG9hZFBsYW5CdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9kb3dubG9hZFBsYW5CdWlsZGVyXCIpO1xuY29uc3QgRE9VQkxFX0NSTEYgPSBCdWZmZXIuZnJvbShcIlxcclxcblxcclxcblwiKTtcbnZhciBSZWFkU3RhdGU7XG4oZnVuY3Rpb24gKFJlYWRTdGF0ZSkge1xuICAgIFJlYWRTdGF0ZVtSZWFkU3RhdGVbXCJJTklUXCJdID0gMF0gPSBcIklOSVRcIjtcbiAgICBSZWFkU3RhdGVbUmVhZFN0YXRlW1wiSEVBREVSXCJdID0gMV0gPSBcIkhFQURFUlwiO1xuICAgIFJlYWRTdGF0ZVtSZWFkU3RhdGVbXCJCT0RZXCJdID0gMl0gPSBcIkJPRFlcIjtcbn0pKFJlYWRTdGF0ZSB8fCAoUmVhZFN0YXRlID0ge30pKTtcbmZ1bmN0aW9uIGNvcHlEYXRhKHRhc2ssIG91dCwgb2xkRmlsZUZkLCByZWplY3QsIHJlc29sdmUpIHtcbiAgICBjb25zdCByZWFkU3RyZWFtID0gZnNfMS5jcmVhdGVSZWFkU3RyZWFtKFwiXCIsIHtcbiAgICAgICAgZmQ6IG9sZEZpbGVGZCxcbiAgICAgICAgYXV0b0Nsb3NlOiBmYWxzZSxcbiAgICAgICAgc3RhcnQ6IHRhc2suc3RhcnQsXG4gICAgICAgIC8vIGVuZCBpcyBpbmNsdXNpdmVcbiAgICAgICAgZW5kOiB0YXNrLmVuZCAtIDEsXG4gICAgfSk7XG4gICAgcmVhZFN0cmVhbS5vbihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgcmVhZFN0cmVhbS5vbmNlKFwiZW5kXCIsIHJlc29sdmUpO1xuICAgIHJlYWRTdHJlYW0ucGlwZShvdXQsIHtcbiAgICAgICAgZW5kOiBmYWxzZSxcbiAgICB9KTtcbn1cbmV4cG9ydHMuY29weURhdGEgPSBjb3B5RGF0YTtcbmNsYXNzIERhdGFTcGxpdHRlciBleHRlbmRzIHN0cmVhbV8xLldyaXRhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihvdXQsIG9wdGlvbnMsIHBhcnRJbmRleFRvVGFza0luZGV4LCBib3VuZGFyeSwgcGFydEluZGV4VG9MZW5ndGgsIGZpbmlzaEhhbmRsZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5vdXQgPSBvdXQ7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMucGFydEluZGV4VG9UYXNrSW5kZXggPSBwYXJ0SW5kZXhUb1Rhc2tJbmRleDtcbiAgICAgICAgdGhpcy5wYXJ0SW5kZXhUb0xlbmd0aCA9IHBhcnRJbmRleFRvTGVuZ3RoO1xuICAgICAgICB0aGlzLmZpbmlzaEhhbmRsZXIgPSBmaW5pc2hIYW5kbGVyO1xuICAgICAgICB0aGlzLnBhcnRJbmRleCA9IC0xO1xuICAgICAgICB0aGlzLmhlYWRlckxpc3RCdWZmZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnJlYWRTdGF0ZSA9IFJlYWRTdGF0ZS5JTklUO1xuICAgICAgICB0aGlzLmlnbm9yZUJ5dGVDb3VudCA9IDA7XG4gICAgICAgIHRoaXMucmVtYWluaW5nUGFydERhdGFDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuYWN0dWFsUGFydExlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuYm91bmRhcnlMZW5ndGggPSBib3VuZGFyeS5sZW5ndGggKyA0OyAvKiBzaXplIG9mIFxcclxcbi0tICovXG4gICAgICAgIC8vIGZpcnN0IGNodW5rIGRvZXNuJ3Qgc3RhcnQgd2l0aCBcXHJcXG5cbiAgICAgICAgdGhpcy5pZ25vcmVCeXRlQ291bnQgPSB0aGlzLmJvdW5kYXJ5TGVuZ3RoIC0gMjtcbiAgICB9XG4gICAgZ2V0IGlzRmluaXNoZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnRJbmRleCA9PT0gdGhpcy5wYXJ0SW5kZXhUb0xlbmd0aC5sZW5ndGg7XG4gICAgfVxuICAgIC8vIG5vaW5zcGVjdGlvbiBKU1VudXNlZEdsb2JhbFN5bWJvbHNcbiAgICBfd3JpdGUoZGF0YSwgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFRyYWlsaW5nIGlnbm9yZWQgZGF0YTogJHtkYXRhLmxlbmd0aH0gYnl0ZXNgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhbmRsZURhdGEoZGF0YSkudGhlbihjYWxsYmFjaykuY2F0Y2goY2FsbGJhY2spO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVEYXRhKGNodW5rKSB7XG4gICAgICAgIGxldCBzdGFydCA9IDA7XG4gICAgICAgIGlmICh0aGlzLmlnbm9yZUJ5dGVDb3VudCAhPT0gMCAmJiB0aGlzLnJlbWFpbmluZ1BhcnREYXRhQ291bnQgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IoXCJJbnRlcm5hbCBlcnJvclwiLCBcIkVSUl9EQVRBX1NQTElUVEVSX0JZVEVfQ09VTlRfTUlTTUFUQ0hcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaWdub3JlQnl0ZUNvdW50ID4gMCkge1xuICAgICAgICAgICAgY29uc3QgdG9JZ25vcmUgPSBNYXRoLm1pbih0aGlzLmlnbm9yZUJ5dGVDb3VudCwgY2h1bmsubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMuaWdub3JlQnl0ZUNvdW50IC09IHRvSWdub3JlO1xuICAgICAgICAgICAgc3RhcnQgPSB0b0lnbm9yZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnJlbWFpbmluZ1BhcnREYXRhQ291bnQgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCB0b1JlYWQgPSBNYXRoLm1pbih0aGlzLnJlbWFpbmluZ1BhcnREYXRhQ291bnQsIGNodW5rLmxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLnJlbWFpbmluZ1BhcnREYXRhQ291bnQgLT0gdG9SZWFkO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wcm9jZXNzUGFydERhdGEoY2h1bmssIDAsIHRvUmVhZCk7XG4gICAgICAgICAgICBzdGFydCA9IHRvUmVhZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgPT09IGNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlYWRTdGF0ZSA9PT0gUmVhZFN0YXRlLkhFQURFUikge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyTGlzdEVuZCA9IHRoaXMuc2VhcmNoSGVhZGVyTGlzdEVuZChjaHVuaywgc3RhcnQpO1xuICAgICAgICAgICAgaWYgKGhlYWRlckxpc3RFbmQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnQgPSBoZWFkZXJMaXN0RW5kO1xuICAgICAgICAgICAgdGhpcy5yZWFkU3RhdGUgPSBSZWFkU3RhdGUuQk9EWTtcbiAgICAgICAgICAgIC8vIGhlYWRlciBsaXN0IGlzIGlnbm9yZWQsIHdlIGRvbid0IG5lZWQgaXRcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyTGlzdEJ1ZmZlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRTdGF0ZSA9PT0gUmVhZFN0YXRlLkJPRFkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWRTdGF0ZSA9IFJlYWRTdGF0ZS5JTklUO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0SW5kZXgrKztcbiAgICAgICAgICAgICAgICBsZXQgdGFza0luZGV4ID0gdGhpcy5wYXJ0SW5kZXhUb1Rhc2tJbmRleC5nZXQodGhpcy5wYXJ0SW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmICh0YXNrSW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrSW5kZXggPSB0aGlzLm9wdGlvbnMuZW5kO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5uZXdFcnJvcihcInRhc2tJbmRleCBpcyBudWxsXCIsIFwiRVJSX0RBVEFfU1BMSVRURVJfVEFTS19JTkRFWF9JU19OVUxMXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZUYXNrSW5kZXggPSB0aGlzLnBhcnRJbmRleCA9PT0gMCA/IHRoaXMub3B0aW9ucy5zdGFydCA6IHRoaXMucGFydEluZGV4VG9UYXNrSW5kZXguZ2V0KHRoaXMucGFydEluZGV4IC0gMSkgKyAxOyAvKiBwcmV2IHBhcnQgaXMgZG93bmxvYWQsIG5leHQgbWF5YmUgY29weSAqL1xuICAgICAgICAgICAgICAgIGlmIChwcmV2VGFza0luZGV4IDwgdGFza0luZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY29weUV4aXN0aW5nRGF0YShwcmV2VGFza0luZGV4LCB0YXNrSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcmV2VGFza0luZGV4ID4gdGFza0luZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IoXCJwcmV2VGFza0luZGV4IG11c3QgYmUgPCB0YXNrSW5kZXhcIiwgXCJFUlJfREFUQV9TUExJVFRFUl9UQVNLX0lOREVYX0FTU0VSVF9GQUlMRURcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblBhcnRFbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5pc2hIYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLnNlYXJjaEhlYWRlckxpc3RFbmQoY2h1bmssIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZFN0YXRlID0gUmVhZFN0YXRlLkhFQURFUjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcnRMZW5ndGggPSB0aGlzLnBhcnRJbmRleFRvTGVuZ3RoW3RoaXMucGFydEluZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgcGFydExlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGVmZmVjdGl2ZUVuZCA9IE1hdGgubWluKGVuZCwgY2h1bmsubGVuZ3RoKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucHJvY2Vzc1BhcnRTdGFydGVkKGNodW5rLCBzdGFydCwgZWZmZWN0aXZlRW5kKTtcbiAgICAgICAgICAgIHRoaXMucmVtYWluaW5nUGFydERhdGFDb3VudCA9IHBhcnRMZW5ndGggLSAoZWZmZWN0aXZlRW5kIC0gc3RhcnQpO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVtYWluaW5nUGFydERhdGFDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydCA9IGVuZCArIHRoaXMuYm91bmRhcnlMZW5ndGg7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPj0gY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pZ25vcmVCeXRlQ291bnQgPSB0aGlzLmJvdW5kYXJ5TGVuZ3RoIC0gKGNodW5rLmxlbmd0aCAtIGVuZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvcHlFeGlzdGluZ0RhdGEoaW5kZXgsIGVuZCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdGFzayA9IHRoaXMub3B0aW9ucy50YXNrc1tpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKHRhc2sua2luZCAhPT0gZG93bmxvYWRQbGFuQnVpbGRlcl8xLk9wZXJhdGlvbktpbmQuQ09QWSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiVGFzayBraW5kIG11c3QgYmUgQ09QWVwiKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29weURhdGEodGFzaywgdGhpcy5vdXQsIHRoaXMub3B0aW9ucy5vbGRGaWxlRmQsIHJlamVjdCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB3KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2VhcmNoSGVhZGVyTGlzdEVuZChjaHVuaywgcmVhZE9mZnNldCkge1xuICAgICAgICBjb25zdCBoZWFkZXJMaXN0RW5kID0gY2h1bmsuaW5kZXhPZihET1VCTEVfQ1JMRiwgcmVhZE9mZnNldCk7XG4gICAgICAgIGlmIChoZWFkZXJMaXN0RW5kICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGhlYWRlckxpc3RFbmQgKyBET1VCTEVfQ1JMRi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm90IGFsbCBoZWFkZXJzIGRhdGEgd2VyZSByZWNlaXZlZCwgc2F2ZSB0byBidWZmZXJcbiAgICAgICAgY29uc3QgcGFydGlhbENodW5rID0gcmVhZE9mZnNldCA9PT0gMCA/IGNodW5rIDogY2h1bmsuc2xpY2UocmVhZE9mZnNldCk7XG4gICAgICAgIGlmICh0aGlzLmhlYWRlckxpc3RCdWZmZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJMaXN0QnVmZmVyID0gcGFydGlhbENodW5rO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJMaXN0QnVmZmVyID0gQnVmZmVyLmNvbmNhdChbdGhpcy5oZWFkZXJMaXN0QnVmZmVyLCBwYXJ0aWFsQ2h1bmtdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIG9uUGFydEVuZCgpIHtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRMZW5ndGggPSB0aGlzLnBhcnRJbmRleFRvTGVuZ3RoW3RoaXMucGFydEluZGV4IC0gMV07XG4gICAgICAgIGlmICh0aGlzLmFjdHVhbFBhcnRMZW5ndGggIT09IGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBidWlsZGVyX3V0aWxfcnVudGltZV8xLm5ld0Vycm9yKGBFeHBlY3RlZCBsZW5ndGg6ICR7ZXhwZWN0ZWRMZW5ndGh9IGRpZmZlcnMgZnJvbSBhY3R1YWw6ICR7dGhpcy5hY3R1YWxQYXJ0TGVuZ3RofWAsIFwiRVJSX0RBVEFfU1BMSVRURVJfTEVOR1RIX01JU01BVENIXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0dWFsUGFydExlbmd0aCA9IDA7XG4gICAgfVxuICAgIHByb2Nlc3NQYXJ0U3RhcnRlZChkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcnRJbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5vblBhcnRFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUGFydERhdGEoZGF0YSwgc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIHByb2Nlc3NQYXJ0RGF0YShkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHRoaXMuYWN0dWFsUGFydExlbmd0aCArPSBlbmQgLSBzdGFydDtcbiAgICAgICAgY29uc3Qgb3V0ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmIChvdXQud3JpdGUoc3RhcnQgPT09IDAgJiYgZGF0YS5sZW5ndGggPT09IGVuZCA/IGRhdGEgOiBkYXRhLnNsaWNlKHN0YXJ0LCBlbmQpKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBvdXQub24oXCJlcnJvclwiLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIG91dC5vbmNlKFwiZHJhaW5cIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvdXQucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRGF0YVNwbGl0dGVyID0gRGF0YVNwbGl0dGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGF0YVNwbGl0dGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jaGVja0lzUmFuZ2VzU3VwcG9ydGVkID0gZXhwb3J0cy5leGVjdXRlVGFza3NVc2luZ011bHRpcGxlUmFuZ2VSZXF1ZXN0cyA9IHZvaWQgMDtcbmNvbnN0IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEgPSByZXF1aXJlKFwiYnVpbGRlci11dGlsLXJ1bnRpbWVcIik7XG5jb25zdCBEYXRhU3BsaXR0ZXJfMSA9IHJlcXVpcmUoXCIuL0RhdGFTcGxpdHRlclwiKTtcbmNvbnN0IGRvd25sb2FkUGxhbkJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL2Rvd25sb2FkUGxhbkJ1aWxkZXJcIik7XG5mdW5jdGlvbiBleGVjdXRlVGFza3NVc2luZ011bHRpcGxlUmFuZ2VSZXF1ZXN0cyhkaWZmZXJlbnRpYWxEb3dubG9hZGVyLCB0YXNrcywgb3V0LCBvbGRGaWxlRmQsIHJlamVjdCkge1xuICAgIGNvbnN0IHcgPSAodGFza09mZnNldCkgPT4ge1xuICAgICAgICBpZiAodGFza09mZnNldCA+PSB0YXNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChkaWZmZXJlbnRpYWxEb3dubG9hZGVyLmZpbGVNZXRhZGF0YUJ1ZmZlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3V0LndyaXRlKGRpZmZlcmVudGlhbERvd25sb2FkZXIuZmlsZU1ldGFkYXRhQnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dC5lbmQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0T2Zmc2V0ID0gdGFza09mZnNldCArIDEwMDA7XG4gICAgICAgIGRvRXhlY3V0ZVRhc2tzKGRpZmZlcmVudGlhbERvd25sb2FkZXIsIHtcbiAgICAgICAgICAgIHRhc2tzLFxuICAgICAgICAgICAgc3RhcnQ6IHRhc2tPZmZzZXQsXG4gICAgICAgICAgICBlbmQ6IE1hdGgubWluKHRhc2tzLmxlbmd0aCwgbmV4dE9mZnNldCksXG4gICAgICAgICAgICBvbGRGaWxlRmQsXG4gICAgICAgIH0sIG91dCwgKCkgPT4gdyhuZXh0T2Zmc2V0KSwgcmVqZWN0KTtcbiAgICB9O1xuICAgIHJldHVybiB3O1xufVxuZXhwb3J0cy5leGVjdXRlVGFza3NVc2luZ011bHRpcGxlUmFuZ2VSZXF1ZXN0cyA9IGV4ZWN1dGVUYXNrc1VzaW5nTXVsdGlwbGVSYW5nZVJlcXVlc3RzO1xuZnVuY3Rpb24gZG9FeGVjdXRlVGFza3MoZGlmZmVyZW50aWFsRG93bmxvYWRlciwgb3B0aW9ucywgb3V0LCByZXNvbHZlLCByZWplY3QpIHtcbiAgICBsZXQgcmFuZ2VzID0gXCJieXRlcz1cIjtcbiAgICBsZXQgcGFydENvdW50ID0gMDtcbiAgICBjb25zdCBwYXJ0SW5kZXhUb1Rhc2tJbmRleCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBwYXJ0SW5kZXhUb0xlbmd0aCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSBvcHRpb25zLnN0YXJ0OyBpIDwgb3B0aW9ucy5lbmQ7IGkrKykge1xuICAgICAgICBjb25zdCB0YXNrID0gb3B0aW9ucy50YXNrc1tpXTtcbiAgICAgICAgaWYgKHRhc2sua2luZCA9PT0gZG93bmxvYWRQbGFuQnVpbGRlcl8xLk9wZXJhdGlvbktpbmQuRE9XTkxPQUQpIHtcbiAgICAgICAgICAgIHJhbmdlcyArPSBgJHt0YXNrLnN0YXJ0fS0ke3Rhc2suZW5kIC0gMX0sIGA7XG4gICAgICAgICAgICBwYXJ0SW5kZXhUb1Rhc2tJbmRleC5zZXQocGFydENvdW50LCBpKTtcbiAgICAgICAgICAgIHBhcnRDb3VudCsrO1xuICAgICAgICAgICAgcGFydEluZGV4VG9MZW5ndGgucHVzaCh0YXNrLmVuZCAtIHRhc2suc3RhcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJ0Q291bnQgPD0gMSkge1xuICAgICAgICAvLyB0aGUgb25seSByZW1vdGUgcmFuZ2UgLSBjb3B5XG4gICAgICAgIGNvbnN0IHcgPSAoaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSBvcHRpb25zLmVuZCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0YXNrID0gb3B0aW9ucy50YXNrc1tpbmRleCsrXTtcbiAgICAgICAgICAgIGlmICh0YXNrLmtpbmQgPT09IGRvd25sb2FkUGxhbkJ1aWxkZXJfMS5PcGVyYXRpb25LaW5kLkNPUFkpIHtcbiAgICAgICAgICAgICAgICBEYXRhU3BsaXR0ZXJfMS5jb3B5RGF0YSh0YXNrLCBvdXQsIG9wdGlvbnMub2xkRmlsZUZkLCByZWplY3QsICgpID0+IHcoaW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RPcHRpb25zID0gZGlmZmVyZW50aWFsRG93bmxvYWRlci5jcmVhdGVSZXF1ZXN0T3B0aW9ucygpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3RPcHRpb25zLmhlYWRlcnMuUmFuZ2UgPSBgYnl0ZXM9JHt0YXNrLnN0YXJ0fS0ke3Rhc2suZW5kIC0gMX1gO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBkaWZmZXJlbnRpYWxEb3dubG9hZGVyLmh0dHBFeGVjdXRvci5jcmVhdGVSZXF1ZXN0KHJlcXVlc3RPcHRpb25zLCByZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2hlY2tJc1Jhbmdlc1N1cHBvcnRlZChyZXNwb25zZSwgcmVqZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnBpcGUob3V0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uub25jZShcImVuZFwiLCAoKSA9PiB3KGluZGV4KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZGlmZmVyZW50aWFsRG93bmxvYWRlci5odHRwRXhlY3V0b3IuYWRkRXJyb3JBbmRUaW1lb3V0SGFuZGxlcnMocmVxdWVzdCwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB3KG9wdGlvbnMuc3RhcnQpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3RPcHRpb25zID0gZGlmZmVyZW50aWFsRG93bmxvYWRlci5jcmVhdGVSZXF1ZXN0T3B0aW9ucygpO1xuICAgIHJlcXVlc3RPcHRpb25zLmhlYWRlcnMuUmFuZ2UgPSByYW5nZXMuc3Vic3RyaW5nKDAsIHJhbmdlcy5sZW5ndGggLSAyKTtcbiAgICBjb25zdCByZXF1ZXN0ID0gZGlmZmVyZW50aWFsRG93bmxvYWRlci5odHRwRXhlY3V0b3IuY3JlYXRlUmVxdWVzdChyZXF1ZXN0T3B0aW9ucywgcmVzcG9uc2UgPT4ge1xuICAgICAgICBpZiAoIWNoZWNrSXNSYW5nZXNTdXBwb3J0ZWQocmVzcG9uc2UsIHJlamVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuc2FmZUdldEhlYWRlcihyZXNwb25zZSwgXCJjb250ZW50LXR5cGVcIik7XG4gICAgICAgIGNvbnN0IG0gPSAvXm11bHRpcGFydFxcLy4rPyg/OjsgYm91bmRhcnk9KD86KD86XCIoLispXCIpfCg/OihbXlxcc10rKSkpKSQvaS5leGVjKGNvbnRlbnRUeXBlKTtcbiAgICAgICAgaWYgKG0gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgQ29udGVudC1UeXBlIFwibXVsdGlwYXJ0L2J5dGVyYW5nZXNcIiBpcyBleHBlY3RlZCwgYnV0IGdvdCBcIiR7Y29udGVudFR5cGV9XCJgKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGljZXIgPSBuZXcgRGF0YVNwbGl0dGVyXzEuRGF0YVNwbGl0dGVyKG91dCwgb3B0aW9ucywgcGFydEluZGV4VG9UYXNrSW5kZXgsIG1bMV0gfHwgbVsyXSwgcGFydEluZGV4VG9MZW5ndGgsIHJlc29sdmUpO1xuICAgICAgICBkaWNlci5vbihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgIHJlc3BvbnNlLnBpcGUoZGljZXIpO1xuICAgICAgICByZXNwb25zZS5vbihcImVuZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlJlc3BvbnNlIGVuZHMgd2l0aG91dCBjYWxsaW5nIGFueSBoYW5kbGVyc1wiKSk7XG4gICAgICAgICAgICB9LCAxMDAwMCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGRpZmZlcmVudGlhbERvd25sb2FkZXIuaHR0cEV4ZWN1dG9yLmFkZEVycm9yQW5kVGltZW91dEhhbmRsZXJzKHJlcXVlc3QsIHJlamVjdCk7XG4gICAgcmVxdWVzdC5lbmQoKTtcbn1cbmZ1bmN0aW9uIGNoZWNrSXNSYW5nZXNTdXBwb3J0ZWQocmVzcG9uc2UsIHJlamVjdCkge1xuICAgIC8vIEVsZWN0cm9uIG5ldCBoYW5kbGVzIHJlZGlyZWN0cyBhdXRvbWF0aWNhbGx5LCBvdXIgTm9kZUpTIHRlc3Qgc2VydmVyIGRvZXNuJ3QgdXNlIHJlZGlyZWN0cyAtIHNvLCB3ZSBkb24ndCBjaGVjayAzeHggY29kZXMuXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPj0gNDAwKSB7XG4gICAgICAgIHJlamVjdChidWlsZGVyX3V0aWxfcnVudGltZV8xLmNyZWF0ZUh0dHBFcnJvcihyZXNwb25zZSkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlICE9PSAyMDYpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0UmFuZ2VzID0gYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5zYWZlR2V0SGVhZGVyKHJlc3BvbnNlLCBcImFjY2VwdC1yYW5nZXNcIik7XG4gICAgICAgIGlmIChhY2NlcHRSYW5nZXMgPT0gbnVsbCB8fCBhY2NlcHRSYW5nZXMgPT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBTZXJ2ZXIgZG9lc24ndCBzdXBwb3J0IEFjY2VwdC1SYW5nZXMgKHJlc3BvbnNlIGNvZGUgJHtyZXNwb25zZS5zdGF0dXNDb2RlfSlgKSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmNoZWNrSXNSYW5nZXNTdXBwb3J0ZWQgPSBjaGVja0lzUmFuZ2VzU3VwcG9ydGVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXVsdGlwbGVSYW5nZURvd25sb2FkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlByb2dyZXNzRGlmZmVyZW50aWFsRG93bmxvYWRDYWxsYmFja1RyYW5zZm9ybSA9IHZvaWQgMDtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbnZhciBPcGVyYXRpb25LaW5kO1xuKGZ1bmN0aW9uIChPcGVyYXRpb25LaW5kKSB7XG4gICAgT3BlcmF0aW9uS2luZFtPcGVyYXRpb25LaW5kW1wiQ09QWVwiXSA9IDBdID0gXCJDT1BZXCI7XG4gICAgT3BlcmF0aW9uS2luZFtPcGVyYXRpb25LaW5kW1wiRE9XTkxPQURcIl0gPSAxXSA9IFwiRE9XTkxPQURcIjtcbn0pKE9wZXJhdGlvbktpbmQgfHwgKE9wZXJhdGlvbktpbmQgPSB7fSkpO1xuY2xhc3MgUHJvZ3Jlc3NEaWZmZXJlbnRpYWxEb3dubG9hZENhbGxiYWNrVHJhbnNmb3JtIGV4dGVuZHMgc3RyZWFtXzEuVHJhbnNmb3JtIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9ncmVzc0RpZmZlcmVudGlhbERvd25sb2FkSW5mbywgY2FuY2VsbGF0aW9uVG9rZW4sIG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wcm9ncmVzc0RpZmZlcmVudGlhbERvd25sb2FkSW5mbyA9IHByb2dyZXNzRGlmZmVyZW50aWFsRG93bmxvYWRJbmZvO1xuICAgICAgICB0aGlzLmNhbmNlbGxhdGlvblRva2VuID0gY2FuY2VsbGF0aW9uVG9rZW47XG4gICAgICAgIHRoaXMub25Qcm9ncmVzcyA9IG9uUHJvZ3Jlc3M7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLnRyYW5zZmVycmVkID0gMDtcbiAgICAgICAgdGhpcy5kZWx0YSA9IDA7XG4gICAgICAgIHRoaXMuZXhwZWN0ZWRCeXRlcyA9IDA7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLm9wZXJhdGlvblR5cGUgPSBPcGVyYXRpb25LaW5kLkNPUFk7XG4gICAgICAgIHRoaXMubmV4dFVwZGF0ZSA9IHRoaXMuc3RhcnQgKyAxMDAwO1xuICAgIH1cbiAgICBfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuY2VsbGF0aW9uVG9rZW4uY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoXCJjYW5jZWxsZWRcIiksIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvbid0IHNlbmQgcHJvZ3Jlc3MgdXBkYXRlIHdoZW4gY29weWluZyBmcm9tIGRpc2tcbiAgICAgICAgaWYgKHRoaXMub3BlcmF0aW9uVHlwZSA9PSBPcGVyYXRpb25LaW5kLkNPUFkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGNodW5rKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYW5zZmVycmVkICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgdGhpcy5kZWx0YSArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGlmIChub3cgPj0gdGhpcy5uZXh0VXBkYXRlICYmXG4gICAgICAgICAgICB0aGlzLnRyYW5zZmVycmVkICE9PSB0aGlzLmV4cGVjdGVkQnl0ZXMgLyogd2lsbCBiZSBlbWl0dGVkIGJ5IGVuZFJhbmdlRG93bmxvYWQoKSAqLyAmJlxuICAgICAgICAgICAgdGhpcy50cmFuc2ZlcnJlZCAhPT0gdGhpcy5wcm9ncmVzc0RpZmZlcmVudGlhbERvd25sb2FkSW5mby5ncmFuZFRvdGFsIC8qIHdpbGwgYmUgZW1pdHRlZCBvbiBfZmx1c2ggKi8pIHtcbiAgICAgICAgICAgIHRoaXMubmV4dFVwZGF0ZSA9IG5vdyArIDEwMDA7XG4gICAgICAgICAgICB0aGlzLm9uUHJvZ3Jlc3Moe1xuICAgICAgICAgICAgICAgIHRvdGFsOiB0aGlzLnByb2dyZXNzRGlmZmVyZW50aWFsRG93bmxvYWRJbmZvLmdyYW5kVG90YWwsXG4gICAgICAgICAgICAgICAgZGVsdGE6IHRoaXMuZGVsdGEsXG4gICAgICAgICAgICAgICAgdHJhbnNmZXJyZWQ6IHRoaXMudHJhbnNmZXJyZWQsXG4gICAgICAgICAgICAgICAgcGVyY2VudDogKHRoaXMudHJhbnNmZXJyZWQgLyB0aGlzLnByb2dyZXNzRGlmZmVyZW50aWFsRG93bmxvYWRJbmZvLmdyYW5kVG90YWwpICogMTAwLFxuICAgICAgICAgICAgICAgIGJ5dGVzUGVyU2Vjb25kOiBNYXRoLnJvdW5kKHRoaXMudHJhbnNmZXJyZWQgLyAoKG5vdyAtIHRoaXMuc3RhcnQpIC8gMTAwMCkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmRlbHRhID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhudWxsLCBjaHVuayk7XG4gICAgfVxuICAgIGJlZ2luRmlsZUNvcHkoKSB7XG4gICAgICAgIHRoaXMub3BlcmF0aW9uVHlwZSA9IE9wZXJhdGlvbktpbmQuQ09QWTtcbiAgICB9XG4gICAgYmVnaW5SYW5nZURvd25sb2FkKCkge1xuICAgICAgICB0aGlzLm9wZXJhdGlvblR5cGUgPSBPcGVyYXRpb25LaW5kLkRPV05MT0FEO1xuICAgICAgICB0aGlzLmV4cGVjdGVkQnl0ZXMgKz0gdGhpcy5wcm9ncmVzc0RpZmZlcmVudGlhbERvd25sb2FkSW5mby5leHBlY3RlZEJ5dGVDb3VudHNbdGhpcy5pbmRleCsrXTtcbiAgICB9XG4gICAgZW5kUmFuZ2VEb3dubG9hZCgpIHtcbiAgICAgICAgLy8gX2ZsdXNoKCkgd2lsbCBkb291ciBmaW5hbCAxMDAlXG4gICAgICAgIGlmICh0aGlzLnRyYW5zZmVycmVkICE9PSB0aGlzLnByb2dyZXNzRGlmZmVyZW50aWFsRG93bmxvYWRJbmZvLmdyYW5kVG90YWwpIHtcbiAgICAgICAgICAgIHRoaXMub25Qcm9ncmVzcyh7XG4gICAgICAgICAgICAgICAgdG90YWw6IHRoaXMucHJvZ3Jlc3NEaWZmZXJlbnRpYWxEb3dubG9hZEluZm8uZ3JhbmRUb3RhbCxcbiAgICAgICAgICAgICAgICBkZWx0YTogdGhpcy5kZWx0YSxcbiAgICAgICAgICAgICAgICB0cmFuc2ZlcnJlZDogdGhpcy50cmFuc2ZlcnJlZCxcbiAgICAgICAgICAgICAgICBwZXJjZW50OiAodGhpcy50cmFuc2ZlcnJlZCAvIHRoaXMucHJvZ3Jlc3NEaWZmZXJlbnRpYWxEb3dubG9hZEluZm8uZ3JhbmRUb3RhbCkgKiAxMDAsXG4gICAgICAgICAgICAgICAgYnl0ZXNQZXJTZWNvbmQ6IE1hdGgucm91bmQodGhpcy50cmFuc2ZlcnJlZCAvICgoRGF0ZS5ub3coKSAtIHRoaXMuc3RhcnQpIC8gMTAwMCkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2FsbGVkIHdoZW4gd2UgYXJlIDEwMCUgZG9uZSB3aXRoIHRoZSBjb25uZWN0aW9uL2Rvd25sb2FkXG4gICAgX2ZsdXNoKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbmNlbGxhdGlvblRva2VuLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKFwiY2FuY2VsbGVkXCIpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uUHJvZ3Jlc3Moe1xuICAgICAgICAgICAgdG90YWw6IHRoaXMucHJvZ3Jlc3NEaWZmZXJlbnRpYWxEb3dubG9hZEluZm8uZ3JhbmRUb3RhbCxcbiAgICAgICAgICAgIGRlbHRhOiB0aGlzLmRlbHRhLFxuICAgICAgICAgICAgdHJhbnNmZXJyZWQ6IHRoaXMudHJhbnNmZXJyZWQsXG4gICAgICAgICAgICBwZXJjZW50OiAxMDAsXG4gICAgICAgICAgICBieXRlc1BlclNlY29uZDogTWF0aC5yb3VuZCh0aGlzLnRyYW5zZmVycmVkIC8gKChEYXRlLm5vdygpIC0gdGhpcy5zdGFydCkgLyAxMDAwKSksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRlbHRhID0gMDtcbiAgICAgICAgdGhpcy50cmFuc2ZlcnJlZCA9IDA7XG4gICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgIH1cbn1cbmV4cG9ydHMuUHJvZ3Jlc3NEaWZmZXJlbnRpYWxEb3dubG9hZENhbGxiYWNrVHJhbnNmb3JtID0gUHJvZ3Jlc3NEaWZmZXJlbnRpYWxEb3dubG9hZENhbGxiYWNrVHJhbnNmb3JtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJvZ3Jlc3NEaWZmZXJlbnRpYWxEb3dubG9hZENhbGxiYWNrVHJhbnNmb3JtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EaWZmZXJlbnRpYWxEb3dubG9hZGVyID0gdm9pZCAwO1xuY29uc3QgYnVpbGRlcl91dGlsX3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZVwiKTtcbmNvbnN0IGZzX2V4dHJhXzEgPSByZXF1aXJlKFwiZnMtZXh0cmFcIik7XG5jb25zdCBmc18xID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgRGF0YVNwbGl0dGVyXzEgPSByZXF1aXJlKFwiLi9EYXRhU3BsaXR0ZXJcIik7XG5jb25zdCB1cmxfMSA9IHJlcXVpcmUoXCJ1cmxcIik7XG5jb25zdCBkb3dubG9hZFBsYW5CdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9kb3dubG9hZFBsYW5CdWlsZGVyXCIpO1xuY29uc3QgbXVsdGlwbGVSYW5nZURvd25sb2FkZXJfMSA9IHJlcXVpcmUoXCIuL211bHRpcGxlUmFuZ2VEb3dubG9hZGVyXCIpO1xuY29uc3QgUHJvZ3Jlc3NEaWZmZXJlbnRpYWxEb3dubG9hZENhbGxiYWNrVHJhbnNmb3JtXzEgPSByZXF1aXJlKFwiLi9Qcm9ncmVzc0RpZmZlcmVudGlhbERvd25sb2FkQ2FsbGJhY2tUcmFuc2Zvcm1cIik7XG5jbGFzcyBEaWZmZXJlbnRpYWxEb3dubG9hZGVyIHtcbiAgICAvLyBub2luc3BlY3Rpb24gVHlwZVNjcmlwdEFic3RyYWN0Q2xhc3NDb25zdHJ1Y3RvckNhbkJlTWFkZVByb3RlY3RlZFxuICAgIGNvbnN0cnVjdG9yKGJsb2NrQXdhcmVGaWxlSW5mbywgaHR0cEV4ZWN1dG9yLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYmxvY2tBd2FyZUZpbGVJbmZvID0gYmxvY2tBd2FyZUZpbGVJbmZvO1xuICAgICAgICB0aGlzLmh0dHBFeGVjdXRvciA9IGh0dHBFeGVjdXRvcjtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5maWxlTWV0YWRhdGFCdWZmZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IG9wdGlvbnMubG9nZ2VyO1xuICAgIH1cbiAgICBjcmVhdGVSZXF1ZXN0T3B0aW9ucygpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucy5yZXF1ZXN0SGVhZGVycyxcbiAgICAgICAgICAgICAgICBhY2NlcHQ6IFwiKi8qXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBidWlsZGVyX3V0aWxfcnVudGltZV8xLmNvbmZpZ3VyZVJlcXVlc3RVcmwodGhpcy5vcHRpb25zLm5ld1VybCwgcmVzdWx0KTtcbiAgICAgICAgLy8gdXNlci1hZ2VudCwgY2FjaGUtY29udHJvbCBhbmQgb3RoZXIgY29tbW9uIG9wdGlvbnNcbiAgICAgICAgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5jb25maWd1cmVSZXF1ZXN0T3B0aW9ucyhyZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBkb0Rvd25sb2FkKG9sZEJsb2NrTWFwLCBuZXdCbG9ja01hcCkge1xuICAgICAgICAvLyB3ZSBkb24ndCBjaGVjayBvdGhlciBtZXRhZGF0YSBsaWtlIGNvbXByZXNzaW9uTWV0aG9kIC0gZ2VuZXJpYyBjaGVjayB0aGF0IGl0IGlzIG1ha2Ugc2Vuc2UgdG8gZGlmZmVyZW50aWFsbHkgdXBkYXRlIGlzIHN1aXRhYmxlIGZvciBpdFxuICAgICAgICBpZiAob2xkQmxvY2tNYXAudmVyc2lvbiAhPT0gbmV3QmxvY2tNYXAudmVyc2lvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB2ZXJzaW9uIGlzIGRpZmZlcmVudCAoJHtvbGRCbG9ja01hcC52ZXJzaW9ufSAtICR7bmV3QmxvY2tNYXAudmVyc2lvbn0pLCBmdWxsIGRvd25sb2FkIGlzIHJlcXVpcmVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9nZ2VyID0gdGhpcy5sb2dnZXI7XG4gICAgICAgIGNvbnN0IG9wZXJhdGlvbnMgPSBkb3dubG9hZFBsYW5CdWlsZGVyXzEuY29tcHV0ZU9wZXJhdGlvbnMob2xkQmxvY2tNYXAsIG5ld0Jsb2NrTWFwLCBsb2dnZXIpO1xuICAgICAgICBpZiAobG9nZ2VyLmRlYnVnICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhKU09OLnN0cmluZ2lmeShvcGVyYXRpb25zLCBudWxsLCAyKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRvd25sb2FkU2l6ZSA9IDA7XG4gICAgICAgIGxldCBjb3B5U2l6ZSA9IDA7XG4gICAgICAgIGZvciAoY29uc3Qgb3BlcmF0aW9uIG9mIG9wZXJhdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IG9wZXJhdGlvbi5lbmQgLSBvcGVyYXRpb24uc3RhcnQ7XG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uLmtpbmQgPT09IGRvd25sb2FkUGxhbkJ1aWxkZXJfMS5PcGVyYXRpb25LaW5kLkRPV05MT0FEKSB7XG4gICAgICAgICAgICAgICAgZG93bmxvYWRTaXplICs9IGxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvcHlTaXplICs9IGxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdTaXplID0gdGhpcy5ibG9ja0F3YXJlRmlsZUluZm8uc2l6ZTtcbiAgICAgICAgaWYgKGRvd25sb2FkU2l6ZSArIGNvcHlTaXplICsgKHRoaXMuZmlsZU1ldGFkYXRhQnVmZmVyID09IG51bGwgPyAwIDogdGhpcy5maWxlTWV0YWRhdGFCdWZmZXIubGVuZ3RoKSAhPT0gbmV3U2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnRlcm5hbCBlcnJvciwgc2l6ZSBtaXNtYXRjaDogZG93bmxvYWRTaXplOiAke2Rvd25sb2FkU2l6ZX0sIGNvcHlTaXplOiAke2NvcHlTaXplfSwgbmV3U2l6ZTogJHtuZXdTaXplfWApO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5pbmZvKGBGdWxsOiAke2Zvcm1hdEJ5dGVzKG5ld1NpemUpfSwgVG8gZG93bmxvYWQ6ICR7Zm9ybWF0Qnl0ZXMoZG93bmxvYWRTaXplKX0gKCR7TWF0aC5yb3VuZChkb3dubG9hZFNpemUgLyAobmV3U2l6ZSAvIDEwMCkpfSUpYCk7XG4gICAgICAgIHJldHVybiB0aGlzLmRvd25sb2FkRmlsZShvcGVyYXRpb25zKTtcbiAgICB9XG4gICAgZG93bmxvYWRGaWxlKHRhc2tzKSB7XG4gICAgICAgIGNvbnN0IGZkTGlzdCA9IFtdO1xuICAgICAgICBjb25zdCBjbG9zZUZpbGVzID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGZkTGlzdC5tYXAob3BlbmVkRmlsZSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZzX2V4dHJhXzEuY2xvc2Uob3BlbmVkRmlsZS5kZXNjcmlwdG9yKS5jYXRjaChlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYGNhbm5vdCBjbG9zZSBmaWxlIFwiJHtvcGVuZWRGaWxlLnBhdGh9XCI6ICR7ZX1gKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9Eb3dubG9hZEZpbGUodGFza3MsIGZkTGlzdClcbiAgICAgICAgICAgIC50aGVuKGNsb3NlRmlsZXMpXG4gICAgICAgICAgICAuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICAvLyB0aGVuIG11c3QgYmUgYWZ0ZXIgY2F0Y2ggaGVyZSAoc2luY2UgdGhlbiBhbHdheXMgdGhyb3dzIGVycm9yKVxuICAgICAgICAgICAgcmV0dXJuIGNsb3NlRmlsZXMoKVxuICAgICAgICAgICAgICAgIC5jYXRjaChjbG9zZUZpbGVzRXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGNsb3NlRmlsZXMgbmV2ZXIgdGhyb3cgZXJyb3IsIGJ1dCBqdXN0IHRvIGJlIHN1cmVcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihgY2Fubm90IGNsb3NlIGZpbGVzOiAke2Nsb3NlRmlsZXNFcnJvcn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yT25Mb2cpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3JPbkxvZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9rLCBnaXZlIHVwIGFuZCBpZ25vcmUgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZG9Eb3dubG9hZEZpbGUodGFza3MsIGZkTGlzdCkge1xuICAgICAgICBjb25zdCBvbGRGaWxlRmQgPSBhd2FpdCBmc19leHRyYV8xLm9wZW4odGhpcy5vcHRpb25zLm9sZEZpbGUsIFwiclwiKTtcbiAgICAgICAgZmRMaXN0LnB1c2goeyBkZXNjcmlwdG9yOiBvbGRGaWxlRmQsIHBhdGg6IHRoaXMub3B0aW9ucy5vbGRGaWxlIH0pO1xuICAgICAgICBjb25zdCBuZXdGaWxlRmQgPSBhd2FpdCBmc19leHRyYV8xLm9wZW4odGhpcy5vcHRpb25zLm5ld0ZpbGUsIFwid1wiKTtcbiAgICAgICAgZmRMaXN0LnB1c2goeyBkZXNjcmlwdG9yOiBuZXdGaWxlRmQsIHBhdGg6IHRoaXMub3B0aW9ucy5uZXdGaWxlIH0pO1xuICAgICAgICBjb25zdCBmaWxlT3V0ID0gZnNfMS5jcmVhdGVXcml0ZVN0cmVhbSh0aGlzLm9wdGlvbnMubmV3RmlsZSwgeyBmZDogbmV3RmlsZUZkIH0pO1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdHJlYW1zID0gW107XG4gICAgICAgICAgICAvLyBDcmVhdGUgb3VyIGRvd25sb2FkIGluZm8gdHJhbnNmb3JtZXIgaWYgd2UgaGF2ZSBvbmVcbiAgICAgICAgICAgIGxldCBkb3dubG9hZEluZm9UcmFuc2Zvcm0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5pc1VzZU11bHRpcGxlUmFuZ2VSZXF1ZXN0ICYmIHRoaXMub3B0aW9ucy5vblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogRG9lcyBub3Qgc3VwcG9ydCBtdWx0aXBsZSByYW5nZXMgKHNvbWVvbmUgZmVlbCBmcmVlIHRvIFBSIHRoaXMhKVxuICAgICAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkQnl0ZUNvdW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIGxldCBncmFuZFRvdGFsQnl0ZXMgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdGFzayBvZiB0YXNrcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFzay5raW5kID09PSBkb3dubG9hZFBsYW5CdWlsZGVyXzEuT3BlcmF0aW9uS2luZC5ET1dOTE9BRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRCeXRlQ291bnRzLnB1c2godGFzay5lbmQgLSB0YXNrLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYW5kVG90YWxCeXRlcyArPSB0YXNrLmVuZCAtIHRhc2suc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvZ3Jlc3NEaWZmZXJlbnRpYWxEb3dubG9hZEluZm8gPSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkQnl0ZUNvdW50czogZXhwZWN0ZWRCeXRlQ291bnRzLFxuICAgICAgICAgICAgICAgICAgICBncmFuZFRvdGFsOiBncmFuZFRvdGFsQnl0ZXMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBkb3dubG9hZEluZm9UcmFuc2Zvcm0gPSBuZXcgUHJvZ3Jlc3NEaWZmZXJlbnRpYWxEb3dubG9hZENhbGxiYWNrVHJhbnNmb3JtXzEuUHJvZ3Jlc3NEaWZmZXJlbnRpYWxEb3dubG9hZENhbGxiYWNrVHJhbnNmb3JtKHByb2dyZXNzRGlmZmVyZW50aWFsRG93bmxvYWRJbmZvLCB0aGlzLm9wdGlvbnMuY2FuY2VsbGF0aW9uVG9rZW4sIHRoaXMub3B0aW9ucy5vblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICBzdHJlYW1zLnB1c2goZG93bmxvYWRJbmZvVHJhbnNmb3JtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRpZ2VzdFRyYW5zZm9ybSA9IG5ldyBidWlsZGVyX3V0aWxfcnVudGltZV8xLkRpZ2VzdFRyYW5zZm9ybSh0aGlzLmJsb2NrQXdhcmVGaWxlSW5mby5zaGE1MTIpO1xuICAgICAgICAgICAgLy8gdG8gc2ltcGx5IGRlYnVnLCBkbyBtYW51YWwgdmFsaWRhdGlvbiB0byBhbGxvdyBmaWxlIHRvIGJlIGZ1bGx5IHdyaXR0ZW5cbiAgICAgICAgICAgIGRpZ2VzdFRyYW5zZm9ybS5pc1ZhbGlkYXRlT25FbmQgPSBmYWxzZTtcbiAgICAgICAgICAgIHN0cmVhbXMucHVzaChkaWdlc3RUcmFuc2Zvcm0pO1xuICAgICAgICAgICAgLy8gbm9pbnNwZWN0aW9uIEpTQXJyb3dGdW5jdGlvbkNhbkJlUmVwbGFjZWRXaXRoU2hvcnRoYW5kXG4gICAgICAgICAgICBmaWxlT3V0Lm9uKFwiZmluaXNoXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgZmlsZU91dC5jbG9zZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBmcm9tIGZkIGxpc3QgYmVjYXVzZSBjbG9zZWQgc3VjY2Vzc2Z1bGx5XG4gICAgICAgICAgICAgICAgICAgIGZkTGlzdC5zcGxpY2UoMSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWdlc3RUcmFuc2Zvcm0udmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RyZWFtcy5wdXNoKGZpbGVPdXQpO1xuICAgICAgICAgICAgbGV0IGxhc3RTdHJlYW0gPSBudWxsO1xuICAgICAgICAgICAgZm9yIChjb25zdCBzdHJlYW0gb2Ygc3RyZWFtcykge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5vbihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RTdHJlYW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0U3RyZWFtID0gc3RyZWFtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFN0cmVhbSA9IGxhc3RTdHJlYW0ucGlwZShzdHJlYW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpcnN0U3RyZWFtID0gc3RyZWFtc1swXTtcbiAgICAgICAgICAgIGxldCB3O1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pc1VzZU11bHRpcGxlUmFuZ2VSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgdyA9IG11bHRpcGxlUmFuZ2VEb3dubG9hZGVyXzEuZXhlY3V0ZVRhc2tzVXNpbmdNdWx0aXBsZVJhbmdlUmVxdWVzdHModGhpcywgdGFza3MsIGZpcnN0U3RyZWFtLCBvbGRGaWxlRmQsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgdygwKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZG93bmxvYWRPcGVyYXRpb25Db3VudCA9IDA7XG4gICAgICAgICAgICBsZXQgYWN0dWFsVXJsID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oYERpZmZlcmVudGlhbCBkb3dubG9hZDogJHt0aGlzLm9wdGlvbnMubmV3VXJsfWApO1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSB0aGlzLmNyZWF0ZVJlcXVlc3RPcHRpb25zKCk7XG4gICAgICAgICAgICByZXF1ZXN0T3B0aW9ucy5yZWRpcmVjdCA9IFwibWFudWFsXCI7XG4gICAgICAgICAgICB3ID0gKGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gdGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbGVNZXRhZGF0YUJ1ZmZlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFN0cmVhbS53cml0ZSh0aGlzLmZpbGVNZXRhZGF0YUJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmlyc3RTdHJlYW0uZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gdGFza3NbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgaWYgKG9wZXJhdGlvbi5raW5kID09PSBkb3dubG9hZFBsYW5CdWlsZGVyXzEuT3BlcmF0aW9uS2luZC5DT1BZKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBjb3B5aW5nLCBsZXQncyBub3Qgc2VuZCBzdGF0dXMgdXBkYXRlcyB0byB0aGUgVUlcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvd25sb2FkSW5mb1RyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG93bmxvYWRJbmZvVHJhbnNmb3JtLmJlZ2luRmlsZUNvcHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBEYXRhU3BsaXR0ZXJfMS5jb3B5RGF0YShvcGVyYXRpb24sIGZpcnN0U3RyZWFtLCBvbGRGaWxlRmQsIHJlamVjdCwgKCkgPT4gdyhpbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gYGJ5dGVzPSR7b3BlcmF0aW9uLnN0YXJ0fS0ke29wZXJhdGlvbi5lbmQgLSAxfWA7XG4gICAgICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnMuaGVhZGVycy5yYW5nZSA9IHJhbmdlO1xuICAgICAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMubG9nZ2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVidWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBgZG93bmxvYWQgcmFuZ2U6ICR7cmFuZ2V9YCk7XG4gICAgICAgICAgICAgICAgLy8gV2UgYXJlIHN0YXJ0aW5nIHRvIGRvd25sb2FkXG4gICAgICAgICAgICAgICAgaWYgKGRvd25sb2FkSW5mb1RyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICBkb3dubG9hZEluZm9UcmFuc2Zvcm0uYmVnaW5SYW5nZURvd25sb2FkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmh0dHBFeGVjdXRvci5jcmVhdGVSZXF1ZXN0KHJlcXVlc3RPcHRpb25zLCByZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVsZWN0cm9uIG5ldCBoYW5kbGVzIHJlZGlyZWN0cyBhdXRvbWF0aWNhbGx5LCBvdXIgTm9kZUpTIHRlc3Qgc2VydmVyIGRvZXNuJ3QgdXNlIHJlZGlyZWN0cyAtIHNvLCB3ZSBkb24ndCBjaGVjayAzeHggY29kZXMuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID49IDQwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuY3JlYXRlSHR0cEVycm9yKHJlc3BvbnNlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UucGlwZShmaXJzdFN0cmVhbSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLm9uY2UoXCJlbmRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFzcyBvbiB0aGF0IHdlIGFyZSBkb3dubG9hZGluZyBhIHNlZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb3dubG9hZEluZm9UcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3dubG9hZEluZm9UcmFuc2Zvcm0uZW5kUmFuZ2VEb3dubG9hZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCsrZG93bmxvYWRPcGVyYXRpb25Db3VudCA9PT0gMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG93bmxvYWRPcGVyYXRpb25Db3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB3KGluZGV4KSwgMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3KGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbihcInJlZGlyZWN0XCIsIChzdGF0dXNDb2RlLCBtZXRob2QsIHJlZGlyZWN0VXJsKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oYFJlZGlyZWN0IHRvICR7cmVtb3ZlUXVlcnkocmVkaXJlY3RVcmwpfWApO1xuICAgICAgICAgICAgICAgICAgICBhY3R1YWxVcmwgPSByZWRpcmVjdFVybDtcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5jb25maWd1cmVSZXF1ZXN0VXJsKG5ldyB1cmxfMS5VUkwoYWN0dWFsVXJsKSwgcmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmZvbGxvd1JlZGlyZWN0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5odHRwRXhlY3V0b3IuYWRkRXJyb3JBbmRUaW1lb3V0SGFuZGxlcnMocmVxdWVzdCwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmVuZCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHcoMCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyByZWFkUmVtb3RlQnl0ZXMoc3RhcnQsIGVuZEluY2x1c2l2ZSkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoZW5kSW5jbHVzaXZlICsgMSAtIHN0YXJ0KTtcbiAgICAgICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSB0aGlzLmNyZWF0ZVJlcXVlc3RPcHRpb25zKCk7XG4gICAgICAgIHJlcXVlc3RPcHRpb25zLmhlYWRlcnMucmFuZ2UgPSBgYnl0ZXM9JHtzdGFydH0tJHtlbmRJbmNsdXNpdmV9YDtcbiAgICAgICAgbGV0IHBvc2l0aW9uID0gMDtcbiAgICAgICAgYXdhaXQgdGhpcy5yZXF1ZXN0KHJlcXVlc3RPcHRpb25zLCBjaHVuayA9PiB7XG4gICAgICAgICAgICBjaHVuay5jb3B5KGJ1ZmZlciwgcG9zaXRpb24pO1xuICAgICAgICAgICAgcG9zaXRpb24gKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBvc2l0aW9uICE9PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlY2VpdmVkIGRhdGEgbGVuZ3RoICR7cG9zaXRpb259IGlzIG5vdCBlcXVhbCB0byBleHBlY3RlZCAke2J1ZmZlci5sZW5ndGh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG4gICAgcmVxdWVzdChyZXF1ZXN0T3B0aW9ucywgZGF0YUhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmh0dHBFeGVjdXRvci5jcmVhdGVSZXF1ZXN0KHJlcXVlc3RPcHRpb25zLCByZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFtdWx0aXBsZVJhbmdlRG93bmxvYWRlcl8xLmNoZWNrSXNSYW5nZXNTdXBwb3J0ZWQocmVzcG9uc2UsIHJlamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNwb25zZS5vbihcImRhdGFcIiwgZGF0YUhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLm9uKFwiZW5kXCIsICgpID0+IHJlc29sdmUoKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuaHR0cEV4ZWN1dG9yLmFkZEVycm9yQW5kVGltZW91dEhhbmRsZXJzKHJlcXVlc3QsIHJlamVjdCk7XG4gICAgICAgICAgICByZXF1ZXN0LmVuZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkRpZmZlcmVudGlhbERvd25sb2FkZXIgPSBEaWZmZXJlbnRpYWxEb3dubG9hZGVyO1xuZnVuY3Rpb24gZm9ybWF0Qnl0ZXModmFsdWUsIHN5bWJvbCA9IFwiIEtCXCIpIHtcbiAgICByZXR1cm4gbmV3IEludGwuTnVtYmVyRm9ybWF0KFwiZW5cIikuZm9ybWF0KCh2YWx1ZSAvIDEwMjQpLnRvRml4ZWQoMikpICsgc3ltYm9sO1xufVxuLy8gc2FmZXR5XG5mdW5jdGlvbiByZW1vdmVRdWVyeSh1cmwpIHtcbiAgICBjb25zdCBpbmRleCA9IHVybC5pbmRleE9mKFwiP1wiKTtcbiAgICByZXR1cm4gaW5kZXggPCAwID8gdXJsIDogdXJsLnN1YnN0cmluZygwLCBpbmRleCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EaWZmZXJlbnRpYWxEb3dubG9hZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyID0gdm9pZCAwO1xuY29uc3QgZnNfZXh0cmFfMSA9IHJlcXVpcmUoXCJmcy1leHRyYVwiKTtcbmNvbnN0IERpZmZlcmVudGlhbERvd25sb2FkZXJfMSA9IHJlcXVpcmUoXCIuL0RpZmZlcmVudGlhbERvd25sb2FkZXJcIik7XG5jb25zdCB6bGliXzEgPSByZXF1aXJlKFwiemxpYlwiKTtcbmNsYXNzIEZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXIgZXh0ZW5kcyBEaWZmZXJlbnRpYWxEb3dubG9hZGVyXzEuRGlmZmVyZW50aWFsRG93bmxvYWRlciB7XG4gICAgYXN5bmMgZG93bmxvYWQoKSB7XG4gICAgICAgIGNvbnN0IHBhY2thZ2VJbmZvID0gdGhpcy5ibG9ja0F3YXJlRmlsZUluZm87XG4gICAgICAgIGNvbnN0IGZpbGVTaXplID0gcGFja2FnZUluZm8uc2l6ZTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gZmlsZVNpemUgLSAocGFja2FnZUluZm8uYmxvY2tNYXBTaXplICsgNCk7XG4gICAgICAgIHRoaXMuZmlsZU1ldGFkYXRhQnVmZmVyID0gYXdhaXQgdGhpcy5yZWFkUmVtb3RlQnl0ZXMob2Zmc2V0LCBmaWxlU2l6ZSAtIDEpO1xuICAgICAgICBjb25zdCBuZXdCbG9ja01hcCA9IHJlYWRCbG9ja01hcCh0aGlzLmZpbGVNZXRhZGF0YUJ1ZmZlci5zbGljZSgwLCB0aGlzLmZpbGVNZXRhZGF0YUJ1ZmZlci5sZW5ndGggLSA0KSk7XG4gICAgICAgIGF3YWl0IHRoaXMuZG9Eb3dubG9hZChhd2FpdCByZWFkRW1iZWRkZWRCbG9ja01hcERhdGEodGhpcy5vcHRpb25zLm9sZEZpbGUpLCBuZXdCbG9ja01hcCk7XG4gICAgfVxufVxuZXhwb3J0cy5GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyID0gRmlsZVdpdGhFbWJlZGRlZEJsb2NrTWFwRGlmZmVyZW50aWFsRG93bmxvYWRlcjtcbmZ1bmN0aW9uIHJlYWRCbG9ja01hcChkYXRhKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoemxpYl8xLmluZmxhdGVSYXdTeW5jKGRhdGEpLnRvU3RyaW5nKCkpO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVhZEVtYmVkZGVkQmxvY2tNYXBEYXRhKGZpbGUpIHtcbiAgICBjb25zdCBmZCA9IGF3YWl0IGZzX2V4dHJhXzEub3BlbihmaWxlLCBcInJcIik7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZmlsZVNpemUgPSAoYXdhaXQgZnNfZXh0cmFfMS5mc3RhdChmZCkpLnNpemU7XG4gICAgICAgIGNvbnN0IHNpemVCdWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNCk7XG4gICAgICAgIGF3YWl0IGZzX2V4dHJhXzEucmVhZChmZCwgc2l6ZUJ1ZmZlciwgMCwgc2l6ZUJ1ZmZlci5sZW5ndGgsIGZpbGVTaXplIC0gc2l6ZUJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICBjb25zdCBkYXRhQnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKHNpemVCdWZmZXIucmVhZFVJbnQzMkJFKDApKTtcbiAgICAgICAgYXdhaXQgZnNfZXh0cmFfMS5yZWFkKGZkLCBkYXRhQnVmZmVyLCAwLCBkYXRhQnVmZmVyLmxlbmd0aCwgZmlsZVNpemUgLSBzaXplQnVmZmVyLmxlbmd0aCAtIGRhdGFCdWZmZXIubGVuZ3RoKTtcbiAgICAgICAgYXdhaXQgZnNfZXh0cmFfMS5jbG9zZShmZCk7XG4gICAgICAgIHJldHVybiByZWFkQmxvY2tNYXAoZGF0YUJ1ZmZlcik7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGF3YWl0IGZzX2V4dHJhXzEuY2xvc2UoZmQpO1xuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFwcEltYWdlVXBkYXRlciA9IHZvaWQgMDtcbmNvbnN0IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEgPSByZXF1aXJlKFwiYnVpbGRlci11dGlsLXJ1bnRpbWVcIik7XG5jb25zdCBjaGlsZF9wcm9jZXNzXzEgPSByZXF1aXJlKFwiY2hpbGRfcHJvY2Vzc1wiKTtcbmNvbnN0IGZzX2V4dHJhXzEgPSByZXF1aXJlKFwiZnMtZXh0cmFcIik7XG5jb25zdCBmc18xID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgQmFzZVVwZGF0ZXJfMSA9IHJlcXVpcmUoXCIuL0Jhc2VVcGRhdGVyXCIpO1xuY29uc3QgRmlsZVdpdGhFbWJlZGRlZEJsb2NrTWFwRGlmZmVyZW50aWFsRG93bmxvYWRlcl8xID0gcmVxdWlyZShcIi4vZGlmZmVyZW50aWFsRG93bmxvYWRlci9GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyXCIpO1xuY29uc3QgbWFpbl8xID0gcmVxdWlyZShcIi4vbWFpblwiKTtcbmNvbnN0IFByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlcnMvUHJvdmlkZXJcIik7XG5jbGFzcyBBcHBJbWFnZVVwZGF0ZXIgZXh0ZW5kcyBCYXNlVXBkYXRlcl8xLkJhc2VVcGRhdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBhcHApIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucywgYXBwKTtcbiAgICB9XG4gICAgaXNVcGRhdGVyQWN0aXZlKCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnZbXCJBUFBJTUFHRVwiXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnZbXCJTTkFQXCJdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIud2FybihcIkFQUElNQUdFIGVudiBpcyBub3QgZGVmaW5lZCwgY3VycmVudCBhcHBsaWNhdGlvbiBpcyBub3QgYW4gQXBwSW1hZ2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIlNOQVAgZW52IGlzIGRlZmluZWQsIHVwZGF0ZXIgaXMgZGlzYWJsZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLmlzVXBkYXRlckFjdGl2ZSgpO1xuICAgIH1cbiAgICAvKioqIEBwcml2YXRlICovXG4gICAgZG9Eb3dubG9hZFVwZGF0ZShkb3dubG9hZFVwZGF0ZU9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBkb3dubG9hZFVwZGF0ZU9wdGlvbnMudXBkYXRlSW5mb0FuZFByb3ZpZGVyLnByb3ZpZGVyO1xuICAgICAgICBjb25zdCBmaWxlSW5mbyA9IFByb3ZpZGVyXzEuZmluZEZpbGUocHJvdmlkZXIucmVzb2x2ZUZpbGVzKGRvd25sb2FkVXBkYXRlT3B0aW9ucy51cGRhdGVJbmZvQW5kUHJvdmlkZXIuaW5mbyksIFwiQXBwSW1hZ2VcIik7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVEb3dubG9hZCh7XG4gICAgICAgICAgICBmaWxlRXh0ZW5zaW9uOiBcIkFwcEltYWdlXCIsXG4gICAgICAgICAgICBmaWxlSW5mbyxcbiAgICAgICAgICAgIGRvd25sb2FkVXBkYXRlT3B0aW9ucyxcbiAgICAgICAgICAgIHRhc2s6IGFzeW5jICh1cGRhdGVGaWxlLCBkb3dubG9hZE9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRGaWxlID0gcHJvY2Vzcy5lbnZbXCJBUFBJTUFHRVwiXTtcbiAgICAgICAgICAgICAgICBpZiAob2xkRmlsZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IoXCJBUFBJTUFHRSBlbnYgaXMgbm90IGRlZmluZWRcIiwgXCJFUlJfVVBEQVRFUl9PTERfRklMRV9OT1RfRk9VTkRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBpc0Rvd25sb2FkRnVsbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvd25sb2FkT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1VybDogZmlsZUluZm8udXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkRmlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcjogdGhpcy5fbG9nZ2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RmlsZTogdXBkYXRlRmlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVXNlTXVsdGlwbGVSYW5nZVJlcXVlc3Q6IHByb3ZpZGVyLmlzVXNlTXVsdGlwbGVSYW5nZVJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SGVhZGVyczogZG93bmxvYWRVcGRhdGVPcHRpb25zLnJlcXVlc3RIZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGF0aW9uVG9rZW46IGRvd25sb2FkVXBkYXRlT3B0aW9ucy5jYW5jZWxsYXRpb25Ub2tlbixcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubGlzdGVuZXJDb3VudChtYWluXzEuRE9XTkxPQURfUFJPR1JFU1MpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG93bmxvYWRPcHRpb25zLm9uUHJvZ3Jlc3MgPSBpdCA9PiB0aGlzLmVtaXQobWFpbl8xLkRPV05MT0FEX1BST0dSRVNTLCBpdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgbmV3IEZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXJfMS5GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyKGZpbGVJbmZvLmluZm8sIHRoaXMuaHR0cEV4ZWN1dG9yLCBkb3dubG9hZE9wdGlvbnMpLmRvd25sb2FkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihgQ2Fubm90IGRvd25sb2FkIGRpZmZlcmVudGlhbGx5LCBmYWxsYmFjayB0byBmdWxsIGRvd25sb2FkOiAke2Uuc3RhY2sgfHwgZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZHVyaW5nIHRlc3QgKGRldmVsb3BlciBtYWNoaW5lIG1hYykgd2UgbXVzdCB0aHJvdyBlcnJvclxuICAgICAgICAgICAgICAgICAgICBpc0Rvd25sb2FkRnVsbCA9IHByb2Nlc3MucGxhdGZvcm0gPT09IFwibGludXhcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzRG93bmxvYWRGdWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuaHR0cEV4ZWN1dG9yLmRvd25sb2FkKGZpbGVJbmZvLnVybCwgdXBkYXRlRmlsZSwgZG93bmxvYWRPcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgZnNfZXh0cmFfMS5jaG1vZCh1cGRhdGVGaWxlLCAwbzc1NSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZG9JbnN0YWxsKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYXBwSW1hZ2VGaWxlID0gcHJvY2Vzcy5lbnZbXCJBUFBJTUFHRVwiXTtcbiAgICAgICAgaWYgKGFwcEltYWdlRmlsZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBidWlsZGVyX3V0aWxfcnVudGltZV8xLm5ld0Vycm9yKFwiQVBQSU1BR0UgZW52IGlzIG5vdCBkZWZpbmVkXCIsIFwiRVJSX1VQREFURVJfT0xEX0ZJTEVfTk9UX0ZPVU5EXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNzEyMDUxLzE5MTAxOTFcbiAgICAgICAgZnNfMS51bmxpbmtTeW5jKGFwcEltYWdlRmlsZSk7XG4gICAgICAgIGxldCBkZXN0aW5hdGlvbjtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdCYXNlTmFtZSA9IHBhdGguYmFzZW5hbWUoYXBwSW1hZ2VGaWxlKTtcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2VsZWN0cm9uLXVzZXJsYW5kL2VsZWN0cm9uLWJ1aWxkZXIvaXNzdWVzLzI5NjRcbiAgICAgICAgLy8gaWYgbm8gdmVyc2lvbiBpbiBleGlzdGluZyBmaWxlIG5hbWUsIGl0IG1lYW5zIHRoYXQgdXNlciB3YW50cyB0byBwcmVzZXJ2ZSBjdXJyZW50IGN1c3RvbSBuYW1lXG4gICAgICAgIGlmIChwYXRoLmJhc2VuYW1lKG9wdGlvbnMuaW5zdGFsbGVyUGF0aCkgPT09IGV4aXN0aW5nQmFzZU5hbWUgfHwgIS9cXGQrXFwuXFxkK1xcLlxcZCsvLnRlc3QoZXhpc3RpbmdCYXNlTmFtZSkpIHtcbiAgICAgICAgICAgIC8vIG5vIHZlcnNpb24gaW4gdGhlIGZpbGUgbmFtZSwgb3ZlcndyaXRlIGV4aXN0aW5nXG4gICAgICAgICAgICBkZXN0aW5hdGlvbiA9IGFwcEltYWdlRmlsZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uID0gcGF0aC5qb2luKHBhdGguZGlybmFtZShhcHBJbWFnZUZpbGUpLCBwYXRoLmJhc2VuYW1lKG9wdGlvbnMuaW5zdGFsbGVyUGF0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkX3Byb2Nlc3NfMS5leGVjRmlsZVN5bmMoXCJtdlwiLCBbXCItZlwiLCBvcHRpb25zLmluc3RhbGxlclBhdGgsIGRlc3RpbmF0aW9uXSk7XG4gICAgICAgIGlmIChkZXN0aW5hdGlvbiAhPT0gYXBwSW1hZ2VGaWxlKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJhcHBpbWFnZS1maWxlbmFtZS11cGRhdGVkXCIsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbnYgPSB7XG4gICAgICAgICAgICAuLi5wcm9jZXNzLmVudixcbiAgICAgICAgICAgIEFQUElNQUdFX1NJTEVOVF9JTlNUQUxMOiBcInRydWVcIixcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMuaXNGb3JjZVJ1bkFmdGVyKSB7XG4gICAgICAgICAgICBjaGlsZF9wcm9jZXNzXzEuc3Bhd24oZGVzdGluYXRpb24sIFtdLCB7XG4gICAgICAgICAgICAgICAgZGV0YWNoZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgc3RkaW86IFwiaWdub3JlXCIsXG4gICAgICAgICAgICAgICAgZW52LFxuICAgICAgICAgICAgfSkudW5yZWYoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVudi5BUFBJTUFHRV9FWElUX0FGVEVSX0lOU1RBTEwgPSBcInRydWVcIjtcbiAgICAgICAgICAgIGNoaWxkX3Byb2Nlc3NfMS5leGVjRmlsZVN5bmMoZGVzdGluYXRpb24sIFtdLCB7IGVudiB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5leHBvcnRzLkFwcEltYWdlVXBkYXRlciA9IEFwcEltYWdlVXBkYXRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFwcEltYWdlVXBkYXRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFjVXBkYXRlciA9IHZvaWQgMDtcbmNvbnN0IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEgPSByZXF1aXJlKFwiYnVpbGRlci11dGlsLXJ1bnRpbWVcIik7XG5jb25zdCBmc19leHRyYV8xID0gcmVxdWlyZShcImZzLWV4dHJhXCIpO1xuY29uc3QgZnNfMSA9IHJlcXVpcmUoXCJmc1wiKTtcbmNvbnN0IGh0dHBfMSA9IHJlcXVpcmUoXCJodHRwXCIpO1xuY29uc3QgQXBwVXBkYXRlcl8xID0gcmVxdWlyZShcIi4vQXBwVXBkYXRlclwiKTtcbmNvbnN0IFByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlcnMvUHJvdmlkZXJcIik7XG5jb25zdCBjaGlsZF9wcm9jZXNzXzEgPSByZXF1aXJlKFwiY2hpbGRfcHJvY2Vzc1wiKTtcbmNsYXNzIE1hY1VwZGF0ZXIgZXh0ZW5kcyBBcHBVcGRhdGVyXzEuQXBwVXBkYXRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgYXBwKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMsIGFwcCk7XG4gICAgICAgIHRoaXMubmF0aXZlVXBkYXRlciA9IHJlcXVpcmUoXCJlbGVjdHJvblwiKS5hdXRvVXBkYXRlcjtcbiAgICAgICAgdGhpcy5zcXVpcnJlbERvd25sb2FkZWRVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5uYXRpdmVVcGRhdGVyLm9uKFwiZXJyb3JcIiwgaXQgPT4ge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oaXQpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgaXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5uYXRpdmVVcGRhdGVyLm9uKFwidXBkYXRlLWRvd25sb2FkZWRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zcXVpcnJlbERvd25sb2FkZWRVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVidWcobWVzc2FnZSkge1xuICAgICAgICBpZiAodGhpcy5fbG9nZ2VyLmRlYnVnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBkb0Rvd25sb2FkVXBkYXRlKGRvd25sb2FkVXBkYXRlT3B0aW9ucykge1xuICAgICAgICBsZXQgZmlsZXMgPSBkb3dubG9hZFVwZGF0ZU9wdGlvbnMudXBkYXRlSW5mb0FuZFByb3ZpZGVyLnByb3ZpZGVyLnJlc29sdmVGaWxlcyhkb3dubG9hZFVwZGF0ZU9wdGlvbnMudXBkYXRlSW5mb0FuZFByb3ZpZGVyLmluZm8pO1xuICAgICAgICBjb25zdCBsb2cgPSB0aGlzLl9sb2dnZXI7XG4gICAgICAgIC8vIGRldGVjdCBpZiB3ZSBhcmUgcnVubmluZyBpbnNpZGUgUm9zZXR0YSBlbXVsYXRpb25cbiAgICAgICAgY29uc3Qgc3lzY3RsUm9zZXR0YUluZm9LZXkgPSBcInN5c2N0bC5wcm9jX3RyYW5zbGF0ZWRcIjtcbiAgICAgICAgbGV0IGlzUm9zZXR0YTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuZGVidWcoXCJDaGVja2luZyBmb3IgbWFjT1MgUm9zZXR0YSBlbnZpcm9ubWVudFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNoaWxkX3Byb2Nlc3NfMS5leGVjRmlsZVN5bmMoXCJzeXNjdGxcIiwgW3N5c2N0bFJvc2V0dGFJbmZvS2V5XSwgeyBlbmNvZGluZzogXCJ1dGY4XCIgfSk7XG4gICAgICAgICAgICBpc1Jvc2V0dGEgPSByZXN1bHQuaW5jbHVkZXMoYCR7c3lzY3RsUm9zZXR0YUluZm9LZXl9OiAxYCk7XG4gICAgICAgICAgICBsb2cuaW5mbyhgQ2hlY2tlZCBmb3IgbWFjT1MgUm9zZXR0YSBlbnZpcm9ubWVudCAoaXNSb3NldHRhPSR7aXNSb3NldHRhfSlgKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nLndhcm4oYHN5c2N0bCBzaGVsbCBjb21tYW5kIHRvIGNoZWNrIGZvciBtYWNPUyBSb3NldHRhIGVudmlyb25tZW50IGZhaWxlZDogJHtlfWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFsbG93IGFybTY0IG1hY3MgdG8gaW5zdGFsbCB1bml2ZXJzYWwgb3Igcm9zZXR0YTIoeDY0KSAtIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGVjdHJvbi11c2VybGFuZC9lbGVjdHJvbi1idWlsZGVyL3B1bGwvNTUyNFxuICAgICAgICBjb25zdCBpc0FybTY0ID0gKGZpbGUpID0+IHsgdmFyIF9hOyByZXR1cm4gZmlsZS51cmwucGF0aG5hbWUuaW5jbHVkZXMoXCJhcm02NFwiKSB8fCAoKF9hID0gZmlsZS5pbmZvLnVybCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKFwiYXJtNjRcIikpOyB9O1xuICAgICAgICBpZiAoZmlsZXMuc29tZShpc0FybTY0KSkge1xuICAgICAgICAgICAgZmlsZXMgPSBmaWxlcy5maWx0ZXIoZmlsZSA9PiAocHJvY2Vzcy5hcmNoID09PSBcImFybTY0XCIgfHwgaXNSb3NldHRhKSA9PT0gaXNBcm02NChmaWxlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgemlwRmlsZUluZm8gPSBQcm92aWRlcl8xLmZpbmRGaWxlKGZpbGVzLCBcInppcFwiLCBbXCJwa2dcIiwgXCJkbWdcIl0pO1xuICAgICAgICBpZiAoemlwRmlsZUluZm8gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5uZXdFcnJvcihgWklQIGZpbGUgbm90IHByb3ZpZGVkOiAke2J1aWxkZXJfdXRpbF9ydW50aW1lXzEuc2FmZVN0cmluZ2lmeUpzb24oZmlsZXMpfWAsIFwiRVJSX1VQREFURVJfWklQX0ZJTEVfTk9UX0ZPVU5EXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVEb3dubG9hZCh7XG4gICAgICAgICAgICBmaWxlRXh0ZW5zaW9uOiBcInppcFwiLFxuICAgICAgICAgICAgZmlsZUluZm86IHppcEZpbGVJbmZvLFxuICAgICAgICAgICAgZG93bmxvYWRVcGRhdGVPcHRpb25zLFxuICAgICAgICAgICAgdGFzazogKGRlc3RpbmF0aW9uRmlsZSwgZG93bmxvYWRPcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaHR0cEV4ZWN1dG9yLmRvd25sb2FkKHppcEZpbGVJbmZvLnVybCwgZGVzdGluYXRpb25GaWxlLCBkb3dubG9hZE9wdGlvbnMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRvbmU6IGV2ZW50ID0+IHRoaXMudXBkYXRlRG93bmxvYWRlZCh6aXBGaWxlSW5mbywgZXZlbnQpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlRG93bmxvYWRlZCh6aXBGaWxlSW5mbywgZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBkb3dubG9hZGVkRmlsZSA9IGV2ZW50LmRvd25sb2FkZWRGaWxlO1xuICAgICAgICBjb25zdCB1cGRhdGVGaWxlU2l6ZSA9IChfYSA9IHppcEZpbGVJbmZvLmluZm8uc2l6ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKGF3YWl0IGZzX2V4dHJhXzEuc3RhdChkb3dubG9hZGVkRmlsZSkpLnNpemU7XG4gICAgICAgIGNvbnN0IGxvZyA9IHRoaXMuX2xvZ2dlcjtcbiAgICAgICAgY29uc3QgbG9nQ29udGV4dCA9IGBmaWxlVG9Qcm94eT0ke3ppcEZpbGVJbmZvLnVybC5ocmVmfWA7XG4gICAgICAgIHRoaXMuZGVidWcoYENyZWF0aW5nIHByb3h5IHNlcnZlciBmb3IgbmF0aXZlIFNxdWlycmVsLk1hYyAoJHtsb2dDb250ZXh0fSlgKTtcbiAgICAgICAgY29uc3Qgc2VydmVyID0gaHR0cF8xLmNyZWF0ZVNlcnZlcigpO1xuICAgICAgICB0aGlzLmRlYnVnKGBQcm94eSBzZXJ2ZXIgZm9yIG5hdGl2ZSBTcXVpcnJlbC5NYWMgaXMgY3JlYXRlZCAoJHtsb2dDb250ZXh0fSlgKTtcbiAgICAgICAgc2VydmVyLm9uKFwiY2xvc2VcIiwgKCkgPT4ge1xuICAgICAgICAgICAgbG9nLmluZm8oYFByb3h5IHNlcnZlciBmb3IgbmF0aXZlIFNxdWlycmVsLk1hYyBpcyBjbG9zZWQgKCR7bG9nQ29udGV4dH0pYCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBtdXN0IGJlIGNhbGxlZCBhZnRlciBzZXJ2ZXIgaXMgbGlzdGVuaW5nLCBvdGhlcndpc2UgYWRkcmVzcyBpcyBudWxsXG4gICAgICAgIGZ1bmN0aW9uIGdldFNlcnZlclVybCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBzZXJ2ZXIuYWRkcmVzcygpO1xuICAgICAgICAgICAgcmV0dXJuIGBodHRwOi8vMTI3LjAuMC4xOiR7YWRkcmVzcy5wb3J0fWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIC8vIGluc2VjdXJlIHJhbmRvbSBpcyBva1xuICAgICAgICAgICAgY29uc3QgZmlsZVVybCA9IGAvJHtEYXRlLm5vdygpLnRvU3RyaW5nKDE2KX0tJHtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA5OTk5KS50b1N0cmluZygxNil9LnppcGA7XG4gICAgICAgICAgICBzZXJ2ZXIub24oXCJyZXF1ZXN0XCIsIChyZXF1ZXN0LCByZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RVcmwgPSByZXF1ZXN0LnVybDtcbiAgICAgICAgICAgICAgICBsb2cuaW5mbyhgJHtyZXF1ZXN0VXJsfSByZXF1ZXN0ZWRgKTtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdFVybCA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IEJ1ZmZlci5mcm9tKGB7IFwidXJsXCI6IFwiJHtnZXRTZXJ2ZXJVcmwoKX0ke2ZpbGVVcmx9XCIgfWApO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS53cml0ZUhlYWQoMjAwLCB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLCBcIkNvbnRlbnQtTGVuZ3RoXCI6IGRhdGEubGVuZ3RoIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5lbmQoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFyZXF1ZXN0VXJsLnN0YXJ0c1dpdGgoZmlsZVVybCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nLndhcm4oYCR7cmVxdWVzdFVybH0gcmVxdWVzdGVkLCBidXQgbm90IHN1cHBvcnRlZGApO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS53cml0ZUhlYWQoNDA0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9nLmluZm8oYCR7ZmlsZVVybH0gcmVxdWVzdGVkIGJ5IFNxdWlycmVsLk1hYywgcGlwZSAke2Rvd25sb2FkZWRGaWxlfWApO1xuICAgICAgICAgICAgICAgIGxldCBlcnJvck9jY3VycmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uub24oXCJmaW5pc2hcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHNlcnZlci5jbG9zZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXJyb3JPY2N1cnJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmF0aXZlVXBkYXRlci5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWFkU3RyZWFtID0gZnNfMS5jcmVhdGVSZWFkU3RyZWFtKGRvd25sb2FkZWRGaWxlKTtcbiAgICAgICAgICAgICAgICByZWFkU3RyZWFtLm9uKFwiZXJyb3JcIiwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZy53YXJuKGBjYW5ub3QgZW5kIHJlc3BvbnNlOiAke2V9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JPY2N1cnJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmF0aXZlVXBkYXRlci5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYENhbm5vdCBwaXBlIFwiJHtkb3dubG9hZGVkRmlsZX1cIjogJHtlcnJvcn1gKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uud3JpdGVIZWFkKDIwMCwge1xuICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL3ppcFwiLFxuICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtTGVuZ3RoXCI6IHVwZGF0ZUZpbGVTaXplLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlYWRTdHJlYW0ucGlwZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZGVidWcoYFByb3h5IHNlcnZlciBmb3IgbmF0aXZlIFNxdWlycmVsLk1hYyBpcyBzdGFydGluZyB0byBsaXN0ZW4gKCR7bG9nQ29udGV4dH0pYCk7XG4gICAgICAgICAgICBzZXJ2ZXIubGlzdGVuKDAsIFwiMTI3LjAuMC4xXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKGBQcm94eSBzZXJ2ZXIgZm9yIG5hdGl2ZSBTcXVpcnJlbC5NYWMgaXMgbGlzdGVuaW5nIChhZGRyZXNzPSR7Z2V0U2VydmVyVXJsKCl9LCAke2xvZ0NvbnRleHR9KWApO1xuICAgICAgICAgICAgICAgIHRoaXMubmF0aXZlVXBkYXRlci5zZXRGZWVkVVJMKHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBnZXRTZXJ2ZXJVcmwoKSxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogeyBcIkNhY2hlLUNvbnRyb2xcIjogXCJuby1jYWNoZVwiIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHVwZGF0ZSBoYXMgYmVlbiBkb3dubG9hZGVkIGFuZCBpcyByZWFkeSB0byBiZSBzZXJ2ZWQgdG8gU3F1aXJyZWxcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoVXBkYXRlRG93bmxvYWRlZChldmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXV0b0luc3RhbGxPbkFwcFF1aXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYXRpdmVVcGRhdGVyLm9uY2UoXCJlcnJvclwiLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgdHJpZ2dlciBmZXRjaGluZyBhbmQgaW5zdGFsbGluZyB0aGUgZmlsZSBvbiBTcXVpcnJlbCBzaWRlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmF0aXZlVXBkYXRlci5jaGVja0ZvclVwZGF0ZXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoW10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcXVpdEFuZEluc3RhbGwoKSB7XG4gICAgICAgIGlmICh0aGlzLnNxdWlycmVsRG93bmxvYWRlZFVwZGF0ZSkge1xuICAgICAgICAgICAgLy8gdXBkYXRlIGFscmVhZHkgZmV0Y2hlZCBieSBTcXVpcnJlbCwgaXQncyByZWFkeSB0byBpbnN0YWxsXG4gICAgICAgICAgICB0aGlzLm5hdGl2ZVVwZGF0ZXIucXVpdEFuZEluc3RhbGwoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHF1aXQgYW5kIGluc3RhbGwgYXMgc29vbiBhcyBTcXVpcnJlbCBnZXQgdGhlIHVwZGF0ZVxuICAgICAgICAgICAgdGhpcy5uYXRpdmVVcGRhdGVyLm9uKFwidXBkYXRlLWRvd25sb2FkZWRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubmF0aXZlVXBkYXRlci5xdWl0QW5kSW5zdGFsbCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLk1hY1VwZGF0ZXIgPSBNYWNVcGRhdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWFjVXBkYXRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR2VuZXJpY0RpZmZlcmVudGlhbERvd25sb2FkZXIgPSB2b2lkIDA7XG5jb25zdCBEaWZmZXJlbnRpYWxEb3dubG9hZGVyXzEgPSByZXF1aXJlKFwiLi9EaWZmZXJlbnRpYWxEb3dubG9hZGVyXCIpO1xuY2xhc3MgR2VuZXJpY0RpZmZlcmVudGlhbERvd25sb2FkZXIgZXh0ZW5kcyBEaWZmZXJlbnRpYWxEb3dubG9hZGVyXzEuRGlmZmVyZW50aWFsRG93bmxvYWRlciB7XG4gICAgZG93bmxvYWQob2xkQmxvY2tNYXAsIG5ld0Jsb2NrTWFwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvRG93bmxvYWQob2xkQmxvY2tNYXAsIG5ld0Jsb2NrTWFwKTtcbiAgICB9XG59XG5leHBvcnRzLkdlbmVyaWNEaWZmZXJlbnRpYWxEb3dubG9hZGVyID0gR2VuZXJpY0RpZmZlcmVudGlhbERvd25sb2FkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HZW5lcmljRGlmZmVyZW50aWFsRG93bmxvYWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmVyaWZ5U2lnbmF0dXJlID0gdm9pZCAwO1xuY29uc3QgYnVpbGRlcl91dGlsX3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZVwiKTtcbmNvbnN0IGNoaWxkX3Byb2Nlc3NfMSA9IHJlcXVpcmUoXCJjaGlsZF9wcm9jZXNzXCIpO1xuY29uc3Qgb3MgPSByZXF1aXJlKFwib3NcIik7XG4vLyAkY2VydGlmaWNhdGVJbmZvID0gKEdldC1BdXRoZW50aWNvZGVTaWduYXR1cmUgJ3h4eFxceXl5LmV4ZSdcbi8vIHwgd2hlcmUgeyRfLlN0YXR1cy5FcXVhbHMoW1N5c3RlbS5NYW5hZ2VtZW50LkF1dG9tYXRpb24uU2lnbmF0dXJlU3RhdHVzXTo6VmFsaWQpIC1hbmQgJF8uU2lnbmVyQ2VydGlmaWNhdGUuU3ViamVjdC5Db250YWlucyhcIkNOPXNpZW1lbnMuY29tXCIpfSlcbi8vIHwgT3V0LVN0cmluZyA7IGlmICgkY2VydGlmaWNhdGVJbmZvKSB7IGV4aXQgMCB9IGVsc2UgeyBleGl0IDEgfVxuZnVuY3Rpb24gdmVyaWZ5U2lnbmF0dXJlKHB1Ymxpc2hlck5hbWVzLCB1bmVzY2FwZWRUZW1wVXBkYXRlRmlsZSwgbG9nZ2VyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAvLyBFc2NhcGUgcXVvdGVzIGFuZCBiYWNrdGlja3MgaW4gZmlsZW5hbWVzIHRvIHByZXZlbnQgdXNlciBmcm9tIGJyZWFraW5nIHRoZVxuICAgICAgICAvLyBhcmd1bWVudHMgYW5kIHBlcmZvcm0gYSByZW1vdGUgY29tbWFuZCBpbmplY3Rpb24uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIENvbnNpZGVyIGV4YW1wbGUgcG93ZXJzaGVsbCBjb21tYW5kOlxuICAgICAgICAvLyBgYGBwb3dlcnNoZWxsXG4gICAgICAgIC8vIEdldC1BdXRoZW50aWNvZGVTaWduYXR1cmUgJ0M6XFxcXHBhdGhcXFxcbXktYmFkLSc7Y2FsYzsnZmlsZW5hbWUuZXhlJ1xuICAgICAgICAvLyBgYGBcbiAgICAgICAgLy8gVGhlIGFib3ZlIHdvdWxkIHdvcmsgZXhwZWN0ZWQgYW5kIGZpbmQgdGhlIGZpbGUgbmFtZSwgaG93ZXZlciwgaXQgd2lsbCBhbHNvIGV4ZWN1dGUgYDtjYWxjO2BcbiAgICAgICAgLy8gY29tbWFuZCBhbmQgc3RhcnQgdGhlIGNhbGN1bGF0b3IgYXBwLlxuICAgICAgICAvL1xuICAgICAgICAvLyBGcm9tIFBvd2Vyc2hlbGwgcXVvdGluZyBydWxlczpcbiAgICAgICAgLy8gaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvcG93ZXJzaGVsbC9tb2R1bGUvbWljcm9zb2Z0LnBvd2Vyc2hlbGwuY29yZS9hYm91dC9hYm91dF9xdW90aW5nX3J1bGVzP3ZpZXc9cG93ZXJzaGVsbC03XG4gICAgICAgIC8vICogRG91YmxlIHF1b3RlcyBgXCJgIGFyZSB0cmVhdGVkIGxpdGVyYWxseSB3aXRoaW4gc2luZ2xlLXF1b3RlZCBzdHJpbmdzO1xuICAgICAgICAvLyAqIFNpbmdsZSBxdW90ZXMgY2FuIGJlIGVzY2FwZWQgYnkgZG91YmxpbmcgdGhlbTogJ2RvbicndCcgLT4gZG9uJ3Q7XG4gICAgICAgIC8vICogQmFja3RpY2tzIGNhbiBiZSBlc2NhcGVkIGJ5IGRvdWJsaW5nIHRoZW06ICdBIGJhY2t0aWNrIChgYCkgY2hhcmFjdGVyJztcbiAgICAgICAgLy9cbiAgICAgICAgLy8gQWxzbyBub3RlIHRoYXQgYXQgdGhpcyBwb2ludCB0aGUgZmlsZSBoYXMgYWxyZWFkeSBiZWVuIHdyaXR0ZW4gdG8gdGhlIGRpc2ssIHRodXMgd2UgYXJlXG4gICAgICAgIC8vIGd1YXJhbnRlZWQgdGhhdCB0aGUgcGF0aCB3aWxsIG5vdCBjb250YWluIGFueSBpbGxlZ2FsIGNoYXJhY3RlcnMgbGlrZSA8PjpcIi9cXHw/KlxuICAgICAgICAvLyBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy93aW5kb3dzL3dpbjMyL2ZpbGVpby9uYW1pbmctYS1maWxlXG4gICAgICAgIGNvbnN0IHRlbXBVcGRhdGVGaWxlID0gdW5lc2NhcGVkVGVtcFVwZGF0ZUZpbGUucmVwbGFjZSgvJy9nLCBcIicnXCIpLnJlcGxhY2UoL2AvZywgXCJgYFwiKTtcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2VsZWN0cm9uLXVzZXJsYW5kL2VsZWN0cm9uLWJ1aWxkZXIvaXNzdWVzLzI0MjFcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2VsZWN0cm9uLXVzZXJsYW5kL2VsZWN0cm9uLWJ1aWxkZXIvaXNzdWVzLzI1MzVcbiAgICAgICAgY2hpbGRfcHJvY2Vzc18xLmV4ZWNGaWxlKFwicG93ZXJzaGVsbC5leGVcIiwgW1xuICAgICAgICAgICAgXCItTm9Qcm9maWxlXCIsXG4gICAgICAgICAgICBcIi1Ob25JbnRlcmFjdGl2ZVwiLFxuICAgICAgICAgICAgXCItSW5wdXRGb3JtYXRcIixcbiAgICAgICAgICAgIFwiTm9uZVwiLFxuICAgICAgICAgICAgXCItQ29tbWFuZFwiLFxuICAgICAgICAgICAgYEdldC1BdXRoZW50aWNvZGVTaWduYXR1cmUgJyR7dGVtcFVwZGF0ZUZpbGV9JyB8IENvbnZlcnRUby1Kc29uIC1Db21wcmVzcyB8IEZvckVhY2gtT2JqZWN0IHsgW0NvbnZlcnRdOjpUb0Jhc2U2NFN0cmluZyhbU3lzdGVtLlRleHQuRW5jb2RpbmddOjpVVEY4LkdldEJ5dGVzKCRfKSkgfWAsXG4gICAgICAgIF0sIHtcbiAgICAgICAgICAgIHRpbWVvdXQ6IDIwICogMTAwMCxcbiAgICAgICAgfSwgKGVycm9yLCBzdGRvdXQsIHN0ZGVycikgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgIT0gbnVsbCB8fCBzdGRlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IobG9nZ2VyLCBlcnJvciwgc3RkZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gcGFyc2VPdXQoQnVmZmVyLmZyb20oc3Rkb3V0LCBcImJhc2U2NFwiKS50b1N0cmluZyhcInV0Zi04XCIpKTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5TdGF0dXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEucGFyc2VEbihkYXRhLlNpZ25lckNlcnRpZmljYXRlLlN1YmplY3QpLmdldChcIkNOXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHVibGlzaGVyTmFtZXMuaW5jbHVkZXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYHB1Ymxpc2hlck5hbWVzOiAke3B1Ymxpc2hlck5hbWVzLmpvaW4oXCIgfCBcIil9LCByYXcgaW5mbzogYCArIEpTT04uc3RyaW5naWZ5KGRhdGEsIChuYW1lLCB2YWx1ZSkgPT4gKG5hbWUgPT09IFwiUmF3RGF0YVwiID8gdW5kZWZpbmVkIDogdmFsdWUpLCAyKTtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgU2lnbiB2ZXJpZmljYXRpb24gZmFpbGVkLCBpbnN0YWxsZXIgc2lnbmVkIHdpdGggaW5jb3JyZWN0IGNlcnRpZmljYXRlOiAke3Jlc3VsdH1gKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBDYW5ub3QgZXhlY3V0ZSBHZXQtQXV0aGVudGljb2RlU2lnbmF0dXJlOiAke2Vycm9yfS4gSWdub3Jpbmcgc2lnbmF0dXJlIHZhbGlkYXRpb24gZHVlIHRvIHVua25vd24gZXJyb3IuYCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy52ZXJpZnlTaWduYXR1cmUgPSB2ZXJpZnlTaWduYXR1cmU7XG5mdW5jdGlvbiBwYXJzZU91dChvdXQpIHtcbiAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShvdXQpO1xuICAgIGRlbGV0ZSBkYXRhLlByaXZhdGVLZXk7XG4gICAgZGVsZXRlIGRhdGEuSXNPU0JpbmFyeTtcbiAgICBkZWxldGUgZGF0YS5TaWduYXR1cmVUeXBlO1xuICAgIGNvbnN0IHNpZ25lckNlcnRpZmljYXRlID0gZGF0YS5TaWduZXJDZXJ0aWZpY2F0ZTtcbiAgICBpZiAoc2lnbmVyQ2VydGlmaWNhdGUgIT0gbnVsbCkge1xuICAgICAgICBkZWxldGUgc2lnbmVyQ2VydGlmaWNhdGUuQXJjaGl2ZWQ7XG4gICAgICAgIGRlbGV0ZSBzaWduZXJDZXJ0aWZpY2F0ZS5FeHRlbnNpb25zO1xuICAgICAgICBkZWxldGUgc2lnbmVyQ2VydGlmaWNhdGUuSGFuZGxlO1xuICAgICAgICBkZWxldGUgc2lnbmVyQ2VydGlmaWNhdGUuSGFzUHJpdmF0ZUtleTtcbiAgICAgICAgLy8gZHVwbGljYXRlcyBkYXRhLlNpZ25lckNlcnRpZmljYXRlIChjb250YWlucyBSYXdEYXRhKVxuICAgICAgICBkZWxldGUgc2lnbmVyQ2VydGlmaWNhdGUuU3ViamVjdE5hbWU7XG4gICAgfVxuICAgIGRlbGV0ZSBkYXRhLlBhdGg7XG4gICAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiBoYW5kbGVFcnJvcihsb2dnZXIsIGVycm9yLCBzdGRlcnIpIHtcbiAgICBpZiAoaXNPbGRXaW42KCkpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oYENhbm5vdCBleGVjdXRlIEdldC1BdXRoZW50aWNvZGVTaWduYXR1cmU6ICR7ZXJyb3IgfHwgc3RkZXJyfS4gSWdub3Jpbmcgc2lnbmF0dXJlIHZhbGlkYXRpb24gZHVlIHRvIHVuc3VwcG9ydGVkIHBvd2Vyc2hlbGwgdmVyc2lvbi4gUGxlYXNlIHVwZ3JhZGUgdG8gcG93ZXJzaGVsbCAzIG9yIGhpZ2hlci5gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBjaGlsZF9wcm9jZXNzXzEuZXhlY0ZpbGVTeW5jKFwicG93ZXJzaGVsbC5leGVcIiwgW1wiLU5vUHJvZmlsZVwiLCBcIi1Ob25JbnRlcmFjdGl2ZVwiLCBcIi1Db21tYW5kXCIsIFwiQ29udmVydFRvLUpzb24gdGVzdFwiXSwgeyB0aW1lb3V0OiAxMCAqIDEwMDAgfSk7XG4gICAgfVxuICAgIGNhdGNoICh0ZXN0RXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oYENhbm5vdCBleGVjdXRlIENvbnZlcnRUby1Kc29uOiAke3Rlc3RFcnJvci5tZXNzYWdlfS4gSWdub3Jpbmcgc2lnbmF0dXJlIHZhbGlkYXRpb24gZHVlIHRvIHVuc3VwcG9ydGVkIHBvd2Vyc2hlbGwgdmVyc2lvbi4gUGxlYXNlIHVwZ3JhZGUgdG8gcG93ZXJzaGVsbCAzIG9yIGhpZ2hlci5gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXJyb3IgIT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKHN0ZGVycikge1xuICAgICAgICBsb2dnZXIud2FybihgQ2Fubm90IGV4ZWN1dGUgR2V0LUF1dGhlbnRpY29kZVNpZ25hdHVyZSwgc3RkZXJyOiAke3N0ZGVycn0uIElnbm9yaW5nIHNpZ25hdHVyZSB2YWxpZGF0aW9uIGR1ZSB0byB1bmtub3duIHN0ZGVyci5gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzT2xkV2luNigpIHtcbiAgICBjb25zdCB3aW5WZXJzaW9uID0gb3MucmVsZWFzZSgpO1xuICAgIHJldHVybiB3aW5WZXJzaW9uLnN0YXJ0c1dpdGgoXCI2LlwiKSAmJiAhd2luVmVyc2lvbi5zdGFydHNXaXRoKFwiNi4zXCIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2luZG93c0V4ZWN1dGFibGVDb2RlU2lnbmF0dXJlVmVyaWZpZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5zaXNVcGRhdGVyID0gdm9pZCAwO1xuY29uc3QgYnVpbGRlcl91dGlsX3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZVwiKTtcbmNvbnN0IGNoaWxkX3Byb2Nlc3NfMSA9IHJlcXVpcmUoXCJjaGlsZF9wcm9jZXNzXCIpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgQmFzZVVwZGF0ZXJfMSA9IHJlcXVpcmUoXCIuL0Jhc2VVcGRhdGVyXCIpO1xuY29uc3QgRmlsZVdpdGhFbWJlZGRlZEJsb2NrTWFwRGlmZmVyZW50aWFsRG93bmxvYWRlcl8xID0gcmVxdWlyZShcIi4vZGlmZmVyZW50aWFsRG93bmxvYWRlci9GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyXCIpO1xuY29uc3QgR2VuZXJpY0RpZmZlcmVudGlhbERvd25sb2FkZXJfMSA9IHJlcXVpcmUoXCIuL2RpZmZlcmVudGlhbERvd25sb2FkZXIvR2VuZXJpY0RpZmZlcmVudGlhbERvd25sb2FkZXJcIik7XG5jb25zdCBtYWluXzEgPSByZXF1aXJlKFwiLi9tYWluXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IFByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlcnMvUHJvdmlkZXJcIik7XG5jb25zdCBmc19leHRyYV8xID0gcmVxdWlyZShcImZzLWV4dHJhXCIpO1xuY29uc3Qgd2luZG93c0V4ZWN1dGFibGVDb2RlU2lnbmF0dXJlVmVyaWZpZXJfMSA9IHJlcXVpcmUoXCIuL3dpbmRvd3NFeGVjdXRhYmxlQ29kZVNpZ25hdHVyZVZlcmlmaWVyXCIpO1xuY29uc3QgdXJsXzEgPSByZXF1aXJlKFwidXJsXCIpO1xuY29uc3QgemxpYl8xID0gcmVxdWlyZShcInpsaWJcIik7XG5jbGFzcyBOc2lzVXBkYXRlciBleHRlbmRzIEJhc2VVcGRhdGVyXzEuQmFzZVVwZGF0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGFwcCkge1xuICAgICAgICBzdXBlcihvcHRpb25zLCBhcHApO1xuICAgIH1cbiAgICAvKioqIEBwcml2YXRlICovXG4gICAgZG9Eb3dubG9hZFVwZGF0ZShkb3dubG9hZFVwZGF0ZU9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBkb3dubG9hZFVwZGF0ZU9wdGlvbnMudXBkYXRlSW5mb0FuZFByb3ZpZGVyLnByb3ZpZGVyO1xuICAgICAgICBjb25zdCBmaWxlSW5mbyA9IFByb3ZpZGVyXzEuZmluZEZpbGUocHJvdmlkZXIucmVzb2x2ZUZpbGVzKGRvd25sb2FkVXBkYXRlT3B0aW9ucy51cGRhdGVJbmZvQW5kUHJvdmlkZXIuaW5mbyksIFwiZXhlXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlRG93bmxvYWQoe1xuICAgICAgICAgICAgZmlsZUV4dGVuc2lvbjogXCJleGVcIixcbiAgICAgICAgICAgIGRvd25sb2FkVXBkYXRlT3B0aW9ucyxcbiAgICAgICAgICAgIGZpbGVJbmZvLFxuICAgICAgICAgICAgdGFzazogYXN5bmMgKGRlc3RpbmF0aW9uRmlsZSwgZG93bmxvYWRPcHRpb25zLCBwYWNrYWdlRmlsZSwgcmVtb3ZlVGVtcERpcklmQW55KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFja2FnZUluZm8gPSBmaWxlSW5mby5wYWNrYWdlSW5mbztcbiAgICAgICAgICAgICAgICBjb25zdCBpc1dlYkluc3RhbGxlciA9IHBhY2thZ2VJbmZvICE9IG51bGwgJiYgcGFja2FnZUZpbGUgIT0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoaXNXZWJJbnN0YWxsZXIgfHwgKGF3YWl0IHRoaXMuZGlmZmVyZW50aWFsRG93bmxvYWRJbnN0YWxsZXIoZmlsZUluZm8sIGRvd25sb2FkVXBkYXRlT3B0aW9ucywgZGVzdGluYXRpb25GaWxlLCBwcm92aWRlcikpKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuaHR0cEV4ZWN1dG9yLmRvd25sb2FkKGZpbGVJbmZvLnVybCwgZGVzdGluYXRpb25GaWxlLCBkb3dubG9hZE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzaWduYXR1cmVWZXJpZmljYXRpb25TdGF0dXMgPSBhd2FpdCB0aGlzLnZlcmlmeVNpZ25hdHVyZShkZXN0aW5hdGlvbkZpbGUpO1xuICAgICAgICAgICAgICAgIGlmIChzaWduYXR1cmVWZXJpZmljYXRpb25TdGF0dXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCByZW1vdmVUZW1wRGlySWZBbnkoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9pbnNwZWN0aW9uIFRocm93SW5zaWRlRmluYWxseUJsb2NrSlNcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5uZXdFcnJvcihgTmV3IHZlcnNpb24gJHtkb3dubG9hZFVwZGF0ZU9wdGlvbnMudXBkYXRlSW5mb0FuZFByb3ZpZGVyLmluZm8udmVyc2lvbn0gaXMgbm90IHNpZ25lZCBieSB0aGUgYXBwbGljYXRpb24gb3duZXI6ICR7c2lnbmF0dXJlVmVyaWZpY2F0aW9uU3RhdHVzfWAsIFwiRVJSX1VQREFURVJfSU5WQUxJRF9TSUdOQVRVUkVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1dlYkluc3RhbGxlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXdhaXQgdGhpcy5kaWZmZXJlbnRpYWxEb3dubG9hZFdlYlBhY2thZ2UoZG93bmxvYWRVcGRhdGVPcHRpb25zLCBwYWNrYWdlSW5mbywgcGFja2FnZUZpbGUsIHByb3ZpZGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmh0dHBFeGVjdXRvci5kb3dubG9hZChuZXcgdXJsXzEuVVJMKHBhY2thZ2VJbmZvLnBhdGgpLCBwYWNrYWdlRmlsZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBkb3dubG9hZFVwZGF0ZU9wdGlvbnMucmVxdWVzdEhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbGxhdGlvblRva2VuOiBkb3dubG9hZFVwZGF0ZU9wdGlvbnMuY2FuY2VsbGF0aW9uVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYTUxMjogcGFja2FnZUluZm8uc2hhNTEyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBmc19leHRyYV8xLnVubGluayhwYWNrYWdlRmlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vICRjZXJ0aWZpY2F0ZUluZm8gPSAoR2V0LUF1dGhlbnRpY29kZVNpZ25hdHVyZSAneHh4XFx5eXkuZXhlJ1xuICAgIC8vIHwgd2hlcmUgeyRfLlN0YXR1cy5FcXVhbHMoW1N5c3RlbS5NYW5hZ2VtZW50LkF1dG9tYXRpb24uU2lnbmF0dXJlU3RhdHVzXTo6VmFsaWQpIC1hbmQgJF8uU2lnbmVyQ2VydGlmaWNhdGUuU3ViamVjdC5Db250YWlucyhcIkNOPXNpZW1lbnMuY29tXCIpfSlcbiAgICAvLyB8IE91dC1TdHJpbmcgOyBpZiAoJGNlcnRpZmljYXRlSW5mbykgeyBleGl0IDAgfSBlbHNlIHsgZXhpdCAxIH1cbiAgICBhc3luYyB2ZXJpZnlTaWduYXR1cmUodGVtcFVwZGF0ZUZpbGUpIHtcbiAgICAgICAgbGV0IHB1Ymxpc2hlck5hbWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwdWJsaXNoZXJOYW1lID0gKGF3YWl0IHRoaXMuY29uZmlnT25EaXNrLnZhbHVlKS5wdWJsaXNoZXJOYW1lO1xuICAgICAgICAgICAgaWYgKHB1Ymxpc2hlck5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZS5jb2RlID09PSBcIkVOT0VOVFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gYXBwLXVwZGF0ZS55bWxcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHdpbmRvd3NFeGVjdXRhYmxlQ29kZVNpZ25hdHVyZVZlcmlmaWVyXzEudmVyaWZ5U2lnbmF0dXJlKEFycmF5LmlzQXJyYXkocHVibGlzaGVyTmFtZSkgPyBwdWJsaXNoZXJOYW1lIDogW3B1Ymxpc2hlck5hbWVdLCB0ZW1wVXBkYXRlRmlsZSwgdGhpcy5fbG9nZ2VyKTtcbiAgICB9XG4gICAgZG9JbnN0YWxsKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IFtcIi0tdXBkYXRlZFwiXTtcbiAgICAgICAgaWYgKG9wdGlvbnMuaXNTaWxlbnQpIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChcIi9TXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmlzRm9yY2VSdW5BZnRlcikge1xuICAgICAgICAgICAgYXJncy5wdXNoKFwiLS1mb3JjZS1ydW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFja2FnZVBhdGggPSB0aGlzLmRvd25sb2FkZWRVcGRhdGVIZWxwZXIgPT0gbnVsbCA/IG51bGwgOiB0aGlzLmRvd25sb2FkZWRVcGRhdGVIZWxwZXIucGFja2FnZUZpbGU7XG4gICAgICAgIGlmIChwYWNrYWdlUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBvbmx5ID0gZm9ybSBpcyBzdXBwb3J0ZWRcbiAgICAgICAgICAgIGFyZ3MucHVzaChgLS1wYWNrYWdlLWZpbGU9JHtwYWNrYWdlUGF0aH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWxsVXNpbmdFbGV2YXRpb24gPSAoKSA9PiB7XG4gICAgICAgICAgICBfc3Bhd24ocGF0aC5qb2luKHByb2Nlc3MucmVzb3VyY2VzUGF0aCwgXCJlbGV2YXRlLmV4ZVwiKSwgW29wdGlvbnMuaW5zdGFsbGVyUGF0aF0uY29uY2F0KGFyZ3MpKS5jYXRjaChlID0+IHRoaXMuZGlzcGF0Y2hFcnJvcihlKSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zLmlzQWRtaW5SaWdodHNSZXF1aXJlZCkge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCJpc0FkbWluUmlnaHRzUmVxdWlyZWQgaXMgc2V0IHRvIHRydWUsIHJ1biBpbnN0YWxsZXIgdXNpbmcgZWxldmF0ZS5leGVcIik7XG4gICAgICAgICAgICBjYWxsVXNpbmdFbGV2YXRpb24oKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIF9zcGF3bihvcHRpb25zLmluc3RhbGxlclBhdGgsIGFyZ3MpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZWxlY3Ryb24tdXNlcmxhbmQvZWxlY3Ryb24tYnVpbGRlci9pc3N1ZXMvMTEyOVxuICAgICAgICAgICAgLy8gTm9kZSA4IHNlbmRzIGVycm9yczogaHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0LXY4LngvZG9jcy9hcGkvZXJyb3JzLmh0bWwjZXJyb3JzX2NvbW1vbl9zeXN0ZW1fZXJyb3JzXG4gICAgICAgICAgICBjb25zdCBlcnJvckNvZGUgPSBlLmNvZGU7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhgQ2Fubm90IHJ1biBpbnN0YWxsZXI6IGVycm9yIGNvZGU6ICR7ZXJyb3JDb2RlfSwgZXJyb3IgbWVzc2FnZTogXCIke2UubWVzc2FnZX1cIiwgd2lsbCBiZSBleGVjdXRlZCBhZ2FpbiB1c2luZyBlbGV2YXRlIGlmIEVBQ0NFU1wiYCk7XG4gICAgICAgICAgICBpZiAoZXJyb3JDb2RlID09PSBcIlVOS05PV05cIiB8fCBlcnJvckNvZGUgPT09IFwiRUFDQ0VTXCIpIHtcbiAgICAgICAgICAgICAgICBjYWxsVXNpbmdFbGV2YXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBhc3luYyBkaWZmZXJlbnRpYWxEb3dubG9hZEluc3RhbGxlcihmaWxlSW5mbywgZG93bmxvYWRVcGRhdGVPcHRpb25zLCBpbnN0YWxsZXJQYXRoLCBwcm92aWRlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Rlc3RPbmx5T3B0aW9ucyAhPSBudWxsICYmICF0aGlzLl90ZXN0T25seU9wdGlvbnMuaXNVc2VEaWZmZXJlbnRpYWxEb3dubG9hZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYmxvY2ttYXBGaWxlVXJscyA9IHV0aWxfMS5ibG9ja21hcEZpbGVzKGZpbGVJbmZvLnVybCwgdGhpcy5hcHAudmVyc2lvbiwgZG93bmxvYWRVcGRhdGVPcHRpb25zLnVwZGF0ZUluZm9BbmRQcm92aWRlci5pbmZvLnZlcnNpb24pO1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oYERvd25sb2FkIGJsb2NrIG1hcHMgKG9sZDogXCIke2Jsb2NrbWFwRmlsZVVybHNbMF19XCIsIG5ldzogJHtibG9ja21hcEZpbGVVcmxzWzFdfSlgKTtcbiAgICAgICAgICAgIGNvbnN0IGRvd25sb2FkQmxvY2tNYXAgPSBhc3luYyAodXJsKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuaHR0cEV4ZWN1dG9yLmRvd25sb2FkVG9CdWZmZXIodXJsLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGRvd25sb2FkVXBkYXRlT3B0aW9ucy5yZXF1ZXN0SGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGF0aW9uVG9rZW46IGRvd25sb2FkVXBkYXRlT3B0aW9ucy5jYW5jZWxsYXRpb25Ub2tlbixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSA9PSBudWxsIHx8IGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQmxvY2ttYXAgXCIke3VybC5ocmVmfVwiIGlzIGVtcHR5YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHpsaWJfMS5ndW56aXBTeW5jKGRhdGEpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBwYXJzZSBibG9ja21hcCBcIiR7dXJsLmhyZWZ9XCIsIGVycm9yOiAke2V9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGRvd25sb2FkT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBuZXdVcmw6IGZpbGVJbmZvLnVybCxcbiAgICAgICAgICAgICAgICBvbGRGaWxlOiBwYXRoLmpvaW4odGhpcy5kb3dubG9hZGVkVXBkYXRlSGVscGVyLmNhY2hlRGlyLCBidWlsZGVyX3V0aWxfcnVudGltZV8xLkNVUlJFTlRfQVBQX0lOU1RBTExFUl9GSUxFX05BTUUpLFxuICAgICAgICAgICAgICAgIGxvZ2dlcjogdGhpcy5fbG9nZ2VyLFxuICAgICAgICAgICAgICAgIG5ld0ZpbGU6IGluc3RhbGxlclBhdGgsXG4gICAgICAgICAgICAgICAgaXNVc2VNdWx0aXBsZVJhbmdlUmVxdWVzdDogcHJvdmlkZXIuaXNVc2VNdWx0aXBsZVJhbmdlUmVxdWVzdCxcbiAgICAgICAgICAgICAgICByZXF1ZXN0SGVhZGVyczogZG93bmxvYWRVcGRhdGVPcHRpb25zLnJlcXVlc3RIZWFkZXJzLFxuICAgICAgICAgICAgICAgIGNhbmNlbGxhdGlvblRva2VuOiBkb3dubG9hZFVwZGF0ZU9wdGlvbnMuY2FuY2VsbGF0aW9uVG9rZW4sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMubGlzdGVuZXJDb3VudChtYWluXzEuRE9XTkxPQURfUFJPR1JFU1MpID4gMCkge1xuICAgICAgICAgICAgICAgIGRvd25sb2FkT3B0aW9ucy5vblByb2dyZXNzID0gaXQgPT4gdGhpcy5lbWl0KG1haW5fMS5ET1dOTE9BRF9QUk9HUkVTUywgaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYmxvY2tNYXBEYXRhTGlzdCA9IGF3YWl0IFByb21pc2UuYWxsKGJsb2NrbWFwRmlsZVVybHMubWFwKHUgPT4gZG93bmxvYWRCbG9ja01hcCh1KSkpO1xuICAgICAgICAgICAgYXdhaXQgbmV3IEdlbmVyaWNEaWZmZXJlbnRpYWxEb3dubG9hZGVyXzEuR2VuZXJpY0RpZmZlcmVudGlhbERvd25sb2FkZXIoZmlsZUluZm8uaW5mbywgdGhpcy5odHRwRXhlY3V0b3IsIGRvd25sb2FkT3B0aW9ucykuZG93bmxvYWQoYmxvY2tNYXBEYXRhTGlzdFswXSwgYmxvY2tNYXBEYXRhTGlzdFsxXSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihgQ2Fubm90IGRvd25sb2FkIGRpZmZlcmVudGlhbGx5LCBmYWxsYmFjayB0byBmdWxsIGRvd25sb2FkOiAke2Uuc3RhY2sgfHwgZX1gKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl90ZXN0T25seU9wdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHRlc3QgbW9kZVxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBkaWZmZXJlbnRpYWxEb3dubG9hZFdlYlBhY2thZ2UoZG93bmxvYWRVcGRhdGVPcHRpb25zLCBwYWNrYWdlSW5mbywgcGFja2FnZVBhdGgsIHByb3ZpZGVyKSB7XG4gICAgICAgIGlmIChwYWNrYWdlSW5mby5ibG9ja01hcFNpemUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRvd25sb2FkT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBuZXdVcmw6IG5ldyB1cmxfMS5VUkwocGFja2FnZUluZm8ucGF0aCksXG4gICAgICAgICAgICAgICAgb2xkRmlsZTogcGF0aC5qb2luKHRoaXMuZG93bmxvYWRlZFVwZGF0ZUhlbHBlci5jYWNoZURpciwgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5DVVJSRU5UX0FQUF9QQUNLQUdFX0ZJTEVfTkFNRSksXG4gICAgICAgICAgICAgICAgbG9nZ2VyOiB0aGlzLl9sb2dnZXIsXG4gICAgICAgICAgICAgICAgbmV3RmlsZTogcGFja2FnZVBhdGgsXG4gICAgICAgICAgICAgICAgcmVxdWVzdEhlYWRlcnM6IHRoaXMucmVxdWVzdEhlYWRlcnMsXG4gICAgICAgICAgICAgICAgaXNVc2VNdWx0aXBsZVJhbmdlUmVxdWVzdDogcHJvdmlkZXIuaXNVc2VNdWx0aXBsZVJhbmdlUmVxdWVzdCxcbiAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25Ub2tlbjogZG93bmxvYWRVcGRhdGVPcHRpb25zLmNhbmNlbGxhdGlvblRva2VuLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpc3RlbmVyQ291bnQobWFpbl8xLkRPV05MT0FEX1BST0dSRVNTKSA+IDApIHtcbiAgICAgICAgICAgICAgICBkb3dubG9hZE9wdGlvbnMub25Qcm9ncmVzcyA9IGl0ID0+IHRoaXMuZW1pdChtYWluXzEuRE9XTkxPQURfUFJPR1JFU1MsIGl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IG5ldyBGaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyXzEuRmlsZVdpdGhFbWJlZGRlZEJsb2NrTWFwRGlmZmVyZW50aWFsRG93bmxvYWRlcihwYWNrYWdlSW5mbywgdGhpcy5odHRwRXhlY3V0b3IsIGRvd25sb2FkT3B0aW9ucykuZG93bmxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGBDYW5ub3QgZG93bmxvYWQgZGlmZmVyZW50aWFsbHksIGZhbGxiYWNrIHRvIGZ1bGwgZG93bmxvYWQ6ICR7ZS5zdGFjayB8fCBlfWApO1xuICAgICAgICAgICAgLy8gZHVyaW5nIHRlc3QgKGRldmVsb3BlciBtYWNoaW5lIG1hYyBvciBsaW51eCkgd2UgbXVzdCB0aHJvdyBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3MucGxhdGZvcm0gPT09IFwid2luMzJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5Oc2lzVXBkYXRlciA9IE5zaXNVcGRhdGVyO1xuLyoqXG4gKiBUaGlzIGhhbmRsZXMgYm90aCBub2RlIDggYW5kIG5vZGUgMTAgd2F5IG9mIGVtaXR0aW5nIGVycm9yIHdoZW4gc3Bhd25pbmcgYSBwcm9jZXNzXG4gKiAgIC0gbm9kZSA4OiBUaHJvd3MgdGhlIGVycm9yXG4gKiAgIC0gbm9kZSAxMDogRW1pdCB0aGUgZXJyb3IoTmVlZCB0byBsaXN0ZW4gd2l0aCBvbilcbiAqL1xuYXN5bmMgZnVuY3Rpb24gX3NwYXduKGV4ZSwgYXJncykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzID0gY2hpbGRfcHJvY2Vzc18xLnNwYXduKGV4ZSwgYXJncywge1xuICAgICAgICAgICAgICAgIGRldGFjaGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIHN0ZGlvOiBcImlnbm9yZVwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcm9jZXNzLm9uKFwiZXJyb3JcIiwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByb2Nlc3MudW5yZWYoKTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLnBpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5zaXNVcGRhdGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VcGRhdGVyU2lnbmFsID0gZXhwb3J0cy5VUERBVEVfRE9XTkxPQURFRCA9IGV4cG9ydHMuRE9XTkxPQURfUFJPR1JFU1MgPSBleHBvcnRzLk5zaXNVcGRhdGVyID0gZXhwb3J0cy5NYWNVcGRhdGVyID0gZXhwb3J0cy5BcHBJbWFnZVVwZGF0ZXIgPSBleHBvcnRzLlByb3ZpZGVyID0gZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlbiA9IGV4cG9ydHMuTm9PcExvZ2dlciA9IGV4cG9ydHMuQXBwVXBkYXRlciA9IHZvaWQgMDtcbmNvbnN0IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEgPSByZXF1aXJlKFwiYnVpbGRlci11dGlsLXJ1bnRpbWVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYW5jZWxsYXRpb25Ub2tlblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5DYW5jZWxsYXRpb25Ub2tlbjsgfSB9KTtcbnZhciBBcHBVcGRhdGVyXzEgPSByZXF1aXJlKFwiLi9BcHBVcGRhdGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXBwVXBkYXRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQXBwVXBkYXRlcl8xLkFwcFVwZGF0ZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb09wTG9nZ2VyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBBcHBVcGRhdGVyXzEuTm9PcExvZ2dlcjsgfSB9KTtcbnZhciBQcm92aWRlcl8xID0gcmVxdWlyZShcIi4vcHJvdmlkZXJzL1Byb3ZpZGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFByb3ZpZGVyXzEuUHJvdmlkZXI7IH0gfSk7XG52YXIgQXBwSW1hZ2VVcGRhdGVyXzEgPSByZXF1aXJlKFwiLi9BcHBJbWFnZVVwZGF0ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBcHBJbWFnZVVwZGF0ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEFwcEltYWdlVXBkYXRlcl8xLkFwcEltYWdlVXBkYXRlcjsgfSB9KTtcbnZhciBNYWNVcGRhdGVyXzEgPSByZXF1aXJlKFwiLi9NYWNVcGRhdGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWFjVXBkYXRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTWFjVXBkYXRlcl8xLk1hY1VwZGF0ZXI7IH0gfSk7XG52YXIgTnNpc1VwZGF0ZXJfMSA9IHJlcXVpcmUoXCIuL05zaXNVcGRhdGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTnNpc1VwZGF0ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5zaXNVcGRhdGVyXzEuTnNpc1VwZGF0ZXI7IH0gfSk7XG4vLyBhdXRvVXBkYXRlciB0byBtaW1pYyBlbGVjdHJvbiBidW5kbGVkIGF1dG9VcGRhdGVyXG5sZXQgX2F1dG9VcGRhdGVyO1xuZnVuY3Rpb24gZG9Mb2FkQXV0b1VwZGF0ZXIoKSB7XG4gICAgLy8gdHNsaW50OmRpc2FibGU6cHJlZmVyLWNvbmRpdGlvbmFsLWV4cHJlc3Npb25cbiAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiKSB7XG4gICAgICAgIF9hdXRvVXBkYXRlciA9IG5ldyAocmVxdWlyZShcIi4vTnNpc1VwZGF0ZXJcIikuTnNpc1VwZGF0ZXIpKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09IFwiZGFyd2luXCIpIHtcbiAgICAgICAgX2F1dG9VcGRhdGVyID0gbmV3IChyZXF1aXJlKFwiLi9NYWNVcGRhdGVyXCIpLk1hY1VwZGF0ZXIpKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBfYXV0b1VwZGF0ZXIgPSBuZXcgKHJlcXVpcmUoXCIuL0FwcEltYWdlVXBkYXRlclwiKS5BcHBJbWFnZVVwZGF0ZXIpKCk7XG4gICAgfVxuICAgIHJldHVybiBfYXV0b1VwZGF0ZXI7XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhdXRvVXBkYXRlclwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIF9hdXRvVXBkYXRlciB8fCBkb0xvYWRBdXRvVXBkYXRlcigpO1xuICAgIH0sXG59KTtcbmV4cG9ydHMuRE9XTkxPQURfUFJPR1JFU1MgPSBcImRvd25sb2FkLXByb2dyZXNzXCI7XG5leHBvcnRzLlVQREFURV9ET1dOTE9BREVEID0gXCJ1cGRhdGUtZG93bmxvYWRlZFwiO1xuY2xhc3MgVXBkYXRlclNpZ25hbCB7XG4gICAgY29uc3RydWN0b3IoZW1pdHRlcikge1xuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBlbWl0dGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4gYW4gYXV0aGVudGljYXRpbmcgcHJveHkgaXMgW2Fza2luZyBmb3IgdXNlciBjcmVkZW50aWFsc10oaHR0cHM6Ly9naXRodWIuY29tL2VsZWN0cm9uL2VsZWN0cm9uL2Jsb2IvbWFzdGVyL2RvY3MvYXBpL2NsaWVudC1yZXF1ZXN0Lm1kI2V2ZW50LWxvZ2luKS5cbiAgICAgKi9cbiAgICBsb2dpbihoYW5kbGVyKSB7XG4gICAgICAgIGFkZEhhbmRsZXIodGhpcy5lbWl0dGVyLCBcImxvZ2luXCIsIGhhbmRsZXIpO1xuICAgIH1cbiAgICBwcm9ncmVzcyhoYW5kbGVyKSB7XG4gICAgICAgIGFkZEhhbmRsZXIodGhpcy5lbWl0dGVyLCBleHBvcnRzLkRPV05MT0FEX1BST0dSRVNTLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgdXBkYXRlRG93bmxvYWRlZChoYW5kbGVyKSB7XG4gICAgICAgIGFkZEhhbmRsZXIodGhpcy5lbWl0dGVyLCBleHBvcnRzLlVQREFURV9ET1dOTE9BREVELCBoYW5kbGVyKTtcbiAgICB9XG4gICAgdXBkYXRlQ2FuY2VsbGVkKGhhbmRsZXIpIHtcbiAgICAgICAgYWRkSGFuZGxlcih0aGlzLmVtaXR0ZXIsIFwidXBkYXRlLWNhbmNlbGxlZFwiLCBoYW5kbGVyKTtcbiAgICB9XG59XG5leHBvcnRzLlVwZGF0ZXJTaWduYWwgPSBVcGRhdGVyU2lnbmFsO1xuY29uc3QgaXNMb2dFdmVudCA9IGZhbHNlO1xuZnVuY3Rpb24gYWRkSGFuZGxlcihlbWl0dGVyLCBldmVudCwgaGFuZGxlcikge1xuICAgIGlmIChpc0xvZ0V2ZW50KSB7XG4gICAgICAgIGVtaXR0ZXIub24oZXZlbnQsICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIiVzICVzXCIsIGV2ZW50LCBhcmdzKTtcbiAgICAgICAgICAgIGhhbmRsZXIoLi4uYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZW1pdHRlci5vbihldmVudCwgaGFuZGxlcik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFpbi5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gdmFsdWUgPT4ge1xuXHRjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXHRyZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IGlzT2JqID0gcmVxdWlyZSgnaXMtb2JqJyk7XG5cbmNvbnN0IGRpc2FsbG93ZWRLZXlzID0gbmV3IFNldChbXG5cdCdfX3Byb3RvX18nLFxuXHQncHJvdG90eXBlJyxcblx0J2NvbnN0cnVjdG9yJ1xuXSk7XG5cbmNvbnN0IGlzVmFsaWRQYXRoID0gcGF0aFNlZ21lbnRzID0+ICFwYXRoU2VnbWVudHMuc29tZShzZWdtZW50ID0+IGRpc2FsbG93ZWRLZXlzLmhhcyhzZWdtZW50KSk7XG5cbmZ1bmN0aW9uIGdldFBhdGhTZWdtZW50cyhwYXRoKSB7XG5cdGNvbnN0IHBhdGhBcnJheSA9IHBhdGguc3BsaXQoJy4nKTtcblx0Y29uc3QgcGFydHMgPSBbXTtcblxuXHRmb3IgKGxldCBpID0gMDsgaSA8IHBhdGhBcnJheS5sZW5ndGg7IGkrKykge1xuXHRcdGxldCBwID0gcGF0aEFycmF5W2ldO1xuXG5cdFx0d2hpbGUgKHBbcC5sZW5ndGggLSAxXSA9PT0gJ1xcXFwnICYmIHBhdGhBcnJheVtpICsgMV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cCA9IHAuc2xpY2UoMCwgLTEpICsgJy4nO1xuXHRcdFx0cCArPSBwYXRoQXJyYXlbKytpXTtcblx0XHR9XG5cblx0XHRwYXJ0cy5wdXNoKHApO1xuXHR9XG5cblx0aWYgKCFpc1ZhbGlkUGF0aChwYXJ0cykpIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblxuXHRyZXR1cm4gcGFydHM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRnZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuXHRcdGlmICghaXNPYmoob2JqZWN0KSB8fCB0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gb2JqZWN0IDogdmFsdWU7XG5cdFx0fVxuXG5cdFx0Y29uc3QgcGF0aEFycmF5ID0gZ2V0UGF0aFNlZ21lbnRzKHBhdGgpO1xuXHRcdGlmIChwYXRoQXJyYXkubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoQXJyYXkubGVuZ3RoOyBpKyspIHtcblx0XHRcdG9iamVjdCA9IG9iamVjdFtwYXRoQXJyYXlbaV1dO1xuXG5cdFx0XHRpZiAob2JqZWN0ID09PSB1bmRlZmluZWQgfHwgb2JqZWN0ID09PSBudWxsKSB7XG5cdFx0XHRcdC8vIGBvYmplY3RgIGlzIGVpdGhlciBgdW5kZWZpbmVkYCBvciBgbnVsbGAgc28gd2Ugd2FudCB0byBzdG9wIHRoZSBsb29wLCBhbmRcblx0XHRcdFx0Ly8gaWYgdGhpcyBpcyBub3QgdGhlIGxhc3QgYml0IG9mIHRoZSBwYXRoLCBhbmRcblx0XHRcdFx0Ly8gaWYgaXQgZGlkJ3QgcmV0dXJuIGB1bmRlZmluZWRgXG5cdFx0XHRcdC8vIGl0IHdvdWxkIHJldHVybiBgbnVsbGAgaWYgYG9iamVjdGAgaXMgYG51bGxgXG5cdFx0XHRcdC8vIGJ1dCB3ZSB3YW50IGBnZXQoe2ZvbzogbnVsbH0sICdmb28uYmFyJylgIHRvIGVxdWFsIGB1bmRlZmluZWRgLCBvciB0aGUgc3VwcGxpZWQgdmFsdWUsIG5vdCBgbnVsbGBcblx0XHRcdFx0aWYgKGkgIT09IHBhdGhBcnJheS5sZW5ndGggLSAxKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iamVjdCA9PT0gdW5kZWZpbmVkID8gdmFsdWUgOiBvYmplY3Q7XG5cdH0sXG5cblx0c2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpIHtcblx0XHRpZiAoIWlzT2JqKG9iamVjdCkgfHwgdHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gb2JqZWN0O1xuXHRcdH1cblxuXHRcdGNvbnN0IHJvb3QgPSBvYmplY3Q7XG5cdFx0Y29uc3QgcGF0aEFycmF5ID0gZ2V0UGF0aFNlZ21lbnRzKHBhdGgpO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoQXJyYXkubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IHAgPSBwYXRoQXJyYXlbaV07XG5cblx0XHRcdGlmICghaXNPYmoob2JqZWN0W3BdKSkge1xuXHRcdFx0XHRvYmplY3RbcF0gPSB7fTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGkgPT09IHBhdGhBcnJheS5sZW5ndGggLSAxKSB7XG5cdFx0XHRcdG9iamVjdFtwXSA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHRvYmplY3QgPSBvYmplY3RbcF07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJvb3Q7XG5cdH0sXG5cblx0ZGVsZXRlKG9iamVjdCwgcGF0aCkge1xuXHRcdGlmICghaXNPYmoob2JqZWN0KSB8fCB0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRjb25zdCBwYXRoQXJyYXkgPSBnZXRQYXRoU2VnbWVudHMocGF0aCk7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHBhdGhBcnJheS5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgcCA9IHBhdGhBcnJheVtpXTtcblxuXHRcdFx0aWYgKGkgPT09IHBhdGhBcnJheS5sZW5ndGggLSAxKSB7XG5cdFx0XHRcdGRlbGV0ZSBvYmplY3RbcF07XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRvYmplY3QgPSBvYmplY3RbcF07XG5cblx0XHRcdGlmICghaXNPYmoob2JqZWN0KSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGhhcyhvYmplY3QsIHBhdGgpIHtcblx0XHRpZiAoIWlzT2JqKG9iamVjdCkgfHwgdHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Y29uc3QgcGF0aEFycmF5ID0gZ2V0UGF0aFNlZ21lbnRzKHBhdGgpO1xuXHRcdGlmIChwYXRoQXJyYXkubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vbm8tZm9yLWxvb3Bcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHBhdGhBcnJheS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGlzT2JqKG9iamVjdCkpIHtcblx0XHRcdFx0aWYgKCEocGF0aEFycmF5W2ldIGluIG9iamVjdCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvYmplY3QgPSBvYmplY3RbcGF0aEFycmF5W2ldXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmcCA9PiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcblx0ZnMuYWNjZXNzKGZwLCBlcnIgPT4ge1xuXHRcdHJlc29sdmUoIWVycik7XG5cdH0pO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzLnN5bmMgPSBmcCA9PiB7XG5cdHRyeSB7XG5cdFx0ZnMuYWNjZXNzU3luYyhmcCk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgcFRyeSA9IChmbiwgLi4uYXJndW1lbnRzXykgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG5cdHJlc29sdmUoZm4oLi4uYXJndW1lbnRzXykpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcFRyeTtcbi8vIFRPRE86IHJlbW92ZSB0aGlzIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb25cbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBwVHJ5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgcFRyeSA9IHJlcXVpcmUoJ3AtdHJ5Jyk7XG5cbmNvbnN0IHBMaW1pdCA9IGNvbmN1cnJlbmN5ID0+IHtcblx0aWYgKCEoKE51bWJlci5pc0ludGVnZXIoY29uY3VycmVuY3kpIHx8IGNvbmN1cnJlbmN5ID09PSBJbmZpbml0eSkgJiYgY29uY3VycmVuY3kgPiAwKSkge1xuXHRcdHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBgY29uY3VycmVuY3lgIHRvIGJlIGEgbnVtYmVyIGZyb20gMSBhbmQgdXAnKSk7XG5cdH1cblxuXHRjb25zdCBxdWV1ZSA9IFtdO1xuXHRsZXQgYWN0aXZlQ291bnQgPSAwO1xuXG5cdGNvbnN0IG5leHQgPSAoKSA9PiB7XG5cdFx0YWN0aXZlQ291bnQtLTtcblxuXHRcdGlmIChxdWV1ZS5sZW5ndGggPiAwKSB7XG5cdFx0XHRxdWV1ZS5zaGlmdCgpKCk7XG5cdFx0fVxuXHR9O1xuXG5cdGNvbnN0IHJ1biA9IChmbiwgcmVzb2x2ZSwgLi4uYXJncykgPT4ge1xuXHRcdGFjdGl2ZUNvdW50Kys7XG5cblx0XHRjb25zdCByZXN1bHQgPSBwVHJ5KGZuLCAuLi5hcmdzKTtcblxuXHRcdHJlc29sdmUocmVzdWx0KTtcblxuXHRcdHJlc3VsdC50aGVuKG5leHQsIG5leHQpO1xuXHR9O1xuXG5cdGNvbnN0IGVucXVldWUgPSAoZm4sIHJlc29sdmUsIC4uLmFyZ3MpID0+IHtcblx0XHRpZiAoYWN0aXZlQ291bnQgPCBjb25jdXJyZW5jeSkge1xuXHRcdFx0cnVuKGZuLCByZXNvbHZlLCAuLi5hcmdzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cXVldWUucHVzaChydW4uYmluZChudWxsLCBmbiwgcmVzb2x2ZSwgLi4uYXJncykpO1xuXHRcdH1cblx0fTtcblxuXHRjb25zdCBnZW5lcmF0b3IgPSAoZm4sIC4uLmFyZ3MpID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gZW5xdWV1ZShmbiwgcmVzb2x2ZSwgLi4uYXJncykpO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhnZW5lcmF0b3IsIHtcblx0XHRhY3RpdmVDb3VudDoge1xuXHRcdFx0Z2V0OiAoKSA9PiBhY3RpdmVDb3VudFxuXHRcdH0sXG5cdFx0cGVuZGluZ0NvdW50OiB7XG5cdFx0XHRnZXQ6ICgpID0+IHF1ZXVlLmxlbmd0aFxuXHRcdH0sXG5cdFx0Y2xlYXJRdWV1ZToge1xuXHRcdFx0dmFsdWU6ICgpID0+IHtcblx0XHRcdFx0cXVldWUubGVuZ3RoID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiBnZW5lcmF0b3I7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBMaW1pdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBwTGltaXQ7XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBwTGltaXQgPSByZXF1aXJlKCdwLWxpbWl0Jyk7XG5cbmNsYXNzIEVuZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXHRjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHR9XG59XG5cbi8vIFRoZSBpbnB1dCBjYW4gYWxzbyBiZSBhIHByb21pc2UsIHNvIHdlIGBQcm9taXNlLnJlc29sdmUoKWAgaXRcbmNvbnN0IHRlc3RFbGVtZW50ID0gKGVsLCB0ZXN0ZXIpID0+IFByb21pc2UucmVzb2x2ZShlbCkudGhlbih0ZXN0ZXIpO1xuXG4vLyBUaGUgaW5wdXQgY2FuIGFsc28gYmUgYSBwcm9taXNlLCBzbyB3ZSBgUHJvbWlzZS5hbGwoKWAgdGhlbSBib3RoXG5jb25zdCBmaW5kZXIgPSBlbCA9PiBQcm9taXNlLmFsbChlbCkudGhlbih2YWwgPT4gdmFsWzFdID09PSB0cnVlICYmIFByb21pc2UucmVqZWN0KG5ldyBFbmRFcnJvcih2YWxbMF0pKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gKGl0ZXJhYmxlLCB0ZXN0ZXIsIG9wdHMpID0+IHtcblx0b3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuXHRcdGNvbmN1cnJlbmN5OiBJbmZpbml0eSxcblx0XHRwcmVzZXJ2ZU9yZGVyOiB0cnVlXG5cdH0sIG9wdHMpO1xuXG5cdGNvbnN0IGxpbWl0ID0gcExpbWl0KG9wdHMuY29uY3VycmVuY3kpO1xuXG5cdC8vIFN0YXJ0IGFsbCB0aGUgcHJvbWlzZXMgY29uY3VycmVudGx5IHdpdGggb3B0aW9uYWwgbGltaXRcblx0Y29uc3QgaXRlbXMgPSBbLi4uaXRlcmFibGVdLm1hcChlbCA9PiBbZWwsIGxpbWl0KHRlc3RFbGVtZW50LCBlbCwgdGVzdGVyKV0pO1xuXG5cdC8vIENoZWNrIHRoZSBwcm9taXNlcyBlaXRoZXIgc2VyaWFsbHkgb3IgY29uY3VycmVudGx5XG5cdGNvbnN0IGNoZWNrTGltaXQgPSBwTGltaXQob3B0cy5wcmVzZXJ2ZU9yZGVyID8gMSA6IEluZmluaXR5KTtcblxuXHRyZXR1cm4gUHJvbWlzZS5hbGwoaXRlbXMubWFwKGVsID0+IGNoZWNrTGltaXQoZmluZGVyLCBlbCkpKVxuXHRcdC50aGVuKCgpID0+IHt9KVxuXHRcdC5jYXRjaChlcnIgPT4gZXJyIGluc3RhbmNlb2YgRW5kRXJyb3IgPyBlcnIudmFsdWUgOiBQcm9taXNlLnJlamVjdChlcnIpKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgcGF0aEV4aXN0cyA9IHJlcXVpcmUoJ3BhdGgtZXhpc3RzJyk7XG5jb25zdCBwTG9jYXRlID0gcmVxdWlyZSgncC1sb2NhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoaXRlcmFibGUsIG9wdGlvbnMpID0+IHtcblx0b3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuXHRcdGN3ZDogcHJvY2Vzcy5jd2QoKVxuXHR9LCBvcHRpb25zKTtcblxuXHRyZXR1cm4gcExvY2F0ZShpdGVyYWJsZSwgZWwgPT4gcGF0aEV4aXN0cyhwYXRoLnJlc29sdmUob3B0aW9ucy5jd2QsIGVsKSksIG9wdGlvbnMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMuc3luYyA9IChpdGVyYWJsZSwgb3B0aW9ucykgPT4ge1xuXHRvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0Y3dkOiBwcm9jZXNzLmN3ZCgpXG5cdH0sIG9wdGlvbnMpO1xuXG5cdGZvciAoY29uc3QgZWwgb2YgaXRlcmFibGUpIHtcblx0XHRpZiAocGF0aEV4aXN0cy5zeW5jKHBhdGgucmVzb2x2ZShvcHRpb25zLmN3ZCwgZWwpKSkge1xuXHRcdFx0cmV0dXJuIGVsO1xuXHRcdH1cblx0fVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBsb2NhdGVQYXRoID0gcmVxdWlyZSgnbG9jYXRlLXBhdGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZmlsZW5hbWUsIG9wdHMgPSB7fSkgPT4ge1xuXHRjb25zdCBzdGFydERpciA9IHBhdGgucmVzb2x2ZShvcHRzLmN3ZCB8fCAnJyk7XG5cdGNvbnN0IHtyb290fSA9IHBhdGgucGFyc2Uoc3RhcnREaXIpO1xuXG5cdGNvbnN0IGZpbGVuYW1lcyA9IFtdLmNvbmNhdChmaWxlbmFtZSk7XG5cblx0cmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuXHRcdChmdW5jdGlvbiBmaW5kKGRpcikge1xuXHRcdFx0bG9jYXRlUGF0aChmaWxlbmFtZXMsIHtjd2Q6IGRpcn0pLnRoZW4oZmlsZSA9PiB7XG5cdFx0XHRcdGlmIChmaWxlKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZShwYXRoLmpvaW4oZGlyLCBmaWxlKSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoZGlyID09PSByb290KSB7XG5cdFx0XHRcdFx0cmVzb2x2ZShudWxsKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmaW5kKHBhdGguZGlybmFtZShkaXIpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSkoc3RhcnREaXIpO1xuXHR9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLnN5bmMgPSAoZmlsZW5hbWUsIG9wdHMgPSB7fSkgPT4ge1xuXHRsZXQgZGlyID0gcGF0aC5yZXNvbHZlKG9wdHMuY3dkIHx8ICcnKTtcblx0Y29uc3Qge3Jvb3R9ID0gcGF0aC5wYXJzZShkaXIpO1xuXG5cdGNvbnN0IGZpbGVuYW1lcyA9IFtdLmNvbmNhdChmaWxlbmFtZSk7XG5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuXHR3aGlsZSAodHJ1ZSkge1xuXHRcdGNvbnN0IGZpbGUgPSBsb2NhdGVQYXRoLnN5bmMoZmlsZW5hbWVzLCB7Y3dkOiBkaXJ9KTtcblxuXHRcdGlmIChmaWxlKSB7XG5cdFx0XHRyZXR1cm4gcGF0aC5qb2luKGRpciwgZmlsZSk7XG5cdFx0fVxuXG5cdFx0aWYgKGRpciA9PT0gcm9vdCkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0ZGlyID0gcGF0aC5kaXJuYW1lKGRpcik7XG5cdH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBmaW5kVXAgPSByZXF1aXJlKCdmaW5kLXVwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXN5bmMgKHtjd2R9ID0ge30pID0+IGZpbmRVcCgncGFja2FnZS5qc29uJywge2N3ZH0pO1xubW9kdWxlLmV4cG9ydHMuc3luYyA9ICh7Y3dkfSA9IHt9KSA9PiBmaW5kVXAuc3luYygncGFja2FnZS5qc29uJywge2N3ZH0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcblxuY29uc3QgaG9tZWRpciA9IG9zLmhvbWVkaXIoKTtcbmNvbnN0IHRtcGRpciA9IG9zLnRtcGRpcigpO1xuY29uc3Qge2Vudn0gPSBwcm9jZXNzO1xuXG5jb25zdCBtYWNvcyA9IG5hbWUgPT4ge1xuXHRjb25zdCBsaWJyYXJ5ID0gcGF0aC5qb2luKGhvbWVkaXIsICdMaWJyYXJ5Jyk7XG5cblx0cmV0dXJuIHtcblx0XHRkYXRhOiBwYXRoLmpvaW4obGlicmFyeSwgJ0FwcGxpY2F0aW9uIFN1cHBvcnQnLCBuYW1lKSxcblx0XHRjb25maWc6IHBhdGguam9pbihsaWJyYXJ5LCAnUHJlZmVyZW5jZXMnLCBuYW1lKSxcblx0XHRjYWNoZTogcGF0aC5qb2luKGxpYnJhcnksICdDYWNoZXMnLCBuYW1lKSxcblx0XHRsb2c6IHBhdGguam9pbihsaWJyYXJ5LCAnTG9ncycsIG5hbWUpLFxuXHRcdHRlbXA6IHBhdGguam9pbih0bXBkaXIsIG5hbWUpXG5cdH07XG59O1xuXG5jb25zdCB3aW5kb3dzID0gbmFtZSA9PiB7XG5cdGNvbnN0IGFwcERhdGEgPSBlbnYuQVBQREFUQSB8fCBwYXRoLmpvaW4oaG9tZWRpciwgJ0FwcERhdGEnLCAnUm9hbWluZycpO1xuXHRjb25zdCBsb2NhbEFwcERhdGEgPSBlbnYuTE9DQUxBUFBEQVRBIHx8IHBhdGguam9pbihob21lZGlyLCAnQXBwRGF0YScsICdMb2NhbCcpO1xuXG5cdHJldHVybiB7XG5cdFx0Ly8gRGF0YS9jb25maWcvY2FjaGUvbG9nIGFyZSBpbnZlbnRlZCBieSBtZSBhcyBXaW5kb3dzIGlzbid0IG9waW5pb25hdGVkIGFib3V0IHRoaXNcblx0XHRkYXRhOiBwYXRoLmpvaW4obG9jYWxBcHBEYXRhLCBuYW1lLCAnRGF0YScpLFxuXHRcdGNvbmZpZzogcGF0aC5qb2luKGFwcERhdGEsIG5hbWUsICdDb25maWcnKSxcblx0XHRjYWNoZTogcGF0aC5qb2luKGxvY2FsQXBwRGF0YSwgbmFtZSwgJ0NhY2hlJyksXG5cdFx0bG9nOiBwYXRoLmpvaW4obG9jYWxBcHBEYXRhLCBuYW1lLCAnTG9nJyksXG5cdFx0dGVtcDogcGF0aC5qb2luKHRtcGRpciwgbmFtZSlcblx0fTtcbn07XG5cbi8vIGh0dHBzOi8vc3BlY2lmaWNhdGlvbnMuZnJlZWRlc2t0b3Aub3JnL2Jhc2VkaXItc3BlYy9iYXNlZGlyLXNwZWMtbGF0ZXN0Lmh0bWxcbmNvbnN0IGxpbnV4ID0gbmFtZSA9PiB7XG5cdGNvbnN0IHVzZXJuYW1lID0gcGF0aC5iYXNlbmFtZShob21lZGlyKTtcblxuXHRyZXR1cm4ge1xuXHRcdGRhdGE6IHBhdGguam9pbihlbnYuWERHX0RBVEFfSE9NRSB8fCBwYXRoLmpvaW4oaG9tZWRpciwgJy5sb2NhbCcsICdzaGFyZScpLCBuYW1lKSxcblx0XHRjb25maWc6IHBhdGguam9pbihlbnYuWERHX0NPTkZJR19IT01FIHx8IHBhdGguam9pbihob21lZGlyLCAnLmNvbmZpZycpLCBuYW1lKSxcblx0XHRjYWNoZTogcGF0aC5qb2luKGVudi5YREdfQ0FDSEVfSE9NRSB8fCBwYXRoLmpvaW4oaG9tZWRpciwgJy5jYWNoZScpLCBuYW1lKSxcblx0XHQvLyBodHRwczovL3dpa2kuZGViaWFuLm9yZy9YREdCYXNlRGlyZWN0b3J5U3BlY2lmaWNhdGlvbiNzdGF0ZVxuXHRcdGxvZzogcGF0aC5qb2luKGVudi5YREdfU1RBVEVfSE9NRSB8fCBwYXRoLmpvaW4oaG9tZWRpciwgJy5sb2NhbCcsICdzdGF0ZScpLCBuYW1lKSxcblx0XHR0ZW1wOiBwYXRoLmpvaW4odG1wZGlyLCB1c2VybmFtZSwgbmFtZSlcblx0fTtcbn07XG5cbmNvbnN0IGVudlBhdGhzID0gKG5hbWUsIG9wdGlvbnMpID0+IHtcblx0aWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIG5hbWV9YCk7XG5cdH1cblxuXHRvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7c3VmZml4OiAnbm9kZWpzJ30sIG9wdGlvbnMpO1xuXG5cdGlmIChvcHRpb25zLnN1ZmZpeCkge1xuXHRcdC8vIEFkZCBzdWZmaXggdG8gcHJldmVudCBwb3NzaWJsZSBjb25mbGljdCB3aXRoIG5hdGl2ZSBhcHBzXG5cdFx0bmFtZSArPSBgLSR7b3B0aW9ucy5zdWZmaXh9YDtcblx0fVxuXG5cdGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnZGFyd2luJykge1xuXHRcdHJldHVybiBtYWNvcyhuYW1lKTtcblx0fVxuXG5cdGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG5cdFx0cmV0dXJuIHdpbmRvd3MobmFtZSk7XG5cdH1cblxuXHRyZXR1cm4gbGludXgobmFtZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVudlBhdGhzO1xuLy8gVE9ETzogUmVtb3ZlIHRoaXMgZm9yIHRoZSBuZXh0IG1ham9yIHJlbGVhc2Vcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBlbnZQYXRocztcbiIsIlwidXNlIHN0cmljdFwiO1xuLyogQ09OU1RTICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5PT1AgPSBleHBvcnRzLkxJTUlUX0ZJTEVTX0RFU0NSSVBUT1JTID0gZXhwb3J0cy5MSU1JVF9CQVNFTkFNRV9MRU5HVEggPSBleHBvcnRzLklTX1VTRVJfUk9PVCA9IGV4cG9ydHMuSVNfUE9TSVggPSBleHBvcnRzLkRFRkFVTFRfVElNRU9VVF9TWU5DID0gZXhwb3J0cy5ERUZBVUxUX1RJTUVPVVRfQVNZTkMgPSBleHBvcnRzLkRFRkFVTFRfV1JJVEVfT1BUSU9OUyA9IGV4cG9ydHMuREVGQVVMVF9SRUFEX09QVElPTlMgPSBleHBvcnRzLkRFRkFVTFRfRk9MREVSX01PREUgPSBleHBvcnRzLkRFRkFVTFRfRklMRV9NT0RFID0gZXhwb3J0cy5ERUZBVUxUX0VOQ09ESU5HID0gdm9pZCAwO1xuY29uc3QgREVGQVVMVF9FTkNPRElORyA9ICd1dGY4JztcbmV4cG9ydHMuREVGQVVMVF9FTkNPRElORyA9IERFRkFVTFRfRU5DT0RJTkc7XG5jb25zdCBERUZBVUxUX0ZJTEVfTU9ERSA9IDBvNjY2O1xuZXhwb3J0cy5ERUZBVUxUX0ZJTEVfTU9ERSA9IERFRkFVTFRfRklMRV9NT0RFO1xuY29uc3QgREVGQVVMVF9GT0xERVJfTU9ERSA9IDBvNzc3O1xuZXhwb3J0cy5ERUZBVUxUX0ZPTERFUl9NT0RFID0gREVGQVVMVF9GT0xERVJfTU9ERTtcbmNvbnN0IERFRkFVTFRfUkVBRF9PUFRJT05TID0ge307XG5leHBvcnRzLkRFRkFVTFRfUkVBRF9PUFRJT05TID0gREVGQVVMVF9SRUFEX09QVElPTlM7XG5jb25zdCBERUZBVUxUX1dSSVRFX09QVElPTlMgPSB7fTtcbmV4cG9ydHMuREVGQVVMVF9XUklURV9PUFRJT05TID0gREVGQVVMVF9XUklURV9PUFRJT05TO1xuY29uc3QgREVGQVVMVF9USU1FT1VUX0FTWU5DID0gNTAwMDtcbmV4cG9ydHMuREVGQVVMVF9USU1FT1VUX0FTWU5DID0gREVGQVVMVF9USU1FT1VUX0FTWU5DO1xuY29uc3QgREVGQVVMVF9USU1FT1VUX1NZTkMgPSAxMDA7XG5leHBvcnRzLkRFRkFVTFRfVElNRU9VVF9TWU5DID0gREVGQVVMVF9USU1FT1VUX1NZTkM7XG5jb25zdCBJU19QT1NJWCA9ICEhcHJvY2Vzcy5nZXR1aWQ7XG5leHBvcnRzLklTX1BPU0lYID0gSVNfUE9TSVg7XG5jb25zdCBJU19VU0VSX1JPT1QgPSBwcm9jZXNzLmdldHVpZCA/ICFwcm9jZXNzLmdldHVpZCgpIDogZmFsc2U7XG5leHBvcnRzLklTX1VTRVJfUk9PVCA9IElTX1VTRVJfUk9PVDtcbmNvbnN0IExJTUlUX0JBU0VOQU1FX0xFTkdUSCA9IDEyODsgLy9UT0RPOiBmZXRjaCB0aGUgcmVhbCBsaW1pdCBmcm9tIHRoZSBmaWxlc3lzdGVtIC8vVE9ETzogZmV0Y2ggdGhlIHdob2xlLXBhdGggbGVuZ3RoIGxpbWl0IHRvb1xuZXhwb3J0cy5MSU1JVF9CQVNFTkFNRV9MRU5HVEggPSBMSU1JVF9CQVNFTkFNRV9MRU5HVEg7XG5jb25zdCBMSU1JVF9GSUxFU19ERVNDUklQVE9SUyA9IDEwMDAwOyAvL1RPRE86IGZldGNoIHRoZSByZWFsIGxpbWl0IGZyb20gdGhlIGZpbGVzeXN0ZW1cbmV4cG9ydHMuTElNSVRfRklMRVNfREVTQ1JJUFRPUlMgPSBMSU1JVF9GSUxFU19ERVNDUklQVE9SUztcbmNvbnN0IE5PT1AgPSAoKSA9PiB7IH07XG5leHBvcnRzLk5PT1AgPSBOT09QO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBJTVBPUlQgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXR0ZW1wdGlmeVN5bmMgPSBleHBvcnRzLmF0dGVtcHRpZnlBc3luYyA9IHZvaWQgMDtcbmNvbnN0IGNvbnN0c18xID0gcmVxdWlyZShcIi4uL2NvbnN0c1wiKTtcbi8qIEFUVEVNUFRJRlkgKi9cbi8vVE9ETzogTWF5YmUgcHVibGlzaCB0aGlzIGFzIGEgc3RhbmRhbG9uZSBwYWNrYWdlXG4vL0ZJWE1FOiBUaGUgdHlwZSBjYXN0aW5ncyBoZXJlIGFyZW4ndCBleGFjdGx5IGNvcnJlY3RcbmNvbnN0IGF0dGVtcHRpZnlBc3luYyA9IChmbiwgb25FcnJvciA9IGNvbnN0c18xLk5PT1ApID0+IHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpLmNhdGNoKG9uRXJyb3IpO1xuICAgIH07XG59O1xuZXhwb3J0cy5hdHRlbXB0aWZ5QXN5bmMgPSBhdHRlbXB0aWZ5QXN5bmM7XG5jb25zdCBhdHRlbXB0aWZ5U3luYyA9IChmbiwgb25FcnJvciA9IGNvbnN0c18xLk5PT1ApID0+IHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuZXhwb3J0cy5hdHRlbXB0aWZ5U3luYyA9IGF0dGVtcHRpZnlTeW5jO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBJTVBPUlQgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvbnN0c18xID0gcmVxdWlyZShcIi4uL2NvbnN0c1wiKTtcbi8qIEZTIEhBTkRMRVJTICovXG5jb25zdCBIYW5kbGVycyA9IHtcbiAgICBpc0NoYW5nZUVycm9yT2s6IChlcnJvcikgPT4ge1xuICAgICAgICBjb25zdCB7IGNvZGUgfSA9IGVycm9yO1xuICAgICAgICBpZiAoY29kZSA9PT0gJ0VOT1NZUycpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKCFjb25zdHNfMS5JU19VU0VSX1JPT1QgJiYgKGNvZGUgPT09ICdFSU5WQUwnIHx8IGNvZGUgPT09ICdFUEVSTScpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGlzUmV0cmlhYmxlRXJyb3I6IChlcnJvcikgPT4ge1xuICAgICAgICBjb25zdCB7IGNvZGUgfSA9IGVycm9yO1xuICAgICAgICBpZiAoY29kZSA9PT0gJ0VNRklMRScgfHwgY29kZSA9PT0gJ0VORklMRScgfHwgY29kZSA9PT0gJ0VBR0FJTicgfHwgY29kZSA9PT0gJ0VCVVNZJyB8fCBjb2RlID09PSAnRUFDQ0VTUycgfHwgY29kZSA9PT0gJ0VBQ0NTJyB8fCBjb2RlID09PSAnRVBFUk0nKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIG9uQ2hhbmdlRXJyb3I6IChlcnJvcikgPT4ge1xuICAgICAgICBpZiAoSGFuZGxlcnMuaXNDaGFuZ2VFcnJvck9rKGVycm9yKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufTtcbi8qIEVYUE9SVCAqL1xuZXhwb3J0cy5kZWZhdWx0ID0gSGFuZGxlcnM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIElNUE9SVCAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29uc3RzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RzXCIpO1xuLyogUkVUUllJRlkgUVVFVUUgKi9cbmNvbnN0IFJldHJ5ZnlRdWV1ZSA9IHtcbiAgICBpbnRlcnZhbDogMjUsXG4gICAgaW50ZXJ2YWxJZDogdW5kZWZpbmVkLFxuICAgIGxpbWl0OiBjb25zdHNfMS5MSU1JVF9GSUxFU19ERVNDUklQVE9SUyxcbiAgICBxdWV1ZUFjdGl2ZTogbmV3IFNldCgpLFxuICAgIHF1ZXVlV2FpdGluZzogbmV3IFNldCgpLFxuICAgIGluaXQ6ICgpID0+IHtcbiAgICAgICAgaWYgKFJldHJ5ZnlRdWV1ZS5pbnRlcnZhbElkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBSZXRyeWZ5UXVldWUuaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKFJldHJ5ZnlRdWV1ZS50aWNrLCBSZXRyeWZ5UXVldWUuaW50ZXJ2YWwpO1xuICAgIH0sXG4gICAgcmVzZXQ6ICgpID0+IHtcbiAgICAgICAgaWYgKCFSZXRyeWZ5UXVldWUuaW50ZXJ2YWxJZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChSZXRyeWZ5UXVldWUuaW50ZXJ2YWxJZCk7XG4gICAgICAgIGRlbGV0ZSBSZXRyeWZ5UXVldWUuaW50ZXJ2YWxJZDtcbiAgICB9LFxuICAgIGFkZDogKGZuKSA9PiB7XG4gICAgICAgIFJldHJ5ZnlRdWV1ZS5xdWV1ZVdhaXRpbmcuYWRkKGZuKTtcbiAgICAgICAgaWYgKFJldHJ5ZnlRdWV1ZS5xdWV1ZUFjdGl2ZS5zaXplIDwgKFJldHJ5ZnlRdWV1ZS5saW1pdCAvIDIpKSB7IC8vIEFjdGl2ZSBxdWV1ZSBub3QgdW5kZXIgcHJlYXNzdXJlLCBleGVjdXRpbmcgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIFJldHJ5ZnlRdWV1ZS50aWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBSZXRyeWZ5UXVldWUuaW5pdCgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZW1vdmU6IChmbikgPT4ge1xuICAgICAgICBSZXRyeWZ5UXVldWUucXVldWVXYWl0aW5nLmRlbGV0ZShmbik7XG4gICAgICAgIFJldHJ5ZnlRdWV1ZS5xdWV1ZUFjdGl2ZS5kZWxldGUoZm4pO1xuICAgIH0sXG4gICAgc2NoZWR1bGU6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2xlYW51cCA9ICgpID0+IFJldHJ5ZnlRdWV1ZS5yZW1vdmUocmVzb2x2ZXIpO1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSAoKSA9PiByZXNvbHZlKGNsZWFudXApO1xuICAgICAgICAgICAgUmV0cnlmeVF1ZXVlLmFkZChyZXNvbHZlcik7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgdGljazogKCkgPT4ge1xuICAgICAgICBpZiAoUmV0cnlmeVF1ZXVlLnF1ZXVlQWN0aXZlLnNpemUgPj0gUmV0cnlmeVF1ZXVlLmxpbWl0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIVJldHJ5ZnlRdWV1ZS5xdWV1ZVdhaXRpbmcuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiBSZXRyeWZ5UXVldWUucmVzZXQoKTtcbiAgICAgICAgZm9yIChjb25zdCBmbiBvZiBSZXRyeWZ5UXVldWUucXVldWVXYWl0aW5nKSB7XG4gICAgICAgICAgICBpZiAoUmV0cnlmeVF1ZXVlLnF1ZXVlQWN0aXZlLnNpemUgPj0gUmV0cnlmeVF1ZXVlLmxpbWl0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgUmV0cnlmeVF1ZXVlLnF1ZXVlV2FpdGluZy5kZWxldGUoZm4pO1xuICAgICAgICAgICAgUmV0cnlmeVF1ZXVlLnF1ZXVlQWN0aXZlLmFkZChmbik7XG4gICAgICAgICAgICBmbigpO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8qIEVYUE9SVCAqL1xuZXhwb3J0cy5kZWZhdWx0ID0gUmV0cnlmeVF1ZXVlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBJTVBPUlQgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmV0cnlpZnlTeW5jID0gZXhwb3J0cy5yZXRyeWlmeUFzeW5jID0gdm9pZCAwO1xuY29uc3QgcmV0cnlpZnlfcXVldWVfMSA9IHJlcXVpcmUoXCIuL3JldHJ5aWZ5X3F1ZXVlXCIpO1xuLyogUkVUUllJRlkgKi9cbmNvbnN0IHJldHJ5aWZ5QXN5bmMgPSAoZm4sIGlzUmV0cmlhYmxlRXJyb3IpID0+IHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRpbWVzdGFtcCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gYXR0ZW1wdCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXRyeWlmeV9xdWV1ZV8xLmRlZmF1bHQuc2NoZWR1bGUoKS50aGVuKGNsZWFudXAgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChEYXRlLm5vdygpID49IHRpbWVzdGFtcClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZXRyaWFibGVFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gTWF0aC5yb3VuZCgxMDAgKyAoNDAwICogTWF0aC5yYW5kb20oKSkpLCBkZWxheVByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWxheVByb21pc2UudGhlbigoKSA9PiBhdHRlbXB0LmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9O1xufTtcbmV4cG9ydHMucmV0cnlpZnlBc3luYyA9IHJldHJ5aWZ5QXN5bmM7XG5jb25zdCByZXRyeWlmeVN5bmMgPSAoZm4sIGlzUmV0cmlhYmxlRXJyb3IpID0+IHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRpbWVzdGFtcCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gYXR0ZW1wdCgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChEYXRlLm5vdygpID4gdGltZXN0YW1wKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXRyaWFibGVFcnJvcihlcnJvcikpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhdHRlbXB0LmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xufTtcbmV4cG9ydHMucmV0cnlpZnlTeW5jID0gcmV0cnlpZnlTeW5jO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBJTVBPUlQgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcInV0aWxcIik7XG5jb25zdCBhdHRlbXB0aWZ5XzEgPSByZXF1aXJlKFwiLi9hdHRlbXB0aWZ5XCIpO1xuY29uc3QgZnNfaGFuZGxlcnNfMSA9IHJlcXVpcmUoXCIuL2ZzX2hhbmRsZXJzXCIpO1xuY29uc3QgcmV0cnlpZnlfMSA9IHJlcXVpcmUoXCIuL3JldHJ5aWZ5XCIpO1xuLyogRlMgKi9cbmNvbnN0IEZTID0ge1xuICAgIGNobW9kQXR0ZW1wdDogYXR0ZW1wdGlmeV8xLmF0dGVtcHRpZnlBc3luYyh1dGlsXzEucHJvbWlzaWZ5KGZzLmNobW9kKSwgZnNfaGFuZGxlcnNfMS5kZWZhdWx0Lm9uQ2hhbmdlRXJyb3IpLFxuICAgIGNob3duQXR0ZW1wdDogYXR0ZW1wdGlmeV8xLmF0dGVtcHRpZnlBc3luYyh1dGlsXzEucHJvbWlzaWZ5KGZzLmNob3duKSwgZnNfaGFuZGxlcnNfMS5kZWZhdWx0Lm9uQ2hhbmdlRXJyb3IpLFxuICAgIGNsb3NlQXR0ZW1wdDogYXR0ZW1wdGlmeV8xLmF0dGVtcHRpZnlBc3luYyh1dGlsXzEucHJvbWlzaWZ5KGZzLmNsb3NlKSksXG4gICAgZnN5bmNBdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMuZnN5bmMpKSxcbiAgICBta2RpckF0dGVtcHQ6IGF0dGVtcHRpZnlfMS5hdHRlbXB0aWZ5QXN5bmModXRpbF8xLnByb21pc2lmeShmcy5ta2RpcikpLFxuICAgIHJlYWxwYXRoQXR0ZW1wdDogYXR0ZW1wdGlmeV8xLmF0dGVtcHRpZnlBc3luYyh1dGlsXzEucHJvbWlzaWZ5KGZzLnJlYWxwYXRoKSksXG4gICAgc3RhdEF0dGVtcHQ6IGF0dGVtcHRpZnlfMS5hdHRlbXB0aWZ5QXN5bmModXRpbF8xLnByb21pc2lmeShmcy5zdGF0KSksXG4gICAgdW5saW5rQXR0ZW1wdDogYXR0ZW1wdGlmeV8xLmF0dGVtcHRpZnlBc3luYyh1dGlsXzEucHJvbWlzaWZ5KGZzLnVubGluaykpLFxuICAgIGNsb3NlUmV0cnk6IHJldHJ5aWZ5XzEucmV0cnlpZnlBc3luYyh1dGlsXzEucHJvbWlzaWZ5KGZzLmNsb3NlKSwgZnNfaGFuZGxlcnNfMS5kZWZhdWx0LmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgIGZzeW5jUmV0cnk6IHJldHJ5aWZ5XzEucmV0cnlpZnlBc3luYyh1dGlsXzEucHJvbWlzaWZ5KGZzLmZzeW5jKSwgZnNfaGFuZGxlcnNfMS5kZWZhdWx0LmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgIG9wZW5SZXRyeTogcmV0cnlpZnlfMS5yZXRyeWlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMub3BlbiksIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5pc1JldHJpYWJsZUVycm9yKSxcbiAgICByZWFkRmlsZVJldHJ5OiByZXRyeWlmeV8xLnJldHJ5aWZ5QXN5bmModXRpbF8xLnByb21pc2lmeShmcy5yZWFkRmlsZSksIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5pc1JldHJpYWJsZUVycm9yKSxcbiAgICByZW5hbWVSZXRyeTogcmV0cnlpZnlfMS5yZXRyeWlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMucmVuYW1lKSwgZnNfaGFuZGxlcnNfMS5kZWZhdWx0LmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgIHN0YXRSZXRyeTogcmV0cnlpZnlfMS5yZXRyeWlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMuc3RhdCksIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5pc1JldHJpYWJsZUVycm9yKSxcbiAgICB3cml0ZVJldHJ5OiByZXRyeWlmeV8xLnJldHJ5aWZ5QXN5bmModXRpbF8xLnByb21pc2lmeShmcy53cml0ZSksIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5pc1JldHJpYWJsZUVycm9yKSxcbiAgICBjaG1vZFN5bmNBdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeVN5bmMoZnMuY2htb2RTeW5jLCBmc19oYW5kbGVyc18xLmRlZmF1bHQub25DaGFuZ2VFcnJvciksXG4gICAgY2hvd25TeW5jQXR0ZW1wdDogYXR0ZW1wdGlmeV8xLmF0dGVtcHRpZnlTeW5jKGZzLmNob3duU3luYywgZnNfaGFuZGxlcnNfMS5kZWZhdWx0Lm9uQ2hhbmdlRXJyb3IpLFxuICAgIGNsb3NlU3luY0F0dGVtcHQ6IGF0dGVtcHRpZnlfMS5hdHRlbXB0aWZ5U3luYyhmcy5jbG9zZVN5bmMpLFxuICAgIG1rZGlyU3luY0F0dGVtcHQ6IGF0dGVtcHRpZnlfMS5hdHRlbXB0aWZ5U3luYyhmcy5ta2RpclN5bmMpLFxuICAgIHJlYWxwYXRoU3luY0F0dGVtcHQ6IGF0dGVtcHRpZnlfMS5hdHRlbXB0aWZ5U3luYyhmcy5yZWFscGF0aFN5bmMpLFxuICAgIHN0YXRTeW5jQXR0ZW1wdDogYXR0ZW1wdGlmeV8xLmF0dGVtcHRpZnlTeW5jKGZzLnN0YXRTeW5jKSxcbiAgICB1bmxpbmtTeW5jQXR0ZW1wdDogYXR0ZW1wdGlmeV8xLmF0dGVtcHRpZnlTeW5jKGZzLnVubGlua1N5bmMpLFxuICAgIGNsb3NlU3luY1JldHJ5OiByZXRyeWlmeV8xLnJldHJ5aWZ5U3luYyhmcy5jbG9zZVN5bmMsIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5pc1JldHJpYWJsZUVycm9yKSxcbiAgICBmc3luY1N5bmNSZXRyeTogcmV0cnlpZnlfMS5yZXRyeWlmeVN5bmMoZnMuZnN5bmNTeW5jLCBmc19oYW5kbGVyc18xLmRlZmF1bHQuaXNSZXRyaWFibGVFcnJvciksXG4gICAgb3BlblN5bmNSZXRyeTogcmV0cnlpZnlfMS5yZXRyeWlmeVN5bmMoZnMub3BlblN5bmMsIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5pc1JldHJpYWJsZUVycm9yKSxcbiAgICByZWFkRmlsZVN5bmNSZXRyeTogcmV0cnlpZnlfMS5yZXRyeWlmeVN5bmMoZnMucmVhZEZpbGVTeW5jLCBmc19oYW5kbGVyc18xLmRlZmF1bHQuaXNSZXRyaWFibGVFcnJvciksXG4gICAgcmVuYW1lU3luY1JldHJ5OiByZXRyeWlmeV8xLnJldHJ5aWZ5U3luYyhmcy5yZW5hbWVTeW5jLCBmc19oYW5kbGVyc18xLmRlZmF1bHQuaXNSZXRyaWFibGVFcnJvciksXG4gICAgc3RhdFN5bmNSZXRyeTogcmV0cnlpZnlfMS5yZXRyeWlmeVN5bmMoZnMuc3RhdFN5bmMsIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5pc1JldHJpYWJsZUVycm9yKSxcbiAgICB3cml0ZVN5bmNSZXRyeTogcmV0cnlpZnlfMS5yZXRyeWlmeVN5bmMoZnMud3JpdGVTeW5jLCBmc19oYW5kbGVyc18xLmRlZmF1bHQuaXNSZXRyaWFibGVFcnJvcilcbn07XG4vKiBFWFBPUlQgKi9cbmV4cG9ydHMuZGVmYXVsdCA9IEZTO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBMQU5HICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBMYW5nID0ge1xuICAgIGlzRnVuY3Rpb246ICh4KSA9PiB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9LFxuICAgIGlzU3RyaW5nOiAoeCkgPT4ge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdzdHJpbmcnO1xuICAgIH0sXG4gICAgaXNVbmRlZmluZWQ6ICh4KSA9PiB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgfVxufTtcbi8qIEVYUE9SVCAqL1xuZXhwb3J0cy5kZWZhdWx0ID0gTGFuZztcbiIsIlwidXNlIHN0cmljdFwiO1xuLyogSU1QT1JUICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiBWQVJJQUJMRVMgKi9cbmNvbnN0IFF1ZXVlcyA9IHt9O1xuLyogU0NIRURVTEVSICovXG4vL1RPRE86IE1heWJlIHB1Ymxpc2ggdGhpcyBhcyBhIHN0YW5kYWxvbmUgcGFja2FnZVxuY29uc3QgU2NoZWR1bGVyID0ge1xuICAgIG5leHQ6IChpZCkgPT4ge1xuICAgICAgICBjb25zdCBxdWV1ZSA9IFF1ZXVlc1tpZF07XG4gICAgICAgIGlmICghcXVldWUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGNvbnN0IGpvYiA9IHF1ZXVlWzBdO1xuICAgICAgICBpZiAoam9iKSB7XG4gICAgICAgICAgICBqb2IoKCkgPT4gU2NoZWR1bGVyLm5leHQoaWQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBRdWV1ZXNbaWRdO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBzY2hlZHVsZTogKGlkKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIGxldCBxdWV1ZSA9IFF1ZXVlc1tpZF07XG4gICAgICAgICAgICBpZiAoIXF1ZXVlKVxuICAgICAgICAgICAgICAgIHF1ZXVlID0gUXVldWVzW2lkXSA9IFtdO1xuICAgICAgICAgICAgcXVldWUucHVzaChyZXNvbHZlKTtcbiAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPiAxKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHJlc29sdmUoKCkgPT4gU2NoZWR1bGVyLm5leHQoaWQpKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbi8qIEVYUE9SVCAqL1xuZXhwb3J0cy5kZWZhdWx0ID0gU2NoZWR1bGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBJTVBPUlQgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IGNvbnN0c18xID0gcmVxdWlyZShcIi4uL2NvbnN0c1wiKTtcbmNvbnN0IGZzXzEgPSByZXF1aXJlKFwiLi9mc1wiKTtcbi8qIFRFTVAgKi9cbi8vVE9ETzogTWF5YmUgcHVibGlzaCB0aGlzIGFzIGEgc3RhbmRhbG9uZSBwYWNrYWdlXG5jb25zdCBUZW1wID0ge1xuICAgIHN0b3JlOiB7fSxcbiAgICBjcmVhdGU6IChmaWxlUGF0aCkgPT4ge1xuICAgICAgICBjb25zdCByYW5kb21uZXNzID0gYDAwMDAwMCR7TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTY3NzcyMTUpLnRvU3RyaW5nKDE2KX1gLnNsaWNlKC02KSwgLy8gNiByYW5kb20tZW5vdWdoIGhleCBjaGFyYWN0ZXJzXG4gICAgICAgIHRpbWVzdGFtcCA9IERhdGUubm93KCkudG9TdHJpbmcoKS5zbGljZSgtMTApLCAvLyAxMCBwcmVjaXNlIHRpbWVzdGFtcCBkaWdpdHNcbiAgICAgICAgcHJlZml4ID0gJ3RtcC0nLCBzdWZmaXggPSBgLiR7cHJlZml4fSR7dGltZXN0YW1wfSR7cmFuZG9tbmVzc31gLCB0ZW1wUGF0aCA9IGAke2ZpbGVQYXRofSR7c3VmZml4fWA7XG4gICAgICAgIHJldHVybiB0ZW1wUGF0aDtcbiAgICB9LFxuICAgIGdldDogKGZpbGVQYXRoLCBjcmVhdG9yLCBwdXJnZSA9IHRydWUpID0+IHtcbiAgICAgICAgY29uc3QgdGVtcFBhdGggPSBUZW1wLnRydW5jYXRlKGNyZWF0b3IoZmlsZVBhdGgpKTtcbiAgICAgICAgaWYgKHRlbXBQYXRoIGluIFRlbXAuc3RvcmUpXG4gICAgICAgICAgICByZXR1cm4gVGVtcC5nZXQoZmlsZVBhdGgsIGNyZWF0b3IsIHB1cmdlKTsgLy8gQ29sbGlzaW9uIGZvdW5kLCB0cnkgYWdhaW5cbiAgICAgICAgVGVtcC5zdG9yZVt0ZW1wUGF0aF0gPSBwdXJnZTtcbiAgICAgICAgY29uc3QgZGlzcG9zZXIgPSAoKSA9PiBkZWxldGUgVGVtcC5zdG9yZVt0ZW1wUGF0aF07XG4gICAgICAgIHJldHVybiBbdGVtcFBhdGgsIGRpc3Bvc2VyXTtcbiAgICB9LFxuICAgIHB1cmdlOiAoZmlsZVBhdGgpID0+IHtcbiAgICAgICAgaWYgKCFUZW1wLnN0b3JlW2ZpbGVQYXRoXSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZGVsZXRlIFRlbXAuc3RvcmVbZmlsZVBhdGhdO1xuICAgICAgICBmc18xLmRlZmF1bHQudW5saW5rQXR0ZW1wdChmaWxlUGF0aCk7XG4gICAgfSxcbiAgICBwdXJnZVN5bmM6IChmaWxlUGF0aCkgPT4ge1xuICAgICAgICBpZiAoIVRlbXAuc3RvcmVbZmlsZVBhdGhdKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBkZWxldGUgVGVtcC5zdG9yZVtmaWxlUGF0aF07XG4gICAgICAgIGZzXzEuZGVmYXVsdC51bmxpbmtTeW5jQXR0ZW1wdChmaWxlUGF0aCk7XG4gICAgfSxcbiAgICBwdXJnZVN5bmNBbGw6ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBmaWxlUGF0aCBpbiBUZW1wLnN0b3JlKSB7XG4gICAgICAgICAgICBUZW1wLnB1cmdlU3luYyhmaWxlUGF0aCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRydW5jYXRlOiAoZmlsZVBhdGgpID0+IHtcbiAgICAgICAgY29uc3QgYmFzZW5hbWUgPSBwYXRoLmJhc2VuYW1lKGZpbGVQYXRoKTtcbiAgICAgICAgaWYgKGJhc2VuYW1lLmxlbmd0aCA8PSBjb25zdHNfMS5MSU1JVF9CQVNFTkFNRV9MRU5HVEgpXG4gICAgICAgICAgICByZXR1cm4gZmlsZVBhdGg7IC8vRklYTUU6IFJvdWdoIGFuZCBxdWljayBhdHRlbXB0IGF0IGRldGVjdGluZyBvayBsZW5ndGhzXG4gICAgICAgIGNvbnN0IHRydW5jYWJsZSA9IC9eKFxcLj8pKC4qPykoKD86XFwuW14uXSspPyg/OlxcLnRtcC1cXGR7MTB9W2EtZjAtOV17Nn0pPykkLy5leGVjKGJhc2VuYW1lKTtcbiAgICAgICAgaWYgKCF0cnVuY2FibGUpXG4gICAgICAgICAgICByZXR1cm4gZmlsZVBhdGg7IC8vRklYTUU6IE5vIHRydW5jYWJsZSBwYXJ0IGRldGVjdGVkLCBjYW4ndCByZWFsbHkgZG8gbXVjaCB3aXRob3V0IGFsc28gY2hhbmdpbmcgdGhlIHBhcmVudCBwYXRoLCB3aGljaCBpcyB1bnNhZmUsIGhvcGluZyBmb3IgdGhlIGJlc3QgaGVyZVxuICAgICAgICBjb25zdCB0cnVuY2F0aW9uTGVuZ3RoID0gYmFzZW5hbWUubGVuZ3RoIC0gY29uc3RzXzEuTElNSVRfQkFTRU5BTUVfTEVOR1RIO1xuICAgICAgICByZXR1cm4gYCR7ZmlsZVBhdGguc2xpY2UoMCwgLWJhc2VuYW1lLmxlbmd0aCl9JHt0cnVuY2FibGVbMV19JHt0cnVuY2FibGVbMl0uc2xpY2UoMCwgLXRydW5jYXRpb25MZW5ndGgpfSR7dHJ1bmNhYmxlWzNdfWA7IC8vRklYTUU6IFRoZSB0cnVuY2FibGUgcGFydCBtaWdodCBiZSBzaG9ydGVyIHRoYW4gbmVlZGVkIGhlcmVcbiAgICB9XG59O1xuLyogSU5JVCAqL1xucHJvY2Vzcy5vbignZXhpdCcsIFRlbXAucHVyZ2VTeW5jQWxsKTsgLy8gRW5zdXJpbmcgcHVyZ2VhYmxlIHRlbXAgZmlsZXMgYXJlIHB1cmdlZCBvbiBleGl0XG4vKiBFWFBPUlQgKi9cbmV4cG9ydHMuZGVmYXVsdCA9IFRlbXA7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIElNUE9SVCAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy53cml0ZUZpbGVTeW5jID0gZXhwb3J0cy53cml0ZUZpbGUgPSBleHBvcnRzLnJlYWRGaWxlU3luYyA9IGV4cG9ydHMucmVhZEZpbGUgPSB2b2lkIDA7XG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCBjb25zdHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0c1wiKTtcbmNvbnN0IGZzXzEgPSByZXF1aXJlKFwiLi91dGlscy9mc1wiKTtcbmNvbnN0IGxhbmdfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2xhbmdcIik7XG5jb25zdCBzY2hlZHVsZXJfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL3NjaGVkdWxlclwiKTtcbmNvbnN0IHRlbXBfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL3RlbXBcIik7XG5mdW5jdGlvbiByZWFkRmlsZShmaWxlUGF0aCwgb3B0aW9ucyA9IGNvbnN0c18xLkRFRkFVTFRfUkVBRF9PUFRJT05TKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChsYW5nXzEuZGVmYXVsdC5pc1N0cmluZyhvcHRpb25zKSlcbiAgICAgICAgcmV0dXJuIHJlYWRGaWxlKGZpbGVQYXRoLCB7IGVuY29kaW5nOiBvcHRpb25zIH0pO1xuICAgIGNvbnN0IHRpbWVvdXQgPSBEYXRlLm5vdygpICsgKChfYSA9IG9wdGlvbnMudGltZW91dCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29uc3RzXzEuREVGQVVMVF9USU1FT1VUX0FTWU5DKTtcbiAgICByZXR1cm4gZnNfMS5kZWZhdWx0LnJlYWRGaWxlUmV0cnkodGltZW91dCkoZmlsZVBhdGgsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5yZWFkRmlsZSA9IHJlYWRGaWxlO1xuO1xuZnVuY3Rpb24gcmVhZEZpbGVTeW5jKGZpbGVQYXRoLCBvcHRpb25zID0gY29uc3RzXzEuREVGQVVMVF9SRUFEX09QVElPTlMpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGxhbmdfMS5kZWZhdWx0LmlzU3RyaW5nKG9wdGlvbnMpKVxuICAgICAgICByZXR1cm4gcmVhZEZpbGVTeW5jKGZpbGVQYXRoLCB7IGVuY29kaW5nOiBvcHRpb25zIH0pO1xuICAgIGNvbnN0IHRpbWVvdXQgPSBEYXRlLm5vdygpICsgKChfYSA9IG9wdGlvbnMudGltZW91dCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29uc3RzXzEuREVGQVVMVF9USU1FT1VUX1NZTkMpO1xuICAgIHJldHVybiBmc18xLmRlZmF1bHQucmVhZEZpbGVTeW5jUmV0cnkodGltZW91dCkoZmlsZVBhdGgsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5yZWFkRmlsZVN5bmMgPSByZWFkRmlsZVN5bmM7XG47XG5jb25zdCB3cml0ZUZpbGUgPSAoZmlsZVBhdGgsIGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gICAgaWYgKGxhbmdfMS5kZWZhdWx0LmlzRnVuY3Rpb24ob3B0aW9ucykpXG4gICAgICAgIHJldHVybiB3cml0ZUZpbGUoZmlsZVBhdGgsIGRhdGEsIGNvbnN0c18xLkRFRkFVTFRfV1JJVEVfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgY29uc3QgcHJvbWlzZSA9IHdyaXRlRmlsZUFzeW5jKGZpbGVQYXRoLCBkYXRhLCBvcHRpb25zKTtcbiAgICBpZiAoY2FsbGJhY2spXG4gICAgICAgIHByb21pc2UudGhlbihjYWxsYmFjaywgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufTtcbmV4cG9ydHMud3JpdGVGaWxlID0gd3JpdGVGaWxlO1xuY29uc3Qgd3JpdGVGaWxlQXN5bmMgPSBhc3luYyAoZmlsZVBhdGgsIGRhdGEsIG9wdGlvbnMgPSBjb25zdHNfMS5ERUZBVUxUX1dSSVRFX09QVElPTlMpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGxhbmdfMS5kZWZhdWx0LmlzU3RyaW5nKG9wdGlvbnMpKVxuICAgICAgICByZXR1cm4gd3JpdGVGaWxlQXN5bmMoZmlsZVBhdGgsIGRhdGEsIHsgZW5jb2Rpbmc6IG9wdGlvbnMgfSk7XG4gICAgY29uc3QgdGltZW91dCA9IERhdGUubm93KCkgKyAoKF9hID0gb3B0aW9ucy50aW1lb3V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb25zdHNfMS5ERUZBVUxUX1RJTUVPVVRfQVNZTkMpO1xuICAgIGxldCBzY2hlZHVsZXJDdXN0b21EaXNwb3NlciA9IG51bGwsIHNjaGVkdWxlckRpc3Bvc2VyID0gbnVsbCwgdGVtcERpc3Bvc2VyID0gbnVsbCwgdGVtcFBhdGggPSBudWxsLCBmZCA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2NoZWR1bGUpXG4gICAgICAgICAgICBzY2hlZHVsZXJDdXN0b21EaXNwb3NlciA9IGF3YWl0IG9wdGlvbnMuc2NoZWR1bGUoZmlsZVBhdGgpO1xuICAgICAgICBzY2hlZHVsZXJEaXNwb3NlciA9IGF3YWl0IHNjaGVkdWxlcl8xLmRlZmF1bHQuc2NoZWR1bGUoZmlsZVBhdGgpO1xuICAgICAgICBmaWxlUGF0aCA9IGF3YWl0IGZzXzEuZGVmYXVsdC5yZWFscGF0aEF0dGVtcHQoZmlsZVBhdGgpIHx8IGZpbGVQYXRoO1xuICAgICAgICBbdGVtcFBhdGgsIHRlbXBEaXNwb3Nlcl0gPSB0ZW1wXzEuZGVmYXVsdC5nZXQoZmlsZVBhdGgsIG9wdGlvbnMudG1wQ3JlYXRlIHx8IHRlbXBfMS5kZWZhdWx0LmNyZWF0ZSwgIShvcHRpb25zLnRtcFB1cmdlID09PSBmYWxzZSkpO1xuICAgICAgICBjb25zdCB1c2VTdGF0Q2hvd24gPSBjb25zdHNfMS5JU19QT1NJWCAmJiBsYW5nXzEuZGVmYXVsdC5pc1VuZGVmaW5lZChvcHRpb25zLmNob3duKSwgdXNlU3RhdE1vZGUgPSBsYW5nXzEuZGVmYXVsdC5pc1VuZGVmaW5lZChvcHRpb25zLm1vZGUpO1xuICAgICAgICBpZiAodXNlU3RhdENob3duIHx8IHVzZVN0YXRNb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ID0gYXdhaXQgZnNfMS5kZWZhdWx0LnN0YXRBdHRlbXB0KGZpbGVQYXRoKTtcbiAgICAgICAgICAgIGlmIChzdGF0KSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgICAgIGlmICh1c2VTdGF0Q2hvd24pXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY2hvd24gPSB7IHVpZDogc3RhdC51aWQsIGdpZDogc3RhdC5naWQgfTtcbiAgICAgICAgICAgICAgICBpZiAodXNlU3RhdE1vZGUpXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubW9kZSA9IHN0YXQubW9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJlbnRQYXRoID0gcGF0aC5kaXJuYW1lKGZpbGVQYXRoKTtcbiAgICAgICAgYXdhaXQgZnNfMS5kZWZhdWx0Lm1rZGlyQXR0ZW1wdChwYXJlbnRQYXRoLCB7XG4gICAgICAgICAgICBtb2RlOiBjb25zdHNfMS5ERUZBVUxUX0ZPTERFUl9NT0RFLFxuICAgICAgICAgICAgcmVjdXJzaXZlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBmZCA9IGF3YWl0IGZzXzEuZGVmYXVsdC5vcGVuUmV0cnkodGltZW91dCkodGVtcFBhdGgsICd3Jywgb3B0aW9ucy5tb2RlIHx8IGNvbnN0c18xLkRFRkFVTFRfRklMRV9NT0RFKTtcbiAgICAgICAgaWYgKG9wdGlvbnMudG1wQ3JlYXRlZClcbiAgICAgICAgICAgIG9wdGlvbnMudG1wQ3JlYXRlZCh0ZW1wUGF0aCk7XG4gICAgICAgIGlmIChsYW5nXzEuZGVmYXVsdC5pc1N0cmluZyhkYXRhKSkge1xuICAgICAgICAgICAgYXdhaXQgZnNfMS5kZWZhdWx0LndyaXRlUmV0cnkodGltZW91dCkoZmQsIGRhdGEsIDAsIG9wdGlvbnMuZW5jb2RpbmcgfHwgY29uc3RzXzEuREVGQVVMVF9FTkNPRElORyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWxhbmdfMS5kZWZhdWx0LmlzVW5kZWZpbmVkKGRhdGEpKSB7XG4gICAgICAgICAgICBhd2FpdCBmc18xLmRlZmF1bHQud3JpdGVSZXRyeSh0aW1lb3V0KShmZCwgZGF0YSwgMCwgZGF0YS5sZW5ndGgsIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmZzeW5jICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZnN5bmNXYWl0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGZzXzEuZGVmYXVsdC5mc3luY1JldHJ5KHRpbWVvdXQpKGZkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZzXzEuZGVmYXVsdC5mc3luY0F0dGVtcHQoZmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGZzXzEuZGVmYXVsdC5jbG9zZVJldHJ5KHRpbWVvdXQpKGZkKTtcbiAgICAgICAgZmQgPSBudWxsO1xuICAgICAgICBpZiAob3B0aW9ucy5jaG93bilcbiAgICAgICAgICAgIGF3YWl0IGZzXzEuZGVmYXVsdC5jaG93bkF0dGVtcHQodGVtcFBhdGgsIG9wdGlvbnMuY2hvd24udWlkLCBvcHRpb25zLmNob3duLmdpZCk7XG4gICAgICAgIGlmIChvcHRpb25zLm1vZGUpXG4gICAgICAgICAgICBhd2FpdCBmc18xLmRlZmF1bHQuY2htb2RBdHRlbXB0KHRlbXBQYXRoLCBvcHRpb25zLm1vZGUpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgZnNfMS5kZWZhdWx0LnJlbmFtZVJldHJ5KHRpbWVvdXQpKHRlbXBQYXRoLCBmaWxlUGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IuY29kZSAhPT0gJ0VOQU1FVE9PTE9ORycpXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICBhd2FpdCBmc18xLmRlZmF1bHQucmVuYW1lUmV0cnkodGltZW91dCkodGVtcFBhdGgsIHRlbXBfMS5kZWZhdWx0LnRydW5jYXRlKGZpbGVQYXRoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcERpc3Bvc2VyKCk7XG4gICAgICAgIHRlbXBQYXRoID0gbnVsbDtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIGlmIChmZClcbiAgICAgICAgICAgIGF3YWl0IGZzXzEuZGVmYXVsdC5jbG9zZUF0dGVtcHQoZmQpO1xuICAgICAgICBpZiAodGVtcFBhdGgpXG4gICAgICAgICAgICB0ZW1wXzEuZGVmYXVsdC5wdXJnZSh0ZW1wUGF0aCk7XG4gICAgICAgIGlmIChzY2hlZHVsZXJDdXN0b21EaXNwb3NlcilcbiAgICAgICAgICAgIHNjaGVkdWxlckN1c3RvbURpc3Bvc2VyKCk7XG4gICAgICAgIGlmIChzY2hlZHVsZXJEaXNwb3NlcilcbiAgICAgICAgICAgIHNjaGVkdWxlckRpc3Bvc2VyKCk7XG4gICAgfVxufTtcbmNvbnN0IHdyaXRlRmlsZVN5bmMgPSAoZmlsZVBhdGgsIGRhdGEsIG9wdGlvbnMgPSBjb25zdHNfMS5ERUZBVUxUX1dSSVRFX09QVElPTlMpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGxhbmdfMS5kZWZhdWx0LmlzU3RyaW5nKG9wdGlvbnMpKVxuICAgICAgICByZXR1cm4gd3JpdGVGaWxlU3luYyhmaWxlUGF0aCwgZGF0YSwgeyBlbmNvZGluZzogb3B0aW9ucyB9KTtcbiAgICBjb25zdCB0aW1lb3V0ID0gRGF0ZS5ub3coKSArICgoX2EgPSBvcHRpb25zLnRpbWVvdXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbnN0c18xLkRFRkFVTFRfVElNRU9VVF9TWU5DKTtcbiAgICBsZXQgdGVtcERpc3Bvc2VyID0gbnVsbCwgdGVtcFBhdGggPSBudWxsLCBmZCA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgICAgZmlsZVBhdGggPSBmc18xLmRlZmF1bHQucmVhbHBhdGhTeW5jQXR0ZW1wdChmaWxlUGF0aCkgfHwgZmlsZVBhdGg7XG4gICAgICAgIFt0ZW1wUGF0aCwgdGVtcERpc3Bvc2VyXSA9IHRlbXBfMS5kZWZhdWx0LmdldChmaWxlUGF0aCwgb3B0aW9ucy50bXBDcmVhdGUgfHwgdGVtcF8xLmRlZmF1bHQuY3JlYXRlLCAhKG9wdGlvbnMudG1wUHVyZ2UgPT09IGZhbHNlKSk7XG4gICAgICAgIGNvbnN0IHVzZVN0YXRDaG93biA9IGNvbnN0c18xLklTX1BPU0lYICYmIGxhbmdfMS5kZWZhdWx0LmlzVW5kZWZpbmVkKG9wdGlvbnMuY2hvd24pLCB1c2VTdGF0TW9kZSA9IGxhbmdfMS5kZWZhdWx0LmlzVW5kZWZpbmVkKG9wdGlvbnMubW9kZSk7XG4gICAgICAgIGlmICh1c2VTdGF0Q2hvd24gfHwgdXNlU3RhdE1vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXQgPSBmc18xLmRlZmF1bHQuc3RhdFN5bmNBdHRlbXB0KGZpbGVQYXRoKTtcbiAgICAgICAgICAgIGlmIChzdGF0KSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgICAgIGlmICh1c2VTdGF0Q2hvd24pXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY2hvd24gPSB7IHVpZDogc3RhdC51aWQsIGdpZDogc3RhdC5naWQgfTtcbiAgICAgICAgICAgICAgICBpZiAodXNlU3RhdE1vZGUpXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubW9kZSA9IHN0YXQubW9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJlbnRQYXRoID0gcGF0aC5kaXJuYW1lKGZpbGVQYXRoKTtcbiAgICAgICAgZnNfMS5kZWZhdWx0Lm1rZGlyU3luY0F0dGVtcHQocGFyZW50UGF0aCwge1xuICAgICAgICAgICAgbW9kZTogY29uc3RzXzEuREVGQVVMVF9GT0xERVJfTU9ERSxcbiAgICAgICAgICAgIHJlY3Vyc2l2ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgZmQgPSBmc18xLmRlZmF1bHQub3BlblN5bmNSZXRyeSh0aW1lb3V0KSh0ZW1wUGF0aCwgJ3cnLCBvcHRpb25zLm1vZGUgfHwgY29uc3RzXzEuREVGQVVMVF9GSUxFX01PREUpO1xuICAgICAgICBpZiAob3B0aW9ucy50bXBDcmVhdGVkKVxuICAgICAgICAgICAgb3B0aW9ucy50bXBDcmVhdGVkKHRlbXBQYXRoKTtcbiAgICAgICAgaWYgKGxhbmdfMS5kZWZhdWx0LmlzU3RyaW5nKGRhdGEpKSB7XG4gICAgICAgICAgICBmc18xLmRlZmF1bHQud3JpdGVTeW5jUmV0cnkodGltZW91dCkoZmQsIGRhdGEsIDAsIG9wdGlvbnMuZW5jb2RpbmcgfHwgY29uc3RzXzEuREVGQVVMVF9FTkNPRElORyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWxhbmdfMS5kZWZhdWx0LmlzVW5kZWZpbmVkKGRhdGEpKSB7XG4gICAgICAgICAgICBmc18xLmRlZmF1bHQud3JpdGVTeW5jUmV0cnkodGltZW91dCkoZmQsIGRhdGEsIDAsIGRhdGEubGVuZ3RoLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5mc3luYyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZzeW5jV2FpdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBmc18xLmRlZmF1bHQuZnN5bmNTeW5jUmV0cnkodGltZW91dCkoZmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZnNfMS5kZWZhdWx0LmZzeW5jQXR0ZW1wdChmZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnNfMS5kZWZhdWx0LmNsb3NlU3luY1JldHJ5KHRpbWVvdXQpKGZkKTtcbiAgICAgICAgZmQgPSBudWxsO1xuICAgICAgICBpZiAob3B0aW9ucy5jaG93bilcbiAgICAgICAgICAgIGZzXzEuZGVmYXVsdC5jaG93blN5bmNBdHRlbXB0KHRlbXBQYXRoLCBvcHRpb25zLmNob3duLnVpZCwgb3B0aW9ucy5jaG93bi5naWQpO1xuICAgICAgICBpZiAob3B0aW9ucy5tb2RlKVxuICAgICAgICAgICAgZnNfMS5kZWZhdWx0LmNobW9kU3luY0F0dGVtcHQodGVtcFBhdGgsIG9wdGlvbnMubW9kZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmc18xLmRlZmF1bHQucmVuYW1lU3luY1JldHJ5KHRpbWVvdXQpKHRlbXBQYXRoLCBmaWxlUGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IuY29kZSAhPT0gJ0VOQU1FVE9PTE9ORycpXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICBmc18xLmRlZmF1bHQucmVuYW1lU3luY1JldHJ5KHRpbWVvdXQpKHRlbXBQYXRoLCB0ZW1wXzEuZGVmYXVsdC50cnVuY2F0ZShmaWxlUGF0aCkpO1xuICAgICAgICB9XG4gICAgICAgIHRlbXBEaXNwb3NlcigpO1xuICAgICAgICB0ZW1wUGF0aCA9IG51bGw7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBpZiAoZmQpXG4gICAgICAgICAgICBmc18xLmRlZmF1bHQuY2xvc2VTeW5jQXR0ZW1wdChmZCk7XG4gICAgICAgIGlmICh0ZW1wUGF0aClcbiAgICAgICAgICAgIHRlbXBfMS5kZWZhdWx0LnB1cmdlKHRlbXBQYXRoKTtcbiAgICB9XG59O1xuZXhwb3J0cy53cml0ZUZpbGVTeW5jID0gd3JpdGVGaWxlU3luYztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZWdleHBDb2RlID0gZXhwb3J0cy5nZXRQcm9wZXJ0eSA9IGV4cG9ydHMuc2FmZVN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJDb25jYXQgPSBleHBvcnRzLmFkZENvZGVBcmcgPSBleHBvcnRzLnN0ciA9IGV4cG9ydHMuXyA9IGV4cG9ydHMubmlsID0gZXhwb3J0cy5fQ29kZSA9IGV4cG9ydHMuTmFtZSA9IGV4cG9ydHMuSURFTlRJRklFUiA9IGV4cG9ydHMuX0NvZGVPck5hbWUgPSB2b2lkIDA7XG5jbGFzcyBfQ29kZU9yTmFtZSB7XG59XG5leHBvcnRzLl9Db2RlT3JOYW1lID0gX0NvZGVPck5hbWU7XG5leHBvcnRzLklERU5USUZJRVIgPSAvXlthLXokX11bYS16JF8wLTldKiQvaTtcbmNsYXNzIE5hbWUgZXh0ZW5kcyBfQ29kZU9yTmFtZSB7XG4gICAgY29uc3RydWN0b3Iocykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAoIWV4cG9ydHMuSURFTlRJRklFUi50ZXN0KHMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29kZUdlbjogbmFtZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclwiKTtcbiAgICAgICAgdGhpcy5zdHIgPSBzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyO1xuICAgIH1cbiAgICBlbXB0eVN0cigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB7IFt0aGlzLnN0cl06IDEgfTtcbiAgICB9XG59XG5leHBvcnRzLk5hbWUgPSBOYW1lO1xuY2xhc3MgX0NvZGUgZXh0ZW5kcyBfQ29kZU9yTmFtZSB7XG4gICAgY29uc3RydWN0b3IoY29kZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9pdGVtcyA9IHR5cGVvZiBjb2RlID09PSBcInN0cmluZ1wiID8gW2NvZGVdIDogY29kZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cjtcbiAgICB9XG4gICAgZW1wdHlTdHIoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pdGVtcy5sZW5ndGggPiAxKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5faXRlbXNbMF07XG4gICAgICAgIHJldHVybiBpdGVtID09PSBcIlwiIHx8IGl0ZW0gPT09ICdcIlwiJztcbiAgICB9XG4gICAgZ2V0IHN0cigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMuX3N0cikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKHRoaXMuX3N0ciA9IHRoaXMuX2l0ZW1zLnJlZHVjZSgocywgYykgPT4gYCR7c30ke2N9YCwgXCJcIikpKTtcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy5fbmFtZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICh0aGlzLl9uYW1lcyA9IHRoaXMuX2l0ZW1zLnJlZHVjZSgobmFtZXMsIGMpID0+IHtcbiAgICAgICAgICAgIGlmIChjIGluc3RhbmNlb2YgTmFtZSlcbiAgICAgICAgICAgICAgICBuYW1lc1tjLnN0cl0gPSAobmFtZXNbYy5zdHJdIHx8IDApICsgMTtcbiAgICAgICAgICAgIHJldHVybiBuYW1lcztcbiAgICAgICAgfSwge30pKSk7XG4gICAgfVxufVxuZXhwb3J0cy5fQ29kZSA9IF9Db2RlO1xuZXhwb3J0cy5uaWwgPSBuZXcgX0NvZGUoXCJcIik7XG5mdW5jdGlvbiBfKHN0cnMsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBjb2RlID0gW3N0cnNbMF1dO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGFkZENvZGVBcmcoY29kZSwgYXJnc1tpXSk7XG4gICAgICAgIGNvZGUucHVzaChzdHJzWysraV0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9Db2RlKGNvZGUpO1xufVxuZXhwb3J0cy5fID0gXztcbmNvbnN0IHBsdXMgPSBuZXcgX0NvZGUoXCIrXCIpO1xuZnVuY3Rpb24gc3RyKHN0cnMsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBleHByID0gW3NhZmVTdHJpbmdpZnkoc3Ryc1swXSldO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGV4cHIucHVzaChwbHVzKTtcbiAgICAgICAgYWRkQ29kZUFyZyhleHByLCBhcmdzW2ldKTtcbiAgICAgICAgZXhwci5wdXNoKHBsdXMsIHNhZmVTdHJpbmdpZnkoc3Ryc1srK2ldKSk7XG4gICAgfVxuICAgIG9wdGltaXplKGV4cHIpO1xuICAgIHJldHVybiBuZXcgX0NvZGUoZXhwcik7XG59XG5leHBvcnRzLnN0ciA9IHN0cjtcbmZ1bmN0aW9uIGFkZENvZGVBcmcoY29kZSwgYXJnKSB7XG4gICAgaWYgKGFyZyBpbnN0YW5jZW9mIF9Db2RlKVxuICAgICAgICBjb2RlLnB1c2goLi4uYXJnLl9pdGVtcyk7XG4gICAgZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgTmFtZSlcbiAgICAgICAgY29kZS5wdXNoKGFyZyk7XG4gICAgZWxzZVxuICAgICAgICBjb2RlLnB1c2goaW50ZXJwb2xhdGUoYXJnKSk7XG59XG5leHBvcnRzLmFkZENvZGVBcmcgPSBhZGRDb2RlQXJnO1xuZnVuY3Rpb24gb3B0aW1pemUoZXhwcikge1xuICAgIGxldCBpID0gMTtcbiAgICB3aGlsZSAoaSA8IGV4cHIubGVuZ3RoIC0gMSkge1xuICAgICAgICBpZiAoZXhwcltpXSA9PT0gcGx1cykge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gbWVyZ2VFeHBySXRlbXMoZXhwcltpIC0gMV0sIGV4cHJbaSArIDFdKTtcbiAgICAgICAgICAgIGlmIChyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGV4cHIuc3BsaWNlKGkgLSAxLCAzLCByZXMpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwcltpKytdID0gXCIrXCI7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1lcmdlRXhwckl0ZW1zKGEsIGIpIHtcbiAgICBpZiAoYiA9PT0gJ1wiXCInKVxuICAgICAgICByZXR1cm4gYTtcbiAgICBpZiAoYSA9PT0gJ1wiXCInKVxuICAgICAgICByZXR1cm4gYjtcbiAgICBpZiAodHlwZW9mIGEgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoYiBpbnN0YW5jZW9mIE5hbWUgfHwgYVthLmxlbmd0aCAtIDFdICE9PSAnXCInKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodHlwZW9mIGIgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJldHVybiBgJHthLnNsaWNlKDAsIC0xKX0ke2J9XCJgO1xuICAgICAgICBpZiAoYlswXSA9PT0gJ1wiJylcbiAgICAgICAgICAgIHJldHVybiBhLnNsaWNlKDAsIC0xKSArIGIuc2xpY2UoMSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBiID09IFwic3RyaW5nXCIgJiYgYlswXSA9PT0gJ1wiJyAmJiAhKGEgaW5zdGFuY2VvZiBOYW1lKSlcbiAgICAgICAgcmV0dXJuIGBcIiR7YX0ke2Iuc2xpY2UoMSl9YDtcbiAgICByZXR1cm47XG59XG5mdW5jdGlvbiBzdHJDb25jYXQoYzEsIGMyKSB7XG4gICAgcmV0dXJuIGMyLmVtcHR5U3RyKCkgPyBjMSA6IGMxLmVtcHR5U3RyKCkgPyBjMiA6IHN0ciBgJHtjMX0ke2MyfWA7XG59XG5leHBvcnRzLnN0ckNvbmNhdCA9IHN0ckNvbmNhdDtcbi8vIFRPRE8gZG8gbm90IGFsbG93IGFycmF5cyBoZXJlXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSh4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHggPT0gXCJib29sZWFuXCIgfHwgeCA9PT0gbnVsbFxuICAgICAgICA/IHhcbiAgICAgICAgOiBzYWZlU3RyaW5naWZ5KEFycmF5LmlzQXJyYXkoeCkgPyB4LmpvaW4oXCIsXCIpIDogeCk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkoeCkge1xuICAgIHJldHVybiBuZXcgX0NvZGUoc2FmZVN0cmluZ2lmeSh4KSk7XG59XG5leHBvcnRzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcbmZ1bmN0aW9uIHNhZmVTdHJpbmdpZnkoeCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh4KVxuICAgICAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCBcIlxcXFx1MjAyOFwiKVxuICAgICAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCBcIlxcXFx1MjAyOVwiKTtcbn1cbmV4cG9ydHMuc2FmZVN0cmluZ2lmeSA9IHNhZmVTdHJpbmdpZnk7XG5mdW5jdGlvbiBnZXRQcm9wZXJ0eShrZXkpIHtcbiAgICByZXR1cm4gdHlwZW9mIGtleSA9PSBcInN0cmluZ1wiICYmIGV4cG9ydHMuSURFTlRJRklFUi50ZXN0KGtleSkgPyBuZXcgX0NvZGUoYC4ke2tleX1gKSA6IF8gYFske2tleX1dYDtcbn1cbmV4cG9ydHMuZ2V0UHJvcGVydHkgPSBnZXRQcm9wZXJ0eTtcbmZ1bmN0aW9uIHJlZ2V4cENvZGUocngpIHtcbiAgICByZXR1cm4gbmV3IF9Db2RlKHJ4LnRvU3RyaW5nKCkpO1xufVxuZXhwb3J0cy5yZWdleHBDb2RlID0gcmVnZXhwQ29kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZhbHVlU2NvcGUgPSBleHBvcnRzLlZhbHVlU2NvcGVOYW1lID0gZXhwb3J0cy5TY29wZSA9IGV4cG9ydHMudmFyS2luZHMgPSBleHBvcnRzLlVzZWRWYWx1ZVN0YXRlID0gdm9pZCAwO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4vY29kZVwiKTtcbmNsYXNzIFZhbHVlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICBzdXBlcihgQ29kZUdlbjogXCJjb2RlXCIgZm9yICR7bmFtZX0gbm90IGRlZmluZWRgKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IG5hbWUudmFsdWU7XG4gICAgfVxufVxudmFyIFVzZWRWYWx1ZVN0YXRlO1xuKGZ1bmN0aW9uIChVc2VkVmFsdWVTdGF0ZSkge1xuICAgIFVzZWRWYWx1ZVN0YXRlW1VzZWRWYWx1ZVN0YXRlW1wiU3RhcnRlZFwiXSA9IDBdID0gXCJTdGFydGVkXCI7XG4gICAgVXNlZFZhbHVlU3RhdGVbVXNlZFZhbHVlU3RhdGVbXCJDb21wbGV0ZWRcIl0gPSAxXSA9IFwiQ29tcGxldGVkXCI7XG59KShVc2VkVmFsdWVTdGF0ZSA9IGV4cG9ydHMuVXNlZFZhbHVlU3RhdGUgfHwgKGV4cG9ydHMuVXNlZFZhbHVlU3RhdGUgPSB7fSkpO1xuZXhwb3J0cy52YXJLaW5kcyA9IHtcbiAgICBjb25zdDogbmV3IGNvZGVfMS5OYW1lKFwiY29uc3RcIiksXG4gICAgbGV0OiBuZXcgY29kZV8xLk5hbWUoXCJsZXRcIiksXG4gICAgdmFyOiBuZXcgY29kZV8xLk5hbWUoXCJ2YXJcIiksXG59O1xuY2xhc3MgU2NvcGUge1xuICAgIGNvbnN0cnVjdG9yKHsgcHJlZml4ZXMsIHBhcmVudCB9ID0ge30pIHtcbiAgICAgICAgdGhpcy5fbmFtZXMgPSB7fTtcbiAgICAgICAgdGhpcy5fcHJlZml4ZXMgPSBwcmVmaXhlcztcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgICB0b05hbWUobmFtZU9yUHJlZml4KSB7XG4gICAgICAgIHJldHVybiBuYW1lT3JQcmVmaXggaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSA/IG5hbWVPclByZWZpeCA6IHRoaXMubmFtZShuYW1lT3JQcmVmaXgpO1xuICAgIH1cbiAgICBuYW1lKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gbmV3IGNvZGVfMS5OYW1lKHRoaXMuX25ld05hbWUocHJlZml4KSk7XG4gICAgfVxuICAgIF9uZXdOYW1lKHByZWZpeCkge1xuICAgICAgICBjb25zdCBuZyA9IHRoaXMuX25hbWVzW3ByZWZpeF0gfHwgdGhpcy5fbmFtZUdyb3VwKHByZWZpeCk7XG4gICAgICAgIHJldHVybiBgJHtwcmVmaXh9JHtuZy5pbmRleCsrfWA7XG4gICAgfVxuICAgIF9uYW1lR3JvdXAocHJlZml4KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICgoKF9iID0gKF9hID0gdGhpcy5fcGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuX3ByZWZpeGVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaGFzKHByZWZpeCkpIHx8ICh0aGlzLl9wcmVmaXhlcyAmJiAhdGhpcy5fcHJlZml4ZXMuaGFzKHByZWZpeCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IHByZWZpeCBcIiR7cHJlZml4fVwiIGlzIG5vdCBhbGxvd2VkIGluIHRoaXMgc2NvcGVgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHRoaXMuX25hbWVzW3ByZWZpeF0gPSB7IHByZWZpeCwgaW5kZXg6IDAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5TY29wZSA9IFNjb3BlO1xuY2xhc3MgVmFsdWVTY29wZU5hbWUgZXh0ZW5kcyBjb2RlXzEuTmFtZSB7XG4gICAgY29uc3RydWN0b3IocHJlZml4LCBuYW1lU3RyKSB7XG4gICAgICAgIHN1cGVyKG5hbWVTdHIpO1xuICAgICAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcbiAgICB9XG4gICAgc2V0VmFsdWUodmFsdWUsIHsgcHJvcGVydHksIGl0ZW1JbmRleCB9KSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zY29wZVBhdGggPSBjb2RlXzEuXyBgLiR7bmV3IGNvZGVfMS5OYW1lKHByb3BlcnR5KX1bJHtpdGVtSW5kZXh9XWA7XG4gICAgfVxufVxuZXhwb3J0cy5WYWx1ZVNjb3BlTmFtZSA9IFZhbHVlU2NvcGVOYW1lO1xuY29uc3QgbGluZSA9IGNvZGVfMS5fIGBcXG5gO1xuY2xhc3MgVmFsdWVTY29wZSBleHRlbmRzIFNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpO1xuICAgICAgICB0aGlzLl92YWx1ZXMgPSB7fTtcbiAgICAgICAgdGhpcy5fc2NvcGUgPSBvcHRzLnNjb3BlO1xuICAgICAgICB0aGlzLm9wdHMgPSB7IC4uLm9wdHMsIF9uOiBvcHRzLmxpbmVzID8gbGluZSA6IGNvZGVfMS5uaWwgfTtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NvcGU7XG4gICAgfVxuICAgIG5hbWUocHJlZml4KSB7XG4gICAgICAgIHJldHVybiBuZXcgVmFsdWVTY29wZU5hbWUocHJlZml4LCB0aGlzLl9uZXdOYW1lKHByZWZpeCkpO1xuICAgIH1cbiAgICB2YWx1ZShuYW1lT3JQcmVmaXgsIHZhbHVlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHZhbHVlLnJlZiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29kZUdlbjogcmVmIG11c3QgYmUgcGFzc2VkIGluIHZhbHVlXCIpO1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy50b05hbWUobmFtZU9yUHJlZml4KTtcbiAgICAgICAgY29uc3QgeyBwcmVmaXggfSA9IG5hbWU7XG4gICAgICAgIGNvbnN0IHZhbHVlS2V5ID0gKF9hID0gdmFsdWUua2V5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2YWx1ZS5yZWY7XG4gICAgICAgIGxldCB2cyA9IHRoaXMuX3ZhbHVlc1twcmVmaXhdO1xuICAgICAgICBpZiAodnMpIHtcbiAgICAgICAgICAgIGNvbnN0IF9uYW1lID0gdnMuZ2V0KHZhbHVlS2V5KTtcbiAgICAgICAgICAgIGlmIChfbmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gX25hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2cyA9IHRoaXMuX3ZhbHVlc1twcmVmaXhdID0gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIHZzLnNldCh2YWx1ZUtleSwgbmFtZSk7XG4gICAgICAgIGNvbnN0IHMgPSB0aGlzLl9zY29wZVtwcmVmaXhdIHx8ICh0aGlzLl9zY29wZVtwcmVmaXhdID0gW10pO1xuICAgICAgICBjb25zdCBpdGVtSW5kZXggPSBzLmxlbmd0aDtcbiAgICAgICAgc1tpdGVtSW5kZXhdID0gdmFsdWUucmVmO1xuICAgICAgICBuYW1lLnNldFZhbHVlKHZhbHVlLCB7IHByb3BlcnR5OiBwcmVmaXgsIGl0ZW1JbmRleCB9KTtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIGdldFZhbHVlKHByZWZpeCwga2V5T3JSZWYpIHtcbiAgICAgICAgY29uc3QgdnMgPSB0aGlzLl92YWx1ZXNbcHJlZml4XTtcbiAgICAgICAgaWYgKCF2cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIHZzLmdldChrZXlPclJlZik7XG4gICAgfVxuICAgIHNjb3BlUmVmcyhzY29wZU5hbWUsIHZhbHVlcyA9IHRoaXMuX3ZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVkdWNlVmFsdWVzKHZhbHVlcywgKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmIChuYW1lLnNjb3BlUGF0aCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogbmFtZSBcIiR7bmFtZX1cIiBoYXMgbm8gdmFsdWVgKTtcbiAgICAgICAgICAgIHJldHVybiBjb2RlXzEuXyBgJHtzY29wZU5hbWV9JHtuYW1lLnNjb3BlUGF0aH1gO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2NvcGVDb2RlKHZhbHVlcyA9IHRoaXMuX3ZhbHVlcywgdXNlZFZhbHVlcywgZ2V0Q29kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVkdWNlVmFsdWVzKHZhbHVlcywgKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmIChuYW1lLnZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiBuYW1lIFwiJHtuYW1lfVwiIGhhcyBubyB2YWx1ZWApO1xuICAgICAgICAgICAgcmV0dXJuIG5hbWUudmFsdWUuY29kZTtcbiAgICAgICAgfSwgdXNlZFZhbHVlcywgZ2V0Q29kZSk7XG4gICAgfVxuICAgIF9yZWR1Y2VWYWx1ZXModmFsdWVzLCB2YWx1ZUNvZGUsIHVzZWRWYWx1ZXMgPSB7fSwgZ2V0Q29kZSkge1xuICAgICAgICBsZXQgY29kZSA9IGNvZGVfMS5uaWw7XG4gICAgICAgIGZvciAoY29uc3QgcHJlZml4IGluIHZhbHVlcykge1xuICAgICAgICAgICAgY29uc3QgdnMgPSB2YWx1ZXNbcHJlZml4XTtcbiAgICAgICAgICAgIGlmICghdnMpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBuYW1lU2V0ID0gKHVzZWRWYWx1ZXNbcHJlZml4XSA9IHVzZWRWYWx1ZXNbcHJlZml4XSB8fCBuZXcgTWFwKCkpO1xuICAgICAgICAgICAgdnMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lU2V0LmhhcyhuYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIG5hbWVTZXQuc2V0KG5hbWUsIFVzZWRWYWx1ZVN0YXRlLlN0YXJ0ZWQpO1xuICAgICAgICAgICAgICAgIGxldCBjID0gdmFsdWVDb2RlKG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlZiA9IHRoaXMub3B0cy5lczUgPyBleHBvcnRzLnZhcktpbmRzLnZhciA6IGV4cG9ydHMudmFyS2luZHMuY29uc3Q7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlXzEuXyBgJHtjb2RlfSR7ZGVmfSAke25hbWV9ID0gJHtjfTske3RoaXMub3B0cy5fbn1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgoYyA9IGdldENvZGUgPT09IG51bGwgfHwgZ2V0Q29kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2V0Q29kZShuYW1lKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvZGVfMS5fIGAke2NvZGV9JHtjfSR7dGhpcy5vcHRzLl9ufWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmFtZVNldC5zZXQobmFtZSwgVXNlZFZhbHVlU3RhdGUuQ29tcGxldGVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbn1cbmV4cG9ydHMuVmFsdWVTY29wZSA9IFZhbHVlU2NvcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY29wZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMub3IgPSBleHBvcnRzLmFuZCA9IGV4cG9ydHMubm90ID0gZXhwb3J0cy5Db2RlR2VuID0gZXhwb3J0cy5vcGVyYXRvcnMgPSBleHBvcnRzLnZhcktpbmRzID0gZXhwb3J0cy5WYWx1ZVNjb3BlTmFtZSA9IGV4cG9ydHMuVmFsdWVTY29wZSA9IGV4cG9ydHMuU2NvcGUgPSBleHBvcnRzLk5hbWUgPSBleHBvcnRzLnJlZ2V4cENvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IGV4cG9ydHMuZ2V0UHJvcGVydHkgPSBleHBvcnRzLm5pbCA9IGV4cG9ydHMuc3RyQ29uY2F0ID0gZXhwb3J0cy5zdHIgPSBleHBvcnRzLl8gPSB2b2lkIDA7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi9jb2RlXCIpO1xuY29uc3Qgc2NvcGVfMSA9IHJlcXVpcmUoXCIuL3Njb3BlXCIpO1xudmFyIGNvZGVfMiA9IHJlcXVpcmUoXCIuL2NvZGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIuXzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0clwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLnN0cjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0ckNvbmNhdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLnN0ckNvbmNhdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5pbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLm5pbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldFByb3BlcnR5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIuZ2V0UHJvcGVydHk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJpbmdpZnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5zdHJpbmdpZnk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZWdleHBDb2RlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIucmVnZXhwQ29kZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5hbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5OYW1lOyB9IH0pO1xudmFyIHNjb3BlXzIgPSByZXF1aXJlKFwiLi9zY29wZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNjb3BlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzY29wZV8yLlNjb3BlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVmFsdWVTY29wZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2NvcGVfMi5WYWx1ZVNjb3BlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVmFsdWVTY29wZU5hbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNjb3BlXzIuVmFsdWVTY29wZU5hbWU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2YXJLaW5kc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2NvcGVfMi52YXJLaW5kczsgfSB9KTtcbmV4cG9ydHMub3BlcmF0b3JzID0ge1xuICAgIEdUOiBuZXcgY29kZV8xLl9Db2RlKFwiPlwiKSxcbiAgICBHVEU6IG5ldyBjb2RlXzEuX0NvZGUoXCI+PVwiKSxcbiAgICBMVDogbmV3IGNvZGVfMS5fQ29kZShcIjxcIiksXG4gICAgTFRFOiBuZXcgY29kZV8xLl9Db2RlKFwiPD1cIiksXG4gICAgRVE6IG5ldyBjb2RlXzEuX0NvZGUoXCI9PT1cIiksXG4gICAgTkVROiBuZXcgY29kZV8xLl9Db2RlKFwiIT09XCIpLFxuICAgIE5PVDogbmV3IGNvZGVfMS5fQ29kZShcIiFcIiksXG4gICAgT1I6IG5ldyBjb2RlXzEuX0NvZGUoXCJ8fFwiKSxcbiAgICBBTkQ6IG5ldyBjb2RlXzEuX0NvZGUoXCImJlwiKSxcbiAgICBBREQ6IG5ldyBjb2RlXzEuX0NvZGUoXCIrXCIpLFxufTtcbmNsYXNzIE5vZGUge1xuICAgIG9wdGltaXplTm9kZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKF9uYW1lcywgX2NvbnN0YW50cykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5jbGFzcyBEZWYgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YXJLaW5kLCBuYW1lLCByaHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52YXJLaW5kID0gdmFyS2luZDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5yaHMgPSByaHM7XG4gICAgfVxuICAgIHJlbmRlcih7IGVzNSwgX24gfSkge1xuICAgICAgICBjb25zdCB2YXJLaW5kID0gZXM1ID8gc2NvcGVfMS52YXJLaW5kcy52YXIgOiB0aGlzLnZhcktpbmQ7XG4gICAgICAgIGNvbnN0IHJocyA9IHRoaXMucmhzID09PSB1bmRlZmluZWQgPyBcIlwiIDogYCA9ICR7dGhpcy5yaHN9YDtcbiAgICAgICAgcmV0dXJuIGAke3ZhcktpbmR9ICR7dGhpcy5uYW1lfSR7cmhzfTtgICsgX247XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICBpZiAoIW5hbWVzW3RoaXMubmFtZS5zdHJdKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5yaHMpXG4gICAgICAgICAgICB0aGlzLnJocyA9IG9wdGltaXplRXhwcih0aGlzLnJocywgbmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJocyBpbnN0YW5jZW9mIGNvZGVfMS5fQ29kZU9yTmFtZSA/IHRoaXMucmhzLm5hbWVzIDoge307XG4gICAgfVxufVxuY2xhc3MgQXNzaWduIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IobGhzLCByaHMsIHNpZGVFZmZlY3RzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubGhzID0gbGhzO1xuICAgICAgICB0aGlzLnJocyA9IHJocztcbiAgICAgICAgdGhpcy5zaWRlRWZmZWN0cyA9IHNpZGVFZmZlY3RzO1xuICAgIH1cbiAgICByZW5kZXIoeyBfbiB9KSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmxoc30gPSAke3RoaXMucmhzfTtgICsgX247XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICBpZiAodGhpcy5saHMgaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSAmJiAhbmFtZXNbdGhpcy5saHMuc3RyXSAmJiAhdGhpcy5zaWRlRWZmZWN0cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5yaHMgPSBvcHRpbWl6ZUV4cHIodGhpcy5yaHMsIG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICBjb25zdCBuYW1lcyA9IHRoaXMubGhzIGluc3RhbmNlb2YgY29kZV8xLk5hbWUgPyB7fSA6IHsgLi4udGhpcy5saHMubmFtZXMgfTtcbiAgICAgICAgcmV0dXJuIGFkZEV4cHJOYW1lcyhuYW1lcywgdGhpcy5yaHMpO1xuICAgIH1cbn1cbmNsYXNzIEFzc2lnbk9wIGV4dGVuZHMgQXNzaWduIHtcbiAgICBjb25zdHJ1Y3RvcihsaHMsIG9wLCByaHMsIHNpZGVFZmZlY3RzKSB7XG4gICAgICAgIHN1cGVyKGxocywgcmhzLCBzaWRlRWZmZWN0cyk7XG4gICAgICAgIHRoaXMub3AgPSBvcDtcbiAgICB9XG4gICAgcmVuZGVyKHsgX24gfSkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5saHN9ICR7dGhpcy5vcH09ICR7dGhpcy5yaHN9O2AgKyBfbjtcbiAgICB9XG59XG5jbGFzcyBMYWJlbCBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGxhYmVsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgdGhpcy5uYW1lcyA9IHt9O1xuICAgIH1cbiAgICByZW5kZXIoeyBfbiB9KSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmxhYmVsfTpgICsgX247XG4gICAgfVxufVxuY2xhc3MgQnJlYWsgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihsYWJlbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgICAgIHRoaXMubmFtZXMgPSB7fTtcbiAgICB9XG4gICAgcmVuZGVyKHsgX24gfSkge1xuICAgICAgICBjb25zdCBsYWJlbCA9IHRoaXMubGFiZWwgPyBgICR7dGhpcy5sYWJlbH1gIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIGBicmVhayR7bGFiZWx9O2AgKyBfbjtcbiAgICB9XG59XG5jbGFzcyBUaHJvdyBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGVycm9yKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gICAgcmVuZGVyKHsgX24gfSkge1xuICAgICAgICByZXR1cm4gYHRocm93ICR7dGhpcy5lcnJvcn07YCArIF9uO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yLm5hbWVzO1xuICAgIH1cbn1cbmNsYXNzIEFueUNvZGUgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxuICAgIHJlbmRlcih7IF9uIH0pIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuY29kZX07YCArIF9uO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5vZGVzKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5jb2RlfWAgPyB0aGlzIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgdGhpcy5jb2RlID0gb3B0aW1pemVFeHByKHRoaXMuY29kZSwgbmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGUgaW5zdGFuY2VvZiBjb2RlXzEuX0NvZGVPck5hbWUgPyB0aGlzLmNvZGUubmFtZXMgOiB7fTtcbiAgICB9XG59XG5jbGFzcyBQYXJlbnROb2RlIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3Iobm9kZXMgPSBbXSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5vZGVzID0gbm9kZXM7XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzLnJlZHVjZSgoY29kZSwgbikgPT4gY29kZSArIG4ucmVuZGVyKG9wdHMpLCBcIlwiKTtcbiAgICB9XG4gICAgb3B0aW1pemVOb2RlcygpIHtcbiAgICAgICAgY29uc3QgeyBub2RlcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBub2Rlc1tpXS5vcHRpbWl6ZU5vZGVzKCk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShuKSlcbiAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaSwgMSwgLi4ubik7XG4gICAgICAgICAgICBlbHNlIGlmIChuKVxuICAgICAgICAgICAgICAgIG5vZGVzW2ldID0gbjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVzLmxlbmd0aCA+IDAgPyB0aGlzIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgY29uc3QgeyBub2RlcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIC8vIGl0ZXJhdGluZyBiYWNrd2FyZHMgaW1wcm92ZXMgMS1wYXNzIG9wdGltaXphdGlvblxuICAgICAgICAgICAgY29uc3QgbiA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKG4ub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHN1YnRyYWN0TmFtZXMobmFtZXMsIG4ubmFtZXMpO1xuICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2Rlcy5sZW5ndGggPiAwID8gdGhpcyA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlcy5yZWR1Y2UoKG5hbWVzLCBuKSA9PiBhZGROYW1lcyhuYW1lcywgbi5uYW1lcyksIHt9KTtcbiAgICB9XG59XG5jbGFzcyBCbG9ja05vZGUgZXh0ZW5kcyBQYXJlbnROb2RlIHtcbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gXCJ7XCIgKyBvcHRzLl9uICsgc3VwZXIucmVuZGVyKG9wdHMpICsgXCJ9XCIgKyBvcHRzLl9uO1xuICAgIH1cbn1cbmNsYXNzIFJvb3QgZXh0ZW5kcyBQYXJlbnROb2RlIHtcbn1cbmNsYXNzIEVsc2UgZXh0ZW5kcyBCbG9ja05vZGUge1xufVxuRWxzZS5raW5kID0gXCJlbHNlXCI7XG5jbGFzcyBJZiBleHRlbmRzIEJsb2NrTm9kZSB7XG4gICAgY29uc3RydWN0b3IoY29uZGl0aW9uLCBub2Rlcykge1xuICAgICAgICBzdXBlcihub2Rlcyk7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICBsZXQgY29kZSA9IGBpZigke3RoaXMuY29uZGl0aW9ufSlgICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgICAgICBpZiAodGhpcy5lbHNlKVxuICAgICAgICAgICAgY29kZSArPSBcImVsc2UgXCIgKyB0aGlzLmVsc2UucmVuZGVyKG9wdHMpO1xuICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9XG4gICAgb3B0aW1pemVOb2RlcygpIHtcbiAgICAgICAgc3VwZXIub3B0aW1pemVOb2RlcygpO1xuICAgICAgICBjb25zdCBjb25kID0gdGhpcy5jb25kaXRpb247XG4gICAgICAgIGlmIChjb25kID09PSB0cnVlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZXM7IC8vIGVsc2UgaXMgaWdub3JlZCBoZXJlXG4gICAgICAgIGxldCBlID0gdGhpcy5lbHNlO1xuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgY29uc3QgbnMgPSBlLm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgICAgIGUgPSB0aGlzLmVsc2UgPSBBcnJheS5pc0FycmF5KG5zKSA/IG5ldyBFbHNlKG5zKSA6IG5zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICBpZiAoY29uZCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBJZiA/IGUgOiBlLm5vZGVzO1xuICAgICAgICAgICAgaWYgKHRoaXMubm9kZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJZihub3QoY29uZCksIGUgaW5zdGFuY2VvZiBJZiA/IFtlXSA6IGUubm9kZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25kID09PSBmYWxzZSB8fCAhdGhpcy5ub2Rlcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5lbHNlID0gKF9hID0gdGhpcy5lbHNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgaWYgKCEoc3VwZXIub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB8fCB0aGlzLmVsc2UpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IG9wdGltaXplRXhwcih0aGlzLmNvbmRpdGlvbiwgbmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gc3VwZXIubmFtZXM7XG4gICAgICAgIGFkZEV4cHJOYW1lcyhuYW1lcywgdGhpcy5jb25kaXRpb24pO1xuICAgICAgICBpZiAodGhpcy5lbHNlKVxuICAgICAgICAgICAgYWRkTmFtZXMobmFtZXMsIHRoaXMuZWxzZS5uYW1lcyk7XG4gICAgICAgIHJldHVybiBuYW1lcztcbiAgICB9XG59XG5JZi5raW5kID0gXCJpZlwiO1xuY2xhc3MgRm9yIGV4dGVuZHMgQmxvY2tOb2RlIHtcbn1cbkZvci5raW5kID0gXCJmb3JcIjtcbmNsYXNzIEZvckxvb3AgZXh0ZW5kcyBGb3Ige1xuICAgIGNvbnN0cnVjdG9yKGl0ZXJhdGlvbikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLml0ZXJhdGlvbiA9IGl0ZXJhdGlvbjtcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGBmb3IoJHt0aGlzLml0ZXJhdGlvbn0pYCArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIGlmICghc3VwZXIub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5pdGVyYXRpb24gPSBvcHRpbWl6ZUV4cHIodGhpcy5pdGVyYXRpb24sIG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4gYWRkTmFtZXMoc3VwZXIubmFtZXMsIHRoaXMuaXRlcmF0aW9uLm5hbWVzKTtcbiAgICB9XG59XG5jbGFzcyBGb3JSYW5nZSBleHRlbmRzIEZvciB7XG4gICAgY29uc3RydWN0b3IodmFyS2luZCwgbmFtZSwgZnJvbSwgdG8pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52YXJLaW5kID0gdmFyS2luZDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICBjb25zdCB2YXJLaW5kID0gb3B0cy5lczUgPyBzY29wZV8xLnZhcktpbmRzLnZhciA6IHRoaXMudmFyS2luZDtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBmcm9tLCB0byB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGBmb3IoJHt2YXJLaW5kfSAke25hbWV9PSR7ZnJvbX07ICR7bmFtZX08JHt0b307ICR7bmFtZX0rKylgICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gYWRkRXhwck5hbWVzKHN1cGVyLm5hbWVzLCB0aGlzLmZyb20pO1xuICAgICAgICByZXR1cm4gYWRkRXhwck5hbWVzKG5hbWVzLCB0aGlzLnRvKTtcbiAgICB9XG59XG5jbGFzcyBGb3JJdGVyIGV4dGVuZHMgRm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihsb29wLCB2YXJLaW5kLCBuYW1lLCBpdGVyYWJsZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxvb3AgPSBsb29wO1xuICAgICAgICB0aGlzLnZhcktpbmQgPSB2YXJLaW5kO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLml0ZXJhYmxlID0gaXRlcmFibGU7XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiBgZm9yKCR7dGhpcy52YXJLaW5kfSAke3RoaXMubmFtZX0gJHt0aGlzLmxvb3B9ICR7dGhpcy5pdGVyYWJsZX0pYCArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIGlmICghc3VwZXIub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5pdGVyYWJsZSA9IG9wdGltaXplRXhwcih0aGlzLml0ZXJhYmxlLCBuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIGFkZE5hbWVzKHN1cGVyLm5hbWVzLCB0aGlzLml0ZXJhYmxlLm5hbWVzKTtcbiAgICB9XG59XG5jbGFzcyBGdW5jIGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBhcmdzLCBhc3luYykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICB0aGlzLmFzeW5jID0gYXN5bmM7XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIGNvbnN0IF9hc3luYyA9IHRoaXMuYXN5bmMgPyBcImFzeW5jIFwiIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIGAke19hc3luY31mdW5jdGlvbiAke3RoaXMubmFtZX0oJHt0aGlzLmFyZ3N9KWAgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxufVxuRnVuYy5raW5kID0gXCJmdW5jXCI7XG5jbGFzcyBSZXR1cm4gZXh0ZW5kcyBQYXJlbnROb2RlIHtcbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gXCJyZXR1cm4gXCIgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxufVxuUmV0dXJuLmtpbmQgPSBcInJldHVyblwiO1xuY2xhc3MgVHJ5IGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICBsZXQgY29kZSA9IFwidHJ5XCIgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgICAgIGlmICh0aGlzLmNhdGNoKVxuICAgICAgICAgICAgY29kZSArPSB0aGlzLmNhdGNoLnJlbmRlcihvcHRzKTtcbiAgICAgICAgaWYgKHRoaXMuZmluYWxseSlcbiAgICAgICAgICAgIGNvZGUgKz0gdGhpcy5maW5hbGx5LnJlbmRlcihvcHRzKTtcbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuICAgIG9wdGltaXplTm9kZXMoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHN1cGVyLm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgKF9hID0gdGhpcy5jYXRjaCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgKF9iID0gdGhpcy5maW5hbGx5KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iub3B0aW1pemVOb2RlcygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHN1cGVyLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIChfYSA9IHRoaXMuY2F0Y2gpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICAoX2IgPSB0aGlzLmZpbmFsbHkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICBjb25zdCBuYW1lcyA9IHN1cGVyLm5hbWVzO1xuICAgICAgICBpZiAodGhpcy5jYXRjaClcbiAgICAgICAgICAgIGFkZE5hbWVzKG5hbWVzLCB0aGlzLmNhdGNoLm5hbWVzKTtcbiAgICAgICAgaWYgKHRoaXMuZmluYWxseSlcbiAgICAgICAgICAgIGFkZE5hbWVzKG5hbWVzLCB0aGlzLmZpbmFsbHkubmFtZXMpO1xuICAgICAgICByZXR1cm4gbmFtZXM7XG4gICAgfVxufVxuY2xhc3MgQ2F0Y2ggZXh0ZW5kcyBCbG9ja05vZGUge1xuICAgIGNvbnN0cnVjdG9yKGVycm9yKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGBjYXRjaCgke3RoaXMuZXJyb3J9KWAgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxufVxuQ2F0Y2gua2luZCA9IFwiY2F0Y2hcIjtcbmNsYXNzIEZpbmFsbHkgZXh0ZW5kcyBCbG9ja05vZGUge1xuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiBcImZpbmFsbHlcIiArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG59XG5GaW5hbGx5LmtpbmQgPSBcImZpbmFsbHlcIjtcbmNsYXNzIENvZGVHZW4ge1xuICAgIGNvbnN0cnVjdG9yKGV4dFNjb3BlLCBvcHRzID0ge30pIHtcbiAgICAgICAgdGhpcy5fdmFsdWVzID0ge307XG4gICAgICAgIHRoaXMuX2Jsb2NrU3RhcnRzID0gW107XG4gICAgICAgIHRoaXMuX2NvbnN0YW50cyA9IHt9O1xuICAgICAgICB0aGlzLm9wdHMgPSB7IC4uLm9wdHMsIF9uOiBvcHRzLmxpbmVzID8gXCJcXG5cIiA6IFwiXCIgfTtcbiAgICAgICAgdGhpcy5fZXh0U2NvcGUgPSBleHRTY29wZTtcbiAgICAgICAgdGhpcy5fc2NvcGUgPSBuZXcgc2NvcGVfMS5TY29wZSh7IHBhcmVudDogZXh0U2NvcGUgfSk7XG4gICAgICAgIHRoaXMuX25vZGVzID0gW25ldyBSb290KCldO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3QucmVuZGVyKHRoaXMub3B0cyk7XG4gICAgfVxuICAgIC8vIHJldHVybnMgdW5pcXVlIG5hbWUgaW4gdGhlIGludGVybmFsIHNjb3BlXG4gICAgbmFtZShwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Njb3BlLm5hbWUocHJlZml4KTtcbiAgICB9XG4gICAgLy8gcmVzZXJ2ZXMgdW5pcXVlIG5hbWUgaW4gdGhlIGV4dGVybmFsIHNjb3BlXG4gICAgc2NvcGVOYW1lKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXh0U2NvcGUubmFtZShwcmVmaXgpO1xuICAgIH1cbiAgICAvLyByZXNlcnZlcyB1bmlxdWUgbmFtZSBpbiB0aGUgZXh0ZXJuYWwgc2NvcGUgYW5kIGFzc2lnbnMgdmFsdWUgdG8gaXRcbiAgICBzY29wZVZhbHVlKHByZWZpeE9yTmFtZSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuX2V4dFNjb3BlLnZhbHVlKHByZWZpeE9yTmFtZSwgdmFsdWUpO1xuICAgICAgICBjb25zdCB2cyA9IHRoaXMuX3ZhbHVlc1tuYW1lLnByZWZpeF0gfHwgKHRoaXMuX3ZhbHVlc1tuYW1lLnByZWZpeF0gPSBuZXcgU2V0KCkpO1xuICAgICAgICB2cy5hZGQobmFtZSk7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICBnZXRTY29wZVZhbHVlKHByZWZpeCwga2V5T3JSZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4dFNjb3BlLmdldFZhbHVlKHByZWZpeCwga2V5T3JSZWYpO1xuICAgIH1cbiAgICAvLyByZXR1cm4gY29kZSB0aGF0IGFzc2lnbnMgdmFsdWVzIGluIHRoZSBleHRlcm5hbCBzY29wZSB0byB0aGUgbmFtZXMgdGhhdCBhcmUgdXNlZCBpbnRlcm5hbGx5XG4gICAgLy8gKHNhbWUgbmFtZXMgdGhhdCB3ZXJlIHJldHVybmVkIGJ5IGdlbi5zY29wZU5hbWUgb3IgZ2VuLnNjb3BlVmFsdWUpXG4gICAgc2NvcGVSZWZzKHNjb3BlTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXh0U2NvcGUuc2NvcGVSZWZzKHNjb3BlTmFtZSwgdGhpcy5fdmFsdWVzKTtcbiAgICB9XG4gICAgc2NvcGVDb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXh0U2NvcGUuc2NvcGVDb2RlKHRoaXMuX3ZhbHVlcyk7XG4gICAgfVxuICAgIF9kZWYodmFyS2luZCwgbmFtZU9yUHJlZml4LCByaHMsIGNvbnN0YW50KSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9zY29wZS50b05hbWUobmFtZU9yUHJlZml4KTtcbiAgICAgICAgaWYgKHJocyAhPT0gdW5kZWZpbmVkICYmIGNvbnN0YW50KVxuICAgICAgICAgICAgdGhpcy5fY29uc3RhbnRzW25hbWUuc3RyXSA9IHJocztcbiAgICAgICAgdGhpcy5fbGVhZk5vZGUobmV3IERlZih2YXJLaW5kLCBuYW1lLCByaHMpKTtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIC8vIGBjb25zdGAgZGVjbGFyYXRpb24gKGB2YXJgIGluIGVzNSBtb2RlKVxuICAgIGNvbnN0KG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZihzY29wZV8xLnZhcktpbmRzLmNvbnN0LCBuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KTtcbiAgICB9XG4gICAgLy8gYGxldGAgZGVjbGFyYXRpb24gd2l0aCBvcHRpb25hbCBhc3NpZ25tZW50IChgdmFyYCBpbiBlczUgbW9kZSlcbiAgICBsZXQobmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmKHNjb3BlXzEudmFyS2luZHMubGV0LCBuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KTtcbiAgICB9XG4gICAgLy8gYHZhcmAgZGVjbGFyYXRpb24gd2l0aCBvcHRpb25hbCBhc3NpZ25tZW50XG4gICAgdmFyKG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZihzY29wZV8xLnZhcktpbmRzLnZhciwgbmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudCk7XG4gICAgfVxuICAgIC8vIGFzc2lnbm1lbnQgY29kZVxuICAgIGFzc2lnbihsaHMsIHJocywgc2lkZUVmZmVjdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBBc3NpZ24obGhzLCByaHMsIHNpZGVFZmZlY3RzKSk7XG4gICAgfVxuICAgIC8vIGArPWAgY29kZVxuICAgIGFkZChsaHMsIHJocykge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IEFzc2lnbk9wKGxocywgZXhwb3J0cy5vcGVyYXRvcnMuQURELCByaHMpKTtcbiAgICB9XG4gICAgLy8gYXBwZW5kcyBwYXNzZWQgU2FmZUV4cHIgdG8gY29kZSBvciBleGVjdXRlcyBCbG9ja1xuICAgIGNvZGUoYykge1xuICAgICAgICBpZiAodHlwZW9mIGMgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgYygpO1xuICAgICAgICBlbHNlIGlmIChjICE9PSBjb2RlXzEubmlsKVxuICAgICAgICAgICAgdGhpcy5fbGVhZk5vZGUobmV3IEFueUNvZGUoYykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gcmV0dXJucyBjb2RlIGZvciBvYmplY3QgbGl0ZXJhbCBmb3IgdGhlIHBhc3NlZCBhcmd1bWVudCBsaXN0IG9mIGtleS12YWx1ZSBwYWlyc1xuICAgIG9iamVjdCguLi5rZXlWYWx1ZXMpIHtcbiAgICAgICAgY29uc3QgY29kZSA9IFtcIntcIl07XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGtleVZhbHVlcykge1xuICAgICAgICAgICAgaWYgKGNvZGUubGVuZ3RoID4gMSlcbiAgICAgICAgICAgICAgICBjb2RlLnB1c2goXCIsXCIpO1xuICAgICAgICAgICAgY29kZS5wdXNoKGtleSk7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSB2YWx1ZSB8fCB0aGlzLm9wdHMuZXM1KSB7XG4gICAgICAgICAgICAgICAgY29kZS5wdXNoKFwiOlwiKTtcbiAgICAgICAgICAgICAgICBjb2RlXzEuYWRkQ29kZUFyZyhjb2RlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29kZS5wdXNoKFwifVwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBjb2RlXzEuX0NvZGUoY29kZSk7XG4gICAgfVxuICAgIC8vIGBpZmAgY2xhdXNlIChvciBzdGF0ZW1lbnQgaWYgYHRoZW5Cb2R5YCBhbmQsIG9wdGlvbmFsbHksIGBlbHNlQm9keWAgYXJlIHBhc3NlZClcbiAgICBpZihjb25kaXRpb24sIHRoZW5Cb2R5LCBlbHNlQm9keSkge1xuICAgICAgICB0aGlzLl9ibG9ja05vZGUobmV3IElmKGNvbmRpdGlvbikpO1xuICAgICAgICBpZiAodGhlbkJvZHkgJiYgZWxzZUJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMuY29kZSh0aGVuQm9keSkuZWxzZSgpLmNvZGUoZWxzZUJvZHkpLmVuZElmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhlbkJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMuY29kZSh0aGVuQm9keSkuZW5kSWYoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbHNlQm9keSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb2RlR2VuOiBcImVsc2VcIiBib2R5IHdpdGhvdXQgXCJ0aGVuXCIgYm9keScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBgZWxzZSBpZmAgY2xhdXNlIC0gaW52YWxpZCB3aXRob3V0IGBpZmAgb3IgYWZ0ZXIgYGVsc2VgIGNsYXVzZXNcbiAgICBlbHNlSWYoY29uZGl0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbHNlTm9kZShuZXcgSWYoY29uZGl0aW9uKSk7XG4gICAgfVxuICAgIC8vIGBlbHNlYCBjbGF1c2UgLSBvbmx5IHZhbGlkIGFmdGVyIGBpZmAgb3IgYGVsc2UgaWZgIGNsYXVzZXNcbiAgICBlbHNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxzZU5vZGUobmV3IEVsc2UoKSk7XG4gICAgfVxuICAgIC8vIGVuZCBgaWZgIHN0YXRlbWVudCAobmVlZGVkIGlmIGdlbi5pZiB3YXMgdXNlZCBvbmx5IHdpdGggY29uZGl0aW9uKVxuICAgIGVuZElmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5kQmxvY2tOb2RlKElmLCBFbHNlKTtcbiAgICB9XG4gICAgX2Zvcihub2RlLCBmb3JCb2R5KSB7XG4gICAgICAgIHRoaXMuX2Jsb2NrTm9kZShub2RlKTtcbiAgICAgICAgaWYgKGZvckJvZHkpXG4gICAgICAgICAgICB0aGlzLmNvZGUoZm9yQm9keSkuZW5kRm9yKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBhIGdlbmVyaWMgYGZvcmAgY2xhdXNlIChvciBzdGF0ZW1lbnQgaWYgYGZvckJvZHlgIGlzIHBhc3NlZClcbiAgICBmb3IoaXRlcmF0aW9uLCBmb3JCb2R5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb3IobmV3IEZvckxvb3AoaXRlcmF0aW9uKSwgZm9yQm9keSk7XG4gICAgfVxuICAgIC8vIGBmb3JgIHN0YXRlbWVudCBmb3IgYSByYW5nZSBvZiB2YWx1ZXNcbiAgICBmb3JSYW5nZShuYW1lT3JQcmVmaXgsIGZyb20sIHRvLCBmb3JCb2R5LCB2YXJLaW5kID0gdGhpcy5vcHRzLmVzNSA/IHNjb3BlXzEudmFyS2luZHMudmFyIDogc2NvcGVfMS52YXJLaW5kcy5sZXQpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuX3Njb3BlLnRvTmFtZShuYW1lT3JQcmVmaXgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9yKG5ldyBGb3JSYW5nZSh2YXJLaW5kLCBuYW1lLCBmcm9tLCB0byksICgpID0+IGZvckJvZHkobmFtZSkpO1xuICAgIH1cbiAgICAvLyBgZm9yLW9mYCBzdGF0ZW1lbnQgKGluIGVzNSBtb2RlIHJlcGxhY2Ugd2l0aCBhIG5vcm1hbCBmb3IgbG9vcClcbiAgICBmb3JPZihuYW1lT3JQcmVmaXgsIGl0ZXJhYmxlLCBmb3JCb2R5LCB2YXJLaW5kID0gc2NvcGVfMS52YXJLaW5kcy5jb25zdCkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fc2NvcGUudG9OYW1lKG5hbWVPclByZWZpeCk7XG4gICAgICAgIGlmICh0aGlzLm9wdHMuZXM1KSB7XG4gICAgICAgICAgICBjb25zdCBhcnIgPSBpdGVyYWJsZSBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lID8gaXRlcmFibGUgOiB0aGlzLnZhcihcIl9hcnJcIiwgaXRlcmFibGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9yUmFuZ2UoXCJfaVwiLCAwLCBjb2RlXzEuXyBgJHthcnJ9Lmxlbmd0aGAsIChpKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy52YXIobmFtZSwgY29kZV8xLl8gYCR7YXJyfVske2l9XWApO1xuICAgICAgICAgICAgICAgIGZvckJvZHkobmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZm9yKG5ldyBGb3JJdGVyKFwib2ZcIiwgdmFyS2luZCwgbmFtZSwgaXRlcmFibGUpLCAoKSA9PiBmb3JCb2R5KG5hbWUpKTtcbiAgICB9XG4gICAgLy8gYGZvci1pbmAgc3RhdGVtZW50LlxuICAgIC8vIFdpdGggb3B0aW9uIGBvd25Qcm9wZXJ0aWVzYCByZXBsYWNlZCB3aXRoIGEgYGZvci1vZmAgbG9vcCBmb3Igb2JqZWN0IGtleXNcbiAgICBmb3JJbihuYW1lT3JQcmVmaXgsIG9iaiwgZm9yQm9keSwgdmFyS2luZCA9IHRoaXMub3B0cy5lczUgPyBzY29wZV8xLnZhcktpbmRzLnZhciA6IHNjb3BlXzEudmFyS2luZHMuY29uc3QpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5vd25Qcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JPZihuYW1lT3JQcmVmaXgsIGNvZGVfMS5fIGBPYmplY3Qua2V5cygke29ian0pYCwgZm9yQm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuX3Njb3BlLnRvTmFtZShuYW1lT3JQcmVmaXgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9yKG5ldyBGb3JJdGVyKFwiaW5cIiwgdmFyS2luZCwgbmFtZSwgb2JqKSwgKCkgPT4gZm9yQm9keShuYW1lKSk7XG4gICAgfVxuICAgIC8vIGVuZCBgZm9yYCBsb29wXG4gICAgZW5kRm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5kQmxvY2tOb2RlKEZvcik7XG4gICAgfVxuICAgIC8vIGBsYWJlbGAgc3RhdGVtZW50XG4gICAgbGFiZWwobGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBMYWJlbChsYWJlbCkpO1xuICAgIH1cbiAgICAvLyBgYnJlYWtgIHN0YXRlbWVudFxuICAgIGJyZWFrKGxhYmVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWFmTm9kZShuZXcgQnJlYWsobGFiZWwpKTtcbiAgICB9XG4gICAgLy8gYHJldHVybmAgc3RhdGVtZW50XG4gICAgcmV0dXJuKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgUmV0dXJuKCk7XG4gICAgICAgIHRoaXMuX2Jsb2NrTm9kZShub2RlKTtcbiAgICAgICAgdGhpcy5jb2RlKHZhbHVlKTtcbiAgICAgICAgaWYgKG5vZGUubm9kZXMubGVuZ3RoICE9PSAxKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb2RlR2VuOiBcInJldHVyblwiIHNob3VsZCBoYXZlIG9uZSBub2RlJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoUmV0dXJuKTtcbiAgICB9XG4gICAgLy8gYHRyeWAgc3RhdGVtZW50XG4gICAgdHJ5KHRyeUJvZHksIGNhdGNoQ29kZSwgZmluYWxseUNvZGUpIHtcbiAgICAgICAgaWYgKCFjYXRjaENvZGUgJiYgIWZpbmFsbHlDb2RlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb2RlR2VuOiBcInRyeVwiIHdpdGhvdXQgXCJjYXRjaFwiIGFuZCBcImZpbmFsbHlcIicpO1xuICAgICAgICBjb25zdCBub2RlID0gbmV3IFRyeSgpO1xuICAgICAgICB0aGlzLl9ibG9ja05vZGUobm9kZSk7XG4gICAgICAgIHRoaXMuY29kZSh0cnlCb2R5KTtcbiAgICAgICAgaWYgKGNhdGNoQ29kZSkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLm5hbWUoXCJlXCIpO1xuICAgICAgICAgICAgdGhpcy5fY3Vyck5vZGUgPSBub2RlLmNhdGNoID0gbmV3IENhdGNoKGVycm9yKTtcbiAgICAgICAgICAgIGNhdGNoQ29kZShlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbmFsbHlDb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyTm9kZSA9IG5vZGUuZmluYWxseSA9IG5ldyBGaW5hbGx5KCk7XG4gICAgICAgICAgICB0aGlzLmNvZGUoZmluYWxseUNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoQ2F0Y2gsIEZpbmFsbHkpO1xuICAgIH1cbiAgICAvLyBgdGhyb3dgIHN0YXRlbWVudFxuICAgIHRocm93KGVycm9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWFmTm9kZShuZXcgVGhyb3coZXJyb3IpKTtcbiAgICB9XG4gICAgLy8gc3RhcnQgc2VsZi1iYWxhbmNpbmcgYmxvY2tcbiAgICBibG9jayhib2R5LCBub2RlQ291bnQpIHtcbiAgICAgICAgdGhpcy5fYmxvY2tTdGFydHMucHVzaCh0aGlzLl9ub2Rlcy5sZW5ndGgpO1xuICAgICAgICBpZiAoYm9keSlcbiAgICAgICAgICAgIHRoaXMuY29kZShib2R5KS5lbmRCbG9jayhub2RlQ291bnQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gZW5kIHRoZSBjdXJyZW50IHNlbGYtYmFsYW5jaW5nIGJsb2NrXG4gICAgZW5kQmxvY2sobm9kZUNvdW50KSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMuX2Jsb2NrU3RhcnRzLnBvcCgpO1xuICAgICAgICBpZiAobGVuID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb2RlR2VuOiBub3QgaW4gc2VsZi1iYWxhbmNpbmcgYmxvY2tcIik7XG4gICAgICAgIGNvbnN0IHRvQ2xvc2UgPSB0aGlzLl9ub2Rlcy5sZW5ndGggLSBsZW47XG4gICAgICAgIGlmICh0b0Nsb3NlIDwgMCB8fCAobm9kZUNvdW50ICE9PSB1bmRlZmluZWQgJiYgdG9DbG9zZSAhPT0gbm9kZUNvdW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiB3cm9uZyBudW1iZXIgb2Ygbm9kZXM6ICR7dG9DbG9zZX0gdnMgJHtub2RlQ291bnR9IGV4cGVjdGVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbm9kZXMubGVuZ3RoID0gbGVuO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gYGZ1bmN0aW9uYCBoZWFkaW5nIChvciBkZWZpbml0aW9uIGlmIGZ1bmNCb2R5IGlzIHBhc3NlZClcbiAgICBmdW5jKG5hbWUsIGFyZ3MgPSBjb2RlXzEubmlsLCBhc3luYywgZnVuY0JvZHkpIHtcbiAgICAgICAgdGhpcy5fYmxvY2tOb2RlKG5ldyBGdW5jKG5hbWUsIGFyZ3MsIGFzeW5jKSk7XG4gICAgICAgIGlmIChmdW5jQm9keSlcbiAgICAgICAgICAgIHRoaXMuY29kZShmdW5jQm9keSkuZW5kRnVuYygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gZW5kIGZ1bmN0aW9uIGRlZmluaXRpb25cbiAgICBlbmRGdW5jKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5kQmxvY2tOb2RlKEZ1bmMpO1xuICAgIH1cbiAgICBvcHRpbWl6ZShuID0gMSkge1xuICAgICAgICB3aGlsZSAobi0tID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fcm9vdC5vcHRpbWl6ZU5vZGVzKCk7XG4gICAgICAgICAgICB0aGlzLl9yb290Lm9wdGltaXplTmFtZXModGhpcy5fcm9vdC5uYW1lcywgdGhpcy5fY29uc3RhbnRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfbGVhZk5vZGUobm9kZSkge1xuICAgICAgICB0aGlzLl9jdXJyTm9kZS5ub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgX2Jsb2NrTm9kZShub2RlKSB7XG4gICAgICAgIHRoaXMuX2N1cnJOb2RlLm5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIHRoaXMuX25vZGVzLnB1c2gobm9kZSk7XG4gICAgfVxuICAgIF9lbmRCbG9ja05vZGUoTjEsIE4yKSB7XG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLl9jdXJyTm9kZTtcbiAgICAgICAgaWYgKG4gaW5zdGFuY2VvZiBOMSB8fCAoTjIgJiYgbiBpbnN0YW5jZW9mIE4yKSkge1xuICAgICAgICAgICAgdGhpcy5fbm9kZXMucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IG5vdCBpbiBibG9jayBcIiR7TjIgPyBgJHtOMS5raW5kfS8ke04yLmtpbmR9YCA6IE4xLmtpbmR9XCJgKTtcbiAgICB9XG4gICAgX2Vsc2VOb2RlKG5vZGUpIHtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuX2N1cnJOb2RlO1xuICAgICAgICBpZiAoIShuIGluc3RhbmNlb2YgSWYpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwiZWxzZVwiIHdpdGhvdXQgXCJpZlwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY3Vyck5vZGUgPSBuLmVsc2UgPSBub2RlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IF9yb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbm9kZXNbMF07XG4gICAgfVxuICAgIGdldCBfY3Vyck5vZGUoKSB7XG4gICAgICAgIGNvbnN0IG5zID0gdGhpcy5fbm9kZXM7XG4gICAgICAgIHJldHVybiBuc1tucy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgc2V0IF9jdXJyTm9kZShub2RlKSB7XG4gICAgICAgIGNvbnN0IG5zID0gdGhpcy5fbm9kZXM7XG4gICAgICAgIG5zW25zLmxlbmd0aCAtIDFdID0gbm9kZTtcbiAgICB9XG59XG5leHBvcnRzLkNvZGVHZW4gPSBDb2RlR2VuO1xuZnVuY3Rpb24gYWRkTmFtZXMobmFtZXMsIGZyb20pIHtcbiAgICBmb3IgKGNvbnN0IG4gaW4gZnJvbSlcbiAgICAgICAgbmFtZXNbbl0gPSAobmFtZXNbbl0gfHwgMCkgKyAoZnJvbVtuXSB8fCAwKTtcbiAgICByZXR1cm4gbmFtZXM7XG59XG5mdW5jdGlvbiBhZGRFeHByTmFtZXMobmFtZXMsIGZyb20pIHtcbiAgICByZXR1cm4gZnJvbSBpbnN0YW5jZW9mIGNvZGVfMS5fQ29kZU9yTmFtZSA/IGFkZE5hbWVzKG5hbWVzLCBmcm9tLm5hbWVzKSA6IG5hbWVzO1xufVxuZnVuY3Rpb24gb3B0aW1pemVFeHByKGV4cHIsIG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICBpZiAoZXhwciBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lKVxuICAgICAgICByZXR1cm4gcmVwbGFjZU5hbWUoZXhwcik7XG4gICAgaWYgKCFjYW5PcHRpbWl6ZShleHByKSlcbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgcmV0dXJuIG5ldyBjb2RlXzEuX0NvZGUoZXhwci5faXRlbXMucmVkdWNlKChpdGVtcywgYykgPT4ge1xuICAgICAgICBpZiAoYyBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lKVxuICAgICAgICAgICAgYyA9IHJlcGxhY2VOYW1lKGMpO1xuICAgICAgICBpZiAoYyBpbnN0YW5jZW9mIGNvZGVfMS5fQ29kZSlcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goLi4uYy5faXRlbXMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBpdGVtcy5wdXNoKGMpO1xuICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgfSwgW10pKTtcbiAgICBmdW5jdGlvbiByZXBsYWNlTmFtZShuKSB7XG4gICAgICAgIGNvbnN0IGMgPSBjb25zdGFudHNbbi5zdHJdO1xuICAgICAgICBpZiAoYyA9PT0gdW5kZWZpbmVkIHx8IG5hbWVzW24uc3RyXSAhPT0gMSlcbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICBkZWxldGUgbmFtZXNbbi5zdHJdO1xuICAgICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FuT3B0aW1pemUoZSkge1xuICAgICAgICByZXR1cm4gKGUgaW5zdGFuY2VvZiBjb2RlXzEuX0NvZGUgJiZcbiAgICAgICAgICAgIGUuX2l0ZW1zLnNvbWUoKGMpID0+IGMgaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSAmJiBuYW1lc1tjLnN0cl0gPT09IDEgJiYgY29uc3RhbnRzW2Muc3RyXSAhPT0gdW5kZWZpbmVkKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc3VidHJhY3ROYW1lcyhuYW1lcywgZnJvbSkge1xuICAgIGZvciAoY29uc3QgbiBpbiBmcm9tKVxuICAgICAgICBuYW1lc1tuXSA9IChuYW1lc1tuXSB8fCAwKSAtIChmcm9tW25dIHx8IDApO1xufVxuZnVuY3Rpb24gbm90KHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT0gXCJib29sZWFuXCIgfHwgdHlwZW9mIHggPT0gXCJudW1iZXJcIiB8fCB4ID09PSBudWxsID8gIXggOiBjb2RlXzEuXyBgISR7cGFyKHgpfWA7XG59XG5leHBvcnRzLm5vdCA9IG5vdDtcbmNvbnN0IGFuZENvZGUgPSBtYXBwZW5kKGV4cG9ydHMub3BlcmF0b3JzLkFORCk7XG4vLyBib29sZWFuIEFORCAoJiYpIGV4cHJlc3Npb24gd2l0aCB0aGUgcGFzc2VkIGFyZ3VtZW50c1xuZnVuY3Rpb24gYW5kKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gYXJncy5yZWR1Y2UoYW5kQ29kZSk7XG59XG5leHBvcnRzLmFuZCA9IGFuZDtcbmNvbnN0IG9yQ29kZSA9IG1hcHBlbmQoZXhwb3J0cy5vcGVyYXRvcnMuT1IpO1xuLy8gYm9vbGVhbiBPUiAofHwpIGV4cHJlc3Npb24gd2l0aCB0aGUgcGFzc2VkIGFyZ3VtZW50c1xuZnVuY3Rpb24gb3IoLi4uYXJncykge1xuICAgIHJldHVybiBhcmdzLnJlZHVjZShvckNvZGUpO1xufVxuZXhwb3J0cy5vciA9IG9yO1xuZnVuY3Rpb24gbWFwcGVuZChvcCkge1xuICAgIHJldHVybiAoeCwgeSkgPT4gKHggPT09IGNvZGVfMS5uaWwgPyB5IDogeSA9PT0gY29kZV8xLm5pbCA/IHggOiBjb2RlXzEuXyBgJHtwYXIoeCl9ICR7b3B9ICR7cGFyKHkpfWApO1xufVxuZnVuY3Rpb24gcGFyKHgpIHtcbiAgICByZXR1cm4geCBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lID8geCA6IGNvZGVfMS5fIGAoJHt4fSlgO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNoZWNrU3RyaWN0TW9kZSA9IGV4cG9ydHMuZ2V0RXJyb3JQYXRoID0gZXhwb3J0cy5UeXBlID0gZXhwb3J0cy51c2VGdW5jID0gZXhwb3J0cy5zZXRFdmFsdWF0ZWQgPSBleHBvcnRzLmV2YWx1YXRlZFByb3BzVG9OYW1lID0gZXhwb3J0cy5tZXJnZUV2YWx1YXRlZCA9IGV4cG9ydHMuZWFjaEl0ZW0gPSBleHBvcnRzLnVuZXNjYXBlSnNvblBvaW50ZXIgPSBleHBvcnRzLmVzY2FwZUpzb25Qb2ludGVyID0gZXhwb3J0cy5lc2NhcGVGcmFnbWVudCA9IGV4cG9ydHMudW5lc2NhcGVGcmFnbWVudCA9IGV4cG9ydHMuc2NoZW1hUmVmT3JWYWwgPSBleHBvcnRzLnNjaGVtYUhhc1J1bGVzQnV0UmVmID0gZXhwb3J0cy5zY2hlbWFIYXNSdWxlcyA9IGV4cG9ydHMuY2hlY2tVbmtub3duUnVsZXMgPSBleHBvcnRzLmFsd2F5c1ZhbGlkU2NoZW1hID0gZXhwb3J0cy50b0hhc2ggPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4vY29kZWdlbi9jb2RlXCIpO1xuLy8gVE9ETyByZWZhY3RvciB0byB1c2UgU2V0XG5mdW5jdGlvbiB0b0hhc2goYXJyKSB7XG4gICAgY29uc3QgaGFzaCA9IHt9O1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpXG4gICAgICAgIGhhc2hbaXRlbV0gPSB0cnVlO1xuICAgIHJldHVybiBoYXNoO1xufVxuZXhwb3J0cy50b0hhc2ggPSB0b0hhc2g7XG5mdW5jdGlvbiBhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgaWYgKE9iamVjdC5rZXlzKHNjaGVtYSkubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjaGVja1Vua25vd25SdWxlcyhpdCwgc2NoZW1hKTtcbiAgICByZXR1cm4gIXNjaGVtYUhhc1J1bGVzKHNjaGVtYSwgaXQuc2VsZi5SVUxFUy5hbGwpO1xufVxuZXhwb3J0cy5hbHdheXNWYWxpZFNjaGVtYSA9IGFsd2F5c1ZhbGlkU2NoZW1hO1xuZnVuY3Rpb24gY2hlY2tVbmtub3duUnVsZXMoaXQsIHNjaGVtYSA9IGl0LnNjaGVtYSkge1xuICAgIGNvbnN0IHsgb3B0cywgc2VsZiB9ID0gaXQ7XG4gICAgaWYgKCFvcHRzLnN0cmljdFNjaGVtYSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHJ1bGVzID0gc2VsZi5SVUxFUy5rZXl3b3JkcztcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgaWYgKCFydWxlc1trZXldKVxuICAgICAgICAgICAgY2hlY2tTdHJpY3RNb2RlKGl0LCBgdW5rbm93biBrZXl3b3JkOiBcIiR7a2V5fVwiYCk7XG4gICAgfVxufVxuZXhwb3J0cy5jaGVja1Vua25vd25SdWxlcyA9IGNoZWNrVW5rbm93blJ1bGVzO1xuZnVuY3Rpb24gc2NoZW1hSGFzUnVsZXMoc2NoZW1hLCBydWxlcykge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm4gIXNjaGVtYTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpXG4gICAgICAgIGlmIChydWxlc1trZXldKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5zY2hlbWFIYXNSdWxlcyA9IHNjaGVtYUhhc1J1bGVzO1xuZnVuY3Rpb24gc2NoZW1hSGFzUnVsZXNCdXRSZWYoc2NoZW1hLCBSVUxFUykge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm4gIXNjaGVtYTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpXG4gICAgICAgIGlmIChrZXkgIT09IFwiJHJlZlwiICYmIFJVTEVTLmFsbFtrZXldKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5zY2hlbWFIYXNSdWxlc0J1dFJlZiA9IHNjaGVtYUhhc1J1bGVzQnV0UmVmO1xuZnVuY3Rpb24gc2NoZW1hUmVmT3JWYWwoeyB0b3BTY2hlbWFSZWYsIHNjaGVtYVBhdGggfSwgc2NoZW1hLCBrZXl3b3JkLCAkZGF0YSkge1xuICAgIGlmICghJGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJudW1iZXJcIiB8fCB0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEuXyBgJHtzY2hlbWF9YDtcbiAgICB9XG4gICAgcmV0dXJuIGNvZGVnZW5fMS5fIGAke3RvcFNjaGVtYVJlZn0ke3NjaGVtYVBhdGh9JHtjb2RlZ2VuXzEuZ2V0UHJvcGVydHkoa2V5d29yZCl9YDtcbn1cbmV4cG9ydHMuc2NoZW1hUmVmT3JWYWwgPSBzY2hlbWFSZWZPclZhbDtcbmZ1bmN0aW9uIHVuZXNjYXBlRnJhZ21lbnQoc3RyKSB7XG4gICAgcmV0dXJuIHVuZXNjYXBlSnNvblBvaW50ZXIoZGVjb2RlVVJJQ29tcG9uZW50KHN0cikpO1xufVxuZXhwb3J0cy51bmVzY2FwZUZyYWdtZW50ID0gdW5lc2NhcGVGcmFnbWVudDtcbmZ1bmN0aW9uIGVzY2FwZUZyYWdtZW50KHN0cikge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoZXNjYXBlSnNvblBvaW50ZXIoc3RyKSk7XG59XG5leHBvcnRzLmVzY2FwZUZyYWdtZW50ID0gZXNjYXBlRnJhZ21lbnQ7XG5mdW5jdGlvbiBlc2NhcGVKc29uUG9pbnRlcihzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciA9PSBcIm51bWJlclwiKVxuICAgICAgICByZXR1cm4gYCR7c3RyfWA7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9+L2csIFwifjBcIikucmVwbGFjZSgvXFwvL2csIFwifjFcIik7XG59XG5leHBvcnRzLmVzY2FwZUpzb25Qb2ludGVyID0gZXNjYXBlSnNvblBvaW50ZXI7XG5mdW5jdGlvbiB1bmVzY2FwZUpzb25Qb2ludGVyKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvfjEvZywgXCIvXCIpLnJlcGxhY2UoL34wL2csIFwiflwiKTtcbn1cbmV4cG9ydHMudW5lc2NhcGVKc29uUG9pbnRlciA9IHVuZXNjYXBlSnNvblBvaW50ZXI7XG5mdW5jdGlvbiBlYWNoSXRlbSh4cywgZikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHhzKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHggb2YgeHMpXG4gICAgICAgICAgICBmKHgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZih4cyk7XG4gICAgfVxufVxuZXhwb3J0cy5lYWNoSXRlbSA9IGVhY2hJdGVtO1xuZnVuY3Rpb24gbWFrZU1lcmdlRXZhbHVhdGVkKHsgbWVyZ2VOYW1lcywgbWVyZ2VUb05hbWUsIG1lcmdlVmFsdWVzLCByZXN1bHRUb05hbWUsIH0pIHtcbiAgICByZXR1cm4gKGdlbiwgZnJvbSwgdG8sIHRvTmFtZSkgPT4ge1xuICAgICAgICBjb25zdCByZXMgPSB0byA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGZyb21cbiAgICAgICAgICAgIDogdG8gaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZVxuICAgICAgICAgICAgICAgID8gKGZyb20gaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSA/IG1lcmdlTmFtZXMoZ2VuLCBmcm9tLCB0bykgOiBtZXJnZVRvTmFtZShnZW4sIGZyb20sIHRvKSwgdG8pXG4gICAgICAgICAgICAgICAgOiBmcm9tIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWVcbiAgICAgICAgICAgICAgICAgICAgPyAobWVyZ2VUb05hbWUoZ2VuLCB0bywgZnJvbSksIGZyb20pXG4gICAgICAgICAgICAgICAgICAgIDogbWVyZ2VWYWx1ZXMoZnJvbSwgdG8pO1xuICAgICAgICByZXR1cm4gdG9OYW1lID09PSBjb2RlZ2VuXzEuTmFtZSAmJiAhKHJlcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lKSA/IHJlc3VsdFRvTmFtZShnZW4sIHJlcykgOiByZXM7XG4gICAgfTtcbn1cbmV4cG9ydHMubWVyZ2VFdmFsdWF0ZWQgPSB7XG4gICAgcHJvcHM6IG1ha2VNZXJnZUV2YWx1YXRlZCh7XG4gICAgICAgIG1lcmdlTmFtZXM6IChnZW4sIGZyb20sIHRvKSA9PiBnZW4uaWYoY29kZWdlbl8xLl8gYCR7dG99ICE9PSB0cnVlICYmICR7ZnJvbX0gIT09IHVuZGVmaW5lZGAsICgpID0+IHtcbiAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtmcm9tfSA9PT0gdHJ1ZWAsICgpID0+IGdlbi5hc3NpZ24odG8sIHRydWUpLCAoKSA9PiBnZW4uYXNzaWduKHRvLCBjb2RlZ2VuXzEuXyBgJHt0b30gfHwge31gKS5jb2RlKGNvZGVnZW5fMS5fIGBPYmplY3QuYXNzaWduKCR7dG99LCAke2Zyb219KWApKTtcbiAgICAgICAgfSksXG4gICAgICAgIG1lcmdlVG9OYW1lOiAoZ2VuLCBmcm9tLCB0bykgPT4gZ2VuLmlmKGNvZGVnZW5fMS5fIGAke3RvfSAhPT0gdHJ1ZWAsICgpID0+IHtcbiAgICAgICAgICAgIGlmIChmcm9tID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih0bywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHRvLCBjb2RlZ2VuXzEuXyBgJHt0b30gfHwge31gKTtcbiAgICAgICAgICAgICAgICBzZXRFdmFsdWF0ZWQoZ2VuLCB0bywgZnJvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBtZXJnZVZhbHVlczogKGZyb20sIHRvKSA9PiAoZnJvbSA9PT0gdHJ1ZSA/IHRydWUgOiB7IC4uLmZyb20sIC4uLnRvIH0pLFxuICAgICAgICByZXN1bHRUb05hbWU6IGV2YWx1YXRlZFByb3BzVG9OYW1lLFxuICAgIH0pLFxuICAgIGl0ZW1zOiBtYWtlTWVyZ2VFdmFsdWF0ZWQoe1xuICAgICAgICBtZXJnZU5hbWVzOiAoZ2VuLCBmcm9tLCB0bykgPT4gZ2VuLmlmKGNvZGVnZW5fMS5fIGAke3RvfSAhPT0gdHJ1ZSAmJiAke2Zyb219ICE9PSB1bmRlZmluZWRgLCAoKSA9PiBnZW4uYXNzaWduKHRvLCBjb2RlZ2VuXzEuXyBgJHtmcm9tfSA9PT0gdHJ1ZSA/IHRydWUgOiAke3RvfSA+ICR7ZnJvbX0gPyAke3RvfSA6ICR7ZnJvbX1gKSksXG4gICAgICAgIG1lcmdlVG9OYW1lOiAoZ2VuLCBmcm9tLCB0bykgPT4gZ2VuLmlmKGNvZGVnZW5fMS5fIGAke3RvfSAhPT0gdHJ1ZWAsICgpID0+IGdlbi5hc3NpZ24odG8sIGZyb20gPT09IHRydWUgPyB0cnVlIDogY29kZWdlbl8xLl8gYCR7dG99ID4gJHtmcm9tfSA/ICR7dG99IDogJHtmcm9tfWApKSxcbiAgICAgICAgbWVyZ2VWYWx1ZXM6IChmcm9tLCB0bykgPT4gKGZyb20gPT09IHRydWUgPyB0cnVlIDogTWF0aC5tYXgoZnJvbSwgdG8pKSxcbiAgICAgICAgcmVzdWx0VG9OYW1lOiAoZ2VuLCBpdGVtcykgPT4gZ2VuLnZhcihcIml0ZW1zXCIsIGl0ZW1zKSxcbiAgICB9KSxcbn07XG5mdW5jdGlvbiBldmFsdWF0ZWRQcm9wc1RvTmFtZShnZW4sIHBzKSB7XG4gICAgaWYgKHBzID09PSB0cnVlKVxuICAgICAgICByZXR1cm4gZ2VuLnZhcihcInByb3BzXCIsIHRydWUpO1xuICAgIGNvbnN0IHByb3BzID0gZ2VuLnZhcihcInByb3BzXCIsIGNvZGVnZW5fMS5fIGB7fWApO1xuICAgIGlmIChwcyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBzZXRFdmFsdWF0ZWQoZ2VuLCBwcm9wcywgcHMpO1xuICAgIHJldHVybiBwcm9wcztcbn1cbmV4cG9ydHMuZXZhbHVhdGVkUHJvcHNUb05hbWUgPSBldmFsdWF0ZWRQcm9wc1RvTmFtZTtcbmZ1bmN0aW9uIHNldEV2YWx1YXRlZChnZW4sIHByb3BzLCBwcykge1xuICAgIE9iamVjdC5rZXlzKHBzKS5mb3JFYWNoKChwKSA9PiBnZW4uYXNzaWduKGNvZGVnZW5fMS5fIGAke3Byb3BzfSR7Y29kZWdlbl8xLmdldFByb3BlcnR5KHApfWAsIHRydWUpKTtcbn1cbmV4cG9ydHMuc2V0RXZhbHVhdGVkID0gc2V0RXZhbHVhdGVkO1xuY29uc3Qgc25pcHBldHMgPSB7fTtcbmZ1bmN0aW9uIHVzZUZ1bmMoZ2VuLCBmKSB7XG4gICAgcmV0dXJuIGdlbi5zY29wZVZhbHVlKFwiZnVuY1wiLCB7XG4gICAgICAgIHJlZjogZixcbiAgICAgICAgY29kZTogc25pcHBldHNbZi5jb2RlXSB8fCAoc25pcHBldHNbZi5jb2RlXSA9IG5ldyBjb2RlXzEuX0NvZGUoZi5jb2RlKSksXG4gICAgfSk7XG59XG5leHBvcnRzLnVzZUZ1bmMgPSB1c2VGdW5jO1xudmFyIFR5cGU7XG4oZnVuY3Rpb24gKFR5cGUpIHtcbiAgICBUeXBlW1R5cGVbXCJOdW1cIl0gPSAwXSA9IFwiTnVtXCI7XG4gICAgVHlwZVtUeXBlW1wiU3RyXCJdID0gMV0gPSBcIlN0clwiO1xufSkoVHlwZSA9IGV4cG9ydHMuVHlwZSB8fCAoZXhwb3J0cy5UeXBlID0ge30pKTtcbmZ1bmN0aW9uIGdldEVycm9yUGF0aChkYXRhUHJvcCwgZGF0YVByb3BUeXBlLCBqc1Byb3BlcnR5U3ludGF4KSB7XG4gICAgLy8gbGV0IHBhdGhcbiAgICBpZiAoZGF0YVByb3AgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSkge1xuICAgICAgICBjb25zdCBpc051bWJlciA9IGRhdGFQcm9wVHlwZSA9PT0gVHlwZS5OdW07XG4gICAgICAgIHJldHVybiBqc1Byb3BlcnR5U3ludGF4XG4gICAgICAgICAgICA/IGlzTnVtYmVyXG4gICAgICAgICAgICAgICAgPyBjb2RlZ2VuXzEuXyBgXCJbXCIgKyAke2RhdGFQcm9wfSArIFwiXVwiYFxuICAgICAgICAgICAgICAgIDogY29kZWdlbl8xLl8gYFwiWydcIiArICR7ZGF0YVByb3B9ICsgXCInXVwiYFxuICAgICAgICAgICAgOiBpc051bWJlclxuICAgICAgICAgICAgICAgID8gY29kZWdlbl8xLl8gYFwiL1wiICsgJHtkYXRhUHJvcH1gXG4gICAgICAgICAgICAgICAgOiBjb2RlZ2VuXzEuXyBgXCIvXCIgKyAke2RhdGFQcm9wfS5yZXBsYWNlKC9+L2csIFwifjBcIikucmVwbGFjZSgvXFxcXC8vZywgXCJ+MVwiKWA7IC8vIFRPRE8gbWF5YmUgdXNlIGdsb2JhbCBlc2NhcGVQb2ludGVyXG4gICAgfVxuICAgIHJldHVybiBqc1Byb3BlcnR5U3ludGF4ID8gY29kZWdlbl8xLmdldFByb3BlcnR5KGRhdGFQcm9wKS50b1N0cmluZygpIDogXCIvXCIgKyBlc2NhcGVKc29uUG9pbnRlcihkYXRhUHJvcCk7XG59XG5leHBvcnRzLmdldEVycm9yUGF0aCA9IGdldEVycm9yUGF0aDtcbmZ1bmN0aW9uIGNoZWNrU3RyaWN0TW9kZShpdCwgbXNnLCBtb2RlID0gaXQub3B0cy5zdHJpY3RTY2hlbWEpIHtcbiAgICBpZiAoIW1vZGUpXG4gICAgICAgIHJldHVybjtcbiAgICBtc2cgPSBgc3RyaWN0IG1vZGU6ICR7bXNnfWA7XG4gICAgaWYgKG1vZGUgPT09IHRydWUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIGl0LnNlbGYubG9nZ2VyLndhcm4obXNnKTtcbn1cbmV4cG9ydHMuY2hlY2tTdHJpY3RNb2RlID0gY2hlY2tTdHJpY3RNb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lcyA9IHtcbiAgICAvLyB2YWxpZGF0aW9uIGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgIGRhdGE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImRhdGFcIiksXG4gICAgLy8gYXJncyBwYXNzZWQgZnJvbSByZWZlcmVuY2luZyBzY2hlbWFcbiAgICB2YWxDeHQ6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInZhbEN4dFwiKSxcbiAgICBpbnN0YW5jZVBhdGg6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImluc3RhbmNlUGF0aFwiKSxcbiAgICBwYXJlbnREYXRhOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJwYXJlbnREYXRhXCIpLFxuICAgIHBhcmVudERhdGFQcm9wZXJ0eTogbmV3IGNvZGVnZW5fMS5OYW1lKFwicGFyZW50RGF0YVByb3BlcnR5XCIpLFxuICAgIHJvb3REYXRhOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJyb290RGF0YVwiKSxcbiAgICBkeW5hbWljQW5jaG9yczogbmV3IGNvZGVnZW5fMS5OYW1lKFwiZHluYW1pY0FuY2hvcnNcIiksXG4gICAgLy8gZnVuY3Rpb24gc2NvcGVkIHZhcmlhYmxlc1xuICAgIHZFcnJvcnM6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInZFcnJvcnNcIiksXG4gICAgZXJyb3JzOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJlcnJvcnNcIiksXG4gICAgdGhpczogbmV3IGNvZGVnZW5fMS5OYW1lKFwidGhpc1wiKSxcbiAgICAvLyBcImdsb2JhbHNcIlxuICAgIHNlbGY6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInNlbGZcIiksXG4gICAgc2NvcGU6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInNjb3BlXCIpLFxuICAgIC8vIEpURCBzZXJpYWxpemUvcGFyc2UgbmFtZSBmb3IgSlNPTiBzdHJpbmcgYW5kIHBvc2l0aW9uXG4gICAganNvbjogbmV3IGNvZGVnZW5fMS5OYW1lKFwianNvblwiKSxcbiAgICBqc29uUG9zOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJqc29uUG9zXCIpLFxuICAgIGpzb25MZW46IG5ldyBjb2RlZ2VuXzEuTmFtZShcImpzb25MZW5cIiksXG4gICAganNvblBhcnQ6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImpzb25QYXJ0XCIpLFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5hbWVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmFtZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4dGVuZEVycm9ycyA9IGV4cG9ydHMucmVzZXRFcnJvcnNDb3VudCA9IGV4cG9ydHMucmVwb3J0RXh0cmFFcnJvciA9IGV4cG9ydHMucmVwb3J0RXJyb3IgPSBleHBvcnRzLmtleXdvcmQkRGF0YUVycm9yID0gZXhwb3J0cy5rZXl3b3JkRXJyb3IgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi9uYW1lc1wiKTtcbmV4cG9ydHMua2V5d29yZEVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IGtleXdvcmQgfSkgPT4gY29kZWdlbl8xLnN0ciBgbXVzdCBwYXNzIFwiJHtrZXl3b3JkfVwiIGtleXdvcmQgdmFsaWRhdGlvbmAsXG59O1xuZXhwb3J0cy5rZXl3b3JkJERhdGFFcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBrZXl3b3JkLCBzY2hlbWFUeXBlIH0pID0+IHNjaGVtYVR5cGVcbiAgICAgICAgPyBjb2RlZ2VuXzEuc3RyIGBcIiR7a2V5d29yZH1cIiBrZXl3b3JkIG11c3QgYmUgJHtzY2hlbWFUeXBlfSAoJGRhdGEpYFxuICAgICAgICA6IGNvZGVnZW5fMS5zdHIgYFwiJHtrZXl3b3JkfVwiIGtleXdvcmQgaXMgaW52YWxpZCAoJGRhdGEpYCxcbn07XG5mdW5jdGlvbiByZXBvcnRFcnJvcihjeHQsIGVycm9yID0gZXhwb3J0cy5rZXl3b3JkRXJyb3IsIGVycm9yUGF0aHMsIG92ZXJyaWRlQWxsRXJyb3JzKSB7XG4gICAgY29uc3QgeyBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IHsgZ2VuLCBjb21wb3NpdGVSdWxlLCBhbGxFcnJvcnMgfSA9IGl0O1xuICAgIGNvbnN0IGVyck9iaiA9IGVycm9yT2JqZWN0Q29kZShjeHQsIGVycm9yLCBlcnJvclBhdGhzKTtcbiAgICBpZiAob3ZlcnJpZGVBbGxFcnJvcnMgIT09IG51bGwgJiYgb3ZlcnJpZGVBbGxFcnJvcnMgIT09IHZvaWQgMCA/IG92ZXJyaWRlQWxsRXJyb3JzIDogKGNvbXBvc2l0ZVJ1bGUgfHwgYWxsRXJyb3JzKSkge1xuICAgICAgICBhZGRFcnJvcihnZW4sIGVyck9iaik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm5FcnJvcnMoaXQsIGNvZGVnZW5fMS5fIGBbJHtlcnJPYmp9XWApO1xuICAgIH1cbn1cbmV4cG9ydHMucmVwb3J0RXJyb3IgPSByZXBvcnRFcnJvcjtcbmZ1bmN0aW9uIHJlcG9ydEV4dHJhRXJyb3IoY3h0LCBlcnJvciA9IGV4cG9ydHMua2V5d29yZEVycm9yLCBlcnJvclBhdGhzKSB7XG4gICAgY29uc3QgeyBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IHsgZ2VuLCBjb21wb3NpdGVSdWxlLCBhbGxFcnJvcnMgfSA9IGl0O1xuICAgIGNvbnN0IGVyck9iaiA9IGVycm9yT2JqZWN0Q29kZShjeHQsIGVycm9yLCBlcnJvclBhdGhzKTtcbiAgICBhZGRFcnJvcihnZW4sIGVyck9iaik7XG4gICAgaWYgKCEoY29tcG9zaXRlUnVsZSB8fCBhbGxFcnJvcnMpKSB7XG4gICAgICAgIHJldHVybkVycm9ycyhpdCwgbmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMpO1xuICAgIH1cbn1cbmV4cG9ydHMucmVwb3J0RXh0cmFFcnJvciA9IHJlcG9ydEV4dHJhRXJyb3I7XG5mdW5jdGlvbiByZXNldEVycm9yc0NvdW50KGdlbiwgZXJyc0NvdW50KSB7XG4gICAgZ2VuLmFzc2lnbihuYW1lc18xLmRlZmF1bHQuZXJyb3JzLCBlcnJzQ291bnQpO1xuICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30gIT09IG51bGxgLCAoKSA9PiBnZW4uaWYoZXJyc0NvdW50LCAoKSA9PiBnZW4uYXNzaWduKGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfS5sZW5ndGhgLCBlcnJzQ291bnQpLCAoKSA9PiBnZW4uYXNzaWduKG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCBudWxsKSkpO1xufVxuZXhwb3J0cy5yZXNldEVycm9yc0NvdW50ID0gcmVzZXRFcnJvcnNDb3VudDtcbmZ1bmN0aW9uIGV4dGVuZEVycm9ycyh7IGdlbiwga2V5d29yZCwgc2NoZW1hVmFsdWUsIGRhdGEsIGVycnNDb3VudCwgaXQsIH0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZXJyc0NvdW50ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICBjb25zdCBlcnIgPSBnZW4ubmFtZShcImVyclwiKTtcbiAgICBnZW4uZm9yUmFuZ2UoXCJpXCIsIGVycnNDb3VudCwgbmFtZXNfMS5kZWZhdWx0LmVycm9ycywgKGkpID0+IHtcbiAgICAgICAgZ2VuLmNvbnN0KGVyciwgY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9WyR7aX1dYCk7XG4gICAgICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtlcnJ9Lmluc3RhbmNlUGF0aCA9PT0gdW5kZWZpbmVkYCwgKCkgPT4gZ2VuLmFzc2lnbihjb2RlZ2VuXzEuXyBgJHtlcnJ9Lmluc3RhbmNlUGF0aGAsIGNvZGVnZW5fMS5zdHJDb25jYXQobmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aCwgaXQuZXJyb3JQYXRoKSkpO1xuICAgICAgICBnZW4uYXNzaWduKGNvZGVnZW5fMS5fIGAke2Vycn0uc2NoZW1hUGF0aGAsIGNvZGVnZW5fMS5zdHIgYCR7aXQuZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWApO1xuICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICBnZW4uYXNzaWduKGNvZGVnZW5fMS5fIGAke2Vycn0uc2NoZW1hYCwgc2NoZW1hVmFsdWUpO1xuICAgICAgICAgICAgZ2VuLmFzc2lnbihjb2RlZ2VuXzEuXyBgJHtlcnJ9LmRhdGFgLCBkYXRhKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5leHRlbmRFcnJvcnMgPSBleHRlbmRFcnJvcnM7XG5mdW5jdGlvbiBhZGRFcnJvcihnZW4sIGVyck9iaikge1xuICAgIGNvbnN0IGVyciA9IGdlbi5jb25zdChcImVyclwiLCBlcnJPYmopO1xuICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30gPT09IG51bGxgLCAoKSA9PiBnZW4uYXNzaWduKG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCBjb2RlZ2VuXzEuXyBgWyR7ZXJyfV1gKSwgY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9LnB1c2goJHtlcnJ9KWApO1xuICAgIGdlbi5jb2RlKGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9KytgKTtcbn1cbmZ1bmN0aW9uIHJldHVybkVycm9ycyhpdCwgZXJycykge1xuICAgIGNvbnN0IHsgZ2VuLCB2YWxpZGF0ZU5hbWUsIHNjaGVtYUVudiB9ID0gaXQ7XG4gICAgaWYgKHNjaGVtYUVudi4kYXN5bmMpIHtcbiAgICAgICAgZ2VuLnRocm93KGNvZGVnZW5fMS5fIGBuZXcgJHtpdC5WYWxpZGF0aW9uRXJyb3J9KCR7ZXJyc30pYCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZW4uYXNzaWduKGNvZGVnZW5fMS5fIGAke3ZhbGlkYXRlTmFtZX0uZXJyb3JzYCwgZXJycyk7XG4gICAgICAgIGdlbi5yZXR1cm4oZmFsc2UpO1xuICAgIH1cbn1cbmNvbnN0IEUgPSB7XG4gICAga2V5d29yZDogbmV3IGNvZGVnZW5fMS5OYW1lKFwia2V5d29yZFwiKSxcbiAgICBzY2hlbWFQYXRoOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJzY2hlbWFQYXRoXCIpLFxuICAgIHBhcmFtczogbmV3IGNvZGVnZW5fMS5OYW1lKFwicGFyYW1zXCIpLFxuICAgIHByb3BlcnR5TmFtZTogbmV3IGNvZGVnZW5fMS5OYW1lKFwicHJvcGVydHlOYW1lXCIpLFxuICAgIG1lc3NhZ2U6IG5ldyBjb2RlZ2VuXzEuTmFtZShcIm1lc3NhZ2VcIiksXG4gICAgc2NoZW1hOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJzY2hlbWFcIiksXG4gICAgcGFyZW50U2NoZW1hOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJwYXJlbnRTY2hlbWFcIiksXG59O1xuZnVuY3Rpb24gZXJyb3JPYmplY3RDb2RlKGN4dCwgZXJyb3IsIGVycm9yUGF0aHMpIHtcbiAgICBjb25zdCB7IGNyZWF0ZUVycm9ycyB9ID0gY3h0Lml0O1xuICAgIGlmIChjcmVhdGVFcnJvcnMgPT09IGZhbHNlKVxuICAgICAgICByZXR1cm4gY29kZWdlbl8xLl8gYHt9YDtcbiAgICByZXR1cm4gZXJyb3JPYmplY3QoY3h0LCBlcnJvciwgZXJyb3JQYXRocyk7XG59XG5mdW5jdGlvbiBlcnJvck9iamVjdChjeHQsIGVycm9yLCBlcnJvclBhdGhzID0ge30pIHtcbiAgICBjb25zdCB7IGdlbiwgaXQgfSA9IGN4dDtcbiAgICBjb25zdCBrZXlWYWx1ZXMgPSBbXG4gICAgICAgIGVycm9ySW5zdGFuY2VQYXRoKGl0LCBlcnJvclBhdGhzKSxcbiAgICAgICAgZXJyb3JTY2hlbWFQYXRoKGN4dCwgZXJyb3JQYXRocyksXG4gICAgXTtcbiAgICBleHRyYUVycm9yUHJvcHMoY3h0LCBlcnJvciwga2V5VmFsdWVzKTtcbiAgICByZXR1cm4gZ2VuLm9iamVjdCguLi5rZXlWYWx1ZXMpO1xufVxuZnVuY3Rpb24gZXJyb3JJbnN0YW5jZVBhdGgoeyBlcnJvclBhdGggfSwgeyBpbnN0YW5jZVBhdGggfSkge1xuICAgIGNvbnN0IGluc3RQYXRoID0gaW5zdGFuY2VQYXRoXG4gICAgICAgID8gY29kZWdlbl8xLnN0ciBgJHtlcnJvclBhdGh9JHt1dGlsXzEuZ2V0RXJyb3JQYXRoKGluc3RhbmNlUGF0aCwgdXRpbF8xLlR5cGUuU3RyKX1gXG4gICAgICAgIDogZXJyb3JQYXRoO1xuICAgIHJldHVybiBbbmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aCwgY29kZWdlbl8xLnN0ckNvbmNhdChuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCBpbnN0UGF0aCldO1xufVxuZnVuY3Rpb24gZXJyb3JTY2hlbWFQYXRoKHsga2V5d29yZCwgaXQ6IHsgZXJyU2NoZW1hUGF0aCB9IH0sIHsgc2NoZW1hUGF0aCwgcGFyZW50U2NoZW1hIH0pIHtcbiAgICBsZXQgc2NoUGF0aCA9IHBhcmVudFNjaGVtYSA/IGVyclNjaGVtYVBhdGggOiBjb2RlZ2VuXzEuc3RyIGAke2VyclNjaGVtYVBhdGh9LyR7a2V5d29yZH1gO1xuICAgIGlmIChzY2hlbWFQYXRoKSB7XG4gICAgICAgIHNjaFBhdGggPSBjb2RlZ2VuXzEuc3RyIGAke3NjaFBhdGh9JHt1dGlsXzEuZ2V0RXJyb3JQYXRoKHNjaGVtYVBhdGgsIHV0aWxfMS5UeXBlLlN0cil9YDtcbiAgICB9XG4gICAgcmV0dXJuIFtFLnNjaGVtYVBhdGgsIHNjaFBhdGhdO1xufVxuZnVuY3Rpb24gZXh0cmFFcnJvclByb3BzKGN4dCwgeyBwYXJhbXMsIG1lc3NhZ2UgfSwga2V5VmFsdWVzKSB7XG4gICAgY29uc3QgeyBrZXl3b3JkLCBkYXRhLCBzY2hlbWFWYWx1ZSwgaXQgfSA9IGN4dDtcbiAgICBjb25zdCB7IG9wdHMsIHByb3BlcnR5TmFtZSwgdG9wU2NoZW1hUmVmLCBzY2hlbWFQYXRoIH0gPSBpdDtcbiAgICBrZXlWYWx1ZXMucHVzaChbRS5rZXl3b3JkLCBrZXl3b3JkXSwgW0UucGFyYW1zLCB0eXBlb2YgcGFyYW1zID09IFwiZnVuY3Rpb25cIiA/IHBhcmFtcyhjeHQpIDogcGFyYW1zIHx8IGNvZGVnZW5fMS5fIGB7fWBdKTtcbiAgICBpZiAob3B0cy5tZXNzYWdlcykge1xuICAgICAgICBrZXlWYWx1ZXMucHVzaChbRS5tZXNzYWdlLCB0eXBlb2YgbWVzc2FnZSA9PSBcImZ1bmN0aW9uXCIgPyBtZXNzYWdlKGN4dCkgOiBtZXNzYWdlXSk7XG4gICAgfVxuICAgIGlmIChvcHRzLnZlcmJvc2UpIHtcbiAgICAgICAga2V5VmFsdWVzLnB1c2goW0Uuc2NoZW1hLCBzY2hlbWFWYWx1ZV0sIFtFLnBhcmVudFNjaGVtYSwgY29kZWdlbl8xLl8gYCR7dG9wU2NoZW1hUmVmfSR7c2NoZW1hUGF0aH1gXSwgW25hbWVzXzEuZGVmYXVsdC5kYXRhLCBkYXRhXSk7XG4gICAgfVxuICAgIGlmIChwcm9wZXJ0eU5hbWUpXG4gICAgICAgIGtleVZhbHVlcy5wdXNoKFtFLnByb3BlcnR5TmFtZSwgcHJvcGVydHlOYW1lXSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJvb2xPckVtcHR5U2NoZW1hID0gZXhwb3J0cy50b3BCb29sT3JFbXB0eVNjaGVtYSA9IHZvaWQgMDtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb2RlZ2VuXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuLi9uYW1lc1wiKTtcbmNvbnN0IGJvb2xFcnJvciA9IHtcbiAgICBtZXNzYWdlOiBcImJvb2xlYW4gc2NoZW1hIGlzIGZhbHNlXCIsXG59O1xuZnVuY3Rpb24gdG9wQm9vbE9yRW1wdHlTY2hlbWEoaXQpIHtcbiAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCB2YWxpZGF0ZU5hbWUgfSA9IGl0O1xuICAgIGlmIChzY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgICAgIGZhbHNlU2NoZW1hRXJyb3IoaXQsIGZhbHNlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiICYmIHNjaGVtYS4kYXN5bmMgPT09IHRydWUpIHtcbiAgICAgICAgZ2VuLnJldHVybihuYW1lc18xLmRlZmF1bHQuZGF0YSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZW4uYXNzaWduKGNvZGVnZW5fMS5fIGAke3ZhbGlkYXRlTmFtZX0uZXJyb3JzYCwgbnVsbCk7XG4gICAgICAgIGdlbi5yZXR1cm4odHJ1ZSk7XG4gICAgfVxufVxuZXhwb3J0cy50b3BCb29sT3JFbXB0eVNjaGVtYSA9IHRvcEJvb2xPckVtcHR5U2NoZW1hO1xuZnVuY3Rpb24gYm9vbE9yRW1wdHlTY2hlbWEoaXQsIHZhbGlkKSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSB9ID0gaXQ7XG4gICAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZ2VuLnZhcih2YWxpZCwgZmFsc2UpOyAvLyBUT0RPIHZhclxuICAgICAgICBmYWxzZVNjaGVtYUVycm9yKGl0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi52YXIodmFsaWQsIHRydWUpOyAvLyBUT0RPIHZhclxuICAgIH1cbn1cbmV4cG9ydHMuYm9vbE9yRW1wdHlTY2hlbWEgPSBib29sT3JFbXB0eVNjaGVtYTtcbmZ1bmN0aW9uIGZhbHNlU2NoZW1hRXJyb3IoaXQsIG92ZXJyaWRlQWxsRXJyb3JzKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEgfSA9IGl0O1xuICAgIC8vIFRPRE8gbWF5YmUgc29tZSBvdGhlciBpbnRlcmZhY2Ugc2hvdWxkIGJlIHVzZWQgZm9yIG5vbi1rZXl3b3JkIHZhbGlkYXRpb24gZXJyb3JzLi4uXG4gICAgY29uc3QgY3h0ID0ge1xuICAgICAgICBnZW4sXG4gICAgICAgIGtleXdvcmQ6IFwiZmFsc2Ugc2NoZW1hXCIsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHNjaGVtYTogZmFsc2UsXG4gICAgICAgIHNjaGVtYUNvZGU6IGZhbHNlLFxuICAgICAgICBzY2hlbWFWYWx1ZTogZmFsc2UsXG4gICAgICAgIHBhcmFtczoge30sXG4gICAgICAgIGl0LFxuICAgIH07XG4gICAgZXJyb3JzXzEucmVwb3J0RXJyb3IoY3h0LCBib29sRXJyb3IsIHVuZGVmaW5lZCwgb3ZlcnJpZGVBbGxFcnJvcnMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ym9vbFNjaGVtYS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0UnVsZXMgPSBleHBvcnRzLmlzSlNPTlR5cGUgPSB2b2lkIDA7XG5jb25zdCBfanNvblR5cGVzID0gW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwiaW50ZWdlclwiLCBcImJvb2xlYW5cIiwgXCJudWxsXCIsIFwib2JqZWN0XCIsIFwiYXJyYXlcIl07XG5jb25zdCBqc29uVHlwZXMgPSBuZXcgU2V0KF9qc29uVHlwZXMpO1xuZnVuY3Rpb24gaXNKU09OVHlwZSh4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09IFwic3RyaW5nXCIgJiYganNvblR5cGVzLmhhcyh4KTtcbn1cbmV4cG9ydHMuaXNKU09OVHlwZSA9IGlzSlNPTlR5cGU7XG5mdW5jdGlvbiBnZXRSdWxlcygpIHtcbiAgICBjb25zdCBncm91cHMgPSB7XG4gICAgICAgIG51bWJlcjogeyB0eXBlOiBcIm51bWJlclwiLCBydWxlczogW10gfSxcbiAgICAgICAgc3RyaW5nOiB7IHR5cGU6IFwic3RyaW5nXCIsIHJ1bGVzOiBbXSB9LFxuICAgICAgICBhcnJheTogeyB0eXBlOiBcImFycmF5XCIsIHJ1bGVzOiBbXSB9LFxuICAgICAgICBvYmplY3Q6IHsgdHlwZTogXCJvYmplY3RcIiwgcnVsZXM6IFtdIH0sXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlczogeyAuLi5ncm91cHMsIGludGVnZXI6IHRydWUsIGJvb2xlYW46IHRydWUsIG51bGw6IHRydWUgfSxcbiAgICAgICAgcnVsZXM6IFt7IHJ1bGVzOiBbXSB9LCBncm91cHMubnVtYmVyLCBncm91cHMuc3RyaW5nLCBncm91cHMuYXJyYXksIGdyb3Vwcy5vYmplY3RdLFxuICAgICAgICBwb3N0OiB7IHJ1bGVzOiBbXSB9LFxuICAgICAgICBhbGw6IHt9LFxuICAgICAgICBrZXl3b3Jkczoge30sXG4gICAgfTtcbn1cbmV4cG9ydHMuZ2V0UnVsZXMgPSBnZXRSdWxlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJ1bGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaG91bGRVc2VSdWxlID0gZXhwb3J0cy5zaG91bGRVc2VHcm91cCA9IGV4cG9ydHMuc2NoZW1hSGFzUnVsZXNGb3JUeXBlID0gdm9pZCAwO1xuZnVuY3Rpb24gc2NoZW1hSGFzUnVsZXNGb3JUeXBlKHsgc2NoZW1hLCBzZWxmIH0sIHR5cGUpIHtcbiAgICBjb25zdCBncm91cCA9IHNlbGYuUlVMRVMudHlwZXNbdHlwZV07XG4gICAgcmV0dXJuIGdyb3VwICYmIGdyb3VwICE9PSB0cnVlICYmIHNob3VsZFVzZUdyb3VwKHNjaGVtYSwgZ3JvdXApO1xufVxuZXhwb3J0cy5zY2hlbWFIYXNSdWxlc0ZvclR5cGUgPSBzY2hlbWFIYXNSdWxlc0ZvclR5cGU7XG5mdW5jdGlvbiBzaG91bGRVc2VHcm91cChzY2hlbWEsIGdyb3VwKSB7XG4gICAgcmV0dXJuIGdyb3VwLnJ1bGVzLnNvbWUoKHJ1bGUpID0+IHNob3VsZFVzZVJ1bGUoc2NoZW1hLCBydWxlKSk7XG59XG5leHBvcnRzLnNob3VsZFVzZUdyb3VwID0gc2hvdWxkVXNlR3JvdXA7XG5mdW5jdGlvbiBzaG91bGRVc2VSdWxlKHNjaGVtYSwgcnVsZSkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKHNjaGVtYVtydWxlLmtleXdvcmRdICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgKChfYSA9IHJ1bGUuZGVmaW5pdGlvbi5pbXBsZW1lbnRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc29tZSgoa3dkKSA9PiBzY2hlbWFba3dkXSAhPT0gdW5kZWZpbmVkKSkpO1xufVxuZXhwb3J0cy5zaG91bGRVc2VSdWxlID0gc2hvdWxkVXNlUnVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcGxpY2FiaWxpdHkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlcG9ydFR5cGVFcnJvciA9IGV4cG9ydHMuY2hlY2tEYXRhVHlwZXMgPSBleHBvcnRzLmNoZWNrRGF0YVR5cGUgPSBleHBvcnRzLmNvZXJjZUFuZENoZWNrRGF0YVR5cGUgPSBleHBvcnRzLmdldEpTT05UeXBlcyA9IGV4cG9ydHMuZ2V0U2NoZW1hVHlwZXMgPSBleHBvcnRzLkRhdGFUeXBlID0gdm9pZCAwO1xuY29uc3QgcnVsZXNfMSA9IHJlcXVpcmUoXCIuLi9ydWxlc1wiKTtcbmNvbnN0IGFwcGxpY2FiaWxpdHlfMSA9IHJlcXVpcmUoXCIuL2FwcGxpY2FiaWxpdHlcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIERhdGFUeXBlO1xuKGZ1bmN0aW9uIChEYXRhVHlwZSkge1xuICAgIERhdGFUeXBlW0RhdGFUeXBlW1wiQ29ycmVjdFwiXSA9IDBdID0gXCJDb3JyZWN0XCI7XG4gICAgRGF0YVR5cGVbRGF0YVR5cGVbXCJXcm9uZ1wiXSA9IDFdID0gXCJXcm9uZ1wiO1xufSkoRGF0YVR5cGUgPSBleHBvcnRzLkRhdGFUeXBlIHx8IChleHBvcnRzLkRhdGFUeXBlID0ge30pKTtcbmZ1bmN0aW9uIGdldFNjaGVtYVR5cGVzKHNjaGVtYSkge1xuICAgIGNvbnN0IHR5cGVzID0gZ2V0SlNPTlR5cGVzKHNjaGVtYS50eXBlKTtcbiAgICBjb25zdCBoYXNOdWxsID0gdHlwZXMuaW5jbHVkZXMoXCJudWxsXCIpO1xuICAgIGlmIChoYXNOdWxsKSB7XG4gICAgICAgIGlmIChzY2hlbWEubnVsbGFibGUgPT09IGZhbHNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHlwZTogbnVsbCBjb250cmFkaWN0cyBudWxsYWJsZTogZmFsc2VcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIXR5cGVzLmxlbmd0aCAmJiBzY2hlbWEubnVsbGFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm51bGxhYmxlXCIgY2Fubm90IGJlIHVzZWQgd2l0aG91dCBcInR5cGVcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEubnVsbGFibGUgPT09IHRydWUpXG4gICAgICAgICAgICB0eXBlcy5wdXNoKFwibnVsbFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVzO1xufVxuZXhwb3J0cy5nZXRTY2hlbWFUeXBlcyA9IGdldFNjaGVtYVR5cGVzO1xuZnVuY3Rpb24gZ2V0SlNPTlR5cGVzKHRzKSB7XG4gICAgY29uc3QgdHlwZXMgPSBBcnJheS5pc0FycmF5KHRzKSA/IHRzIDogdHMgPyBbdHNdIDogW107XG4gICAgaWYgKHR5cGVzLmV2ZXJ5KHJ1bGVzXzEuaXNKU09OVHlwZSkpXG4gICAgICAgIHJldHVybiB0eXBlcztcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0eXBlIG11c3QgYmUgSlNPTlR5cGUgb3IgSlNPTlR5cGVbXTogXCIgKyB0eXBlcy5qb2luKFwiLFwiKSk7XG59XG5leHBvcnRzLmdldEpTT05UeXBlcyA9IGdldEpTT05UeXBlcztcbmZ1bmN0aW9uIGNvZXJjZUFuZENoZWNrRGF0YVR5cGUoaXQsIHR5cGVzKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIG9wdHMgfSA9IGl0O1xuICAgIGNvbnN0IGNvZXJjZVRvID0gY29lcmNlVG9UeXBlcyh0eXBlcywgb3B0cy5jb2VyY2VUeXBlcyk7XG4gICAgY29uc3QgY2hlY2tUeXBlcyA9IHR5cGVzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgIShjb2VyY2VUby5sZW5ndGggPT09IDAgJiYgdHlwZXMubGVuZ3RoID09PSAxICYmIGFwcGxpY2FiaWxpdHlfMS5zY2hlbWFIYXNSdWxlc0ZvclR5cGUoaXQsIHR5cGVzWzBdKSk7XG4gICAgaWYgKGNoZWNrVHlwZXMpIHtcbiAgICAgICAgY29uc3Qgd3JvbmdUeXBlID0gY2hlY2tEYXRhVHlwZXModHlwZXMsIGRhdGEsIG9wdHMuc3RyaWN0TnVtYmVycywgRGF0YVR5cGUuV3JvbmcpO1xuICAgICAgICBnZW4uaWYod3JvbmdUeXBlLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY29lcmNlVG8ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGNvZXJjZURhdGEoaXQsIHR5cGVzLCBjb2VyY2VUbyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmVwb3J0VHlwZUVycm9yKGl0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjaGVja1R5cGVzO1xufVxuZXhwb3J0cy5jb2VyY2VBbmRDaGVja0RhdGFUeXBlID0gY29lcmNlQW5kQ2hlY2tEYXRhVHlwZTtcbmNvbnN0IENPRVJDSUJMRSA9IG5ldyBTZXQoW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwiaW50ZWdlclwiLCBcImJvb2xlYW5cIiwgXCJudWxsXCJdKTtcbmZ1bmN0aW9uIGNvZXJjZVRvVHlwZXModHlwZXMsIGNvZXJjZVR5cGVzKSB7XG4gICAgcmV0dXJuIGNvZXJjZVR5cGVzXG4gICAgICAgID8gdHlwZXMuZmlsdGVyKCh0KSA9PiBDT0VSQ0lCTEUuaGFzKHQpIHx8IChjb2VyY2VUeXBlcyA9PT0gXCJhcnJheVwiICYmIHQgPT09IFwiYXJyYXlcIikpXG4gICAgICAgIDogW107XG59XG5mdW5jdGlvbiBjb2VyY2VEYXRhKGl0LCB0eXBlcywgY29lcmNlVG8pIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwgb3B0cyB9ID0gaXQ7XG4gICAgY29uc3QgZGF0YVR5cGUgPSBnZW4ubGV0KFwiZGF0YVR5cGVcIiwgY29kZWdlbl8xLl8gYHR5cGVvZiAke2RhdGF9YCk7XG4gICAgY29uc3QgY29lcmNlZCA9IGdlbi5sZXQoXCJjb2VyY2VkXCIsIGNvZGVnZW5fMS5fIGB1bmRlZmluZWRgKTtcbiAgICBpZiAob3B0cy5jb2VyY2VUeXBlcyA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtkYXRhVHlwZX0gPT0gJ29iamVjdCcgJiYgQXJyYXkuaXNBcnJheSgke2RhdGF9KSAmJiAke2RhdGF9Lmxlbmd0aCA9PSAxYCwgKCkgPT4gZ2VuXG4gICAgICAgICAgICAuYXNzaWduKGRhdGEsIGNvZGVnZW5fMS5fIGAke2RhdGF9WzBdYClcbiAgICAgICAgICAgIC5hc3NpZ24oZGF0YVR5cGUsIGNvZGVnZW5fMS5fIGB0eXBlb2YgJHtkYXRhfWApXG4gICAgICAgICAgICAuaWYoY2hlY2tEYXRhVHlwZXModHlwZXMsIGRhdGEsIG9wdHMuc3RyaWN0TnVtYmVycyksICgpID0+IGdlbi5hc3NpZ24oY29lcmNlZCwgZGF0YSkpKTtcbiAgICB9XG4gICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke2NvZXJjZWR9ICE9PSB1bmRlZmluZWRgKTtcbiAgICBmb3IgKGNvbnN0IHQgb2YgY29lcmNlVG8pIHtcbiAgICAgICAgaWYgKENPRVJDSUJMRS5oYXModCkgfHwgKHQgPT09IFwiYXJyYXlcIiAmJiBvcHRzLmNvZXJjZVR5cGVzID09PSBcImFycmF5XCIpKSB7XG4gICAgICAgICAgICBjb2VyY2VTcGVjaWZpY1R5cGUodCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2VuLmVsc2UoKTtcbiAgICByZXBvcnRUeXBlRXJyb3IoaXQpO1xuICAgIGdlbi5lbmRJZigpO1xuICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtjb2VyY2VkfSAhPT0gdW5kZWZpbmVkYCwgKCkgPT4ge1xuICAgICAgICBnZW4uYXNzaWduKGRhdGEsIGNvZXJjZWQpO1xuICAgICAgICBhc3NpZ25QYXJlbnREYXRhKGl0LCBjb2VyY2VkKTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBjb2VyY2VTcGVjaWZpY1R5cGUodCkge1xuICAgICAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgLmVsc2VJZihjb2RlZ2VuXzEuXyBgJHtkYXRhVHlwZX0gPT0gXCJudW1iZXJcIiB8fCAke2RhdGFUeXBlfSA9PSBcImJvb2xlYW5cImApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgY29kZWdlbl8xLl8gYFwiXCIgKyAke2RhdGF9YClcbiAgICAgICAgICAgICAgICAgICAgLmVsc2VJZihjb2RlZ2VuXzEuXyBgJHtkYXRhfSA9PT0gbnVsbGApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgY29kZWdlbl8xLl8gYFwiXCJgKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoY29kZWdlbl8xLl8gYCR7ZGF0YVR5cGV9ID09IFwiYm9vbGVhblwiIHx8ICR7ZGF0YX0gPT09IG51bGxcbiAgICAgICAgICAgICAgfHwgKCR7ZGF0YVR5cGV9ID09IFwic3RyaW5nXCIgJiYgJHtkYXRhfSAmJiAke2RhdGF9ID09ICske2RhdGF9KWApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgY29kZWdlbl8xLl8gYCske2RhdGF9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcImludGVnZXJcIjpcbiAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgLmVsc2VJZihjb2RlZ2VuXzEuXyBgJHtkYXRhVHlwZX0gPT09IFwiYm9vbGVhblwiIHx8ICR7ZGF0YX0gPT09IG51bGxcbiAgICAgICAgICAgICAgfHwgKCR7ZGF0YVR5cGV9ID09PSBcInN0cmluZ1wiICYmICR7ZGF0YX0gJiYgJHtkYXRhfSA9PSArJHtkYXRhfSAmJiAhKCR7ZGF0YX0gJSAxKSlgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsIGNvZGVnZW5fMS5fIGArJHtkYXRhfWApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoY29kZWdlbl8xLl8gYCR7ZGF0YX0gPT09IFwiZmFsc2VcIiB8fCAke2RhdGF9ID09PSAwIHx8ICR7ZGF0YX0gPT09IG51bGxgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKGNvZGVnZW5fMS5fIGAke2RhdGF9ID09PSBcInRydWVcIiB8fCAke2RhdGF9ID09PSAxYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwibnVsbFwiOlxuICAgICAgICAgICAgICAgIGdlbi5lbHNlSWYoY29kZWdlbl8xLl8gYCR7ZGF0YX0gPT09IFwiXCIgfHwgJHtkYXRhfSA9PT0gMCB8fCAke2RhdGF9ID09PSBmYWxzZWApO1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oY29lcmNlZCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoY29kZWdlbl8xLl8gYCR7ZGF0YVR5cGV9ID09PSBcInN0cmluZ1wiIHx8ICR7ZGF0YVR5cGV9ID09PSBcIm51bWJlclwiXG4gICAgICAgICAgICAgIHx8ICR7ZGF0YVR5cGV9ID09PSBcImJvb2xlYW5cIiB8fCAke2RhdGF9ID09PSBudWxsYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCBjb2RlZ2VuXzEuXyBgWyR7ZGF0YX1dYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBhc3NpZ25QYXJlbnREYXRhKHsgZ2VuLCBwYXJlbnREYXRhLCBwYXJlbnREYXRhUHJvcGVydHkgfSwgZXhwcikge1xuICAgIC8vIFRPRE8gdXNlIGdlbi5wcm9wZXJ0eVxuICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtwYXJlbnREYXRhfSAhPT0gdW5kZWZpbmVkYCwgKCkgPT4gZ2VuLmFzc2lnbihjb2RlZ2VuXzEuXyBgJHtwYXJlbnREYXRhfVske3BhcmVudERhdGFQcm9wZXJ0eX1dYCwgZXhwcikpO1xufVxuZnVuY3Rpb24gY2hlY2tEYXRhVHlwZShkYXRhVHlwZSwgZGF0YSwgc3RyaWN0TnVtcywgY29ycmVjdCA9IERhdGFUeXBlLkNvcnJlY3QpIHtcbiAgICBjb25zdCBFUSA9IGNvcnJlY3QgPT09IERhdGFUeXBlLkNvcnJlY3QgPyBjb2RlZ2VuXzEub3BlcmF0b3JzLkVRIDogY29kZWdlbl8xLm9wZXJhdG9ycy5ORVE7XG4gICAgbGV0IGNvbmQ7XG4gICAgc3dpdGNoIChkYXRhVHlwZSkge1xuICAgICAgICBjYXNlIFwibnVsbFwiOlxuICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5fIGAke2RhdGF9ICR7RVF9IG51bGxgO1xuICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgICAgIGNvbmQgPSBjb2RlZ2VuXzEuXyBgQXJyYXkuaXNBcnJheSgke2RhdGF9KWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgY29uZCA9IGNvZGVnZW5fMS5fIGAke2RhdGF9ICYmIHR5cGVvZiAke2RhdGF9ID09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoJHtkYXRhfSlgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJpbnRlZ2VyXCI6XG4gICAgICAgICAgICBjb25kID0gbnVtQ29uZChjb2RlZ2VuXzEuXyBgISgke2RhdGF9ICUgMSkgJiYgIWlzTmFOKCR7ZGF0YX0pYCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgY29uZCA9IG51bUNvbmQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5fIGB0eXBlb2YgJHtkYXRhfSAke0VRfSAke2RhdGFUeXBlfWA7XG4gICAgfVxuICAgIHJldHVybiBjb3JyZWN0ID09PSBEYXRhVHlwZS5Db3JyZWN0ID8gY29uZCA6IGNvZGVnZW5fMS5ub3QoY29uZCk7XG4gICAgZnVuY3Rpb24gbnVtQ29uZChfY29uZCA9IGNvZGVnZW5fMS5uaWwpIHtcbiAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5hbmQoY29kZWdlbl8xLl8gYHR5cGVvZiAke2RhdGF9ID09IFwibnVtYmVyXCJgLCBfY29uZCwgc3RyaWN0TnVtcyA/IGNvZGVnZW5fMS5fIGBpc0Zpbml0ZSgke2RhdGF9KWAgOiBjb2RlZ2VuXzEubmlsKTtcbiAgICB9XG59XG5leHBvcnRzLmNoZWNrRGF0YVR5cGUgPSBjaGVja0RhdGFUeXBlO1xuZnVuY3Rpb24gY2hlY2tEYXRhVHlwZXMoZGF0YVR5cGVzLCBkYXRhLCBzdHJpY3ROdW1zLCBjb3JyZWN0KSB7XG4gICAgaWYgKGRhdGFUeXBlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrRGF0YVR5cGUoZGF0YVR5cGVzWzBdLCBkYXRhLCBzdHJpY3ROdW1zLCBjb3JyZWN0KTtcbiAgICB9XG4gICAgbGV0IGNvbmQ7XG4gICAgY29uc3QgdHlwZXMgPSB1dGlsXzEudG9IYXNoKGRhdGFUeXBlcyk7XG4gICAgaWYgKHR5cGVzLmFycmF5ICYmIHR5cGVzLm9iamVjdCkge1xuICAgICAgICBjb25zdCBub3RPYmogPSBjb2RlZ2VuXzEuXyBgdHlwZW9mICR7ZGF0YX0gIT0gXCJvYmplY3RcImA7XG4gICAgICAgIGNvbmQgPSB0eXBlcy5udWxsID8gbm90T2JqIDogY29kZWdlbl8xLl8gYCEke2RhdGF9IHx8ICR7bm90T2JqfWA7XG4gICAgICAgIGRlbGV0ZSB0eXBlcy5udWxsO1xuICAgICAgICBkZWxldGUgdHlwZXMuYXJyYXk7XG4gICAgICAgIGRlbGV0ZSB0eXBlcy5vYmplY3Q7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25kID0gY29kZWdlbl8xLm5pbDtcbiAgICB9XG4gICAgaWYgKHR5cGVzLm51bWJlcilcbiAgICAgICAgZGVsZXRlIHR5cGVzLmludGVnZXI7XG4gICAgZm9yIChjb25zdCB0IGluIHR5cGVzKVxuICAgICAgICBjb25kID0gY29kZWdlbl8xLmFuZChjb25kLCBjaGVja0RhdGFUeXBlKHQsIGRhdGEsIHN0cmljdE51bXMsIGNvcnJlY3QpKTtcbiAgICByZXR1cm4gY29uZDtcbn1cbmV4cG9ydHMuY2hlY2tEYXRhVHlwZXMgPSBjaGVja0RhdGFUeXBlcztcbmNvbnN0IHR5cGVFcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBzY2hlbWEgfSkgPT4gYG11c3QgYmUgJHtzY2hlbWF9YCxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYSwgc2NoZW1hVmFsdWUgfSkgPT4gdHlwZW9mIHNjaGVtYSA9PSBcInN0cmluZ1wiID8gY29kZWdlbl8xLl8gYHt0eXBlOiAke3NjaGVtYX19YCA6IGNvZGVnZW5fMS5fIGB7dHlwZTogJHtzY2hlbWFWYWx1ZX19YCxcbn07XG5mdW5jdGlvbiByZXBvcnRUeXBlRXJyb3IoaXQpIHtcbiAgICBjb25zdCBjeHQgPSBnZXRUeXBlRXJyb3JDb250ZXh0KGl0KTtcbiAgICBlcnJvcnNfMS5yZXBvcnRFcnJvcihjeHQsIHR5cGVFcnJvcik7XG59XG5leHBvcnRzLnJlcG9ydFR5cGVFcnJvciA9IHJlcG9ydFR5cGVFcnJvcjtcbmZ1bmN0aW9uIGdldFR5cGVFcnJvckNvbnRleHQoaXQpIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwgc2NoZW1hIH0gPSBpdDtcbiAgICBjb25zdCBzY2hlbWFDb2RlID0gdXRpbF8xLnNjaGVtYVJlZk9yVmFsKGl0LCBzY2hlbWEsIFwidHlwZVwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZW4sXG4gICAgICAgIGtleXdvcmQ6IFwidHlwZVwiLFxuICAgICAgICBkYXRhLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYS50eXBlLFxuICAgICAgICBzY2hlbWFDb2RlLFxuICAgICAgICBzY2hlbWFWYWx1ZTogc2NoZW1hQ29kZSxcbiAgICAgICAgcGFyZW50U2NoZW1hOiBzY2hlbWEsXG4gICAgICAgIHBhcmFtczoge30sXG4gICAgICAgIGl0LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhVHlwZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXNzaWduRGVmYXVsdHMgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuZnVuY3Rpb24gYXNzaWduRGVmYXVsdHMoaXQsIHR5KSB7XG4gICAgY29uc3QgeyBwcm9wZXJ0aWVzLCBpdGVtcyB9ID0gaXQuc2NoZW1hO1xuICAgIGlmICh0eSA9PT0gXCJvYmplY3RcIiAmJiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGFzc2lnbkRlZmF1bHQoaXQsIGtleSwgcHJvcGVydGllc1trZXldLmRlZmF1bHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5ID09PSBcImFycmF5XCIgJiYgQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICAgICAgaXRlbXMuZm9yRWFjaCgoc2NoLCBpKSA9PiBhc3NpZ25EZWZhdWx0KGl0LCBpLCBzY2guZGVmYXVsdCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNzaWduRGVmYXVsdHMgPSBhc3NpZ25EZWZhdWx0cztcbmZ1bmN0aW9uIGFzc2lnbkRlZmF1bHQoaXQsIHByb3AsIGRlZmF1bHRWYWx1ZSkge1xuICAgIGNvbnN0IHsgZ2VuLCBjb21wb3NpdGVSdWxlLCBkYXRhLCBvcHRzIH0gPSBpdDtcbiAgICBpZiAoZGVmYXVsdFZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBjaGlsZERhdGEgPSBjb2RlZ2VuXzEuXyBgJHtkYXRhfSR7Y29kZWdlbl8xLmdldFByb3BlcnR5KHByb3ApfWA7XG4gICAgaWYgKGNvbXBvc2l0ZVJ1bGUpIHtcbiAgICAgICAgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZShpdCwgYGRlZmF1bHQgaXMgaWdub3JlZCBmb3I6ICR7Y2hpbGREYXRhfWApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjb25kaXRpb24gPSBjb2RlZ2VuXzEuXyBgJHtjaGlsZERhdGF9ID09PSB1bmRlZmluZWRgO1xuICAgIGlmIChvcHRzLnVzZURlZmF1bHRzID09PSBcImVtcHR5XCIpIHtcbiAgICAgICAgY29uZGl0aW9uID0gY29kZWdlbl8xLl8gYCR7Y29uZGl0aW9ufSB8fCAke2NoaWxkRGF0YX0gPT09IG51bGwgfHwgJHtjaGlsZERhdGF9ID09PSBcIlwiYDtcbiAgICB9XG4gICAgLy8gYCR7Y2hpbGREYXRhfSA9PT0gdW5kZWZpbmVkYCArXG4gICAgLy8gKG9wdHMudXNlRGVmYXVsdHMgPT09IFwiZW1wdHlcIiA/IGAgfHwgJHtjaGlsZERhdGF9ID09PSBudWxsIHx8ICR7Y2hpbGREYXRhfSA9PT0gXCJcImAgOiBcIlwiKVxuICAgIGdlbi5pZihjb25kaXRpb24sIGNvZGVnZW5fMS5fIGAke2NoaWxkRGF0YX0gPSAke2NvZGVnZW5fMS5zdHJpbmdpZnkoZGVmYXVsdFZhbHVlKX1gKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0ZVVuaW9uID0gZXhwb3J0cy52YWxpZGF0ZUFycmF5ID0gZXhwb3J0cy51c2VQYXR0ZXJuID0gZXhwb3J0cy5jYWxsVmFsaWRhdGVDb2RlID0gZXhwb3J0cy5zY2hlbWFQcm9wZXJ0aWVzID0gZXhwb3J0cy5hbGxTY2hlbWFQcm9wZXJ0aWVzID0gZXhwb3J0cy5ub1Byb3BlcnR5SW5EYXRhID0gZXhwb3J0cy5wcm9wZXJ0eUluRGF0YSA9IGV4cG9ydHMuaXNPd25Qcm9wZXJ0eSA9IGV4cG9ydHMuaGFzUHJvcEZ1bmMgPSBleHBvcnRzLnJlcG9ydE1pc3NpbmdQcm9wID0gZXhwb3J0cy5jaGVja01pc3NpbmdQcm9wID0gZXhwb3J0cy5jaGVja1JlcG9ydE1pc3NpbmdQcm9wID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uL2NvbXBpbGUvbmFtZXNcIik7XG5mdW5jdGlvbiBjaGVja1JlcG9ydE1pc3NpbmdQcm9wKGN4dCwgcHJvcCkge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBpdCB9ID0gY3h0O1xuICAgIGdlbi5pZihub1Byb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKSwgKCkgPT4ge1xuICAgICAgICBjeHQuc2V0UGFyYW1zKHsgbWlzc2luZ1Byb3BlcnR5OiBjb2RlZ2VuXzEuXyBgJHtwcm9wfWAgfSwgdHJ1ZSk7XG4gICAgICAgIGN4dC5lcnJvcigpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5jaGVja1JlcG9ydE1pc3NpbmdQcm9wID0gY2hlY2tSZXBvcnRNaXNzaW5nUHJvcDtcbmZ1bmN0aW9uIGNoZWNrTWlzc2luZ1Byb3AoeyBnZW4sIGRhdGEsIGl0OiB7IG9wdHMgfSB9LCBwcm9wZXJ0aWVzLCBtaXNzaW5nKSB7XG4gICAgcmV0dXJuIGNvZGVnZW5fMS5vciguLi5wcm9wZXJ0aWVzLm1hcCgocHJvcCkgPT4gY29kZWdlbl8xLmFuZChub1Byb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgb3B0cy5vd25Qcm9wZXJ0aWVzKSwgY29kZWdlbl8xLl8gYCR7bWlzc2luZ30gPSAke3Byb3B9YCkpKTtcbn1cbmV4cG9ydHMuY2hlY2tNaXNzaW5nUHJvcCA9IGNoZWNrTWlzc2luZ1Byb3A7XG5mdW5jdGlvbiByZXBvcnRNaXNzaW5nUHJvcChjeHQsIG1pc3NpbmcpIHtcbiAgICBjeHQuc2V0UGFyYW1zKHsgbWlzc2luZ1Byb3BlcnR5OiBtaXNzaW5nIH0sIHRydWUpO1xuICAgIGN4dC5lcnJvcigpO1xufVxuZXhwb3J0cy5yZXBvcnRNaXNzaW5nUHJvcCA9IHJlcG9ydE1pc3NpbmdQcm9wO1xuZnVuY3Rpb24gaGFzUHJvcEZ1bmMoZ2VuKSB7XG4gICAgcmV0dXJuIGdlbi5zY29wZVZhbHVlKFwiZnVuY1wiLCB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICAgICAgcmVmOiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuICAgICAgICBjb2RlOiBjb2RlZ2VuXzEuXyBgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eWAsXG4gICAgfSk7XG59XG5leHBvcnRzLmhhc1Byb3BGdW5jID0gaGFzUHJvcEZ1bmM7XG5mdW5jdGlvbiBpc093blByb3BlcnR5KGdlbiwgZGF0YSwgcHJvcGVydHkpIHtcbiAgICByZXR1cm4gY29kZWdlbl8xLl8gYCR7aGFzUHJvcEZ1bmMoZ2VuKX0uY2FsbCgke2RhdGF9LCAke3Byb3BlcnR5fSlgO1xufVxuZXhwb3J0cy5pc093blByb3BlcnR5ID0gaXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIHByb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcGVydHksIG93blByb3BlcnRpZXMpIHtcbiAgICBjb25zdCBjb25kID0gY29kZWdlbl8xLl8gYCR7ZGF0YX0ke2NvZGVnZW5fMS5nZXRQcm9wZXJ0eShwcm9wZXJ0eSl9ICE9PSB1bmRlZmluZWRgO1xuICAgIHJldHVybiBvd25Qcm9wZXJ0aWVzID8gY29kZWdlbl8xLl8gYCR7Y29uZH0gJiYgJHtpc093blByb3BlcnR5KGdlbiwgZGF0YSwgcHJvcGVydHkpfWAgOiBjb25kO1xufVxuZXhwb3J0cy5wcm9wZXJ0eUluRGF0YSA9IHByb3BlcnR5SW5EYXRhO1xuZnVuY3Rpb24gbm9Qcm9wZXJ0eUluRGF0YShnZW4sIGRhdGEsIHByb3BlcnR5LCBvd25Qcm9wZXJ0aWVzKSB7XG4gICAgY29uc3QgY29uZCA9IGNvZGVnZW5fMS5fIGAke2RhdGF9JHtjb2RlZ2VuXzEuZ2V0UHJvcGVydHkocHJvcGVydHkpfSA9PT0gdW5kZWZpbmVkYDtcbiAgICByZXR1cm4gb3duUHJvcGVydGllcyA/IGNvZGVnZW5fMS5vcihjb25kLCBjb2RlZ2VuXzEubm90KGlzT3duUHJvcGVydHkoZ2VuLCBkYXRhLCBwcm9wZXJ0eSkpKSA6IGNvbmQ7XG59XG5leHBvcnRzLm5vUHJvcGVydHlJbkRhdGEgPSBub1Byb3BlcnR5SW5EYXRhO1xuZnVuY3Rpb24gYWxsU2NoZW1hUHJvcGVydGllcyhzY2hlbWFNYXApIHtcbiAgICByZXR1cm4gc2NoZW1hTWFwID8gT2JqZWN0LmtleXMoc2NoZW1hTWFwKS5maWx0ZXIoKHApID0+IHAgIT09IFwiX19wcm90b19fXCIpIDogW107XG59XG5leHBvcnRzLmFsbFNjaGVtYVByb3BlcnRpZXMgPSBhbGxTY2hlbWFQcm9wZXJ0aWVzO1xuZnVuY3Rpb24gc2NoZW1hUHJvcGVydGllcyhpdCwgc2NoZW1hTWFwKSB7XG4gICAgcmV0dXJuIGFsbFNjaGVtYVByb3BlcnRpZXMoc2NoZW1hTWFwKS5maWx0ZXIoKHApID0+ICF1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYU1hcFtwXSkpO1xufVxuZXhwb3J0cy5zY2hlbWFQcm9wZXJ0aWVzID0gc2NoZW1hUHJvcGVydGllcztcbmZ1bmN0aW9uIGNhbGxWYWxpZGF0ZUNvZGUoeyBzY2hlbWFDb2RlLCBkYXRhLCBpdDogeyBnZW4sIHRvcFNjaGVtYVJlZiwgc2NoZW1hUGF0aCwgZXJyb3JQYXRoIH0sIGl0IH0sIGZ1bmMsIGNvbnRleHQsIHBhc3NTY2hlbWEpIHtcbiAgICBjb25zdCBkYXRhQW5kU2NoZW1hID0gcGFzc1NjaGVtYSA/IGNvZGVnZW5fMS5fIGAke3NjaGVtYUNvZGV9LCAke2RhdGF9LCAke3RvcFNjaGVtYVJlZn0ke3NjaGVtYVBhdGh9YCA6IGRhdGE7XG4gICAgY29uc3QgdmFsQ3h0ID0gW1xuICAgICAgICBbbmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aCwgY29kZWdlbl8xLnN0ckNvbmNhdChuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCBlcnJvclBhdGgpXSxcbiAgICAgICAgW25hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhLCBpdC5wYXJlbnREYXRhXSxcbiAgICAgICAgW25hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHksIGl0LnBhcmVudERhdGFQcm9wZXJ0eV0sXG4gICAgICAgIFtuYW1lc18xLmRlZmF1bHQucm9vdERhdGEsIG5hbWVzXzEuZGVmYXVsdC5yb290RGF0YV0sXG4gICAgXTtcbiAgICBpZiAoaXQub3B0cy5keW5hbWljUmVmKVxuICAgICAgICB2YWxDeHQucHVzaChbbmFtZXNfMS5kZWZhdWx0LmR5bmFtaWNBbmNob3JzLCBuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnNdKTtcbiAgICBjb25zdCBhcmdzID0gY29kZWdlbl8xLl8gYCR7ZGF0YUFuZFNjaGVtYX0sICR7Z2VuLm9iamVjdCguLi52YWxDeHQpfWA7XG4gICAgcmV0dXJuIGNvbnRleHQgIT09IGNvZGVnZW5fMS5uaWwgPyBjb2RlZ2VuXzEuXyBgJHtmdW5jfS5jYWxsKCR7Y29udGV4dH0sICR7YXJnc30pYCA6IGNvZGVnZW5fMS5fIGAke2Z1bmN9KCR7YXJnc30pYDtcbn1cbmV4cG9ydHMuY2FsbFZhbGlkYXRlQ29kZSA9IGNhbGxWYWxpZGF0ZUNvZGU7XG5mdW5jdGlvbiB1c2VQYXR0ZXJuKHsgZ2VuLCBpdDogeyBvcHRzIH0gfSwgcGF0dGVybikge1xuICAgIGNvbnN0IHUgPSBvcHRzLnVuaWNvZGVSZWdFeHAgPyBcInVcIiA6IFwiXCI7XG4gICAgcmV0dXJuIGdlbi5zY29wZVZhbHVlKFwicGF0dGVyblwiLCB7XG4gICAgICAgIGtleTogcGF0dGVybixcbiAgICAgICAgcmVmOiBuZXcgUmVnRXhwKHBhdHRlcm4sIHUpLFxuICAgICAgICBjb2RlOiBjb2RlZ2VuXzEuXyBgbmV3IFJlZ0V4cCgke3BhdHRlcm59LCAke3V9KWAsXG4gICAgfSk7XG59XG5leHBvcnRzLnVzZVBhdHRlcm4gPSB1c2VQYXR0ZXJuO1xuZnVuY3Rpb24gdmFsaWRhdGVBcnJheShjeHQpIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgaWYgKGl0LmFsbEVycm9ycykge1xuICAgICAgICBjb25zdCB2YWxpZEFyciA9IGdlbi5sZXQoXCJ2YWxpZFwiLCB0cnVlKTtcbiAgICAgICAgdmFsaWRhdGVJdGVtcygoKSA9PiBnZW4uYXNzaWduKHZhbGlkQXJyLCBmYWxzZSkpO1xuICAgICAgICByZXR1cm4gdmFsaWRBcnI7XG4gICAgfVxuICAgIGdlbi52YXIodmFsaWQsIHRydWUpO1xuICAgIHZhbGlkYXRlSXRlbXMoKCkgPT4gZ2VuLmJyZWFrKCkpO1xuICAgIHJldHVybiB2YWxpZDtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUl0ZW1zKG5vdFZhbGlkKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IGdlbi5jb25zdChcImxlblwiLCBjb2RlZ2VuXzEuXyBgJHtkYXRhfS5sZW5ndGhgKTtcbiAgICAgICAgZ2VuLmZvclJhbmdlKFwiaVwiLCAwLCBsZW4sIChpKSA9PiB7XG4gICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkLFxuICAgICAgICAgICAgICAgIGRhdGFQcm9wOiBpLFxuICAgICAgICAgICAgICAgIGRhdGFQcm9wVHlwZTogdXRpbF8xLlR5cGUuTnVtLFxuICAgICAgICAgICAgfSwgdmFsaWQpO1xuICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5ub3QodmFsaWQpLCBub3RWYWxpZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVBcnJheSA9IHZhbGlkYXRlQXJyYXk7XG5mdW5jdGlvbiB2YWxpZGF0ZVVuaW9uKGN4dCkge1xuICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIGtleXdvcmQsIGl0IH0gPSBjeHQ7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICBjb25zdCBhbHdheXNWYWxpZCA9IHNjaGVtYS5zb21lKChzY2gpID0+IHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoKSk7XG4gICAgaWYgKGFsd2F5c1ZhbGlkICYmICFpdC5vcHRzLnVuZXZhbHVhdGVkKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgZmFsc2UpO1xuICAgIGNvbnN0IHNjaFZhbGlkID0gZ2VuLm5hbWUoXCJfdmFsaWRcIik7XG4gICAgZ2VuLmJsb2NrKCgpID0+IHNjaGVtYS5mb3JFYWNoKChfc2NoLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAga2V5d29yZCxcbiAgICAgICAgICAgIHNjaGVtYVByb3A6IGksXG4gICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICB9LCBzY2hWYWxpZCk7XG4gICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGNvZGVnZW5fMS5fIGAke3ZhbGlkfSB8fCAke3NjaFZhbGlkfWApO1xuICAgICAgICBjb25zdCBtZXJnZWQgPSBjeHQubWVyZ2VWYWxpZEV2YWx1YXRlZChzY2hDeHQsIHNjaFZhbGlkKTtcbiAgICAgICAgLy8gY2FuIHNob3J0LWNpcmN1aXQgaWYgYHVuZXZhbHVhdGVkUHJvcGVydGllcy9JdGVtc2Agbm90IHN1cHBvcnRlZCAob3B0cy51bmV2YWx1YXRlZCAhPT0gdHJ1ZSlcbiAgICAgICAgLy8gb3IgaWYgYWxsIHByb3BlcnRpZXMgYW5kIGl0ZW1zIHdlcmUgZXZhbHVhdGVkIChpdC5wcm9wcyA9PT0gdHJ1ZSAmJiBpdC5pdGVtcyA9PT0gdHJ1ZSlcbiAgICAgICAgaWYgKCFtZXJnZWQpXG4gICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLm5vdCh2YWxpZCkpO1xuICAgIH0pKTtcbiAgICBjeHQucmVzdWx0KHZhbGlkLCAoKSA9PiBjeHQucmVzZXQoKSwgKCkgPT4gY3h0LmVycm9yKHRydWUpKTtcbn1cbmV4cG9ydHMudmFsaWRhdGVVbmlvbiA9IHZhbGlkYXRlVW5pb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0ZUtleXdvcmRVc2FnZSA9IGV4cG9ydHMudmFsaWRTY2hlbWFUeXBlID0gZXhwb3J0cy5mdW5jS2V5d29yZENvZGUgPSBleHBvcnRzLm1hY3JvS2V5d29yZENvZGUgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi4vbmFtZXNcIik7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vLi4vdm9jYWJ1bGFyaWVzL2NvZGVcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG5mdW5jdGlvbiBtYWNyb0tleXdvcmRDb2RlKGN4dCwgZGVmKSB7XG4gICAgY29uc3QgeyBnZW4sIGtleXdvcmQsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IG1hY3JvU2NoZW1hID0gZGVmLm1hY3JvLmNhbGwoaXQuc2VsZiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0KTtcbiAgICBjb25zdCBzY2hlbWFSZWYgPSB1c2VLZXl3b3JkKGdlbiwga2V5d29yZCwgbWFjcm9TY2hlbWEpO1xuICAgIGlmIChpdC5vcHRzLnZhbGlkYXRlU2NoZW1hICE9PSBmYWxzZSlcbiAgICAgICAgaXQuc2VsZi52YWxpZGF0ZVNjaGVtYShtYWNyb1NjaGVtYSwgdHJ1ZSk7XG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgIGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICBzY2hlbWE6IG1hY3JvU2NoZW1hLFxuICAgICAgICBzY2hlbWFQYXRoOiBjb2RlZ2VuXzEubmlsLFxuICAgICAgICBlcnJTY2hlbWFQYXRoOiBgJHtpdC5lcnJTY2hlbWFQYXRofS8ke2tleXdvcmR9YCxcbiAgICAgICAgdG9wU2NoZW1hUmVmOiBzY2hlbWFSZWYsXG4gICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgfSwgdmFsaWQpO1xuICAgIGN4dC5wYXNzKHZhbGlkLCAoKSA9PiBjeHQuZXJyb3IodHJ1ZSkpO1xufVxuZXhwb3J0cy5tYWNyb0tleXdvcmRDb2RlID0gbWFjcm9LZXl3b3JkQ29kZTtcbmZ1bmN0aW9uIGZ1bmNLZXl3b3JkQ29kZShjeHQsIGRlZikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IGdlbiwga2V5d29yZCwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsICRkYXRhLCBpdCB9ID0gY3h0O1xuICAgIGNoZWNrQXN5bmNLZXl3b3JkKGl0LCBkZWYpO1xuICAgIGNvbnN0IHZhbGlkYXRlID0gISRkYXRhICYmIGRlZi5jb21waWxlID8gZGVmLmNvbXBpbGUuY2FsbChpdC5zZWxmLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQpIDogZGVmLnZhbGlkYXRlO1xuICAgIGNvbnN0IHZhbGlkYXRlUmVmID0gdXNlS2V5d29yZChnZW4sIGtleXdvcmQsIHZhbGlkYXRlKTtcbiAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiKTtcbiAgICBjeHQuYmxvY2skZGF0YSh2YWxpZCwgdmFsaWRhdGVLZXl3b3JkKTtcbiAgICBjeHQub2soKF9hID0gZGVmLnZhbGlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2YWxpZCk7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVLZXl3b3JkKCkge1xuICAgICAgICBpZiAoZGVmLmVycm9ycyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGFzc2lnblZhbGlkKCk7XG4gICAgICAgICAgICBpZiAoZGVmLm1vZGlmeWluZylcbiAgICAgICAgICAgICAgICBtb2RpZnlEYXRhKGN4dCk7XG4gICAgICAgICAgICByZXBvcnRFcnJzKCgpID0+IGN4dC5lcnJvcigpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bGVFcnJzID0gZGVmLmFzeW5jID8gdmFsaWRhdGVBc3luYygpIDogdmFsaWRhdGVTeW5jKCk7XG4gICAgICAgICAgICBpZiAoZGVmLm1vZGlmeWluZylcbiAgICAgICAgICAgICAgICBtb2RpZnlEYXRhKGN4dCk7XG4gICAgICAgICAgICByZXBvcnRFcnJzKCgpID0+IGFkZEVycnMoY3h0LCBydWxlRXJycykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlQXN5bmMoKSB7XG4gICAgICAgIGNvbnN0IHJ1bGVFcnJzID0gZ2VuLmxldChcInJ1bGVFcnJzXCIsIG51bGwpO1xuICAgICAgICBnZW4udHJ5KCgpID0+IGFzc2lnblZhbGlkKGNvZGVnZW5fMS5fIGBhd2FpdCBgKSwgKGUpID0+IGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKS5pZihjb2RlZ2VuXzEuXyBgJHtlfSBpbnN0YW5jZW9mICR7aXQuVmFsaWRhdGlvbkVycm9yfWAsICgpID0+IGdlbi5hc3NpZ24ocnVsZUVycnMsIGNvZGVnZW5fMS5fIGAke2V9LmVycm9yc2ApLCAoKSA9PiBnZW4udGhyb3coZSkpKTtcbiAgICAgICAgcmV0dXJuIHJ1bGVFcnJzO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVN5bmMoKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlRXJycyA9IGNvZGVnZW5fMS5fIGAke3ZhbGlkYXRlUmVmfS5lcnJvcnNgO1xuICAgICAgICBnZW4uYXNzaWduKHZhbGlkYXRlRXJycywgbnVsbCk7XG4gICAgICAgIGFzc2lnblZhbGlkKGNvZGVnZW5fMS5uaWwpO1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVFcnJzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc3NpZ25WYWxpZChfYXdhaXQgPSBkZWYuYXN5bmMgPyBjb2RlZ2VuXzEuXyBgYXdhaXQgYCA6IGNvZGVnZW5fMS5uaWwpIHtcbiAgICAgICAgY29uc3QgcGFzc0N4dCA9IGl0Lm9wdHMucGFzc0NvbnRleHQgPyBuYW1lc18xLmRlZmF1bHQudGhpcyA6IG5hbWVzXzEuZGVmYXVsdC5zZWxmO1xuICAgICAgICBjb25zdCBwYXNzU2NoZW1hID0gISgoXCJjb21waWxlXCIgaW4gZGVmICYmICEkZGF0YSkgfHwgZGVmLnNjaGVtYSA9PT0gZmFsc2UpO1xuICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBjb2RlZ2VuXzEuXyBgJHtfYXdhaXR9JHtjb2RlXzEuY2FsbFZhbGlkYXRlQ29kZShjeHQsIHZhbGlkYXRlUmVmLCBwYXNzQ3h0LCBwYXNzU2NoZW1hKX1gLCBkZWYubW9kaWZ5aW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVwb3J0RXJycyhlcnJvcnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBnZW4uaWYoY29kZWdlbl8xLm5vdCgoX2EgPSBkZWYudmFsaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbGlkKSwgZXJyb3JzKTtcbiAgICB9XG59XG5leHBvcnRzLmZ1bmNLZXl3b3JkQ29kZSA9IGZ1bmNLZXl3b3JkQ29kZTtcbmZ1bmN0aW9uIG1vZGlmeURhdGEoY3h0KSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgZ2VuLmlmKGl0LnBhcmVudERhdGEsICgpID0+IGdlbi5hc3NpZ24oZGF0YSwgY29kZWdlbl8xLl8gYCR7aXQucGFyZW50RGF0YX1bJHtpdC5wYXJlbnREYXRhUHJvcGVydHl9XWApKTtcbn1cbmZ1bmN0aW9uIGFkZEVycnMoY3h0LCBlcnJzKSB7XG4gICAgY29uc3QgeyBnZW4gfSA9IGN4dDtcbiAgICBnZW4uaWYoY29kZWdlbl8xLl8gYEFycmF5LmlzQXJyYXkoJHtlcnJzfSlgLCAoKSA9PiB7XG4gICAgICAgIGdlblxuICAgICAgICAgICAgLmFzc2lnbihuYW1lc18xLmRlZmF1bHQudkVycm9ycywgY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9ID09PSBudWxsID8gJHtlcnJzfSA6ICR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9LmNvbmNhdCgke2VycnN9KWApXG4gICAgICAgICAgICAuYXNzaWduKG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMsIGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfS5sZW5ndGhgKTtcbiAgICAgICAgZXJyb3JzXzEuZXh0ZW5kRXJyb3JzKGN4dCk7XG4gICAgfSwgKCkgPT4gY3h0LmVycm9yKCkpO1xufVxuZnVuY3Rpb24gY2hlY2tBc3luY0tleXdvcmQoeyBzY2hlbWFFbnYgfSwgZGVmKSB7XG4gICAgaWYgKGRlZi5hc3luYyAmJiAhc2NoZW1hRW52LiRhc3luYylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXN5bmMga2V5d29yZCBpbiBzeW5jIHNjaGVtYVwiKTtcbn1cbmZ1bmN0aW9uIHVzZUtleXdvcmQoZ2VuLCBrZXl3b3JkLCByZXN1bHQpIHtcbiAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihga2V5d29yZCBcIiR7a2V5d29yZH1cIiBmYWlsZWQgdG8gY29tcGlsZWApO1xuICAgIHJldHVybiBnZW4uc2NvcGVWYWx1ZShcImtleXdvcmRcIiwgdHlwZW9mIHJlc3VsdCA9PSBcImZ1bmN0aW9uXCIgPyB7IHJlZjogcmVzdWx0IH0gOiB7IHJlZjogcmVzdWx0LCBjb2RlOiBjb2RlZ2VuXzEuc3RyaW5naWZ5KHJlc3VsdCkgfSk7XG59XG5mdW5jdGlvbiB2YWxpZFNjaGVtYVR5cGUoc2NoZW1hLCBzY2hlbWFUeXBlLCBhbGxvd1VuZGVmaW5lZCA9IGZhbHNlKSB7XG4gICAgLy8gVE9ETyBhZGQgdGVzdHNcbiAgICByZXR1cm4gKCFzY2hlbWFUeXBlLmxlbmd0aCB8fFxuICAgICAgICBzY2hlbWFUeXBlLnNvbWUoKHN0KSA9PiBzdCA9PT0gXCJhcnJheVwiXG4gICAgICAgICAgICA/IEFycmF5LmlzQXJyYXkoc2NoZW1hKVxuICAgICAgICAgICAgOiBzdCA9PT0gXCJvYmplY3RcIlxuICAgICAgICAgICAgICAgID8gc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShzY2hlbWEpXG4gICAgICAgICAgICAgICAgOiB0eXBlb2Ygc2NoZW1hID09IHN0IHx8IChhbGxvd1VuZGVmaW5lZCAmJiB0eXBlb2Ygc2NoZW1hID09IFwidW5kZWZpbmVkXCIpKSk7XG59XG5leHBvcnRzLnZhbGlkU2NoZW1hVHlwZSA9IHZhbGlkU2NoZW1hVHlwZTtcbmZ1bmN0aW9uIHZhbGlkYXRlS2V5d29yZFVzYWdlKHsgc2NoZW1hLCBvcHRzLCBzZWxmLCBlcnJTY2hlbWFQYXRoIH0sIGRlZiwga2V5d29yZCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRlZi5rZXl3b3JkKSA/ICFkZWYua2V5d29yZC5pbmNsdWRlcyhrZXl3b3JkKSA6IGRlZi5rZXl3b3JkICE9PSBrZXl3b3JkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICB9XG4gICAgY29uc3QgZGVwcyA9IGRlZi5kZXBlbmRlbmNpZXM7XG4gICAgaWYgKGRlcHMgPT09IG51bGwgfHwgZGVwcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVwcy5zb21lKChrd2QpID0+ICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2NoZW1hLCBrd2QpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhcmVudCBzY2hlbWEgbXVzdCBoYXZlIGRlcGVuZGVuY2llcyBvZiAke2tleXdvcmR9OiAke2RlcHMuam9pbihcIixcIil9YCk7XG4gICAgfVxuICAgIGlmIChkZWYudmFsaWRhdGVTY2hlbWEpIHtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBkZWYudmFsaWRhdGVTY2hlbWEoc2NoZW1hW2tleXdvcmRdKTtcbiAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gYGtleXdvcmQgXCIke2tleXdvcmR9XCIgdmFsdWUgaXMgaW52YWxpZCBhdCBwYXRoIFwiJHtlcnJTY2hlbWFQYXRofVwiOiBgICtcbiAgICAgICAgICAgICAgICBzZWxmLmVycm9yc1RleHQoZGVmLnZhbGlkYXRlU2NoZW1hLmVycm9ycyk7XG4gICAgICAgICAgICBpZiAob3B0cy52YWxpZGF0ZVNjaGVtYSA9PT0gXCJsb2dcIilcbiAgICAgICAgICAgICAgICBzZWxmLmxvZ2dlci5lcnJvcihtc2cpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZUtleXdvcmRVc2FnZSA9IHZhbGlkYXRlS2V5d29yZFVzYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2V5d29yZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXh0ZW5kU3Vic2NoZW1hTW9kZSA9IGV4cG9ydHMuZXh0ZW5kU3Vic2NoZW1hRGF0YSA9IGV4cG9ydHMuZ2V0U3Vic2NoZW1hID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmZ1bmN0aW9uIGdldFN1YnNjaGVtYShpdCwgeyBrZXl3b3JkLCBzY2hlbWFQcm9wLCBzY2hlbWEsIHNjaGVtYVBhdGgsIGVyclNjaGVtYVBhdGgsIHRvcFNjaGVtYVJlZiB9KSB7XG4gICAgaWYgKGtleXdvcmQgIT09IHVuZGVmaW5lZCAmJiBzY2hlbWEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvdGggXCJrZXl3b3JkXCIgYW5kIFwic2NoZW1hXCIgcGFzc2VkLCBvbmx5IG9uZSBhbGxvd2VkJyk7XG4gICAgfVxuICAgIGlmIChrZXl3b3JkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qgc2NoID0gaXQuc2NoZW1hW2tleXdvcmRdO1xuICAgICAgICByZXR1cm4gc2NoZW1hUHJvcCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBzY2hlbWE6IHNjaCxcbiAgICAgICAgICAgICAgICBzY2hlbWFQYXRoOiBjb2RlZ2VuXzEuXyBgJHtpdC5zY2hlbWFQYXRofSR7Y29kZWdlbl8xLmdldFByb3BlcnR5KGtleXdvcmQpfWAsXG4gICAgICAgICAgICAgICAgZXJyU2NoZW1hUGF0aDogYCR7aXQuZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWAsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICBzY2hlbWE6IHNjaFtzY2hlbWFQcm9wXSxcbiAgICAgICAgICAgICAgICBzY2hlbWFQYXRoOiBjb2RlZ2VuXzEuXyBgJHtpdC5zY2hlbWFQYXRofSR7Y29kZWdlbl8xLmdldFByb3BlcnR5KGtleXdvcmQpfSR7Y29kZWdlbl8xLmdldFByb3BlcnR5KHNjaGVtYVByb3ApfWAsXG4gICAgICAgICAgICAgICAgZXJyU2NoZW1hUGF0aDogYCR7aXQuZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfS8ke3V0aWxfMS5lc2NhcGVGcmFnbWVudChzY2hlbWFQcm9wKX1gLFxuICAgICAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChzY2hlbWFQYXRoID09PSB1bmRlZmluZWQgfHwgZXJyU2NoZW1hUGF0aCA9PT0gdW5kZWZpbmVkIHx8IHRvcFNjaGVtYVJlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wic2NoZW1hUGF0aFwiLCBcImVyclNjaGVtYVBhdGhcIiBhbmQgXCJ0b3BTY2hlbWFSZWZcIiBhcmUgcmVxdWlyZWQgd2l0aCBcInNjaGVtYVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgIHNjaGVtYVBhdGgsXG4gICAgICAgICAgICB0b3BTY2hlbWFSZWYsXG4gICAgICAgICAgICBlcnJTY2hlbWFQYXRoLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VpdGhlciBcImtleXdvcmRcIiBvciBcInNjaGVtYVwiIG11c3QgYmUgcGFzc2VkJyk7XG59XG5leHBvcnRzLmdldFN1YnNjaGVtYSA9IGdldFN1YnNjaGVtYTtcbmZ1bmN0aW9uIGV4dGVuZFN1YnNjaGVtYURhdGEoc3Vic2NoZW1hLCBpdCwgeyBkYXRhUHJvcCwgZGF0YVByb3BUeXBlOiBkcFR5cGUsIGRhdGEsIGRhdGFUeXBlcywgcHJvcGVydHlOYW1lIH0pIHtcbiAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkICYmIGRhdGFQcm9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdib3RoIFwiZGF0YVwiIGFuZCBcImRhdGFQcm9wXCIgcGFzc2VkLCBvbmx5IG9uZSBhbGxvd2VkJyk7XG4gICAgfVxuICAgIGNvbnN0IHsgZ2VuIH0gPSBpdDtcbiAgICBpZiAoZGF0YVByb3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB7IGVycm9yUGF0aCwgZGF0YVBhdGhBcnIsIG9wdHMgfSA9IGl0O1xuICAgICAgICBjb25zdCBuZXh0RGF0YSA9IGdlbi5sZXQoXCJkYXRhXCIsIGNvZGVnZW5fMS5fIGAke2l0LmRhdGF9JHtjb2RlZ2VuXzEuZ2V0UHJvcGVydHkoZGF0YVByb3ApfWAsIHRydWUpO1xuICAgICAgICBkYXRhQ29udGV4dFByb3BzKG5leHREYXRhKTtcbiAgICAgICAgc3Vic2NoZW1hLmVycm9yUGF0aCA9IGNvZGVnZW5fMS5zdHIgYCR7ZXJyb3JQYXRofSR7dXRpbF8xLmdldEVycm9yUGF0aChkYXRhUHJvcCwgZHBUeXBlLCBvcHRzLmpzUHJvcGVydHlTeW50YXgpfWA7XG4gICAgICAgIHN1YnNjaGVtYS5wYXJlbnREYXRhUHJvcGVydHkgPSBjb2RlZ2VuXzEuXyBgJHtkYXRhUHJvcH1gO1xuICAgICAgICBzdWJzY2hlbWEuZGF0YVBhdGhBcnIgPSBbLi4uZGF0YVBhdGhBcnIsIHN1YnNjaGVtYS5wYXJlbnREYXRhUHJvcGVydHldO1xuICAgIH1cbiAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IG5leHREYXRhID0gZGF0YSBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lID8gZGF0YSA6IGdlbi5sZXQoXCJkYXRhXCIsIGRhdGEsIHRydWUpOyAvLyByZXBsYWNlYWJsZSBpZiB1c2VkIG9uY2U/XG4gICAgICAgIGRhdGFDb250ZXh0UHJvcHMobmV4dERhdGEpO1xuICAgICAgICBpZiAocHJvcGVydHlOYW1lICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBzdWJzY2hlbWEucHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lO1xuICAgICAgICAvLyBUT0RPIHNvbWV0aGluZyBpcyBwb3NzaWJseSB3cm9uZyBoZXJlIHdpdGggbm90IGNoYW5naW5nIHBhcmVudERhdGFQcm9wZXJ0eSBhbmQgbm90IGFwcGVuZGluZyBkYXRhUGF0aEFyclxuICAgIH1cbiAgICBpZiAoZGF0YVR5cGVzKVxuICAgICAgICBzdWJzY2hlbWEuZGF0YVR5cGVzID0gZGF0YVR5cGVzO1xuICAgIGZ1bmN0aW9uIGRhdGFDb250ZXh0UHJvcHMoX25leHREYXRhKSB7XG4gICAgICAgIHN1YnNjaGVtYS5kYXRhID0gX25leHREYXRhO1xuICAgICAgICBzdWJzY2hlbWEuZGF0YUxldmVsID0gaXQuZGF0YUxldmVsICsgMTtcbiAgICAgICAgc3Vic2NoZW1hLmRhdGFUeXBlcyA9IFtdO1xuICAgICAgICBpdC5kZWZpbmVkUHJvcGVydGllcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgc3Vic2NoZW1hLnBhcmVudERhdGEgPSBpdC5kYXRhO1xuICAgICAgICBzdWJzY2hlbWEuZGF0YU5hbWVzID0gWy4uLml0LmRhdGFOYW1lcywgX25leHREYXRhXTtcbiAgICB9XG59XG5leHBvcnRzLmV4dGVuZFN1YnNjaGVtYURhdGEgPSBleHRlbmRTdWJzY2hlbWFEYXRhO1xuZnVuY3Rpb24gZXh0ZW5kU3Vic2NoZW1hTW9kZShzdWJzY2hlbWEsIHsganRkRGlzY3JpbWluYXRvciwganRkTWV0YWRhdGEsIGNvbXBvc2l0ZVJ1bGUsIGNyZWF0ZUVycm9ycywgYWxsRXJyb3JzIH0pIHtcbiAgICBpZiAoY29tcG9zaXRlUnVsZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBzdWJzY2hlbWEuY29tcG9zaXRlUnVsZSA9IGNvbXBvc2l0ZVJ1bGU7XG4gICAgaWYgKGNyZWF0ZUVycm9ycyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBzdWJzY2hlbWEuY3JlYXRlRXJyb3JzID0gY3JlYXRlRXJyb3JzO1xuICAgIGlmIChhbGxFcnJvcnMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgc3Vic2NoZW1hLmFsbEVycm9ycyA9IGFsbEVycm9ycztcbiAgICBzdWJzY2hlbWEuanRkRGlzY3JpbWluYXRvciA9IGp0ZERpc2NyaW1pbmF0b3I7IC8vIG5vdCBpbmhlcml0ZWRcbiAgICBzdWJzY2hlbWEuanRkTWV0YWRhdGEgPSBqdGRNZXRhZGF0YTsgLy8gbm90IGluaGVyaXRlZFxufVxuZXhwb3J0cy5leHRlbmRTdWJzY2hlbWFNb2RlID0gZXh0ZW5kU3Vic2NoZW1hTW9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YnNjaGVtYS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbi8vIGRvIG5vdCBlZGl0IC5qcyBmaWxlcyBkaXJlY3RseSAtIGVkaXQgc3JjL2luZGV4LmpzdFxuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09ICdvYmplY3QnICYmIHR5cGVvZiBiID09ICdvYmplY3QnKSB7XG4gICAgaWYgKGEuY29uc3RydWN0b3IgIT09IGIuY29uc3RydWN0b3IpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBsZW5ndGgsIGksIGtleXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgICBpZiAoIWVxdWFsKGFbaV0sIGJbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cblxuXG4gICAgaWYgKGEuY29uc3RydWN0b3IgPT09IFJlZ0V4cCkgcmV0dXJuIGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmZsYWdzID09PSBiLmZsYWdzO1xuICAgIGlmIChhLnZhbHVlT2YgIT09IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZikgcmV0dXJuIGEudmFsdWVPZigpID09PSBiLnZhbHVlT2YoKTtcbiAgICBpZiAoYS50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykgcmV0dXJuIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpO1xuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwga2V5c1tpXSkpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmICghZXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyB0cnVlIGlmIGJvdGggTmFOLCBmYWxzZSBvdGhlcndpc2VcbiAgcmV0dXJuIGEhPT1hICYmIGIhPT1iO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRyYXZlcnNlID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2NoZW1hLCBvcHRzLCBjYikge1xuICAvLyBMZWdhY3kgc3VwcG9ydCBmb3IgdjAuMy4xIGFuZCBlYXJsaWVyLlxuICBpZiAodHlwZW9mIG9wdHMgPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cblxuICBjYiA9IG9wdHMuY2IgfHwgY2I7XG4gIHZhciBwcmUgPSAodHlwZW9mIGNiID09ICdmdW5jdGlvbicpID8gY2IgOiBjYi5wcmUgfHwgZnVuY3Rpb24oKSB7fTtcbiAgdmFyIHBvc3QgPSBjYi5wb3N0IHx8IGZ1bmN0aW9uKCkge307XG5cbiAgX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoZW1hLCAnJywgc2NoZW1hKTtcbn07XG5cblxudHJhdmVyc2Uua2V5d29yZHMgPSB7XG4gIGFkZGl0aW9uYWxJdGVtczogdHJ1ZSxcbiAgaXRlbXM6IHRydWUsXG4gIGNvbnRhaW5zOiB0cnVlLFxuICBhZGRpdGlvbmFsUHJvcGVydGllczogdHJ1ZSxcbiAgcHJvcGVydHlOYW1lczogdHJ1ZSxcbiAgbm90OiB0cnVlLFxuICBpZjogdHJ1ZSxcbiAgdGhlbjogdHJ1ZSxcbiAgZWxzZTogdHJ1ZVxufTtcblxudHJhdmVyc2UuYXJyYXlLZXl3b3JkcyA9IHtcbiAgaXRlbXM6IHRydWUsXG4gIGFsbE9mOiB0cnVlLFxuICBhbnlPZjogdHJ1ZSxcbiAgb25lT2Y6IHRydWVcbn07XG5cbnRyYXZlcnNlLnByb3BzS2V5d29yZHMgPSB7XG4gICRkZWZzOiB0cnVlLFxuICBkZWZpbml0aW9uczogdHJ1ZSxcbiAgcHJvcGVydGllczogdHJ1ZSxcbiAgcGF0dGVyblByb3BlcnRpZXM6IHRydWUsXG4gIGRlcGVuZGVuY2llczogdHJ1ZVxufTtcblxudHJhdmVyc2Uuc2tpcEtleXdvcmRzID0ge1xuICBkZWZhdWx0OiB0cnVlLFxuICBlbnVtOiB0cnVlLFxuICBjb25zdDogdHJ1ZSxcbiAgcmVxdWlyZWQ6IHRydWUsXG4gIG1heGltdW06IHRydWUsXG4gIG1pbmltdW06IHRydWUsXG4gIGV4Y2x1c2l2ZU1heGltdW06IHRydWUsXG4gIGV4Y2x1c2l2ZU1pbmltdW06IHRydWUsXG4gIG11bHRpcGxlT2Y6IHRydWUsXG4gIG1heExlbmd0aDogdHJ1ZSxcbiAgbWluTGVuZ3RoOiB0cnVlLFxuICBwYXR0ZXJuOiB0cnVlLFxuICBmb3JtYXQ6IHRydWUsXG4gIG1heEl0ZW1zOiB0cnVlLFxuICBtaW5JdGVtczogdHJ1ZSxcbiAgdW5pcXVlSXRlbXM6IHRydWUsXG4gIG1heFByb3BlcnRpZXM6IHRydWUsXG4gIG1pblByb3BlcnRpZXM6IHRydWVcbn07XG5cblxuZnVuY3Rpb24gX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoZW1hLCBqc29uUHRyLCByb290U2NoZW1hLCBwYXJlbnRKc29uUHRyLCBwYXJlbnRLZXl3b3JkLCBwYXJlbnRTY2hlbWEsIGtleUluZGV4KSB7XG4gIGlmIChzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYSA9PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgcHJlKHNjaGVtYSwganNvblB0ciwgcm9vdFNjaGVtYSwgcGFyZW50SnNvblB0ciwgcGFyZW50S2V5d29yZCwgcGFyZW50U2NoZW1hLCBrZXlJbmRleCk7XG4gICAgZm9yICh2YXIga2V5IGluIHNjaGVtYSkge1xuICAgICAgdmFyIHNjaCA9IHNjaGVtYVtrZXldO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoKSkge1xuICAgICAgICBpZiAoa2V5IGluIHRyYXZlcnNlLmFycmF5S2V5d29yZHMpIHtcbiAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8c2NoLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoW2ldLCBqc29uUHRyICsgJy8nICsga2V5ICsgJy8nICsgaSwgcm9vdFNjaGVtYSwganNvblB0ciwga2V5LCBzY2hlbWEsIGkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSBpbiB0cmF2ZXJzZS5wcm9wc0tleXdvcmRzKSB7XG4gICAgICAgIGlmIChzY2ggJiYgdHlwZW9mIHNjaCA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gc2NoKVxuICAgICAgICAgICAgX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoW3Byb3BdLCBqc29uUHRyICsgJy8nICsga2V5ICsgJy8nICsgZXNjYXBlSnNvblB0cihwcm9wKSwgcm9vdFNjaGVtYSwganNvblB0ciwga2V5LCBzY2hlbWEsIHByb3ApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSBpbiB0cmF2ZXJzZS5rZXl3b3JkcyB8fCAob3B0cy5hbGxLZXlzICYmICEoa2V5IGluIHRyYXZlcnNlLnNraXBLZXl3b3JkcykpKSB7XG4gICAgICAgIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaCwganNvblB0ciArICcvJyArIGtleSwgcm9vdFNjaGVtYSwganNvblB0ciwga2V5LCBzY2hlbWEpO1xuICAgICAgfVxuICAgIH1cbiAgICBwb3N0KHNjaGVtYSwganNvblB0ciwgcm9vdFNjaGVtYSwgcGFyZW50SnNvblB0ciwgcGFyZW50S2V5d29yZCwgcGFyZW50U2NoZW1hLCBrZXlJbmRleCk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBlc2NhcGVKc29uUHRyKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL34vZywgJ34wJykucmVwbGFjZSgvXFwvL2csICd+MScpO1xufVxuIiwiLyoqIEBsaWNlbnNlIFVSSS5qcyB2NC40LjEgKGMpIDIwMTEgR2FyeSBDb3VydC4gTGljZW5zZTogaHR0cDovL2dpdGh1Yi5jb20vZ2FyeWNvdXJ0L3VyaS1qcyAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgoZ2xvYmFsLlVSSSA9IGdsb2JhbC5VUkkgfHwge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG1lcmdlKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzZXRzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIHNldHNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgaWYgKHNldHMubGVuZ3RoID4gMSkge1xuICAgICAgICBzZXRzWzBdID0gc2V0c1swXS5zbGljZSgwLCAtMSk7XG4gICAgICAgIHZhciB4bCA9IHNldHMubGVuZ3RoIC0gMTtcbiAgICAgICAgZm9yICh2YXIgeCA9IDE7IHggPCB4bDsgKyt4KSB7XG4gICAgICAgICAgICBzZXRzW3hdID0gc2V0c1t4XS5zbGljZSgxLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0c1t4bF0gPSBzZXRzW3hsXS5zbGljZSgxKTtcbiAgICAgICAgcmV0dXJuIHNldHMuam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNldHNbMF07XG4gICAgfVxufVxuZnVuY3Rpb24gc3ViZXhwKHN0cikge1xuICAgIHJldHVybiBcIig/OlwiICsgc3RyICsgXCIpXCI7XG59XG5mdW5jdGlvbiB0eXBlT2Yobykge1xuICAgIHJldHVybiBvID09PSB1bmRlZmluZWQgPyBcInVuZGVmaW5lZFwiIDogbyA9PT0gbnVsbCA/IFwibnVsbFwiIDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNwbGl0KFwiIFwiKS5wb3AoKS5zcGxpdChcIl1cIikuc2hpZnQoKS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gdG9VcHBlckNhc2Uoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci50b1VwcGVyQ2FzZSgpO1xufVxuZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgICByZXR1cm4gb2JqICE9PSB1bmRlZmluZWQgJiYgb2JqICE9PSBudWxsID8gb2JqIGluc3RhbmNlb2YgQXJyYXkgPyBvYmogOiB0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gXCJudW1iZXJcIiB8fCBvYmouc3BsaXQgfHwgb2JqLnNldEludGVydmFsIHx8IG9iai5jYWxsID8gW29ial0gOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmopIDogW107XG59XG5mdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHtcbiAgICB2YXIgb2JqID0gdGFyZ2V0O1xuICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgb2JqW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBidWlsZEV4cHMoaXNJUkkpIHtcbiAgICB2YXIgQUxQSEEkJCA9IFwiW0EtWmEtel1cIixcbiAgICAgICAgQ1IkID0gXCJbXFxcXHgwRF1cIixcbiAgICAgICAgRElHSVQkJCA9IFwiWzAtOV1cIixcbiAgICAgICAgRFFVT1RFJCQgPSBcIltcXFxceDIyXVwiLFxuICAgICAgICBIRVhESUckJCA9IG1lcmdlKERJR0lUJCQsIFwiW0EtRmEtZl1cIiksXG4gICAgICAgIC8vY2FzZS1pbnNlbnNpdGl2ZVxuICAgIExGJCQgPSBcIltcXFxceDBBXVwiLFxuICAgICAgICBTUCQkID0gXCJbXFxcXHgyMF1cIixcbiAgICAgICAgUENUX0VOQ09ERUQkID0gc3ViZXhwKHN1YmV4cChcIiVbRUZlZl1cIiArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSArIFwifFwiICsgc3ViZXhwKFwiJVs4OUEtRmEtZl1cIiArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSArIFwifFwiICsgc3ViZXhwKFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkpLFxuICAgICAgICAvL2V4cGFuZGVkXG4gICAgR0VOX0RFTElNUyQkID0gXCJbXFxcXDpcXFxcL1xcXFw/XFxcXCNcXFxcW1xcXFxdXFxcXEBdXCIsXG4gICAgICAgIFNVQl9ERUxJTVMkJCA9IFwiW1xcXFwhXFxcXCRcXFxcJlxcXFwnXFxcXChcXFxcKVxcXFwqXFxcXCtcXFxcLFxcXFw7XFxcXD1dXCIsXG4gICAgICAgIFJFU0VSVkVEJCQgPSBtZXJnZShHRU5fREVMSU1TJCQsIFNVQl9ERUxJTVMkJCksXG4gICAgICAgIFVDU0NIQVIkJCA9IGlzSVJJID8gXCJbXFxcXHhBMC1cXFxcdTIwMERcXFxcdTIwMTAtXFxcXHUyMDI5XFxcXHUyMDJGLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXVwiIDogXCJbXVwiLFxuICAgICAgICAvL3N1YnNldCwgZXhjbHVkZXMgYmlkaSBjb250cm9sIGNoYXJhY3RlcnNcbiAgICBJUFJJVkFURSQkID0gaXNJUkkgPyBcIltcXFxcdUUwMDAtXFxcXHVGOEZGXVwiIDogXCJbXVwiLFxuICAgICAgICAvL3N1YnNldFxuICAgIFVOUkVTRVJWRUQkJCA9IG1lcmdlKEFMUEhBJCQsIERJR0lUJCQsIFwiW1xcXFwtXFxcXC5cXFxcX1xcXFx+XVwiLCBVQ1NDSEFSJCQpLFxuICAgICAgICBTQ0hFTUUkID0gc3ViZXhwKEFMUEhBJCQgKyBtZXJnZShBTFBIQSQkLCBESUdJVCQkLCBcIltcXFxcK1xcXFwtXFxcXC5dXCIpICsgXCIqXCIpLFxuICAgICAgICBVU0VSSU5GTyQgPSBzdWJleHAoc3ViZXhwKFBDVF9FTkNPREVEJCArIFwifFwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XVwiKSkgKyBcIipcIiksXG4gICAgICAgIERFQ19PQ1RFVCQgPSBzdWJleHAoc3ViZXhwKFwiMjVbMC01XVwiKSArIFwifFwiICsgc3ViZXhwKFwiMlswLTRdXCIgKyBESUdJVCQkKSArIFwifFwiICsgc3ViZXhwKFwiMVwiICsgRElHSVQkJCArIERJR0lUJCQpICsgXCJ8XCIgKyBzdWJleHAoXCJbMS05XVwiICsgRElHSVQkJCkgKyBcInxcIiArIERJR0lUJCQpLFxuICAgICAgICBERUNfT0NURVRfUkVMQVhFRCQgPSBzdWJleHAoc3ViZXhwKFwiMjVbMC01XVwiKSArIFwifFwiICsgc3ViZXhwKFwiMlswLTRdXCIgKyBESUdJVCQkKSArIFwifFwiICsgc3ViZXhwKFwiMVwiICsgRElHSVQkJCArIERJR0lUJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIwP1sxLTldXCIgKyBESUdJVCQkKSArIFwifDA/MD9cIiArIERJR0lUJCQpLFxuICAgICAgICAvL3JlbGF4ZWQgcGFyc2luZyBydWxlc1xuICAgIElQVjRBRERSRVNTJCA9IHN1YmV4cChERUNfT0NURVRfUkVMQVhFRCQgKyBcIlxcXFwuXCIgKyBERUNfT0NURVRfUkVMQVhFRCQgKyBcIlxcXFwuXCIgKyBERUNfT0NURVRfUkVMQVhFRCQgKyBcIlxcXFwuXCIgKyBERUNfT0NURVRfUkVMQVhFRCQpLFxuICAgICAgICBIMTYkID0gc3ViZXhwKEhFWERJRyQkICsgXCJ7MSw0fVwiKSxcbiAgICAgICAgTFMzMiQgPSBzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIgKyBIMTYkKSArIFwifFwiICsgSVBWNEFERFJFU1MkKSxcbiAgICAgICAgSVBWNkFERFJFU1MxJCA9IHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcIns2fVwiICsgTFMzMiQpLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgIDYoIGgxNiBcIjpcIiApIGxzMzJcbiAgICBJUFY2QUREUkVTUzIkID0gc3ViZXhwKFwiXFxcXDpcXFxcOlwiICsgc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7NX1cIiArIExTMzIkKSxcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgXCI6OlwiIDUoIGgxNiBcIjpcIiApIGxzMzJcbiAgICBJUFY2QUREUkVTUzMkID0gc3ViZXhwKHN1YmV4cChIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezR9XCIgKyBMUzMyJCksXG4gICAgICAgIC8vWyAgICAgICAgICAgICAgIGgxNiBdIFwiOjpcIiA0KCBoMTYgXCI6XCIgKSBsczMyXG4gICAgSVBWNkFERFJFU1M0JCA9IHN1YmV4cChzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7MCwxfVwiICsgSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgKyBzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInszfVwiICsgTFMzMiQpLFxuICAgICAgICAvL1sgKjEoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAzKCBoMTYgXCI6XCIgKSBsczMyXG4gICAgSVBWNkFERFJFU1M1JCA9IHN1YmV4cChzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7MCwyfVwiICsgSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgKyBzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInsyfVwiICsgTFMzMiQpLFxuICAgICAgICAvL1sgKjIoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAyKCBoMTYgXCI6XCIgKSBsczMyXG4gICAgSVBWNkFERFJFU1M2JCA9IHN1YmV4cChzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7MCwzfVwiICsgSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgKyBIMTYkICsgXCJcXFxcOlwiICsgTFMzMiQpLFxuICAgICAgICAvL1sgKjMoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAgICBoMTYgXCI6XCIgICBsczMyXG4gICAgSVBWNkFERFJFU1M3JCA9IHN1YmV4cChzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7MCw0fVwiICsgSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgKyBMUzMyJCksXG4gICAgICAgIC8vWyAqNCggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiICAgICAgICAgICAgICBsczMyXG4gICAgSVBWNkFERFJFU1M4JCA9IHN1YmV4cChzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7MCw1fVwiICsgSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgKyBIMTYkKSxcbiAgICAgICAgLy9bICo1KCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgICAgICAgICAgICAgIGgxNlxuICAgIElQVjZBRERSRVNTOSQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsNn1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiKSxcbiAgICAgICAgLy9bICo2KCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCJcbiAgICBJUFY2QUREUkVTUyQgPSBzdWJleHAoW0lQVjZBRERSRVNTMSQsIElQVjZBRERSRVNTMiQsIElQVjZBRERSRVNTMyQsIElQVjZBRERSRVNTNCQsIElQVjZBRERSRVNTNSQsIElQVjZBRERSRVNTNiQsIElQVjZBRERSRVNTNyQsIElQVjZBRERSRVNTOCQsIElQVjZBRERSRVNTOSRdLmpvaW4oXCJ8XCIpKSxcbiAgICAgICAgWk9ORUlEJCA9IHN1YmV4cChzdWJleHAoVU5SRVNFUlZFRCQkICsgXCJ8XCIgKyBQQ1RfRU5DT0RFRCQpICsgXCIrXCIpLFxuICAgICAgICAvL1JGQyA2ODc0XG4gICAgSVBWNkFERFJaJCA9IHN1YmV4cChJUFY2QUREUkVTUyQgKyBcIlxcXFwlMjVcIiArIFpPTkVJRCQpLFxuICAgICAgICAvL1JGQyA2ODc0XG4gICAgSVBWNkFERFJaX1JFTEFYRUQkID0gc3ViZXhwKElQVjZBRERSRVNTJCArIHN1YmV4cChcIlxcXFwlMjV8XFxcXCUoPyFcIiArIEhFWERJRyQkICsgXCJ7Mn0pXCIpICsgWk9ORUlEJCksXG4gICAgICAgIC8vUkZDIDY4NzQsIHdpdGggcmVsYXhlZCBwYXJzaW5nIHJ1bGVzXG4gICAgSVBWRlVUVVJFJCA9IHN1YmV4cChcIlt2Vl1cIiArIEhFWERJRyQkICsgXCIrXFxcXC5cIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOl1cIikgKyBcIitcIiksXG4gICAgICAgIElQX0xJVEVSQUwkID0gc3ViZXhwKFwiXFxcXFtcIiArIHN1YmV4cChJUFY2QUREUlpfUkVMQVhFRCQgKyBcInxcIiArIElQVjZBRERSRVNTJCArIFwifFwiICsgSVBWRlVUVVJFJCkgKyBcIlxcXFxdXCIpLFxuICAgICAgICAvL1JGQyA2ODc0XG4gICAgUkVHX05BTUUkID0gc3ViZXhwKHN1YmV4cChQQ1RfRU5DT0RFRCQgKyBcInxcIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSkgKyBcIipcIiksXG4gICAgICAgIEhPU1QkID0gc3ViZXhwKElQX0xJVEVSQUwkICsgXCJ8XCIgKyBJUFY0QUREUkVTUyQgKyBcIig/IVwiICsgUkVHX05BTUUkICsgXCIpXCIgKyBcInxcIiArIFJFR19OQU1FJCksXG4gICAgICAgIFBPUlQkID0gc3ViZXhwKERJR0lUJCQgKyBcIipcIiksXG4gICAgICAgIEFVVEhPUklUWSQgPSBzdWJleHAoc3ViZXhwKFVTRVJJTkZPJCArIFwiQFwiKSArIFwiP1wiICsgSE9TVCQgKyBzdWJleHAoXCJcXFxcOlwiICsgUE9SVCQpICsgXCI/XCIpLFxuICAgICAgICBQQ0hBUiQgPSBzdWJleHAoUENUX0VOQ09ERUQkICsgXCJ8XCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpcXFxcQF1cIikpLFxuICAgICAgICBTRUdNRU5UJCA9IHN1YmV4cChQQ0hBUiQgKyBcIipcIiksXG4gICAgICAgIFNFR01FTlRfTlokID0gc3ViZXhwKFBDSEFSJCArIFwiK1wiKSxcbiAgICAgICAgU0VHTUVOVF9OWl9OQyQgPSBzdWJleHAoc3ViZXhwKFBDVF9FTkNPREVEJCArIFwifFwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFxAXVwiKSkgKyBcIitcIiksXG4gICAgICAgIFBBVEhfQUJFTVBUWSQgPSBzdWJleHAoc3ViZXhwKFwiXFxcXC9cIiArIFNFR01FTlQkKSArIFwiKlwiKSxcbiAgICAgICAgUEFUSF9BQlNPTFVURSQgPSBzdWJleHAoXCJcXFxcL1wiICsgc3ViZXhwKFNFR01FTlRfTlokICsgUEFUSF9BQkVNUFRZJCkgKyBcIj9cIiksXG4gICAgICAgIC8vc2ltcGxpZmllZFxuICAgIFBBVEhfTk9TQ0hFTUUkID0gc3ViZXhwKFNFR01FTlRfTlpfTkMkICsgUEFUSF9BQkVNUFRZJCksXG4gICAgICAgIC8vc2ltcGxpZmllZFxuICAgIFBBVEhfUk9PVExFU1MkID0gc3ViZXhwKFNFR01FTlRfTlokICsgUEFUSF9BQkVNUFRZJCksXG4gICAgICAgIC8vc2ltcGxpZmllZFxuICAgIFBBVEhfRU1QVFkkID0gXCIoPyFcIiArIFBDSEFSJCArIFwiKVwiLFxuICAgICAgICBQQVRIJCA9IHN1YmV4cChQQVRIX0FCRU1QVFkkICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9OT1NDSEVNRSQgKyBcInxcIiArIFBBVEhfUk9PVExFU1MkICsgXCJ8XCIgKyBQQVRIX0VNUFRZJCksXG4gICAgICAgIFFVRVJZJCA9IHN1YmV4cChzdWJleHAoUENIQVIkICsgXCJ8XCIgKyBtZXJnZShcIltcXFxcL1xcXFw/XVwiLCBJUFJJVkFURSQkKSkgKyBcIipcIiksXG4gICAgICAgIEZSQUdNRU5UJCA9IHN1YmV4cChzdWJleHAoUENIQVIkICsgXCJ8W1xcXFwvXFxcXD9dXCIpICsgXCIqXCIpLFxuICAgICAgICBISUVSX1BBUlQkID0gc3ViZXhwKHN1YmV4cChcIlxcXFwvXFxcXC9cIiArIEFVVEhPUklUWSQgKyBQQVRIX0FCRU1QVFkkKSArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfUk9PVExFU1MkICsgXCJ8XCIgKyBQQVRIX0VNUFRZJCksXG4gICAgICAgIFVSSSQgPSBzdWJleHAoU0NIRU1FJCArIFwiXFxcXDpcIiArIEhJRVJfUEFSVCQgKyBzdWJleHAoXCJcXFxcP1wiICsgUVVFUlkkKSArIFwiP1wiICsgc3ViZXhwKFwiXFxcXCNcIiArIEZSQUdNRU5UJCkgKyBcIj9cIiksXG4gICAgICAgIFJFTEFUSVZFX1BBUlQkID0gc3ViZXhwKHN1YmV4cChcIlxcXFwvXFxcXC9cIiArIEFVVEhPUklUWSQgKyBQQVRIX0FCRU1QVFkkKSArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfTk9TQ0hFTUUkICsgXCJ8XCIgKyBQQVRIX0VNUFRZJCksXG4gICAgICAgIFJFTEFUSVZFJCA9IHN1YmV4cChSRUxBVElWRV9QQVJUJCArIHN1YmV4cChcIlxcXFw/XCIgKyBRVUVSWSQpICsgXCI/XCIgKyBzdWJleHAoXCJcXFxcI1wiICsgRlJBR01FTlQkKSArIFwiP1wiKSxcbiAgICAgICAgVVJJX1JFRkVSRU5DRSQgPSBzdWJleHAoVVJJJCArIFwifFwiICsgUkVMQVRJVkUkKSxcbiAgICAgICAgQUJTT0xVVEVfVVJJJCA9IHN1YmV4cChTQ0hFTUUkICsgXCJcXFxcOlwiICsgSElFUl9QQVJUJCArIHN1YmV4cChcIlxcXFw/XCIgKyBRVUVSWSQpICsgXCI/XCIpLFxuICAgICAgICBHRU5FUklDX1JFRiQgPSBcIl4oXCIgKyBTQ0hFTUUkICsgXCIpXFxcXDpcIiArIHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvKFwiICsgc3ViZXhwKFwiKFwiICsgVVNFUklORk8kICsgXCIpQFwiKSArIFwiPyhcIiArIEhPU1QkICsgXCIpXCIgKyBzdWJleHAoXCJcXFxcOihcIiArIFBPUlQkICsgXCIpXCIpICsgXCI/KVwiKSArIFwiPyhcIiArIFBBVEhfQUJFTVBUWSQgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX1JPT1RMRVNTJCArIFwifFwiICsgUEFUSF9FTVBUWSQgKyBcIilcIikgKyBzdWJleHAoXCJcXFxcPyhcIiArIFFVRVJZJCArIFwiKVwiKSArIFwiP1wiICsgc3ViZXhwKFwiXFxcXCMoXCIgKyBGUkFHTUVOVCQgKyBcIilcIikgKyBcIj8kXCIsXG4gICAgICAgIFJFTEFUSVZFX1JFRiQgPSBcIl4oKXswfVwiICsgc3ViZXhwKHN1YmV4cChcIlxcXFwvXFxcXC8oXCIgKyBzdWJleHAoXCIoXCIgKyBVU0VSSU5GTyQgKyBcIilAXCIpICsgXCI/KFwiICsgSE9TVCQgKyBcIilcIiArIHN1YmV4cChcIlxcXFw6KFwiICsgUE9SVCQgKyBcIilcIikgKyBcIj8pXCIpICsgXCI/KFwiICsgUEFUSF9BQkVNUFRZJCArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfTk9TQ0hFTUUkICsgXCJ8XCIgKyBQQVRIX0VNUFRZJCArIFwiKVwiKSArIHN1YmV4cChcIlxcXFw/KFwiICsgUVVFUlkkICsgXCIpXCIpICsgXCI/XCIgKyBzdWJleHAoXCJcXFxcIyhcIiArIEZSQUdNRU5UJCArIFwiKVwiKSArIFwiPyRcIixcbiAgICAgICAgQUJTT0xVVEVfUkVGJCA9IFwiXihcIiArIFNDSEVNRSQgKyBcIilcXFxcOlwiICsgc3ViZXhwKHN1YmV4cChcIlxcXFwvXFxcXC8oXCIgKyBzdWJleHAoXCIoXCIgKyBVU0VSSU5GTyQgKyBcIilAXCIpICsgXCI/KFwiICsgSE9TVCQgKyBcIilcIiArIHN1YmV4cChcIlxcXFw6KFwiICsgUE9SVCQgKyBcIilcIikgKyBcIj8pXCIpICsgXCI/KFwiICsgUEFUSF9BQkVNUFRZJCArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfUk9PVExFU1MkICsgXCJ8XCIgKyBQQVRIX0VNUFRZJCArIFwiKVwiKSArIHN1YmV4cChcIlxcXFw/KFwiICsgUVVFUlkkICsgXCIpXCIpICsgXCI/JFwiLFxuICAgICAgICBTQU1FRE9DX1JFRiQgPSBcIl5cIiArIHN1YmV4cChcIlxcXFwjKFwiICsgRlJBR01FTlQkICsgXCIpXCIpICsgXCI/JFwiLFxuICAgICAgICBBVVRIT1JJVFlfUkVGJCA9IFwiXlwiICsgc3ViZXhwKFwiKFwiICsgVVNFUklORk8kICsgXCIpQFwiKSArIFwiPyhcIiArIEhPU1QkICsgXCIpXCIgKyBzdWJleHAoXCJcXFxcOihcIiArIFBPUlQkICsgXCIpXCIpICsgXCI/JFwiO1xuICAgIHJldHVybiB7XG4gICAgICAgIE5PVF9TQ0hFTUU6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXl1cIiwgQUxQSEEkJCwgRElHSVQkJCwgXCJbXFxcXCtcXFxcLVxcXFwuXVwiKSwgXCJnXCIpLFxuICAgICAgICBOT1RfVVNFUklORk86IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXFxcXDpdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxuICAgICAgICBOT1RfSE9TVDogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVcXFxcW1xcXFxdXFxcXDpdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxuICAgICAgICBOT1RfUEFUSDogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVcXFxcL1xcXFw6XFxcXEBdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxuICAgICAgICBOT1RfUEFUSF9OT1NDSEVNRTogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVcXFxcL1xcXFxAXVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcbiAgICAgICAgTk9UX1FVRVJZOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJV1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XFxcXEBcXFxcL1xcXFw/XVwiLCBJUFJJVkFURSQkKSwgXCJnXCIpLFxuICAgICAgICBOT1RfRlJBR01FTlQ6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpcXFxcQFxcXFwvXFxcXD9dXCIpLCBcImdcIiksXG4gICAgICAgIEVTQ0FQRTogbmV3IFJlZ0V4cChtZXJnZShcIlteXVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcbiAgICAgICAgVU5SRVNFUlZFRDogbmV3IFJlZ0V4cChVTlJFU0VSVkVEJCQsIFwiZ1wiKSxcbiAgICAgICAgT1RIRVJfQ0hBUlM6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXVwiLCBVTlJFU0VSVkVEJCQsIFJFU0VSVkVEJCQpLCBcImdcIiksXG4gICAgICAgIFBDVF9FTkNPREVEOiBuZXcgUmVnRXhwKFBDVF9FTkNPREVEJCwgXCJnXCIpLFxuICAgICAgICBJUFY0QUREUkVTUzogbmV3IFJlZ0V4cChcIl4oXCIgKyBJUFY0QUREUkVTUyQgKyBcIikkXCIpLFxuICAgICAgICBJUFY2QUREUkVTUzogbmV3IFJlZ0V4cChcIl5cXFxcWz8oXCIgKyBJUFY2QUREUkVTUyQgKyBcIilcIiArIHN1YmV4cChzdWJleHAoXCJcXFxcJTI1fFxcXFwlKD8hXCIgKyBIRVhESUckJCArIFwiezJ9KVwiKSArIFwiKFwiICsgWk9ORUlEJCArIFwiKVwiKSArIFwiP1xcXFxdPyRcIikgLy9SRkMgNjg3NCwgd2l0aCByZWxheGVkIHBhcnNpbmcgcnVsZXNcbiAgICB9O1xufVxudmFyIFVSSV9QUk9UT0NPTCA9IGJ1aWxkRXhwcyhmYWxzZSk7XG5cbnZhciBJUklfUFJPVE9DT0wgPSBidWlsZEV4cHModHJ1ZSk7XG5cbnZhciBzbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkge1xuICAgIHZhciBfYXJyID0gW107XG4gICAgdmFyIF9uID0gdHJ1ZTtcbiAgICB2YXIgX2QgPSBmYWxzZTtcbiAgICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kID0gdHJ1ZTtcbiAgICAgIF9lID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX2FycjtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkge1xuICAgICAgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gICAgfVxuICB9O1xufSgpO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgdG9Db25zdW1hYmxlQXJyYXkgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gICAgcmV0dXJuIGFycjI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oYXJyKTtcbiAgfVxufTtcblxuLyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXG52YXIgbWF4SW50ID0gMjE0NzQ4MzY0NzsgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG4vKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG52YXIgYmFzZSA9IDM2O1xudmFyIHRNaW4gPSAxO1xudmFyIHRNYXggPSAyNjtcbnZhciBza2V3ID0gMzg7XG52YXIgZGFtcCA9IDcwMDtcbnZhciBpbml0aWFsQmlhcyA9IDcyO1xudmFyIGluaXRpYWxOID0gMTI4OyAvLyAweDgwXG52YXIgZGVsaW1pdGVyID0gJy0nOyAvLyAnXFx4MkQnXG5cbi8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG52YXIgcmVnZXhQdW55Y29kZSA9IC9eeG4tLS87XG52YXIgcmVnZXhOb25BU0NJSSA9IC9bXlxcMC1cXHg3RV0vOyAvLyBub24tQVNDSUkgY2hhcnNcbnZhciByZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nOyAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cbi8qKiBFcnJvciBtZXNzYWdlcyAqL1xudmFyIGVycm9ycyA9IHtcblx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcbn07XG5cbi8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cbnZhciBiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW47XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4vKipcbiAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBlcnJvciQxKHR5cGUpIHtcblx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcbn1cblxuLyoqXG4gKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG4gKiBpdGVtLlxuICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdHZhciByZXN1bHQgPSBbXTtcblx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuICogYWRkcmVzc2VzLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcbiAqIGNoYXJhY3Rlci5cbiAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG4gKiBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdHZhciByZXN1bHQgPSAnJztcblx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0fVxuXHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG4gKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG4gKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG4gKiBtYXRjaGluZyBVVEYtMTYuXG4gKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcbiAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcbiAqIEBuYW1lIGRlY29kZVxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cbiAqL1xuZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0dmFyIG91dHB1dCA9IFtdO1xuXHR2YXIgY291bnRlciA9IDA7XG5cdHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdHZhciB2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0Ly8gSXQncyBhIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3Rlci5cblx0XHRcdHZhciBleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHtcblx0XHRcdFx0Ly8gTG93IHN1cnJvZ2F0ZS5cblx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEl0J3MgYW4gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlXG5cdFx0XHRcdC8vIG5leHQgY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyLlxuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gb3V0cHV0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cbiAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcbiAqIEBuYW1lIGVuY29kZVxuICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cbiAqL1xudmFyIHVjczJlbmNvZGUgPSBmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludC5hcHBseShTdHJpbmcsIHRvQ29uc3VtYWJsZUFycmF5KGFycmF5KSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cbiAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG4gKi9cbnZhciBiYXNpY1RvRGlnaXQgPSBmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdGlmIChjb2RlUG9pbnQgLSAweDMwIDwgMHgwQSkge1xuXHRcdHJldHVybiBjb2RlUG9pbnQgLSAweDE2O1xuXHR9XG5cdGlmIChjb2RlUG9pbnQgLSAweDQxIDwgMHgxQSkge1xuXHRcdHJldHVybiBjb2RlUG9pbnQgLSAweDQxO1xuXHR9XG5cdGlmIChjb2RlUG9pbnQgLSAweDYxIDwgMHgxQSkge1xuXHRcdHJldHVybiBjb2RlUG9pbnQgLSAweDYxO1xuXHR9XG5cdHJldHVybiBiYXNlO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG4gKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3JcbiAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG4gKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcbiAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG4gKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuICovXG52YXIgZGlnaXRUb0Jhc2ljID0gZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xufTtcblxuLyoqXG4gKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBhZGFwdCA9IGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHR2YXIgayA9IDA7XG5cdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0Zm9yICg7IC8qIG5vIGluaXRpYWxpemF0aW9uICovZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdH1cblx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG4gKiBzeW1ib2xzLlxuICogQG1lbWJlck9mIHB1bnljb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG4gKi9cbnZhciBkZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0Ly8gRG9uJ3QgdXNlIFVDUy0yLlxuXHR2YXIgb3V0cHV0ID0gW107XG5cdHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblx0dmFyIGkgPSAwO1xuXHR2YXIgbiA9IGluaXRpYWxOO1xuXHR2YXIgYmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHR2YXIgYmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0YmFzaWMgPSAwO1xuXHR9XG5cblx0Zm9yICh2YXIgaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0ZXJyb3IkMSgnbm90LWJhc2ljJyk7XG5cdFx0fVxuXHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHR9XG5cblx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdGZvciAodmFyIGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDspIC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi97XG5cblx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdHZhciBvbGRpID0gaTtcblx0XHRmb3IgKHZhciB3ID0gMSwgayA9IGJhc2U7OyAvKiBubyBjb25kaXRpb24gKi9rICs9IGJhc2UpIHtcblxuXHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdGVycm9yJDEoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdGVycm9yJDEoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0dmFyIHQgPSBrIDw9IGJpYXMgPyB0TWluIDogayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcztcblxuXHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0dmFyIGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0ZXJyb3IkMSgnb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXHRcdH1cblxuXHRcdHZhciBvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRlcnJvciQxKCdvdmVyZmxvdycpO1xuXHRcdH1cblxuXHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0aSAlPSBvdXQ7XG5cblx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0LlxuXHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblx0fVxuXG5cdHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludC5hcHBseShTdHJpbmcsIG91dHB1dCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG4gKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICogQG1lbWJlck9mIHB1bnljb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG4gKi9cbnZhciBlbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0dmFyIG91dHB1dCA9IFtdO1xuXG5cdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIGFuIGFycmF5IG9mIFVuaWNvZGUgY29kZSBwb2ludHMuXG5cdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0Ly8gQ2FjaGUgdGhlIGxlbmd0aC5cblx0dmFyIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlLlxuXHR2YXIgbiA9IGluaXRpYWxOO1xuXHR2YXIgZGVsdGEgPSAwO1xuXHR2YXIgYmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHMuXG5cdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcblx0dmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG5cdHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuXHR0cnkge1xuXHRcdGZvciAodmFyIF9pdGVyYXRvciA9IGlucHV0W1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuXHRcdFx0dmFyIF9jdXJyZW50VmFsdWUyID0gX3N0ZXAudmFsdWU7XG5cblx0XHRcdGlmIChfY3VycmVudFZhbHVlMiA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKF9jdXJyZW50VmFsdWUyKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGNhdGNoIChlcnIpIHtcblx0XHRfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG5cdFx0X2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG5cdH0gZmluYWxseSB7XG5cdFx0dHJ5IHtcblx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG5cdFx0XHRcdF9pdGVyYXRvci5yZXR1cm4oKTtcblx0XHRcdH1cblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG5cdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHZhciBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cdHZhciBoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoO1xuXG5cdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgd2l0aCBhIGRlbGltaXRlciB1bmxlc3MgaXQncyBlbXB0eS5cblx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0fVxuXG5cdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdHZhciBtID0gbWF4SW50O1xuXHRcdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG5cdFx0dmFyIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlO1xuXHRcdHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7XG5cblx0XHR0cnkge1xuXHRcdFx0Zm9yICh2YXIgX2l0ZXJhdG9yMiA9IGlucHV0W1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7XG5cdFx0XHRcdHZhciBjdXJyZW50VmFsdWUgPSBfc3RlcDIudmFsdWU7XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93LlxuXHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0X2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTtcblx0XHRcdF9pdGVyYXRvckVycm9yMiA9IGVycjtcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyLnJldHVybikge1xuXHRcdFx0XHRcdF9pdGVyYXRvcjIucmV0dXJuKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHtcblx0XHRcdFx0XHR0aHJvdyBfaXRlcmF0b3JFcnJvcjI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgaGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRlcnJvciQxKCdvdmVyZmxvdycpO1xuXHRcdH1cblxuXHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0biA9IG07XG5cblx0XHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlO1xuXHRcdHZhciBfZGlkSXRlcmF0b3JFcnJvcjMgPSBmYWxzZTtcblx0XHR2YXIgX2l0ZXJhdG9yRXJyb3IzID0gdW5kZWZpbmVkO1xuXG5cdFx0dHJ5IHtcblx0XHRcdGZvciAodmFyIF9pdGVyYXRvcjMgPSBpbnB1dFtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IChfc3RlcDMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZSkge1xuXHRcdFx0XHR2YXIgX2N1cnJlbnRWYWx1ZSA9IF9zdGVwMy52YWx1ZTtcblxuXHRcdFx0XHRpZiAoX2N1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yJDEoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKF9jdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLlxuXHRcdFx0XHRcdHZhciBxID0gZGVsdGE7XG5cdFx0XHRcdFx0Zm9yICh2YXIgayA9IGJhc2U7OyAvKiBubyBjb25kaXRpb24gKi9rICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHZhciB0ID0gayA8PSBiaWFzID8gdE1pbiA6IGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXM7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR2YXIgcU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0dmFyIGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSkpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0X2RpZEl0ZXJhdG9yRXJyb3IzID0gdHJ1ZTtcblx0XHRcdF9pdGVyYXRvckVycm9yMyA9IGVycjtcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyAmJiBfaXRlcmF0b3IzLnJldHVybikge1xuXHRcdFx0XHRcdF9pdGVyYXRvcjMucmV0dXJuKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcjMpIHtcblx0XHRcdFx0XHR0aHJvdyBfaXRlcmF0b3JFcnJvcjM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQrK2RlbHRhO1xuXHRcdCsrbjtcblx0fVxuXHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG4gKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG4gKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cbiAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuICogQG1lbWJlck9mIHB1bnljb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG4gKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcbiAqIHN0cmluZy5cbiAqL1xudmFyIHRvVW5pY29kZSA9IGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpID8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKSA6IHN0cmluZztcblx0fSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG4gKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cbiAqIEFTQ0lJLlxuICogQG1lbWJlck9mIHB1bnljb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuICogVW5pY29kZSBzdHJpbmcuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG4gKiBlbWFpbCBhZGRyZXNzLlxuICovXG52YXIgdG9BU0NJSSA9IGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24gKHN0cmluZykge1xuXHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKSA/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpIDogc3RyaW5nO1xuXHR9KTtcbn07XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4vKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG52YXIgcHVueWNvZGUgPSB7XG5cdC8qKlxuICAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cbiAgKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAgKiBAdHlwZSBTdHJpbmdcbiAgKi9cblx0J3ZlcnNpb24nOiAnMi4xLjAnLFxuXHQvKipcbiAgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuICAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG4gICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG4gICogQG1lbWJlck9mIHB1bnljb2RlXG4gICogQHR5cGUgT2JqZWN0XG4gICovXG5cdCd1Y3MyJzoge1xuXHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdH0sXG5cdCdkZWNvZGUnOiBkZWNvZGUsXG5cdCdlbmNvZGUnOiBlbmNvZGUsXG5cdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxufTtcblxuLyoqXG4gKiBVUkkuanNcbiAqXG4gKiBAZmlsZW92ZXJ2aWV3IEFuIFJGQyAzOTg2IGNvbXBsaWFudCwgc2NoZW1lIGV4dGVuZGFibGUgVVJJIHBhcnNpbmcvdmFsaWRhdGluZy9yZXNvbHZpbmcgbGlicmFyeSBmb3IgSmF2YVNjcmlwdC5cbiAqIEBhdXRob3IgPGEgaHJlZj1cIm1haWx0bzpnYXJ5LmNvdXJ0QGdtYWlsLmNvbVwiPkdhcnkgQ291cnQ8L2E+XG4gKiBAc2VlIGh0dHA6Ly9naXRodWIuY29tL2dhcnljb3VydC91cmktanNcbiAqL1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMSBHYXJ5IENvdXJ0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sIGFyZVxuICogcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKlxuICogICAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2ZcbiAqICAgICAgIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAgICAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdFxuICogICAgICAgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHNcbiAqICAgICAgIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIEdBUlkgQ09VUlQgYGBBUyBJUycnIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEXG4gKiBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgR0FSWSBDT1VSVCBPUlxuICogQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcbiAqIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1JcbiAqIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cbiAqIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRlxuICogQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKlxuICogVGhlIHZpZXdzIGFuZCBjb25jbHVzaW9ucyBjb250YWluZWQgaW4gdGhlIHNvZnR3YXJlIGFuZCBkb2N1bWVudGF0aW9uIGFyZSB0aG9zZSBvZiB0aGVcbiAqIGF1dGhvcnMgYW5kIHNob3VsZCBub3QgYmUgaW50ZXJwcmV0ZWQgYXMgcmVwcmVzZW50aW5nIG9mZmljaWFsIHBvbGljaWVzLCBlaXRoZXIgZXhwcmVzc2VkXG4gKiBvciBpbXBsaWVkLCBvZiBHYXJ5IENvdXJ0LlxuICovXG52YXIgU0NIRU1FUyA9IHt9O1xuZnVuY3Rpb24gcGN0RW5jQ2hhcihjaHIpIHtcbiAgICB2YXIgYyA9IGNoci5jaGFyQ29kZUF0KDApO1xuICAgIHZhciBlID0gdm9pZCAwO1xuICAgIGlmIChjIDwgMTYpIGUgPSBcIiUwXCIgKyBjLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO2Vsc2UgaWYgKGMgPCAxMjgpIGUgPSBcIiVcIiArIGMudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7ZWxzZSBpZiAoYyA8IDIwNDgpIGUgPSBcIiVcIiArIChjID4+IDYgfCAxOTIpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgXCIlXCIgKyAoYyAmIDYzIHwgMTI4KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtlbHNlIGUgPSBcIiVcIiArIChjID4+IDEyIHwgMjI0KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArIFwiJVwiICsgKGMgPj4gNiAmIDYzIHwgMTI4KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArIFwiJVwiICsgKGMgJiA2MyB8IDEyOCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBwY3REZWNDaGFycyhzdHIpIHtcbiAgICB2YXIgbmV3U3RyID0gXCJcIjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGlsID0gc3RyLmxlbmd0aDtcbiAgICB3aGlsZSAoaSA8IGlsKSB7XG4gICAgICAgIHZhciBjID0gcGFyc2VJbnQoc3RyLnN1YnN0cihpICsgMSwgMiksIDE2KTtcbiAgICAgICAgaWYgKGMgPCAxMjgpIHtcbiAgICAgICAgICAgIG5ld1N0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgICAgICAgICAgaSArPSAzO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPj0gMTk0ICYmIGMgPCAyMjQpIHtcbiAgICAgICAgICAgIGlmIChpbCAtIGkgPj0gNikge1xuICAgICAgICAgICAgICAgIHZhciBjMiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSArIDQsIDIpLCAxNik7XG4gICAgICAgICAgICAgICAgbmV3U3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgJiAzMSkgPDwgNiB8IGMyICYgNjMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdTdHIgKz0gc3RyLnN1YnN0cihpLCA2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkgKz0gNjtcbiAgICAgICAgfSBlbHNlIGlmIChjID49IDIyNCkge1xuICAgICAgICAgICAgaWYgKGlsIC0gaSA+PSA5KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9jID0gcGFyc2VJbnQoc3RyLnN1YnN0cihpICsgNCwgMiksIDE2KTtcbiAgICAgICAgICAgICAgICB2YXIgYzMgPSBwYXJzZUludChzdHIuc3Vic3RyKGkgKyA3LCAyKSwgMTYpO1xuICAgICAgICAgICAgICAgIG5ld1N0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgMTUpIDw8IDEyIHwgKF9jICYgNjMpIDw8IDYgfCBjMyAmIDYzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3U3RyICs9IHN0ci5zdWJzdHIoaSwgOSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpICs9IDk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdTdHIgKz0gc3RyLnN1YnN0cihpLCAzKTtcbiAgICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3U3RyO1xufVxuZnVuY3Rpb24gX25vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKGNvbXBvbmVudHMsIHByb3RvY29sKSB7XG4gICAgZnVuY3Rpb24gZGVjb2RlVW5yZXNlcnZlZChzdHIpIHtcbiAgICAgICAgdmFyIGRlY1N0ciA9IHBjdERlY0NoYXJzKHN0cik7XG4gICAgICAgIHJldHVybiAhZGVjU3RyLm1hdGNoKHByb3RvY29sLlVOUkVTRVJWRUQpID8gc3RyIDogZGVjU3RyO1xuICAgIH1cbiAgICBpZiAoY29tcG9uZW50cy5zY2hlbWUpIGNvbXBvbmVudHMuc2NoZW1lID0gU3RyaW5nKGNvbXBvbmVudHMuc2NoZW1lKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UocHJvdG9jb2wuTk9UX1NDSEVNRSwgXCJcIik7XG4gICAgaWYgKGNvbXBvbmVudHMudXNlcmluZm8gIT09IHVuZGVmaW5lZCkgY29tcG9uZW50cy51c2VyaW5mbyA9IFN0cmluZyhjb21wb25lbnRzLnVzZXJpbmZvKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKHByb3RvY29sLk5PVF9VU0VSSU5GTywgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuICAgIGlmIChjb21wb25lbnRzLmhvc3QgIT09IHVuZGVmaW5lZCkgY29tcG9uZW50cy5ob3N0ID0gU3RyaW5nKGNvbXBvbmVudHMuaG9zdCkucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKHByb3RvY29sLk5PVF9IT1NULCBwY3RFbmNDaGFyKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSk7XG4gICAgaWYgKGNvbXBvbmVudHMucGF0aCAhPT0gdW5kZWZpbmVkKSBjb21wb25lbnRzLnBhdGggPSBTdHJpbmcoY29tcG9uZW50cy5wYXRoKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKGNvbXBvbmVudHMuc2NoZW1lID8gcHJvdG9jb2wuTk9UX1BBVEggOiBwcm90b2NvbC5OT1RfUEFUSF9OT1NDSEVNRSwgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuICAgIGlmIChjb21wb25lbnRzLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMucXVlcnkgPSBTdHJpbmcoY29tcG9uZW50cy5xdWVyeSkucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShwcm90b2NvbC5OT1RfUVVFUlksIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcbiAgICBpZiAoY29tcG9uZW50cy5mcmFnbWVudCAhPT0gdW5kZWZpbmVkKSBjb21wb25lbnRzLmZyYWdtZW50ID0gU3RyaW5nKGNvbXBvbmVudHMuZnJhZ21lbnQpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UocHJvdG9jb2wuTk9UX0ZSQUdNRU5ULCBwY3RFbmNDaGFyKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSk7XG4gICAgcmV0dXJuIGNvbXBvbmVudHM7XG59XG5cbmZ1bmN0aW9uIF9zdHJpcExlYWRpbmdaZXJvcyhzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL14wKiguKikvLCBcIiQxXCIpIHx8IFwiMFwiO1xufVxuZnVuY3Rpb24gX25vcm1hbGl6ZUlQdjQoaG9zdCwgcHJvdG9jb2wpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IGhvc3QubWF0Y2gocHJvdG9jb2wuSVBWNEFERFJFU1MpIHx8IFtdO1xuXG4gICAgdmFyIF9tYXRjaGVzID0gc2xpY2VkVG9BcnJheShtYXRjaGVzLCAyKSxcbiAgICAgICAgYWRkcmVzcyA9IF9tYXRjaGVzWzFdO1xuXG4gICAgaWYgKGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIGFkZHJlc3Muc3BsaXQoXCIuXCIpLm1hcChfc3RyaXBMZWFkaW5nWmVyb3MpLmpvaW4oXCIuXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBob3N0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9ub3JtYWxpemVJUHY2KGhvc3QsIHByb3RvY29sKSB7XG4gICAgdmFyIG1hdGNoZXMgPSBob3N0Lm1hdGNoKHByb3RvY29sLklQVjZBRERSRVNTKSB8fCBbXTtcblxuICAgIHZhciBfbWF0Y2hlczIgPSBzbGljZWRUb0FycmF5KG1hdGNoZXMsIDMpLFxuICAgICAgICBhZGRyZXNzID0gX21hdGNoZXMyWzFdLFxuICAgICAgICB6b25lID0gX21hdGNoZXMyWzJdO1xuXG4gICAgaWYgKGFkZHJlc3MpIHtcbiAgICAgICAgdmFyIF9hZGRyZXNzJHRvTG93ZXJDYXNlJCA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKS5zcGxpdCgnOjonKS5yZXZlcnNlKCksXG4gICAgICAgICAgICBfYWRkcmVzcyR0b0xvd2VyQ2FzZSQyID0gc2xpY2VkVG9BcnJheShfYWRkcmVzcyR0b0xvd2VyQ2FzZSQsIDIpLFxuICAgICAgICAgICAgbGFzdCA9IF9hZGRyZXNzJHRvTG93ZXJDYXNlJDJbMF0sXG4gICAgICAgICAgICBmaXJzdCA9IF9hZGRyZXNzJHRvTG93ZXJDYXNlJDJbMV07XG5cbiAgICAgICAgdmFyIGZpcnN0RmllbGRzID0gZmlyc3QgPyBmaXJzdC5zcGxpdChcIjpcIikubWFwKF9zdHJpcExlYWRpbmdaZXJvcykgOiBbXTtcbiAgICAgICAgdmFyIGxhc3RGaWVsZHMgPSBsYXN0LnNwbGl0KFwiOlwiKS5tYXAoX3N0cmlwTGVhZGluZ1plcm9zKTtcbiAgICAgICAgdmFyIGlzTGFzdEZpZWxkSVB2NEFkZHJlc3MgPSBwcm90b2NvbC5JUFY0QUREUkVTUy50ZXN0KGxhc3RGaWVsZHNbbGFzdEZpZWxkcy5sZW5ndGggLSAxXSk7XG4gICAgICAgIHZhciBmaWVsZENvdW50ID0gaXNMYXN0RmllbGRJUHY0QWRkcmVzcyA/IDcgOiA4O1xuICAgICAgICB2YXIgbGFzdEZpZWxkc1N0YXJ0ID0gbGFzdEZpZWxkcy5sZW5ndGggLSBmaWVsZENvdW50O1xuICAgICAgICB2YXIgZmllbGRzID0gQXJyYXkoZmllbGRDb3VudCk7XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgZmllbGRDb3VudDsgKyt4KSB7XG4gICAgICAgICAgICBmaWVsZHNbeF0gPSBmaXJzdEZpZWxkc1t4XSB8fCBsYXN0RmllbGRzW2xhc3RGaWVsZHNTdGFydCArIHhdIHx8ICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xhc3RGaWVsZElQdjRBZGRyZXNzKSB7XG4gICAgICAgICAgICBmaWVsZHNbZmllbGRDb3VudCAtIDFdID0gX25vcm1hbGl6ZUlQdjQoZmllbGRzW2ZpZWxkQ291bnQgLSAxXSwgcHJvdG9jb2wpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbGxaZXJvRmllbGRzID0gZmllbGRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBmaWVsZCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghZmllbGQgfHwgZmllbGQgPT09IFwiMFwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RMb25nZXN0ID0gYWNjW2FjYy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdExvbmdlc3QgJiYgbGFzdExvbmdlc3QuaW5kZXggKyBsYXN0TG9uZ2VzdC5sZW5ndGggPT09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RMb25nZXN0Lmxlbmd0aCsrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFjYy5wdXNoKHsgaW5kZXg6IGluZGV4LCBsZW5ndGg6IDEgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwgW10pO1xuICAgICAgICB2YXIgbG9uZ2VzdFplcm9GaWVsZHMgPSBhbGxaZXJvRmllbGRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgICB9KVswXTtcbiAgICAgICAgdmFyIG5ld0hvc3QgPSB2b2lkIDA7XG4gICAgICAgIGlmIChsb25nZXN0WmVyb0ZpZWxkcyAmJiBsb25nZXN0WmVyb0ZpZWxkcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgbmV3Rmlyc3QgPSBmaWVsZHMuc2xpY2UoMCwgbG9uZ2VzdFplcm9GaWVsZHMuaW5kZXgpO1xuICAgICAgICAgICAgdmFyIG5ld0xhc3QgPSBmaWVsZHMuc2xpY2UobG9uZ2VzdFplcm9GaWVsZHMuaW5kZXggKyBsb25nZXN0WmVyb0ZpZWxkcy5sZW5ndGgpO1xuICAgICAgICAgICAgbmV3SG9zdCA9IG5ld0ZpcnN0LmpvaW4oXCI6XCIpICsgXCI6OlwiICsgbmV3TGFzdC5qb2luKFwiOlwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0hvc3QgPSBmaWVsZHMuam9pbihcIjpcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHpvbmUpIHtcbiAgICAgICAgICAgIG5ld0hvc3QgKz0gXCIlXCIgKyB6b25lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdIb3N0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBob3N0O1xuICAgIH1cbn1cbnZhciBVUklfUEFSU0UgPSAvXig/OihbXjpcXC8/I10rKTopPyg/OlxcL1xcLygoPzooW15cXC8/I0BdKilAKT8oXFxbW15cXC8/I1xcXV0rXFxdfFteXFwvPyM6XSopKD86XFw6KFxcZCopKT8pKT8oW14/I10qKSg/OlxcPyhbXiNdKikpPyg/OiMoKD86LnxcXG58XFxyKSopKT8vaTtcbnZhciBOT19NQVRDSF9JU19VTkRFRklORUQgPSBcIlwiLm1hdGNoKC8oKXswfS8pWzFdID09PSB1bmRlZmluZWQ7XG5mdW5jdGlvbiBwYXJzZSh1cmlTdHJpbmcpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICB2YXIgY29tcG9uZW50cyA9IHt9O1xuICAgIHZhciBwcm90b2NvbCA9IG9wdGlvbnMuaXJpICE9PSBmYWxzZSA/IElSSV9QUk9UT0NPTCA6IFVSSV9QUk9UT0NPTDtcbiAgICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgPT09IFwic3VmZml4XCIpIHVyaVN0cmluZyA9IChvcHRpb25zLnNjaGVtZSA/IG9wdGlvbnMuc2NoZW1lICsgXCI6XCIgOiBcIlwiKSArIFwiLy9cIiArIHVyaVN0cmluZztcbiAgICB2YXIgbWF0Y2hlcyA9IHVyaVN0cmluZy5tYXRjaChVUklfUEFSU0UpO1xuICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIGlmIChOT19NQVRDSF9JU19VTkRFRklORUQpIHtcbiAgICAgICAgICAgIC8vc3RvcmUgZWFjaCBjb21wb25lbnRcbiAgICAgICAgICAgIGNvbXBvbmVudHMuc2NoZW1lID0gbWF0Y2hlc1sxXTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMudXNlcmluZm8gPSBtYXRjaGVzWzNdO1xuICAgICAgICAgICAgY29tcG9uZW50cy5ob3N0ID0gbWF0Y2hlc1s0XTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucG9ydCA9IHBhcnNlSW50KG1hdGNoZXNbNV0sIDEwKTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucGF0aCA9IG1hdGNoZXNbNl0gfHwgXCJcIjtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucXVlcnkgPSBtYXRjaGVzWzddO1xuICAgICAgICAgICAgY29tcG9uZW50cy5mcmFnbWVudCA9IG1hdGNoZXNbOF07XG4gICAgICAgICAgICAvL2ZpeCBwb3J0IG51bWJlclxuICAgICAgICAgICAgaWYgKGlzTmFOKGNvbXBvbmVudHMucG9ydCkpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLnBvcnQgPSBtYXRjaGVzWzVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9JRSBGSVggZm9yIGltcHJvcGVyIFJlZ0V4cCBtYXRjaGluZ1xuICAgICAgICAgICAgLy9zdG9yZSBlYWNoIGNvbXBvbmVudFxuICAgICAgICAgICAgY29tcG9uZW50cy5zY2hlbWUgPSBtYXRjaGVzWzFdIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbXBvbmVudHMudXNlcmluZm8gPSB1cmlTdHJpbmcuaW5kZXhPZihcIkBcIikgIT09IC0xID8gbWF0Y2hlc1szXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuaG9zdCA9IHVyaVN0cmluZy5pbmRleE9mKFwiLy9cIikgIT09IC0xID8gbWF0Y2hlc1s0XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucG9ydCA9IHBhcnNlSW50KG1hdGNoZXNbNV0sIDEwKTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucGF0aCA9IG1hdGNoZXNbNl0gfHwgXCJcIjtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucXVlcnkgPSB1cmlTdHJpbmcuaW5kZXhPZihcIj9cIikgIT09IC0xID8gbWF0Y2hlc1s3XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuZnJhZ21lbnQgPSB1cmlTdHJpbmcuaW5kZXhPZihcIiNcIikgIT09IC0xID8gbWF0Y2hlc1s4XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIC8vZml4IHBvcnQgbnVtYmVyXG4gICAgICAgICAgICBpZiAoaXNOYU4oY29tcG9uZW50cy5wb3J0KSkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucG9ydCA9IHVyaVN0cmluZy5tYXRjaCgvXFwvXFwvKD86LnxcXG4pKlxcOig/OlxcL3xcXD98XFwjfCQpLykgPyBtYXRjaGVzWzRdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wb25lbnRzLmhvc3QpIHtcbiAgICAgICAgICAgIC8vbm9ybWFsaXplIElQIGhvc3RzXG4gICAgICAgICAgICBjb21wb25lbnRzLmhvc3QgPSBfbm9ybWFsaXplSVB2Nihfbm9ybWFsaXplSVB2NChjb21wb25lbnRzLmhvc3QsIHByb3RvY29sKSwgcHJvdG9jb2wpO1xuICAgICAgICB9XG4gICAgICAgIC8vZGV0ZXJtaW5lIHJlZmVyZW5jZSB0eXBlXG4gICAgICAgIGlmIChjb21wb25lbnRzLnNjaGVtZSA9PT0gdW5kZWZpbmVkICYmIGNvbXBvbmVudHMudXNlcmluZm8gPT09IHVuZGVmaW5lZCAmJiBjb21wb25lbnRzLmhvc3QgPT09IHVuZGVmaW5lZCAmJiBjb21wb25lbnRzLnBvcnQgPT09IHVuZGVmaW5lZCAmJiAhY29tcG9uZW50cy5wYXRoICYmIGNvbXBvbmVudHMucXVlcnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29tcG9uZW50cy5yZWZlcmVuY2UgPSBcInNhbWUtZG9jdW1lbnRcIjtcbiAgICAgICAgfSBlbHNlIGlmIChjb21wb25lbnRzLnNjaGVtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnJlZmVyZW5jZSA9IFwicmVsYXRpdmVcIjtcbiAgICAgICAgfSBlbHNlIGlmIChjb21wb25lbnRzLmZyYWdtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucmVmZXJlbmNlID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcG9uZW50cy5yZWZlcmVuY2UgPSBcInVyaVwiO1xuICAgICAgICB9XG4gICAgICAgIC8vY2hlY2sgZm9yIHJlZmVyZW5jZSBlcnJvcnNcbiAgICAgICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICYmIG9wdGlvbnMucmVmZXJlbmNlICE9PSBcInN1ZmZpeFwiICYmIG9wdGlvbnMucmVmZXJlbmNlICE9PSBjb21wb25lbnRzLnJlZmVyZW5jZSkge1xuICAgICAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJVUkkgaXMgbm90IGEgXCIgKyBvcHRpb25zLnJlZmVyZW5jZSArIFwiIHJlZmVyZW5jZS5cIjtcbiAgICAgICAgfVxuICAgICAgICAvL2ZpbmQgc2NoZW1lIGhhbmRsZXJcbiAgICAgICAgdmFyIHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTWyhvcHRpb25zLnNjaGVtZSB8fCBjb21wb25lbnRzLnNjaGVtZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgLy9jaGVjayBpZiBzY2hlbWUgY2FuJ3QgaGFuZGxlIElSSXNcbiAgICAgICAgaWYgKCFvcHRpb25zLnVuaWNvZGVTdXBwb3J0ICYmICghc2NoZW1lSGFuZGxlciB8fCAhc2NoZW1lSGFuZGxlci51bmljb2RlU3VwcG9ydCkpIHtcbiAgICAgICAgICAgIC8vaWYgaG9zdCBjb21wb25lbnQgaXMgYSBkb21haW4gbmFtZVxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudHMuaG9zdCAmJiAob3B0aW9ucy5kb21haW5Ib3N0IHx8IHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5kb21haW5Ib3N0KSkge1xuICAgICAgICAgICAgICAgIC8vY29udmVydCBVbmljb2RlIElETiAtPiBBU0NJSSBJRE5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLmhvc3QgPSBwdW55Y29kZS50b0FTQ0lJKGNvbXBvbmVudHMuaG9zdC5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBwY3REZWNDaGFycykudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIkhvc3QncyBkb21haW4gbmFtZSBjYW4gbm90IGJlIGNvbnZlcnRlZCB0byBBU0NJSSB2aWEgcHVueWNvZGU6IFwiICsgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2NvbnZlcnQgSVJJIC0+IFVSSVxuICAgICAgICAgICAgX25vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKGNvbXBvbmVudHMsIFVSSV9QUk9UT0NPTCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL25vcm1hbGl6ZSBlbmNvZGluZ3NcbiAgICAgICAgICAgIF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzLCBwcm90b2NvbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy9wZXJmb3JtIHNjaGVtZSBzcGVjaWZpYyBwYXJzaW5nXG4gICAgICAgIGlmIChzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIucGFyc2UpIHtcbiAgICAgICAgICAgIHNjaGVtZUhhbmRsZXIucGFyc2UoY29tcG9uZW50cywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIlVSSSBjYW4gbm90IGJlIHBhcnNlZC5cIjtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBvbmVudHM7XG59XG5cbmZ1bmN0aW9uIF9yZWNvbXBvc2VBdXRob3JpdHkoY29tcG9uZW50cywgb3B0aW9ucykge1xuICAgIHZhciBwcm90b2NvbCA9IG9wdGlvbnMuaXJpICE9PSBmYWxzZSA/IElSSV9QUk9UT0NPTCA6IFVSSV9QUk9UT0NPTDtcbiAgICB2YXIgdXJpVG9rZW5zID0gW107XG4gICAgaWYgKGNvbXBvbmVudHMudXNlcmluZm8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cmlUb2tlbnMucHVzaChjb21wb25lbnRzLnVzZXJpbmZvKTtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goXCJAXCIpO1xuICAgIH1cbiAgICBpZiAoY29tcG9uZW50cy5ob3N0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy9ub3JtYWxpemUgSVAgaG9zdHMsIGFkZCBicmFja2V0cyBhbmQgZXNjYXBlIHpvbmUgc2VwYXJhdG9yIGZvciBJUHY2XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKF9ub3JtYWxpemVJUHY2KF9ub3JtYWxpemVJUHY0KFN0cmluZyhjb21wb25lbnRzLmhvc3QpLCBwcm90b2NvbCksIHByb3RvY29sKS5yZXBsYWNlKHByb3RvY29sLklQVjZBRERSRVNTLCBmdW5jdGlvbiAoXywgJDEsICQyKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJbXCIgKyAkMSArICgkMiA/IFwiJTI1XCIgKyAkMiA6IFwiXCIpICsgXCJdXCI7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnRzLnBvcnQgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGNvbXBvbmVudHMucG9ydCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB1cmlUb2tlbnMucHVzaChcIjpcIik7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKFN0cmluZyhjb21wb25lbnRzLnBvcnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHVyaVRva2Vucy5sZW5ndGggPyB1cmlUb2tlbnMuam9pbihcIlwiKSA6IHVuZGVmaW5lZDtcbn1cblxudmFyIFJEUzEgPSAvXlxcLlxcLj9cXC8vO1xudmFyIFJEUzIgPSAvXlxcL1xcLihcXC98JCkvO1xudmFyIFJEUzMgPSAvXlxcL1xcLlxcLihcXC98JCkvO1xudmFyIFJEUzUgPSAvXlxcLz8oPzoufFxcbikqPyg/PVxcL3wkKS87XG5mdW5jdGlvbiByZW1vdmVEb3RTZWdtZW50cyhpbnB1dCkge1xuICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICB3aGlsZSAoaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIGlmIChpbnB1dC5tYXRjaChSRFMxKSkge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKFJEUzEsIFwiXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0Lm1hdGNoKFJEUzIpKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoUkRTMiwgXCIvXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0Lm1hdGNoKFJEUzMpKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoUkRTMywgXCIvXCIpO1xuICAgICAgICAgICAgb3V0cHV0LnBvcCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0ID09PSBcIi5cIiB8fCBpbnB1dCA9PT0gXCIuLlwiKSB7XG4gICAgICAgICAgICBpbnB1dCA9IFwiXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaW0gPSBpbnB1dC5tYXRjaChSRFM1KTtcbiAgICAgICAgICAgIGlmIChpbSkge1xuICAgICAgICAgICAgICAgIHZhciBzID0gaW1bMF07XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZShzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gocyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgZG90IHNlZ21lbnQgY29uZGl0aW9uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQuam9pbihcIlwiKTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplKGNvbXBvbmVudHMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICB2YXIgcHJvdG9jb2wgPSBvcHRpb25zLmlyaSA/IElSSV9QUk9UT0NPTCA6IFVSSV9QUk9UT0NPTDtcbiAgICB2YXIgdXJpVG9rZW5zID0gW107XG4gICAgLy9maW5kIHNjaGVtZSBoYW5kbGVyXG4gICAgdmFyIHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTWyhvcHRpb25zLnNjaGVtZSB8fCBjb21wb25lbnRzLnNjaGVtZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpXTtcbiAgICAvL3BlcmZvcm0gc2NoZW1lIHNwZWNpZmljIHNlcmlhbGl6YXRpb25cbiAgICBpZiAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZSkgc2NoZW1lSGFuZGxlci5zZXJpYWxpemUoY29tcG9uZW50cywgb3B0aW9ucyk7XG4gICAgaWYgKGNvbXBvbmVudHMuaG9zdCkge1xuICAgICAgICAvL2lmIGhvc3QgY29tcG9uZW50IGlzIGFuIElQdjYgYWRkcmVzc1xuICAgICAgICBpZiAocHJvdG9jb2wuSVBWNkFERFJFU1MudGVzdChjb21wb25lbnRzLmhvc3QpKSB7fVxuICAgICAgICAvL1RPRE86IG5vcm1hbGl6ZSBJUHY2IGFkZHJlc3MgYXMgcGVyIFJGQyA1OTUyXG5cbiAgICAgICAgLy9pZiBob3N0IGNvbXBvbmVudCBpcyBhIGRvbWFpbiBuYW1lXG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuZG9tYWluSG9zdCB8fCBzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIuZG9tYWluSG9zdCkge1xuICAgICAgICAgICAgICAgIC8vY29udmVydCBJRE4gdmlhIHB1bnljb2RlXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5ob3N0ID0gIW9wdGlvbnMuaXJpID8gcHVueWNvZGUudG9BU0NJSShjb21wb25lbnRzLmhvc3QucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgcGN0RGVjQ2hhcnMpLnRvTG93ZXJDYXNlKCkpIDogcHVueWNvZGUudG9Vbmljb2RlKGNvbXBvbmVudHMuaG9zdCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIkhvc3QncyBkb21haW4gbmFtZSBjYW4gbm90IGJlIGNvbnZlcnRlZCB0byBcIiArICghb3B0aW9ucy5pcmkgPyBcIkFTQ0lJXCIgOiBcIlVuaWNvZGVcIikgKyBcIiB2aWEgcHVueWNvZGU6IFwiICsgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIC8vbm9ybWFsaXplIGVuY29kaW5nXG4gICAgX25vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKGNvbXBvbmVudHMsIHByb3RvY29sKTtcbiAgICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgIT09IFwic3VmZml4XCIgJiYgY29tcG9uZW50cy5zY2hlbWUpIHtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy5zY2hlbWUpO1xuICAgICAgICB1cmlUb2tlbnMucHVzaChcIjpcIik7XG4gICAgfVxuICAgIHZhciBhdXRob3JpdHkgPSBfcmVjb21wb3NlQXV0aG9yaXR5KGNvbXBvbmVudHMsIG9wdGlvbnMpO1xuICAgIGlmIChhdXRob3JpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgIT09IFwic3VmZml4XCIpIHtcbiAgICAgICAgICAgIHVyaVRva2Vucy5wdXNoKFwiLy9cIik7XG4gICAgICAgIH1cbiAgICAgICAgdXJpVG9rZW5zLnB1c2goYXV0aG9yaXR5KTtcbiAgICAgICAgaWYgKGNvbXBvbmVudHMucGF0aCAmJiBjb21wb25lbnRzLnBhdGguY2hhckF0KDApICE9PSBcIi9cIikge1xuICAgICAgICAgICAgdXJpVG9rZW5zLnB1c2goXCIvXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRzLnBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgcyA9IGNvbXBvbmVudHMucGF0aDtcbiAgICAgICAgaWYgKCFvcHRpb25zLmFic29sdXRlUGF0aCAmJiAoIXNjaGVtZUhhbmRsZXIgfHwgIXNjaGVtZUhhbmRsZXIuYWJzb2x1dGVQYXRoKSkge1xuICAgICAgICAgICAgcyA9IHJlbW92ZURvdFNlZ21lbnRzKHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdXRob3JpdHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgvXlxcL1xcLy8sIFwiLyUyRlwiKTsgLy9kb24ndCBhbGxvdyB0aGUgcGF0aCB0byBzdGFydCB3aXRoIFwiLy9cIlxuICAgICAgICB9XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKHMpO1xuICAgIH1cbiAgICBpZiAoY29tcG9uZW50cy5xdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKFwiP1wiKTtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy5xdWVyeSk7XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRzLmZyYWdtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goXCIjXCIpO1xuICAgICAgICB1cmlUb2tlbnMucHVzaChjb21wb25lbnRzLmZyYWdtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHVyaVRva2Vucy5qb2luKFwiXCIpOyAvL21lcmdlIHRva2VucyBpbnRvIGEgc3RyaW5nXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnRzKGJhc2UsIHJlbGF0aXZlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBza2lwTm9ybWFsaXphdGlvbiA9IGFyZ3VtZW50c1szXTtcblxuICAgIHZhciB0YXJnZXQgPSB7fTtcbiAgICBpZiAoIXNraXBOb3JtYWxpemF0aW9uKSB7XG4gICAgICAgIGJhc2UgPSBwYXJzZShzZXJpYWxpemUoYmFzZSwgb3B0aW9ucyksIG9wdGlvbnMpOyAvL25vcm1hbGl6ZSBiYXNlIGNvbXBvbmVudHNcbiAgICAgICAgcmVsYXRpdmUgPSBwYXJzZShzZXJpYWxpemUocmVsYXRpdmUsIG9wdGlvbnMpLCBvcHRpb25zKTsgLy9ub3JtYWxpemUgcmVsYXRpdmUgY29tcG9uZW50c1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoIW9wdGlvbnMudG9sZXJhbnQgJiYgcmVsYXRpdmUuc2NoZW1lKSB7XG4gICAgICAgIHRhcmdldC5zY2hlbWUgPSByZWxhdGl2ZS5zY2hlbWU7XG4gICAgICAgIC8vdGFyZ2V0LmF1dGhvcml0eSA9IHJlbGF0aXZlLmF1dGhvcml0eTtcbiAgICAgICAgdGFyZ2V0LnVzZXJpbmZvID0gcmVsYXRpdmUudXNlcmluZm87XG4gICAgICAgIHRhcmdldC5ob3N0ID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgdGFyZ2V0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlLnBhdGggfHwgXCJcIik7XG4gICAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyZWxhdGl2ZS51c2VyaW5mbyAhPT0gdW5kZWZpbmVkIHx8IHJlbGF0aXZlLmhvc3QgIT09IHVuZGVmaW5lZCB8fCByZWxhdGl2ZS5wb3J0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vdGFyZ2V0LmF1dGhvcml0eSA9IHJlbGF0aXZlLmF1dGhvcml0eTtcbiAgICAgICAgICAgIHRhcmdldC51c2VyaW5mbyA9IHJlbGF0aXZlLnVzZXJpbmZvO1xuICAgICAgICAgICAgdGFyZ2V0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICAgICAgdGFyZ2V0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoIHx8IFwiXCIpO1xuICAgICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXJlbGF0aXZlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQucGF0aCA9IGJhc2UucGF0aDtcbiAgICAgICAgICAgICAgICBpZiAocmVsYXRpdmUucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucXVlcnkgPSBiYXNlLnF1ZXJ5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlbGF0aXZlLnBhdGguY2hhckF0KDApID09PSBcIi9cIikge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlLnBhdGgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoYmFzZS51c2VyaW5mbyAhPT0gdW5kZWZpbmVkIHx8IGJhc2UuaG9zdCAhPT0gdW5kZWZpbmVkIHx8IGJhc2UucG9ydCAhPT0gdW5kZWZpbmVkKSAmJiAhYmFzZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQucGF0aCA9IFwiL1wiICsgcmVsYXRpdmUucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghYmFzZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbGF0aXZlLnBhdGg7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQucGF0aCA9IGJhc2UucGF0aC5zbGljZSgwLCBiYXNlLnBhdGgubGFzdEluZGV4T2YoXCIvXCIpICsgMSkgKyByZWxhdGl2ZS5wYXRoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHModGFyZ2V0LnBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vdGFyZ2V0LmF1dGhvcml0eSA9IGJhc2UuYXV0aG9yaXR5O1xuICAgICAgICAgICAgdGFyZ2V0LnVzZXJpbmZvID0gYmFzZS51c2VyaW5mbztcbiAgICAgICAgICAgIHRhcmdldC5ob3N0ID0gYmFzZS5ob3N0O1xuICAgICAgICAgICAgdGFyZ2V0LnBvcnQgPSBiYXNlLnBvcnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LnNjaGVtZSA9IGJhc2Uuc2NoZW1lO1xuICAgIH1cbiAgICB0YXJnZXQuZnJhZ21lbnQgPSByZWxhdGl2ZS5mcmFnbWVudDtcbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlKGJhc2VVUkksIHJlbGF0aXZlVVJJLCBvcHRpb25zKSB7XG4gICAgdmFyIHNjaGVtZWxlc3NPcHRpb25zID0gYXNzaWduKHsgc2NoZW1lOiAnbnVsbCcgfSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZShyZXNvbHZlQ29tcG9uZW50cyhwYXJzZShiYXNlVVJJLCBzY2hlbWVsZXNzT3B0aW9ucyksIHBhcnNlKHJlbGF0aXZlVVJJLCBzY2hlbWVsZXNzT3B0aW9ucyksIHNjaGVtZWxlc3NPcHRpb25zLCB0cnVlKSwgc2NoZW1lbGVzc09wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemUodXJpLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiB1cmkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdXJpID0gc2VyaWFsaXplKHBhcnNlKHVyaSwgb3B0aW9ucyksIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAodHlwZU9mKHVyaSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdXJpID0gcGFyc2Uoc2VyaWFsaXplKHVyaSwgb3B0aW9ucyksIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdXJpO1xufVxuXG5mdW5jdGlvbiBlcXVhbCh1cmlBLCB1cmlCLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiB1cmlBID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHVyaUEgPSBzZXJpYWxpemUocGFyc2UodXJpQSwgb3B0aW9ucyksIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAodHlwZU9mKHVyaUEpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHVyaUEgPSBzZXJpYWxpemUodXJpQSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdXJpQiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB1cmlCID0gc2VyaWFsaXplKHBhcnNlKHVyaUIsIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVPZih1cmlCKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB1cmlCID0gc2VyaWFsaXplKHVyaUIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdXJpQSA9PT0gdXJpQjtcbn1cblxuZnVuY3Rpb24gZXNjYXBlQ29tcG9uZW50KHN0ciwgb3B0aW9ucykge1xuICAgIHJldHVybiBzdHIgJiYgc3RyLnRvU3RyaW5nKCkucmVwbGFjZSghb3B0aW9ucyB8fCAhb3B0aW9ucy5pcmkgPyBVUklfUFJPVE9DT0wuRVNDQVBFIDogSVJJX1BST1RPQ09MLkVTQ0FQRSwgcGN0RW5jQ2hhcik7XG59XG5cbmZ1bmN0aW9uIHVuZXNjYXBlQ29tcG9uZW50KHN0ciwgb3B0aW9ucykge1xuICAgIHJldHVybiBzdHIgJiYgc3RyLnRvU3RyaW5nKCkucmVwbGFjZSghb3B0aW9ucyB8fCAhb3B0aW9ucy5pcmkgPyBVUklfUFJPVE9DT0wuUENUX0VOQ09ERUQgOiBJUklfUFJPVE9DT0wuUENUX0VOQ09ERUQsIHBjdERlY0NoYXJzKTtcbn1cblxudmFyIGhhbmRsZXIgPSB7XG4gICAgc2NoZW1lOiBcImh0dHBcIixcbiAgICBkb21haW5Ib3N0OiB0cnVlLFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShjb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIC8vcmVwb3J0IG1pc3NpbmcgaG9zdFxuICAgICAgICBpZiAoIWNvbXBvbmVudHMuaG9zdCkge1xuICAgICAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJIVFRQIFVSSXMgbXVzdCBoYXZlIGEgaG9zdC5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcG9uZW50cztcbiAgICB9LFxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gc2VyaWFsaXplKGNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHNlY3VyZSA9IFN0cmluZyhjb21wb25lbnRzLnNjaGVtZSkudG9Mb3dlckNhc2UoKSA9PT0gXCJodHRwc1wiO1xuICAgICAgICAvL25vcm1hbGl6ZSB0aGUgZGVmYXVsdCBwb3J0XG4gICAgICAgIGlmIChjb21wb25lbnRzLnBvcnQgPT09IChzZWN1cmUgPyA0NDMgOiA4MCkgfHwgY29tcG9uZW50cy5wb3J0ID09PSBcIlwiKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnBvcnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy9ub3JtYWxpemUgdGhlIGVtcHR5IHBhdGhcbiAgICAgICAgaWYgKCFjb21wb25lbnRzLnBhdGgpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucGF0aCA9IFwiL1wiO1xuICAgICAgICB9XG4gICAgICAgIC8vTk9URTogV2UgZG8gbm90IHBhcnNlIHF1ZXJ5IHN0cmluZ3MgZm9yIEhUVFAgVVJJc1xuICAgICAgICAvL2FzIFdXVyBGb3JtIFVybCBFbmNvZGVkIHF1ZXJ5IHN0cmluZ3MgYXJlIHBhcnQgb2YgdGhlIEhUTUw0KyBzcGVjLFxuICAgICAgICAvL2FuZCBub3QgdGhlIEhUVFAgc3BlYy5cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gICAgfVxufTtcblxudmFyIGhhbmRsZXIkMSA9IHtcbiAgICBzY2hlbWU6IFwiaHR0cHNcIixcbiAgICBkb21haW5Ib3N0OiBoYW5kbGVyLmRvbWFpbkhvc3QsXG4gICAgcGFyc2U6IGhhbmRsZXIucGFyc2UsXG4gICAgc2VyaWFsaXplOiBoYW5kbGVyLnNlcmlhbGl6ZVxufTtcblxuZnVuY3Rpb24gaXNTZWN1cmUod3NDb21wb25lbnRzKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB3c0NvbXBvbmVudHMuc2VjdXJlID09PSAnYm9vbGVhbicgPyB3c0NvbXBvbmVudHMuc2VjdXJlIDogU3RyaW5nKHdzQ29tcG9uZW50cy5zY2hlbWUpLnRvTG93ZXJDYXNlKCkgPT09IFwid3NzXCI7XG59XG4vL1JGQyA2NDU1XG52YXIgaGFuZGxlciQyID0ge1xuICAgIHNjaGVtZTogXCJ3c1wiLFxuICAgIGRvbWFpbkhvc3Q6IHRydWUsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKGNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHdzQ29tcG9uZW50cyA9IGNvbXBvbmVudHM7XG4gICAgICAgIC8vaW5kaWNhdGUgaWYgdGhlIHNlY3VyZSBmbGFnIGlzIHNldFxuICAgICAgICB3c0NvbXBvbmVudHMuc2VjdXJlID0gaXNTZWN1cmUod3NDb21wb25lbnRzKTtcbiAgICAgICAgLy9jb25zdHJ1Y3QgcmVzb3VjZSBuYW1lXG4gICAgICAgIHdzQ29tcG9uZW50cy5yZXNvdXJjZU5hbWUgPSAod3NDb21wb25lbnRzLnBhdGggfHwgJy8nKSArICh3c0NvbXBvbmVudHMucXVlcnkgPyAnPycgKyB3c0NvbXBvbmVudHMucXVlcnkgOiAnJyk7XG4gICAgICAgIHdzQ29tcG9uZW50cy5wYXRoID0gdW5kZWZpbmVkO1xuICAgICAgICB3c0NvbXBvbmVudHMucXVlcnkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB3c0NvbXBvbmVudHM7XG4gICAgfSxcbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSh3c0NvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgLy9ub3JtYWxpemUgdGhlIGRlZmF1bHQgcG9ydFxuICAgICAgICBpZiAod3NDb21wb25lbnRzLnBvcnQgPT09IChpc1NlY3VyZSh3c0NvbXBvbmVudHMpID8gNDQzIDogODApIHx8IHdzQ29tcG9uZW50cy5wb3J0ID09PSBcIlwiKSB7XG4gICAgICAgICAgICB3c0NvbXBvbmVudHMucG9ydCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvL2Vuc3VyZSBzY2hlbWUgbWF0Y2hlcyBzZWN1cmUgZmxhZ1xuICAgICAgICBpZiAodHlwZW9mIHdzQ29tcG9uZW50cy5zZWN1cmUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgd3NDb21wb25lbnRzLnNjaGVtZSA9IHdzQ29tcG9uZW50cy5zZWN1cmUgPyAnd3NzJyA6ICd3cyc7XG4gICAgICAgICAgICB3c0NvbXBvbmVudHMuc2VjdXJlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vcmVjb25zdHJ1Y3QgcGF0aCBmcm9tIHJlc291cmNlIG5hbWVcbiAgICAgICAgaWYgKHdzQ29tcG9uZW50cy5yZXNvdXJjZU5hbWUpIHtcbiAgICAgICAgICAgIHZhciBfd3NDb21wb25lbnRzJHJlc291cmMgPSB3c0NvbXBvbmVudHMucmVzb3VyY2VOYW1lLnNwbGl0KCc/JyksXG4gICAgICAgICAgICAgICAgX3dzQ29tcG9uZW50cyRyZXNvdXJjMiA9IHNsaWNlZFRvQXJyYXkoX3dzQ29tcG9uZW50cyRyZXNvdXJjLCAyKSxcbiAgICAgICAgICAgICAgICBwYXRoID0gX3dzQ29tcG9uZW50cyRyZXNvdXJjMlswXSxcbiAgICAgICAgICAgICAgICBxdWVyeSA9IF93c0NvbXBvbmVudHMkcmVzb3VyYzJbMV07XG5cbiAgICAgICAgICAgIHdzQ29tcG9uZW50cy5wYXRoID0gcGF0aCAmJiBwYXRoICE9PSAnLycgPyBwYXRoIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgd3NDb21wb25lbnRzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgICAgICB3c0NvbXBvbmVudHMucmVzb3VyY2VOYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vZm9yYmlkIGZyYWdtZW50IGNvbXBvbmVudFxuICAgICAgICB3c0NvbXBvbmVudHMuZnJhZ21lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB3c0NvbXBvbmVudHM7XG4gICAgfVxufTtcblxudmFyIGhhbmRsZXIkMyA9IHtcbiAgICBzY2hlbWU6IFwid3NzXCIsXG4gICAgZG9tYWluSG9zdDogaGFuZGxlciQyLmRvbWFpbkhvc3QsXG4gICAgcGFyc2U6IGhhbmRsZXIkMi5wYXJzZSxcbiAgICBzZXJpYWxpemU6IGhhbmRsZXIkMi5zZXJpYWxpemVcbn07XG5cbnZhciBPID0ge307XG52YXIgaXNJUkkgPSB0cnVlO1xuLy9SRkMgMzk4NlxudmFyIFVOUkVTRVJWRUQkJCA9IFwiW0EtWmEtejAtOVxcXFwtXFxcXC5cXFxcX1xcXFx+XCIgKyAoaXNJUkkgPyBcIlxcXFx4QTAtXFxcXHUyMDBEXFxcXHUyMDEwLVxcXFx1MjAyOVxcXFx1MjAyRi1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRlwiIDogXCJcIikgKyBcIl1cIjtcbnZhciBIRVhESUckJCA9IFwiWzAtOUEtRmEtZl1cIjsgLy9jYXNlLWluc2Vuc2l0aXZlXG52YXIgUENUX0VOQ09ERUQkID0gc3ViZXhwKHN1YmV4cChcIiVbRUZlZl1cIiArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSArIFwifFwiICsgc3ViZXhwKFwiJVs4OUEtRmEtZl1cIiArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSArIFwifFwiICsgc3ViZXhwKFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkpOyAvL2V4cGFuZGVkXG4vL1JGQyA1MzIyLCBleGNlcHQgdGhlc2Ugc3ltYm9scyBhcyBwZXIgUkZDIDYwNjg6IEAgOiAvID8gIyBbIF0gJiA7ID1cbi8vY29uc3QgQVRFWFQkJCA9IFwiW0EtWmEtejAtOVxcXFwhXFxcXCNcXFxcJFxcXFwlXFxcXCZcXFxcJ1xcXFwqXFxcXCtcXFxcLVxcXFwvXFxcXD1cXFxcP1xcXFxeXFxcXF9cXFxcYFxcXFx7XFxcXHxcXFxcfVxcXFx+XVwiO1xuLy9jb25zdCBXU1AkJCA9IFwiW1xcXFx4MjBcXFxceDA5XVwiO1xuLy9jb25zdCBPQlNfUVRFWFQkJCA9IFwiW1xcXFx4MDEtXFxcXHgwOFxcXFx4MEJcXFxceDBDXFxcXHgwRS1cXFxceDFGXFxcXHg3Rl1cIjsgIC8vKCVkMS04IC8gJWQxMS0xMiAvICVkMTQtMzEgLyAlZDEyNylcbi8vY29uc3QgUVRFWFQkJCA9IG1lcmdlKFwiW1xcXFx4MjFcXFxceDIzLVxcXFx4NUJcXFxceDVELVxcXFx4N0VdXCIsIE9CU19RVEVYVCQkKTsgIC8vJWQzMyAvICVkMzUtOTEgLyAlZDkzLTEyNiAvIG9icy1xdGV4dFxuLy9jb25zdCBWQ0hBUiQkID0gXCJbXFxcXHgyMS1cXFxceDdFXVwiO1xuLy9jb25zdCBXU1AkJCA9IFwiW1xcXFx4MjBcXFxceDA5XVwiO1xuLy9jb25zdCBPQlNfUVAkID0gc3ViZXhwKFwiXFxcXFxcXFxcIiArIG1lcmdlKFwiW1xcXFx4MDBcXFxceDBEXFxcXHgwQV1cIiwgT0JTX1FURVhUJCQpKTsgIC8vJWQwIC8gQ1IgLyBMRiAvIG9icy1xdGV4dFxuLy9jb25zdCBGV1MkID0gc3ViZXhwKHN1YmV4cChXU1AkJCArIFwiKlwiICsgXCJcXFxceDBEXFxcXHgwQVwiKSArIFwiP1wiICsgV1NQJCQgKyBcIitcIik7XG4vL2NvbnN0IFFVT1RFRF9QQUlSJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcXFxcXFwiICsgc3ViZXhwKFZDSEFSJCQgKyBcInxcIiArIFdTUCQkKSkgKyBcInxcIiArIE9CU19RUCQpO1xuLy9jb25zdCBRVU9URURfU1RSSU5HJCA9IHN1YmV4cCgnXFxcXFwiJyArIHN1YmV4cChGV1MkICsgXCI/XCIgKyBRQ09OVEVOVCQpICsgXCIqXCIgKyBGV1MkICsgXCI/XCIgKyAnXFxcXFwiJyk7XG52YXIgQVRFWFQkJCA9IFwiW0EtWmEtejAtOVxcXFwhXFxcXCRcXFxcJVxcXFwnXFxcXCpcXFxcK1xcXFwtXFxcXF5cXFxcX1xcXFxgXFxcXHtcXFxcfFxcXFx9XFxcXH5dXCI7XG52YXIgUVRFWFQkJCA9IFwiW1xcXFwhXFxcXCRcXFxcJVxcXFwnXFxcXChcXFxcKVxcXFwqXFxcXCtcXFxcLFxcXFwtXFxcXC4wLTlcXFxcPFxcXFw+QS1aXFxcXHg1RS1cXFxceDdFXVwiO1xudmFyIFZDSEFSJCQgPSBtZXJnZShRVEVYVCQkLCBcIltcXFxcXFxcIlxcXFxcXFxcXVwiKTtcbnZhciBTT01FX0RFTElNUyQkID0gXCJbXFxcXCFcXFxcJFxcXFwnXFxcXChcXFxcKVxcXFwqXFxcXCtcXFxcLFxcXFw7XFxcXDpcXFxcQF1cIjtcbnZhciBVTlJFU0VSVkVEID0gbmV3IFJlZ0V4cChVTlJFU0VSVkVEJCQsIFwiZ1wiKTtcbnZhciBQQ1RfRU5DT0RFRCA9IG5ldyBSZWdFeHAoUENUX0VOQ09ERUQkLCBcImdcIik7XG52YXIgTk9UX0xPQ0FMX1BBUlQgPSBuZXcgUmVnRXhwKG1lcmdlKFwiW15dXCIsIEFURVhUJCQsIFwiW1xcXFwuXVwiLCAnW1xcXFxcIl0nLCBWQ0hBUiQkKSwgXCJnXCIpO1xudmFyIE5PVF9IRk5BTUUgPSBuZXcgUmVnRXhwKG1lcmdlKFwiW15dXCIsIFVOUkVTRVJWRUQkJCwgU09NRV9ERUxJTVMkJCksIFwiZ1wiKTtcbnZhciBOT1RfSEZWQUxVRSA9IE5PVF9IRk5BTUU7XG5mdW5jdGlvbiBkZWNvZGVVbnJlc2VydmVkKHN0cikge1xuICAgIHZhciBkZWNTdHIgPSBwY3REZWNDaGFycyhzdHIpO1xuICAgIHJldHVybiAhZGVjU3RyLm1hdGNoKFVOUkVTRVJWRUQpID8gc3RyIDogZGVjU3RyO1xufVxudmFyIGhhbmRsZXIkNCA9IHtcbiAgICBzY2hlbWU6IFwibWFpbHRvXCIsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlJCQxKGNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG1haWx0b0NvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuICAgICAgICB2YXIgdG8gPSBtYWlsdG9Db21wb25lbnRzLnRvID0gbWFpbHRvQ29tcG9uZW50cy5wYXRoID8gbWFpbHRvQ29tcG9uZW50cy5wYXRoLnNwbGl0KFwiLFwiKSA6IFtdO1xuICAgICAgICBtYWlsdG9Db21wb25lbnRzLnBhdGggPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYWlsdG9Db21wb25lbnRzLnF1ZXJ5KSB7XG4gICAgICAgICAgICB2YXIgdW5rbm93bkhlYWRlcnMgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBoZWFkZXJzID0ge307XG4gICAgICAgICAgICB2YXIgaGZpZWxkcyA9IG1haWx0b0NvbXBvbmVudHMucXVlcnkuc3BsaXQoXCImXCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDAsIHhsID0gaGZpZWxkcy5sZW5ndGg7IHggPCB4bDsgKyt4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGhmaWVsZCA9IGhmaWVsZHNbeF0uc3BsaXQoXCI9XCIpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoaGZpZWxkWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0b1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvQWRkcnMgPSBoZmllbGRbMV0uc3BsaXQoXCIsXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX3ggPSAwLCBfeGwgPSB0b0FkZHJzLmxlbmd0aDsgX3ggPCBfeGw7ICsrX3gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0by5wdXNoKHRvQWRkcnNbX3hdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3ViamVjdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbHRvQ29tcG9uZW50cy5zdWJqZWN0ID0gdW5lc2NhcGVDb21wb25lbnQoaGZpZWxkWzFdLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYm9keVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbHRvQ29tcG9uZW50cy5ib2R5ID0gdW5lc2NhcGVDb21wb25lbnQoaGZpZWxkWzFdLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdW5rbm93bkhlYWRlcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1t1bmVzY2FwZUNvbXBvbmVudChoZmllbGRbMF0sIG9wdGlvbnMpXSA9IHVuZXNjYXBlQ29tcG9uZW50KGhmaWVsZFsxXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5rbm93bkhlYWRlcnMpIG1haWx0b0NvbXBvbmVudHMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgbWFpbHRvQ29tcG9uZW50cy5xdWVyeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yICh2YXIgX3gyID0gMCwgX3hsMiA9IHRvLmxlbmd0aDsgX3gyIDwgX3hsMjsgKytfeDIpIHtcbiAgICAgICAgICAgIHZhciBhZGRyID0gdG9bX3gyXS5zcGxpdChcIkBcIik7XG4gICAgICAgICAgICBhZGRyWzBdID0gdW5lc2NhcGVDb21wb25lbnQoYWRkclswXSk7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMudW5pY29kZVN1cHBvcnQpIHtcbiAgICAgICAgICAgICAgICAvL2NvbnZlcnQgVW5pY29kZSBJRE4gLT4gQVNDSUkgSUROXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYWRkclsxXSA9IHB1bnljb2RlLnRvQVNDSUkodW5lc2NhcGVDb21wb25lbnQoYWRkclsxXSwgb3B0aW9ucykudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBtYWlsdG9Db21wb25lbnRzLmVycm9yID0gbWFpbHRvQ29tcG9uZW50cy5lcnJvciB8fCBcIkVtYWlsIGFkZHJlc3MncyBkb21haW4gbmFtZSBjYW4gbm90IGJlIGNvbnZlcnRlZCB0byBBU0NJSSB2aWEgcHVueWNvZGU6IFwiICsgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZHJbMV0gPSB1bmVzY2FwZUNvbXBvbmVudChhZGRyWzFdLCBvcHRpb25zKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9bX3gyXSA9IGFkZHIuam9pbihcIkBcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1haWx0b0NvbXBvbmVudHM7XG4gICAgfSxcbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSQkMShtYWlsdG9Db21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBjb21wb25lbnRzID0gbWFpbHRvQ29tcG9uZW50cztcbiAgICAgICAgdmFyIHRvID0gdG9BcnJheShtYWlsdG9Db21wb25lbnRzLnRvKTtcbiAgICAgICAgaWYgKHRvKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMCwgeGwgPSB0by5sZW5ndGg7IHggPCB4bDsgKyt4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvQWRkciA9IFN0cmluZyh0b1t4XSk7XG4gICAgICAgICAgICAgICAgdmFyIGF0SWR4ID0gdG9BZGRyLmxhc3RJbmRleE9mKFwiQFwiKTtcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxQYXJ0ID0gdG9BZGRyLnNsaWNlKDAsIGF0SWR4KS5yZXBsYWNlKFBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKFBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSkucmVwbGFjZShOT1RfTE9DQUxfUEFSVCwgcGN0RW5jQ2hhcik7XG4gICAgICAgICAgICAgICAgdmFyIGRvbWFpbiA9IHRvQWRkci5zbGljZShhdElkeCArIDEpO1xuICAgICAgICAgICAgICAgIC8vY29udmVydCBJRE4gdmlhIHB1bnljb2RlXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluID0gIW9wdGlvbnMuaXJpID8gcHVueWNvZGUudG9BU0NJSSh1bmVzY2FwZUNvbXBvbmVudChkb21haW4sIG9wdGlvbnMpLnRvTG93ZXJDYXNlKCkpIDogcHVueWNvZGUudG9Vbmljb2RlKGRvbWFpbik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIkVtYWlsIGFkZHJlc3MncyBkb21haW4gbmFtZSBjYW4gbm90IGJlIGNvbnZlcnRlZCB0byBcIiArICghb3B0aW9ucy5pcmkgPyBcIkFTQ0lJXCIgOiBcIlVuaWNvZGVcIikgKyBcIiB2aWEgcHVueWNvZGU6IFwiICsgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9beF0gPSBsb2NhbFBhcnQgKyBcIkBcIiArIGRvbWFpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXBvbmVudHMucGF0aCA9IHRvLmpvaW4oXCIsXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoZWFkZXJzID0gbWFpbHRvQ29tcG9uZW50cy5oZWFkZXJzID0gbWFpbHRvQ29tcG9uZW50cy5oZWFkZXJzIHx8IHt9O1xuICAgICAgICBpZiAobWFpbHRvQ29tcG9uZW50cy5zdWJqZWN0KSBoZWFkZXJzW1wic3ViamVjdFwiXSA9IG1haWx0b0NvbXBvbmVudHMuc3ViamVjdDtcbiAgICAgICAgaWYgKG1haWx0b0NvbXBvbmVudHMuYm9keSkgaGVhZGVyc1tcImJvZHlcIl0gPSBtYWlsdG9Db21wb25lbnRzLmJvZHk7XG4gICAgICAgIHZhciBmaWVsZHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBoZWFkZXJzKSB7XG4gICAgICAgICAgICBpZiAoaGVhZGVyc1tuYW1lXSAhPT0gT1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIGZpZWxkcy5wdXNoKG5hbWUucmVwbGFjZShQQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShQQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpLnJlcGxhY2UoTk9UX0hGTkFNRSwgcGN0RW5jQ2hhcikgKyBcIj1cIiArIGhlYWRlcnNbbmFtZV0ucmVwbGFjZShQQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShQQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpLnJlcGxhY2UoTk9UX0hGVkFMVUUsIHBjdEVuY0NoYXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29tcG9uZW50cy5xdWVyeSA9IGZpZWxkcy5qb2luKFwiJlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcG9uZW50cztcbiAgICB9XG59O1xuXG52YXIgVVJOX1BBUlNFID0gL14oW15cXDpdKylcXDooLiopLztcbi8vUkZDIDIxNDFcbnZhciBoYW5kbGVyJDUgPSB7XG4gICAgc2NoZW1lOiBcInVyblwiLFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSQkMShjb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBtYXRjaGVzID0gY29tcG9uZW50cy5wYXRoICYmIGNvbXBvbmVudHMucGF0aC5tYXRjaChVUk5fUEFSU0UpO1xuICAgICAgICB2YXIgdXJuQ29tcG9uZW50cyA9IGNvbXBvbmVudHM7XG4gICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICB2YXIgc2NoZW1lID0gb3B0aW9ucy5zY2hlbWUgfHwgdXJuQ29tcG9uZW50cy5zY2hlbWUgfHwgXCJ1cm5cIjtcbiAgICAgICAgICAgIHZhciBuaWQgPSBtYXRjaGVzWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB2YXIgbnNzID0gbWF0Y2hlc1syXTtcbiAgICAgICAgICAgIHZhciB1cm5TY2hlbWUgPSBzY2hlbWUgKyBcIjpcIiArIChvcHRpb25zLm5pZCB8fCBuaWQpO1xuICAgICAgICAgICAgdmFyIHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTW3VyblNjaGVtZV07XG4gICAgICAgICAgICB1cm5Db21wb25lbnRzLm5pZCA9IG5pZDtcbiAgICAgICAgICAgIHVybkNvbXBvbmVudHMubnNzID0gbnNzO1xuICAgICAgICAgICAgdXJuQ29tcG9uZW50cy5wYXRoID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHNjaGVtZUhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB1cm5Db21wb25lbnRzID0gc2NoZW1lSGFuZGxlci5wYXJzZSh1cm5Db21wb25lbnRzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVybkNvbXBvbmVudHMuZXJyb3IgPSB1cm5Db21wb25lbnRzLmVycm9yIHx8IFwiVVJOIGNhbiBub3QgYmUgcGFyc2VkLlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cm5Db21wb25lbnRzO1xuICAgIH0sXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbiBzZXJpYWxpemUkJDEodXJuQ29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgc2NoZW1lID0gb3B0aW9ucy5zY2hlbWUgfHwgdXJuQ29tcG9uZW50cy5zY2hlbWUgfHwgXCJ1cm5cIjtcbiAgICAgICAgdmFyIG5pZCA9IHVybkNvbXBvbmVudHMubmlkO1xuICAgICAgICB2YXIgdXJuU2NoZW1lID0gc2NoZW1lICsgXCI6XCIgKyAob3B0aW9ucy5uaWQgfHwgbmlkKTtcbiAgICAgICAgdmFyIHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTW3VyblNjaGVtZV07XG4gICAgICAgIGlmIChzY2hlbWVIYW5kbGVyKSB7XG4gICAgICAgICAgICB1cm5Db21wb25lbnRzID0gc2NoZW1lSGFuZGxlci5zZXJpYWxpemUodXJuQ29tcG9uZW50cywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVyaUNvbXBvbmVudHMgPSB1cm5Db21wb25lbnRzO1xuICAgICAgICB2YXIgbnNzID0gdXJuQ29tcG9uZW50cy5uc3M7XG4gICAgICAgIHVyaUNvbXBvbmVudHMucGF0aCA9IChuaWQgfHwgb3B0aW9ucy5uaWQpICsgXCI6XCIgKyBuc3M7XG4gICAgICAgIHJldHVybiB1cmlDb21wb25lbnRzO1xuICAgIH1cbn07XG5cbnZhciBVVUlEID0gL15bMC05QS1GYS1mXXs4fSg/OlxcLVswLTlBLUZhLWZdezR9KXszfVxcLVswLTlBLUZhLWZdezEyfSQvO1xuLy9SRkMgNDEyMlxudmFyIGhhbmRsZXIkNiA9IHtcbiAgICBzY2hlbWU6IFwidXJuOnV1aWRcIixcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UodXJuQ29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgdXVpZENvbXBvbmVudHMgPSB1cm5Db21wb25lbnRzO1xuICAgICAgICB1dWlkQ29tcG9uZW50cy51dWlkID0gdXVpZENvbXBvbmVudHMubnNzO1xuICAgICAgICB1dWlkQ29tcG9uZW50cy5uc3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghb3B0aW9ucy50b2xlcmFudCAmJiAoIXV1aWRDb21wb25lbnRzLnV1aWQgfHwgIXV1aWRDb21wb25lbnRzLnV1aWQubWF0Y2goVVVJRCkpKSB7XG4gICAgICAgICAgICB1dWlkQ29tcG9uZW50cy5lcnJvciA9IHV1aWRDb21wb25lbnRzLmVycm9yIHx8IFwiVVVJRCBpcyBub3QgdmFsaWQuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHV1aWRDb21wb25lbnRzO1xuICAgIH0sXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbiBzZXJpYWxpemUodXVpZENvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHVybkNvbXBvbmVudHMgPSB1dWlkQ29tcG9uZW50cztcbiAgICAgICAgLy9ub3JtYWxpemUgVVVJRFxuICAgICAgICB1cm5Db21wb25lbnRzLm5zcyA9ICh1dWlkQ29tcG9uZW50cy51dWlkIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiB1cm5Db21wb25lbnRzO1xuICAgIH1cbn07XG5cblNDSEVNRVNbaGFuZGxlci5zY2hlbWVdID0gaGFuZGxlcjtcblNDSEVNRVNbaGFuZGxlciQxLnNjaGVtZV0gPSBoYW5kbGVyJDE7XG5TQ0hFTUVTW2hhbmRsZXIkMi5zY2hlbWVdID0gaGFuZGxlciQyO1xuU0NIRU1FU1toYW5kbGVyJDMuc2NoZW1lXSA9IGhhbmRsZXIkMztcblNDSEVNRVNbaGFuZGxlciQ0LnNjaGVtZV0gPSBoYW5kbGVyJDQ7XG5TQ0hFTUVTW2hhbmRsZXIkNS5zY2hlbWVdID0gaGFuZGxlciQ1O1xuU0NIRU1FU1toYW5kbGVyJDYuc2NoZW1lXSA9IGhhbmRsZXIkNjtcblxuZXhwb3J0cy5TQ0hFTUVTID0gU0NIRU1FUztcbmV4cG9ydHMucGN0RW5jQ2hhciA9IHBjdEVuY0NoYXI7XG5leHBvcnRzLnBjdERlY0NoYXJzID0gcGN0RGVjQ2hhcnM7XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5leHBvcnRzLnJlbW92ZURvdFNlZ21lbnRzID0gcmVtb3ZlRG90U2VnbWVudHM7XG5leHBvcnRzLnNlcmlhbGl6ZSA9IHNlcmlhbGl6ZTtcbmV4cG9ydHMucmVzb2x2ZUNvbXBvbmVudHMgPSByZXNvbHZlQ29tcG9uZW50cztcbmV4cG9ydHMucmVzb2x2ZSA9IHJlc29sdmU7XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcbmV4cG9ydHMuZXF1YWwgPSBlcXVhbDtcbmV4cG9ydHMuZXNjYXBlQ29tcG9uZW50ID0gZXNjYXBlQ29tcG9uZW50O1xuZXhwb3J0cy51bmVzY2FwZUNvbXBvbmVudCA9IHVuZXNjYXBlQ29tcG9uZW50O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJpLmFsbC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRTY2hlbWFSZWZzID0gZXhwb3J0cy5yZXNvbHZlVXJsID0gZXhwb3J0cy5ub3JtYWxpemVJZCA9IGV4cG9ydHMuX2dldEZ1bGxQYXRoID0gZXhwb3J0cy5nZXRGdWxsUGF0aCA9IGV4cG9ydHMuaW5saW5lUmVmID0gdm9pZCAwO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IGVxdWFsID0gcmVxdWlyZShcImZhc3QtZGVlcC1lcXVhbFwiKTtcbmNvbnN0IHRyYXZlcnNlID0gcmVxdWlyZShcImpzb24tc2NoZW1hLXRyYXZlcnNlXCIpO1xuY29uc3QgVVJJID0gcmVxdWlyZShcInVyaS1qc1wiKTtcbi8vIFRPRE8gcmVmYWN0b3IgdG8gdXNlIGtleXdvcmQgZGVmaW5pdGlvbnNcbmNvbnN0IFNJTVBMRV9JTkxJTkVEID0gbmV3IFNldChbXG4gICAgXCJ0eXBlXCIsXG4gICAgXCJmb3JtYXRcIixcbiAgICBcInBhdHRlcm5cIixcbiAgICBcIm1heExlbmd0aFwiLFxuICAgIFwibWluTGVuZ3RoXCIsXG4gICAgXCJtYXhQcm9wZXJ0aWVzXCIsXG4gICAgXCJtaW5Qcm9wZXJ0aWVzXCIsXG4gICAgXCJtYXhJdGVtc1wiLFxuICAgIFwibWluSXRlbXNcIixcbiAgICBcIm1heGltdW1cIixcbiAgICBcIm1pbmltdW1cIixcbiAgICBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgXCJtdWx0aXBsZU9mXCIsXG4gICAgXCJyZXF1aXJlZFwiLFxuICAgIFwiZW51bVwiLFxuICAgIFwiY29uc3RcIixcbl0pO1xuZnVuY3Rpb24gaW5saW5lUmVmKHNjaGVtYSwgbGltaXQgPSB0cnVlKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChsaW1pdCA9PT0gdHJ1ZSlcbiAgICAgICAgcmV0dXJuICFoYXNSZWYoc2NoZW1hKTtcbiAgICBpZiAoIWxpbWl0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGNvdW50S2V5cyhzY2hlbWEpIDw9IGxpbWl0O1xufVxuZXhwb3J0cy5pbmxpbmVSZWYgPSBpbmxpbmVSZWY7XG5jb25zdCBSRUZfS0VZV09SRFMgPSBuZXcgU2V0KFtcbiAgICBcIiRyZWZcIixcbiAgICBcIiRyZWN1cnNpdmVSZWZcIixcbiAgICBcIiRyZWN1cnNpdmVBbmNob3JcIixcbiAgICBcIiRkeW5hbWljUmVmXCIsXG4gICAgXCIkZHluYW1pY0FuY2hvclwiLFxuXSk7XG5mdW5jdGlvbiBoYXNSZWYoc2NoZW1hKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgIGlmIChSRUZfS0VZV09SRFMuaGFzKGtleSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY29uc3Qgc2NoID0gc2NoZW1hW2tleV07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaCkgJiYgc2NoLnNvbWUoaGFzUmVmKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodHlwZW9mIHNjaCA9PSBcIm9iamVjdFwiICYmIGhhc1JlZihzY2gpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNvdW50S2V5cyhzY2hlbWEpIHtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgICAgICBpZiAoa2V5ID09PSBcIiRyZWZcIilcbiAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgY291bnQrKztcbiAgICAgICAgaWYgKFNJTVBMRV9JTkxJTkVELmhhcyhrZXkpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hW2tleV0gPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgdXRpbF8xLmVhY2hJdGVtKHNjaGVtYVtrZXldLCAoc2NoKSA9PiAoY291bnQgKz0gY291bnRLZXlzKHNjaCkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY291bnQgPT09IEluZmluaXR5KVxuICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgICByZXR1cm4gY291bnQ7XG59XG5mdW5jdGlvbiBnZXRGdWxsUGF0aChpZCA9IFwiXCIsIG5vcm1hbGl6ZSkge1xuICAgIGlmIChub3JtYWxpemUgIT09IGZhbHNlKVxuICAgICAgICBpZCA9IG5vcm1hbGl6ZUlkKGlkKTtcbiAgICBjb25zdCBwID0gVVJJLnBhcnNlKGlkKTtcbiAgICByZXR1cm4gX2dldEZ1bGxQYXRoKHApO1xufVxuZXhwb3J0cy5nZXRGdWxsUGF0aCA9IGdldEZ1bGxQYXRoO1xuZnVuY3Rpb24gX2dldEZ1bGxQYXRoKHApIHtcbiAgICByZXR1cm4gVVJJLnNlcmlhbGl6ZShwKS5zcGxpdChcIiNcIilbMF0gKyBcIiNcIjtcbn1cbmV4cG9ydHMuX2dldEZ1bGxQYXRoID0gX2dldEZ1bGxQYXRoO1xuY29uc3QgVFJBSUxJTkdfU0xBU0hfSEFTSCA9IC8jXFwvPyQvO1xuZnVuY3Rpb24gbm9ybWFsaXplSWQoaWQpIHtcbiAgICByZXR1cm4gaWQgPyBpZC5yZXBsYWNlKFRSQUlMSU5HX1NMQVNIX0hBU0gsIFwiXCIpIDogXCJcIjtcbn1cbmV4cG9ydHMubm9ybWFsaXplSWQgPSBub3JtYWxpemVJZDtcbmZ1bmN0aW9uIHJlc29sdmVVcmwoYmFzZUlkLCBpZCkge1xuICAgIGlkID0gbm9ybWFsaXplSWQoaWQpO1xuICAgIHJldHVybiBVUkkucmVzb2x2ZShiYXNlSWQsIGlkKTtcbn1cbmV4cG9ydHMucmVzb2x2ZVVybCA9IHJlc29sdmVVcmw7XG5jb25zdCBBTkNIT1IgPSAvXlthLXpfXVstYS16MC05Ll9dKiQvaTtcbmZ1bmN0aW9uIGdldFNjaGVtYVJlZnMoc2NoZW1hKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybiB7fTtcbiAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgY29uc3Qgc2NoSWQgPSBub3JtYWxpemVJZChzY2hlbWFbc2NoZW1hSWRdKTtcbiAgICBjb25zdCBiYXNlSWRzID0geyBcIlwiOiBzY2hJZCB9O1xuICAgIGNvbnN0IHBhdGhQcmVmaXggPSBnZXRGdWxsUGF0aChzY2hJZCwgZmFsc2UpO1xuICAgIGNvbnN0IGxvY2FsUmVmcyA9IHt9O1xuICAgIGNvbnN0IHNjaGVtYVJlZnMgPSBuZXcgU2V0KCk7XG4gICAgdHJhdmVyc2Uoc2NoZW1hLCB7IGFsbEtleXM6IHRydWUgfSwgKHNjaCwganNvblB0ciwgXywgcGFyZW50SnNvblB0cikgPT4ge1xuICAgICAgICBpZiAocGFyZW50SnNvblB0ciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGhQcmVmaXggKyBqc29uUHRyO1xuICAgICAgICBsZXQgYmFzZUlkID0gYmFzZUlkc1twYXJlbnRKc29uUHRyXTtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hbc2NoZW1hSWRdID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBiYXNlSWQgPSBhZGRSZWYuY2FsbCh0aGlzLCBzY2hbc2NoZW1hSWRdKTtcbiAgICAgICAgYWRkQW5jaG9yLmNhbGwodGhpcywgc2NoLiRhbmNob3IpO1xuICAgICAgICBhZGRBbmNob3IuY2FsbCh0aGlzLCBzY2guJGR5bmFtaWNBbmNob3IpO1xuICAgICAgICBiYXNlSWRzW2pzb25QdHJdID0gYmFzZUlkO1xuICAgICAgICBmdW5jdGlvbiBhZGRSZWYocmVmKSB7XG4gICAgICAgICAgICByZWYgPSBub3JtYWxpemVJZChiYXNlSWQgPyBVUkkucmVzb2x2ZShiYXNlSWQsIHJlZikgOiByZWYpO1xuICAgICAgICAgICAgaWYgKHNjaGVtYVJlZnMuaGFzKHJlZikpXG4gICAgICAgICAgICAgICAgdGhyb3cgYW1iaWd1b3MocmVmKTtcbiAgICAgICAgICAgIHNjaGVtYVJlZnMuYWRkKHJlZik7XG4gICAgICAgICAgICBsZXQgc2NoT3JSZWYgPSB0aGlzLnJlZnNbcmVmXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoT3JSZWYgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBzY2hPclJlZiA9IHRoaXMucmVmc1tzY2hPclJlZl07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjaE9yUmVmID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBjaGVja0FtYmlndW9zUmVmKHNjaCwgc2NoT3JSZWYuc2NoZW1hLCByZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVmICE9PSBub3JtYWxpemVJZChmdWxsUGF0aCkpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVmWzBdID09PSBcIiNcIikge1xuICAgICAgICAgICAgICAgICAgICBjaGVja0FtYmlndW9zUmVmKHNjaCwgbG9jYWxSZWZzW3JlZl0sIHJlZik7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsUmVmc1tyZWZdID0gc2NoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZzW3JlZl0gPSBmdWxsUGF0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVmO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFkZEFuY2hvcihhbmNob3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYW5jaG9yID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFOQ0hPUi50ZXN0KGFuY2hvcikpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBhbmNob3IgXCIke2FuY2hvcn1cImApO1xuICAgICAgICAgICAgICAgIGFkZFJlZi5jYWxsKHRoaXMsIGAjJHthbmNob3J9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbG9jYWxSZWZzO1xuICAgIGZ1bmN0aW9uIGNoZWNrQW1iaWd1b3NSZWYoc2NoMSwgc2NoMiwgcmVmKSB7XG4gICAgICAgIGlmIChzY2gyICE9PSB1bmRlZmluZWQgJiYgIWVxdWFsKHNjaDEsIHNjaDIpKVxuICAgICAgICAgICAgdGhyb3cgYW1iaWd1b3MocmVmKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYW1iaWd1b3MocmVmKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoYHJlZmVyZW5jZSBcIiR7cmVmfVwiIHJlc29sdmVzIHRvIG1vcmUgdGhhbiBvbmUgc2NoZW1hYCk7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRTY2hlbWFSZWZzID0gZ2V0U2NoZW1hUmVmcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldERhdGEgPSBleHBvcnRzLktleXdvcmRDeHQgPSBleHBvcnRzLnZhbGlkYXRlRnVuY3Rpb25Db2RlID0gdm9pZCAwO1xuY29uc3QgYm9vbFNjaGVtYV8xID0gcmVxdWlyZShcIi4vYm9vbFNjaGVtYVwiKTtcbmNvbnN0IGRhdGFUeXBlXzEgPSByZXF1aXJlKFwiLi9kYXRhVHlwZVwiKTtcbmNvbnN0IGFwcGxpY2FiaWxpdHlfMSA9IHJlcXVpcmUoXCIuL2FwcGxpY2FiaWxpdHlcIik7XG5jb25zdCBkYXRhVHlwZV8yID0gcmVxdWlyZShcIi4vZGF0YVR5cGVcIik7XG5jb25zdCBkZWZhdWx0c18xID0gcmVxdWlyZShcIi4vZGVmYXVsdHNcIik7XG5jb25zdCBrZXl3b3JkXzEgPSByZXF1aXJlKFwiLi9rZXl3b3JkXCIpO1xuY29uc3Qgc3Vic2NoZW1hXzEgPSByZXF1aXJlKFwiLi9zdWJzY2hlbWFcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi4vbmFtZXNcIik7XG5jb25zdCByZXNvbHZlXzEgPSByZXF1aXJlKFwiLi4vcmVzb2x2ZVwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuLy8gc2NoZW1hIGNvbXBpbGF0aW9uIC0gZ2VuZXJhdGVzIHZhbGlkYXRpb24gZnVuY3Rpb24sIHN1YnNjaGVtYUNvZGUgKGJlbG93KSBpcyB1c2VkIGZvciBzdWJzY2hlbWFzXG5mdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uQ29kZShpdCkge1xuICAgIGlmIChpc1NjaGVtYU9iaihpdCkpIHtcbiAgICAgICAgY2hlY2tLZXl3b3JkcyhpdCk7XG4gICAgICAgIGlmIChzY2hlbWFDeHRIYXNSdWxlcyhpdCkpIHtcbiAgICAgICAgICAgIHRvcFNjaGVtYU9iakNvZGUoaXQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhbGlkYXRlRnVuY3Rpb24oaXQsICgpID0+IGJvb2xTY2hlbWFfMS50b3BCb29sT3JFbXB0eVNjaGVtYShpdCkpO1xufVxuZXhwb3J0cy52YWxpZGF0ZUZ1bmN0aW9uQ29kZSA9IHZhbGlkYXRlRnVuY3Rpb25Db2RlO1xuZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbih7IGdlbiwgdmFsaWRhdGVOYW1lLCBzY2hlbWEsIHNjaGVtYUVudiwgb3B0cyB9LCBib2R5KSB7XG4gICAgaWYgKG9wdHMuY29kZS5lczUpIHtcbiAgICAgICAgZ2VuLmZ1bmModmFsaWRhdGVOYW1lLCBjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQuZGF0YX0sICR7bmFtZXNfMS5kZWZhdWx0LnZhbEN4dH1gLCBzY2hlbWFFbnYuJGFzeW5jLCAoKSA9PiB7XG4gICAgICAgICAgICBnZW4uY29kZShjb2RlZ2VuXzEuXyBgXCJ1c2Ugc3RyaWN0XCI7ICR7ZnVuY1NvdXJjZVVybChzY2hlbWEsIG9wdHMpfWApO1xuICAgICAgICAgICAgZGVzdHJ1Y3R1cmVWYWxDeHRFUzUoZ2VuLCBvcHRzKTtcbiAgICAgICAgICAgIGdlbi5jb2RlKGJvZHkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi5mdW5jKHZhbGlkYXRlTmFtZSwgY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LmRhdGF9LCAke2Rlc3RydWN0dXJlVmFsQ3h0KG9wdHMpfWAsIHNjaGVtYUVudi4kYXN5bmMsICgpID0+IGdlbi5jb2RlKGZ1bmNTb3VyY2VVcmwoc2NoZW1hLCBvcHRzKSkuY29kZShib2R5KSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVzdHJ1Y3R1cmVWYWxDeHQob3B0cykge1xuICAgIHJldHVybiBjb2RlZ2VuXzEuXyBgeyR7bmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aH09XCJcIiwgJHtuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YX0sICR7bmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGFQcm9wZXJ0eX0sICR7bmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhfT0ke25hbWVzXzEuZGVmYXVsdC5kYXRhfSR7b3B0cy5keW5hbWljUmVmID8gY29kZWdlbl8xLl8gYCwgJHtuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnN9PXt9YCA6IGNvZGVnZW5fMS5uaWx9fT17fWA7XG59XG5mdW5jdGlvbiBkZXN0cnVjdHVyZVZhbEN4dEVTNShnZW4sIG9wdHMpIHtcbiAgICBnZW4uaWYobmFtZXNfMS5kZWZhdWx0LnZhbEN4dCwgKCkgPT4ge1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsIGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9LiR7bmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aH1gKTtcbiAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YSwgY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LnZhbEN4dH0uJHtuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YX1gKTtcbiAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YVByb3BlcnR5LCBjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQudmFsQ3h0fS4ke25hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHl9YCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhLCBjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQudmFsQ3h0fS4ke25hbWVzXzEuZGVmYXVsdC5yb290RGF0YX1gKTtcbiAgICAgICAgaWYgKG9wdHMuZHluYW1pY1JlZilcbiAgICAgICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LmR5bmFtaWNBbmNob3JzLCBjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQudmFsQ3h0fS4ke25hbWVzXzEuZGVmYXVsdC5keW5hbWljQW5jaG9yc31gKTtcbiAgICB9LCAoKSA9PiB7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aCwgY29kZWdlbl8xLl8gYFwiXCJgKTtcbiAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YSwgY29kZWdlbl8xLl8gYHVuZGVmaW5lZGApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHksIGNvZGVnZW5fMS5fIGB1bmRlZmluZWRgKTtcbiAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQucm9vdERhdGEsIG5hbWVzXzEuZGVmYXVsdC5kYXRhKTtcbiAgICAgICAgaWYgKG9wdHMuZHluYW1pY1JlZilcbiAgICAgICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LmR5bmFtaWNBbmNob3JzLCBjb2RlZ2VuXzEuXyBge31gKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHRvcFNjaGVtYU9iakNvZGUoaXQpIHtcbiAgICBjb25zdCB7IHNjaGVtYSwgb3B0cywgZ2VuIH0gPSBpdDtcbiAgICB2YWxpZGF0ZUZ1bmN0aW9uKGl0LCAoKSA9PiB7XG4gICAgICAgIGlmIChvcHRzLiRjb21tZW50ICYmIHNjaGVtYS4kY29tbWVudClcbiAgICAgICAgICAgIGNvbW1lbnRLZXl3b3JkKGl0KTtcbiAgICAgICAgY2hlY2tOb0RlZmF1bHQoaXQpO1xuICAgICAgICBnZW4ubGV0KG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCBudWxsKTtcbiAgICAgICAgZ2VuLmxldChuYW1lc18xLmRlZmF1bHQuZXJyb3JzLCAwKTtcbiAgICAgICAgaWYgKG9wdHMudW5ldmFsdWF0ZWQpXG4gICAgICAgICAgICByZXNldEV2YWx1YXRlZChpdCk7XG4gICAgICAgIHR5cGVBbmRLZXl3b3JkcyhpdCk7XG4gICAgICAgIHJldHVyblJlc3VsdHMoaXQpO1xuICAgIH0pO1xuICAgIHJldHVybjtcbn1cbmZ1bmN0aW9uIHJlc2V0RXZhbHVhdGVkKGl0KSB7XG4gICAgLy8gVE9ETyBtYXliZSBzb21lIGhvb2sgdG8gZXhlY3V0ZSBpdCBpbiB0aGUgZW5kIHRvIGNoZWNrIHdoZXRoZXIgcHJvcHMvaXRlbXMgYXJlIE5hbWUsIGFzIGluIGFzc2lnbkV2YWx1YXRlZFxuICAgIGNvbnN0IHsgZ2VuLCB2YWxpZGF0ZU5hbWUgfSA9IGl0O1xuICAgIGl0LmV2YWx1YXRlZCA9IGdlbi5jb25zdChcImV2YWx1YXRlZFwiLCBjb2RlZ2VuXzEuXyBgJHt2YWxpZGF0ZU5hbWV9LmV2YWx1YXRlZGApO1xuICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtpdC5ldmFsdWF0ZWR9LmR5bmFtaWNQcm9wc2AsICgpID0+IGdlbi5hc3NpZ24oY29kZWdlbl8xLl8gYCR7aXQuZXZhbHVhdGVkfS5wcm9wc2AsIGNvZGVnZW5fMS5fIGB1bmRlZmluZWRgKSk7XG4gICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke2l0LmV2YWx1YXRlZH0uZHluYW1pY0l0ZW1zYCwgKCkgPT4gZ2VuLmFzc2lnbihjb2RlZ2VuXzEuXyBgJHtpdC5ldmFsdWF0ZWR9Lml0ZW1zYCwgY29kZWdlbl8xLl8gYHVuZGVmaW5lZGApKTtcbn1cbmZ1bmN0aW9uIGZ1bmNTb3VyY2VVcmwoc2NoZW1hLCBvcHRzKSB7XG4gICAgY29uc3Qgc2NoSWQgPSB0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgc2NoZW1hW29wdHMuc2NoZW1hSWRdO1xuICAgIHJldHVybiBzY2hJZCAmJiAob3B0cy5jb2RlLnNvdXJjZSB8fCBvcHRzLmNvZGUucHJvY2VzcykgPyBjb2RlZ2VuXzEuXyBgLyojIHNvdXJjZVVSTD0ke3NjaElkfSAqL2AgOiBjb2RlZ2VuXzEubmlsO1xufVxuLy8gc2NoZW1hIGNvbXBpbGF0aW9uIC0gdGhpcyBmdW5jdGlvbiBpcyB1c2VkIHJlY3Vyc2l2ZWx5IHRvIGdlbmVyYXRlIGNvZGUgZm9yIHN1Yi1zY2hlbWFzXG5mdW5jdGlvbiBzdWJzY2hlbWFDb2RlKGl0LCB2YWxpZCkge1xuICAgIGlmIChpc1NjaGVtYU9iaihpdCkpIHtcbiAgICAgICAgY2hlY2tLZXl3b3JkcyhpdCk7XG4gICAgICAgIGlmIChzY2hlbWFDeHRIYXNSdWxlcyhpdCkpIHtcbiAgICAgICAgICAgIHN1YlNjaGVtYU9iakNvZGUoaXQsIHZhbGlkKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBib29sU2NoZW1hXzEuYm9vbE9yRW1wdHlTY2hlbWEoaXQsIHZhbGlkKTtcbn1cbmZ1bmN0aW9uIHNjaGVtYUN4dEhhc1J1bGVzKHsgc2NoZW1hLCBzZWxmIH0pIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuICFzY2hlbWE7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKVxuICAgICAgICBpZiAoc2VsZi5SVUxFUy5hbGxba2V5XSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzU2NoZW1hT2JqKGl0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpdC5zY2hlbWEgIT0gXCJib29sZWFuXCI7XG59XG5mdW5jdGlvbiBzdWJTY2hlbWFPYmpDb2RlKGl0LCB2YWxpZCkge1xuICAgIGNvbnN0IHsgc2NoZW1hLCBnZW4sIG9wdHMgfSA9IGl0O1xuICAgIGlmIChvcHRzLiRjb21tZW50ICYmIHNjaGVtYS4kY29tbWVudClcbiAgICAgICAgY29tbWVudEtleXdvcmQoaXQpO1xuICAgIHVwZGF0ZUNvbnRleHQoaXQpO1xuICAgIGNoZWNrQXN5bmNTY2hlbWEoaXQpO1xuICAgIGNvbnN0IGVycnNDb3VudCA9IGdlbi5jb25zdChcIl9lcnJzXCIsIG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMpO1xuICAgIHR5cGVBbmRLZXl3b3JkcyhpdCwgZXJyc0NvdW50KTtcbiAgICAvLyBUT0RPIHZhclxuICAgIGdlbi52YXIodmFsaWQsIGNvZGVnZW5fMS5fIGAke2VycnNDb3VudH0gPT09ICR7bmFtZXNfMS5kZWZhdWx0LmVycm9yc31gKTtcbn1cbmZ1bmN0aW9uIGNoZWNrS2V5d29yZHMoaXQpIHtcbiAgICB1dGlsXzEuY2hlY2tVbmtub3duUnVsZXMoaXQpO1xuICAgIGNoZWNrUmVmc0FuZEtleXdvcmRzKGl0KTtcbn1cbmZ1bmN0aW9uIHR5cGVBbmRLZXl3b3JkcyhpdCwgZXJyc0NvdW50KSB7XG4gICAgaWYgKGl0Lm9wdHMuanRkKVxuICAgICAgICByZXR1cm4gc2NoZW1hS2V5d29yZHMoaXQsIFtdLCBmYWxzZSwgZXJyc0NvdW50KTtcbiAgICBjb25zdCB0eXBlcyA9IGRhdGFUeXBlXzEuZ2V0U2NoZW1hVHlwZXMoaXQuc2NoZW1hKTtcbiAgICBjb25zdCBjaGVja2VkVHlwZXMgPSBkYXRhVHlwZV8xLmNvZXJjZUFuZENoZWNrRGF0YVR5cGUoaXQsIHR5cGVzKTtcbiAgICBzY2hlbWFLZXl3b3JkcyhpdCwgdHlwZXMsICFjaGVja2VkVHlwZXMsIGVycnNDb3VudCk7XG59XG5mdW5jdGlvbiBjaGVja1JlZnNBbmRLZXl3b3JkcyhpdCkge1xuICAgIGNvbnN0IHsgc2NoZW1hLCBlcnJTY2hlbWFQYXRoLCBvcHRzLCBzZWxmIH0gPSBpdDtcbiAgICBpZiAoc2NoZW1hLiRyZWYgJiYgb3B0cy5pZ25vcmVLZXl3b3Jkc1dpdGhSZWYgJiYgdXRpbF8xLnNjaGVtYUhhc1J1bGVzQnV0UmVmKHNjaGVtYSwgc2VsZi5SVUxFUykpIHtcbiAgICAgICAgc2VsZi5sb2dnZXIud2FybihgJHJlZjoga2V5d29yZHMgaWdub3JlZCBpbiBzY2hlbWEgYXQgcGF0aCBcIiR7ZXJyU2NoZW1hUGF0aH1cImApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrTm9EZWZhdWx0KGl0KSB7XG4gICAgY29uc3QgeyBzY2hlbWEsIG9wdHMgfSA9IGl0O1xuICAgIGlmIChzY2hlbWEuZGVmYXVsdCAhPT0gdW5kZWZpbmVkICYmIG9wdHMudXNlRGVmYXVsdHMgJiYgb3B0cy5zdHJpY3RTY2hlbWEpIHtcbiAgICAgICAgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZShpdCwgXCJkZWZhdWx0IGlzIGlnbm9yZWQgaW4gdGhlIHNjaGVtYSByb290XCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZUNvbnRleHQoaXQpIHtcbiAgICBjb25zdCBzY2hJZCA9IGl0LnNjaGVtYVtpdC5vcHRzLnNjaGVtYUlkXTtcbiAgICBpZiAoc2NoSWQpXG4gICAgICAgIGl0LmJhc2VJZCA9IHJlc29sdmVfMS5yZXNvbHZlVXJsKGl0LmJhc2VJZCwgc2NoSWQpO1xufVxuZnVuY3Rpb24gY2hlY2tBc3luY1NjaGVtYShpdCkge1xuICAgIGlmIChpdC5zY2hlbWEuJGFzeW5jICYmICFpdC5zY2hlbWFFbnYuJGFzeW5jKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhc3luYyBzY2hlbWEgaW4gc3luYyBzY2hlbWFcIik7XG59XG5mdW5jdGlvbiBjb21tZW50S2V5d29yZCh7IGdlbiwgc2NoZW1hRW52LCBzY2hlbWEsIGVyclNjaGVtYVBhdGgsIG9wdHMgfSkge1xuICAgIGNvbnN0IG1zZyA9IHNjaGVtYS4kY29tbWVudDtcbiAgICBpZiAob3B0cy4kY29tbWVudCA9PT0gdHJ1ZSkge1xuICAgICAgICBnZW4uY29kZShjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQuc2VsZn0ubG9nZ2VyLmxvZygke21zZ30pYCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRzLiRjb21tZW50ID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCBzY2hlbWFQYXRoID0gY29kZWdlbl8xLnN0ciBgJHtlcnJTY2hlbWFQYXRofS8kY29tbWVudGA7XG4gICAgICAgIGNvbnN0IHJvb3ROYW1lID0gZ2VuLnNjb3BlVmFsdWUoXCJyb290XCIsIHsgcmVmOiBzY2hlbWFFbnYucm9vdCB9KTtcbiAgICAgICAgZ2VuLmNvZGUoY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LnNlbGZ9Lm9wdHMuJGNvbW1lbnQoJHttc2d9LCAke3NjaGVtYVBhdGh9LCAke3Jvb3ROYW1lfS5zY2hlbWEpYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmV0dXJuUmVzdWx0cyhpdCkge1xuICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWFFbnYsIHZhbGlkYXRlTmFtZSwgVmFsaWRhdGlvbkVycm9yLCBvcHRzIH0gPSBpdDtcbiAgICBpZiAoc2NoZW1hRW52LiRhc3luYykge1xuICAgICAgICAvLyBUT0RPIGFzc2lnbiB1bmV2YWx1YXRlZFxuICAgICAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LmVycm9yc30gPT09IDBgLCAoKSA9PiBnZW4ucmV0dXJuKG5hbWVzXzEuZGVmYXVsdC5kYXRhKSwgKCkgPT4gZ2VuLnRocm93KGNvZGVnZW5fMS5fIGBuZXcgJHtWYWxpZGF0aW9uRXJyb3J9KCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9KWApKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi5hc3NpZ24oY29kZWdlbl8xLl8gYCR7dmFsaWRhdGVOYW1lfS5lcnJvcnNgLCBuYW1lc18xLmRlZmF1bHQudkVycm9ycyk7XG4gICAgICAgIGlmIChvcHRzLnVuZXZhbHVhdGVkKVxuICAgICAgICAgICAgYXNzaWduRXZhbHVhdGVkKGl0KTtcbiAgICAgICAgZ2VuLnJldHVybihjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQuZXJyb3JzfSA9PT0gMGApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2lnbkV2YWx1YXRlZCh7IGdlbiwgZXZhbHVhdGVkLCBwcm9wcywgaXRlbXMgfSkge1xuICAgIGlmIChwcm9wcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lKVxuICAgICAgICBnZW4uYXNzaWduKGNvZGVnZW5fMS5fIGAke2V2YWx1YXRlZH0ucHJvcHNgLCBwcm9wcyk7XG4gICAgaWYgKGl0ZW1zIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUpXG4gICAgICAgIGdlbi5hc3NpZ24oY29kZWdlbl8xLl8gYCR7ZXZhbHVhdGVkfS5pdGVtc2AsIGl0ZW1zKTtcbn1cbmZ1bmN0aW9uIHNjaGVtYUtleXdvcmRzKGl0LCB0eXBlcywgdHlwZUVycm9ycywgZXJyc0NvdW50KSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgZGF0YSwgYWxsRXJyb3JzLCBvcHRzLCBzZWxmIH0gPSBpdDtcbiAgICBjb25zdCB7IFJVTEVTIH0gPSBzZWxmO1xuICAgIGlmIChzY2hlbWEuJHJlZiAmJiAob3B0cy5pZ25vcmVLZXl3b3Jkc1dpdGhSZWYgfHwgIXV0aWxfMS5zY2hlbWFIYXNSdWxlc0J1dFJlZihzY2hlbWEsIFJVTEVTKSkpIHtcbiAgICAgICAgZ2VuLmJsb2NrKCgpID0+IGtleXdvcmRDb2RlKGl0LCBcIiRyZWZcIiwgUlVMRVMuYWxsLiRyZWYuZGVmaW5pdGlvbikpOyAvLyBUT0RPIHR5cGVjYXN0XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFvcHRzLmp0ZClcbiAgICAgICAgY2hlY2tTdHJpY3RUeXBlcyhpdCwgdHlwZXMpO1xuICAgIGdlbi5ibG9jaygoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgUlVMRVMucnVsZXMpXG4gICAgICAgICAgICBncm91cEtleXdvcmRzKGdyb3VwKTtcbiAgICAgICAgZ3JvdXBLZXl3b3JkcyhSVUxFUy5wb3N0KTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBncm91cEtleXdvcmRzKGdyb3VwKSB7XG4gICAgICAgIGlmICghYXBwbGljYWJpbGl0eV8xLnNob3VsZFVzZUdyb3VwKHNjaGVtYSwgZ3JvdXApKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZ3JvdXAudHlwZSkge1xuICAgICAgICAgICAgZ2VuLmlmKGRhdGFUeXBlXzIuY2hlY2tEYXRhVHlwZShncm91cC50eXBlLCBkYXRhLCBvcHRzLnN0cmljdE51bWJlcnMpKTtcbiAgICAgICAgICAgIGl0ZXJhdGVLZXl3b3JkcyhpdCwgZ3JvdXApO1xuICAgICAgICAgICAgaWYgKHR5cGVzLmxlbmd0aCA9PT0gMSAmJiB0eXBlc1swXSA9PT0gZ3JvdXAudHlwZSAmJiB0eXBlRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgZ2VuLmVsc2UoKTtcbiAgICAgICAgICAgICAgICBkYXRhVHlwZV8yLnJlcG9ydFR5cGVFcnJvcihpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZW4uZW5kSWYoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGl0ZXJhdGVLZXl3b3JkcyhpdCwgZ3JvdXApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8gbWFrZSBpdCBcIm9rXCIgY2FsbD9cbiAgICAgICAgaWYgKCFhbGxFcnJvcnMpXG4gICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LmVycm9yc30gPT09ICR7ZXJyc0NvdW50IHx8IDB9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXRlcmF0ZUtleXdvcmRzKGl0LCBncm91cCkge1xuICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIG9wdHM6IHsgdXNlRGVmYXVsdHMgfSwgfSA9IGl0O1xuICAgIGlmICh1c2VEZWZhdWx0cylcbiAgICAgICAgZGVmYXVsdHNfMS5hc3NpZ25EZWZhdWx0cyhpdCwgZ3JvdXAudHlwZSk7XG4gICAgZ2VuLmJsb2NrKCgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBydWxlIG9mIGdyb3VwLnJ1bGVzKSB7XG4gICAgICAgICAgICBpZiAoYXBwbGljYWJpbGl0eV8xLnNob3VsZFVzZVJ1bGUoc2NoZW1hLCBydWxlKSkge1xuICAgICAgICAgICAgICAgIGtleXdvcmRDb2RlKGl0LCBydWxlLmtleXdvcmQsIHJ1bGUuZGVmaW5pdGlvbiwgZ3JvdXAudHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNoZWNrU3RyaWN0VHlwZXMoaXQsIHR5cGVzKSB7XG4gICAgaWYgKGl0LnNjaGVtYUVudi5tZXRhIHx8ICFpdC5vcHRzLnN0cmljdFR5cGVzKVxuICAgICAgICByZXR1cm47XG4gICAgY2hlY2tDb250ZXh0VHlwZXMoaXQsIHR5cGVzKTtcbiAgICBpZiAoIWl0Lm9wdHMuYWxsb3dVbmlvblR5cGVzKVxuICAgICAgICBjaGVja011bHRpcGxlVHlwZXMoaXQsIHR5cGVzKTtcbiAgICBjaGVja0tleXdvcmRUeXBlcyhpdCwgaXQuZGF0YVR5cGVzKTtcbn1cbmZ1bmN0aW9uIGNoZWNrQ29udGV4dFR5cGVzKGl0LCB0eXBlcykge1xuICAgIGlmICghdHlwZXMubGVuZ3RoKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCFpdC5kYXRhVHlwZXMubGVuZ3RoKSB7XG4gICAgICAgIGl0LmRhdGFUeXBlcyA9IHR5cGVzO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHR5cGVzLmZvckVhY2goKHQpID0+IHtcbiAgICAgICAgaWYgKCFpbmNsdWRlc1R5cGUoaXQuZGF0YVR5cGVzLCB0KSkge1xuICAgICAgICAgICAgc3RyaWN0VHlwZXNFcnJvcihpdCwgYHR5cGUgXCIke3R9XCIgbm90IGFsbG93ZWQgYnkgY29udGV4dCBcIiR7aXQuZGF0YVR5cGVzLmpvaW4oXCIsXCIpfVwiYCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpdC5kYXRhVHlwZXMgPSBpdC5kYXRhVHlwZXMuZmlsdGVyKCh0KSA9PiBpbmNsdWRlc1R5cGUodHlwZXMsIHQpKTtcbn1cbmZ1bmN0aW9uIGNoZWNrTXVsdGlwbGVUeXBlcyhpdCwgdHMpIHtcbiAgICBpZiAodHMubGVuZ3RoID4gMSAmJiAhKHRzLmxlbmd0aCA9PT0gMiAmJiB0cy5pbmNsdWRlcyhcIm51bGxcIikpKSB7XG4gICAgICAgIHN0cmljdFR5cGVzRXJyb3IoaXQsIFwidXNlIGFsbG93VW5pb25UeXBlcyB0byBhbGxvdyB1bmlvbiB0eXBlIGtleXdvcmRcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tLZXl3b3JkVHlwZXMoaXQsIHRzKSB7XG4gICAgY29uc3QgcnVsZXMgPSBpdC5zZWxmLlJVTEVTLmFsbDtcbiAgICBmb3IgKGNvbnN0IGtleXdvcmQgaW4gcnVsZXMpIHtcbiAgICAgICAgY29uc3QgcnVsZSA9IHJ1bGVzW2tleXdvcmRdO1xuICAgICAgICBpZiAodHlwZW9mIHJ1bGUgPT0gXCJvYmplY3RcIiAmJiBhcHBsaWNhYmlsaXR5XzEuc2hvdWxkVXNlUnVsZShpdC5zY2hlbWEsIHJ1bGUpKSB7XG4gICAgICAgICAgICBjb25zdCB7IHR5cGUgfSA9IHJ1bGUuZGVmaW5pdGlvbjtcbiAgICAgICAgICAgIGlmICh0eXBlLmxlbmd0aCAmJiAhdHlwZS5zb21lKCh0KSA9PiBoYXNBcHBsaWNhYmxlVHlwZSh0cywgdCkpKSB7XG4gICAgICAgICAgICAgICAgc3RyaWN0VHlwZXNFcnJvcihpdCwgYG1pc3NpbmcgdHlwZSBcIiR7dHlwZS5qb2luKFwiLFwiKX1cIiBmb3Iga2V5d29yZCBcIiR7a2V5d29yZH1cImApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzQXBwbGljYWJsZVR5cGUoc2NoVHMsIGt3ZFQpIHtcbiAgICByZXR1cm4gc2NoVHMuaW5jbHVkZXMoa3dkVCkgfHwgKGt3ZFQgPT09IFwibnVtYmVyXCIgJiYgc2NoVHMuaW5jbHVkZXMoXCJpbnRlZ2VyXCIpKTtcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzVHlwZSh0cywgdCkge1xuICAgIHJldHVybiB0cy5pbmNsdWRlcyh0KSB8fCAodCA9PT0gXCJpbnRlZ2VyXCIgJiYgdHMuaW5jbHVkZXMoXCJudW1iZXJcIikpO1xufVxuZnVuY3Rpb24gc3RyaWN0VHlwZXNFcnJvcihpdCwgbXNnKSB7XG4gICAgY29uc3Qgc2NoZW1hUGF0aCA9IGl0LnNjaGVtYUVudi5iYXNlSWQgKyBpdC5lcnJTY2hlbWFQYXRoO1xuICAgIG1zZyArPSBgIGF0IFwiJHtzY2hlbWFQYXRofVwiIChzdHJpY3RUeXBlcylgO1xuICAgIHV0aWxfMS5jaGVja1N0cmljdE1vZGUoaXQsIG1zZywgaXQub3B0cy5zdHJpY3RUeXBlcyk7XG59XG5jbGFzcyBLZXl3b3JkQ3h0IHtcbiAgICBjb25zdHJ1Y3RvcihpdCwgZGVmLCBrZXl3b3JkKSB7XG4gICAgICAgIGtleXdvcmRfMS52YWxpZGF0ZUtleXdvcmRVc2FnZShpdCwgZGVmLCBrZXl3b3JkKTtcbiAgICAgICAgdGhpcy5nZW4gPSBpdC5nZW47XG4gICAgICAgIHRoaXMuYWxsRXJyb3JzID0gaXQuYWxsRXJyb3JzO1xuICAgICAgICB0aGlzLmtleXdvcmQgPSBrZXl3b3JkO1xuICAgICAgICB0aGlzLmRhdGEgPSBpdC5kYXRhO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IGl0LnNjaGVtYVtrZXl3b3JkXTtcbiAgICAgICAgdGhpcy4kZGF0YSA9IGRlZi4kZGF0YSAmJiBpdC5vcHRzLiRkYXRhICYmIHRoaXMuc2NoZW1hICYmIHRoaXMuc2NoZW1hLiRkYXRhO1xuICAgICAgICB0aGlzLnNjaGVtYVZhbHVlID0gdXRpbF8xLnNjaGVtYVJlZk9yVmFsKGl0LCB0aGlzLnNjaGVtYSwga2V5d29yZCwgdGhpcy4kZGF0YSk7XG4gICAgICAgIHRoaXMuc2NoZW1hVHlwZSA9IGRlZi5zY2hlbWFUeXBlO1xuICAgICAgICB0aGlzLnBhcmVudFNjaGVtYSA9IGl0LnNjaGVtYTtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSB7fTtcbiAgICAgICAgdGhpcy5pdCA9IGl0O1xuICAgICAgICB0aGlzLmRlZiA9IGRlZjtcbiAgICAgICAgaWYgKHRoaXMuJGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuc2NoZW1hQ29kZSA9IGl0Lmdlbi5jb25zdChcInZTY2hlbWFcIiwgZ2V0RGF0YSh0aGlzLiRkYXRhLCBpdCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zY2hlbWFDb2RlID0gdGhpcy5zY2hlbWFWYWx1ZTtcbiAgICAgICAgICAgIGlmICgha2V5d29yZF8xLnZhbGlkU2NoZW1hVHlwZSh0aGlzLnNjaGVtYSwgZGVmLnNjaGVtYVR5cGUsIGRlZi5hbGxvd1VuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7a2V5d29yZH0gdmFsdWUgbXVzdCBiZSAke0pTT04uc3RyaW5naWZ5KGRlZi5zY2hlbWFUeXBlKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJjb2RlXCIgaW4gZGVmID8gZGVmLnRyYWNrRXJyb3JzIDogZGVmLmVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc0NvdW50ID0gaXQuZ2VuLmNvbnN0KFwiX2VycnNcIiwgbmFtZXNfMS5kZWZhdWx0LmVycm9ycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0KGNvbmRpdGlvbiwgc3VjY2Vzc0FjdGlvbiwgZmFpbEFjdGlvbikge1xuICAgICAgICB0aGlzLmZhaWxSZXN1bHQoY29kZWdlbl8xLm5vdChjb25kaXRpb24pLCBzdWNjZXNzQWN0aW9uLCBmYWlsQWN0aW9uKTtcbiAgICB9XG4gICAgZmFpbFJlc3VsdChjb25kaXRpb24sIHN1Y2Nlc3NBY3Rpb24sIGZhaWxBY3Rpb24pIHtcbiAgICAgICAgdGhpcy5nZW4uaWYoY29uZGl0aW9uKTtcbiAgICAgICAgaWYgKGZhaWxBY3Rpb24pXG4gICAgICAgICAgICBmYWlsQWN0aW9uKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoKTtcbiAgICAgICAgaWYgKHN1Y2Nlc3NBY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZ2VuLmVsc2UoKTtcbiAgICAgICAgICAgIHN1Y2Nlc3NBY3Rpb24oKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFsbEVycm9ycylcbiAgICAgICAgICAgICAgICB0aGlzLmdlbi5lbmRJZigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuLmVuZElmKCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5nZW4uZWxzZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhc3MoY29uZGl0aW9uLCBmYWlsQWN0aW9uKSB7XG4gICAgICAgIHRoaXMuZmFpbFJlc3VsdChjb2RlZ2VuXzEubm90KGNvbmRpdGlvbiksIHVuZGVmaW5lZCwgZmFpbEFjdGlvbik7XG4gICAgfVxuICAgIGZhaWwoY29uZGl0aW9uKSB7XG4gICAgICAgIGlmIChjb25kaXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcigpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFsbEVycm9ycylcbiAgICAgICAgICAgICAgICB0aGlzLmdlbi5pZihmYWxzZSk7IC8vIHRoaXMgYnJhbmNoIHdpbGwgYmUgcmVtb3ZlZCBieSBnZW4ub3B0aW1pemVcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdlbi5pZihjb25kaXRpb24pO1xuICAgICAgICB0aGlzLmVycm9yKCk7XG4gICAgICAgIGlmICh0aGlzLmFsbEVycm9ycylcbiAgICAgICAgICAgIHRoaXMuZ2VuLmVuZElmKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuZ2VuLmVsc2UoKTtcbiAgICB9XG4gICAgZmFpbCRkYXRhKGNvbmRpdGlvbikge1xuICAgICAgICBpZiAoIXRoaXMuJGRhdGEpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mYWlsKGNvbmRpdGlvbik7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hQ29kZSB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5mYWlsKGNvZGVnZW5fMS5fIGAke3NjaGVtYUNvZGV9ICE9PSB1bmRlZmluZWQgJiYgKCR7Y29kZWdlbl8xLm9yKHRoaXMuaW52YWxpZCRkYXRhKCksIGNvbmRpdGlvbil9KWApO1xuICAgIH1cbiAgICBlcnJvcihhcHBlbmQsIGVycm9yUGFyYW1zLCBlcnJvclBhdGhzKSB7XG4gICAgICAgIGlmIChlcnJvclBhcmFtcykge1xuICAgICAgICAgICAgdGhpcy5zZXRQYXJhbXMoZXJyb3JQYXJhbXMpO1xuICAgICAgICAgICAgdGhpcy5fZXJyb3IoYXBwZW5kLCBlcnJvclBhdGhzKTtcbiAgICAgICAgICAgIHRoaXMuc2V0UGFyYW1zKHt9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lcnJvcihhcHBlbmQsIGVycm9yUGF0aHMpO1xuICAgIH1cbiAgICBfZXJyb3IoYXBwZW5kLCBlcnJvclBhdGhzKSB7XG4gICAgICAgIDtcbiAgICAgICAgKGFwcGVuZCA/IGVycm9yc18xLnJlcG9ydEV4dHJhRXJyb3IgOiBlcnJvcnNfMS5yZXBvcnRFcnJvcikodGhpcywgdGhpcy5kZWYuZXJyb3IsIGVycm9yUGF0aHMpO1xuICAgIH1cbiAgICAkZGF0YUVycm9yKCkge1xuICAgICAgICBlcnJvcnNfMS5yZXBvcnRFcnJvcih0aGlzLCB0aGlzLmRlZi4kZGF0YUVycm9yIHx8IGVycm9yc18xLmtleXdvcmQkRGF0YUVycm9yKTtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmVycnNDb3VudCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZGQgXCJ0cmFja0Vycm9yc1wiIHRvIGtleXdvcmQgZGVmaW5pdGlvbicpO1xuICAgICAgICBlcnJvcnNfMS5yZXNldEVycm9yc0NvdW50KHRoaXMuZ2VuLCB0aGlzLmVycnNDb3VudCk7XG4gICAgfVxuICAgIG9rKGNvbmQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFsbEVycm9ycylcbiAgICAgICAgICAgIHRoaXMuZ2VuLmlmKGNvbmQpO1xuICAgIH1cbiAgICBzZXRQYXJhbXMob2JqLCBhc3NpZ24pIHtcbiAgICAgICAgaWYgKGFzc2lnbilcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5wYXJhbXMsIG9iaik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucGFyYW1zID0gb2JqO1xuICAgIH1cbiAgICBibG9jayRkYXRhKHZhbGlkLCBjb2RlQmxvY2ssICRkYXRhVmFsaWQgPSBjb2RlZ2VuXzEubmlsKSB7XG4gICAgICAgIHRoaXMuZ2VuLmJsb2NrKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2skZGF0YSh2YWxpZCwgJGRhdGFWYWxpZCk7XG4gICAgICAgICAgICBjb2RlQmxvY2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNoZWNrJGRhdGEodmFsaWQgPSBjb2RlZ2VuXzEubmlsLCAkZGF0YVZhbGlkID0gY29kZWdlbl8xLm5pbCkge1xuICAgICAgICBpZiAoIXRoaXMuJGRhdGEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWFDb2RlLCBzY2hlbWFUeXBlLCBkZWYgfSA9IHRoaXM7XG4gICAgICAgIGdlbi5pZihjb2RlZ2VuXzEub3IoY29kZWdlbl8xLl8gYCR7c2NoZW1hQ29kZX0gPT09IHVuZGVmaW5lZGAsICRkYXRhVmFsaWQpKTtcbiAgICAgICAgaWYgKHZhbGlkICE9PSBjb2RlZ2VuXzEubmlsKVxuICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSk7XG4gICAgICAgIGlmIChzY2hlbWFUeXBlLmxlbmd0aCB8fCBkZWYudmFsaWRhdGVTY2hlbWEpIHtcbiAgICAgICAgICAgIGdlbi5lbHNlSWYodGhpcy5pbnZhbGlkJGRhdGEoKSk7XG4gICAgICAgICAgICB0aGlzLiRkYXRhRXJyb3IoKTtcbiAgICAgICAgICAgIGlmICh2YWxpZCAhPT0gY29kZWdlbl8xLm5pbClcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2VuLmVsc2UoKTtcbiAgICB9XG4gICAgaW52YWxpZCRkYXRhKCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hQ29kZSwgc2NoZW1hVHlwZSwgZGVmLCBpdCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5vcih3cm9uZyREYXRhVHlwZSgpLCBpbnZhbGlkJERhdGFTY2hlbWEoKSk7XG4gICAgICAgIGZ1bmN0aW9uIHdyb25nJERhdGFUeXBlKCkge1xuICAgICAgICAgICAgaWYgKHNjaGVtYVR5cGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKCEoc2NoZW1hQ29kZSBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0ID0gQXJyYXkuaXNBcnJheShzY2hlbWFUeXBlKSA/IHNjaGVtYVR5cGUgOiBbc2NoZW1hVHlwZV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5fIGAke2RhdGFUeXBlXzIuY2hlY2tEYXRhVHlwZXMoc3QsIHNjaGVtYUNvZGUsIGl0Lm9wdHMuc3RyaWN0TnVtYmVycywgZGF0YVR5cGVfMi5EYXRhVHlwZS5Xcm9uZyl9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEubmlsO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGludmFsaWQkRGF0YVNjaGVtYSgpIHtcbiAgICAgICAgICAgIGlmIChkZWYudmFsaWRhdGVTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZGF0ZVNjaGVtYVJlZiA9IGdlbi5zY29wZVZhbHVlKFwidmFsaWRhdGUkZGF0YVwiLCB7IHJlZjogZGVmLnZhbGlkYXRlU2NoZW1hIH0pOyAvLyBUT0RPIHZhbHVlLmNvZGUgZm9yIHN0YW5kYWxvbmVcbiAgICAgICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLl8gYCEke3ZhbGlkYXRlU2NoZW1hUmVmfSgke3NjaGVtYUNvZGV9KWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLm5pbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdWJzY2hlbWEoYXBwbCwgdmFsaWQpIHtcbiAgICAgICAgY29uc3Qgc3Vic2NoZW1hID0gc3Vic2NoZW1hXzEuZ2V0U3Vic2NoZW1hKHRoaXMuaXQsIGFwcGwpO1xuICAgICAgICBzdWJzY2hlbWFfMS5leHRlbmRTdWJzY2hlbWFEYXRhKHN1YnNjaGVtYSwgdGhpcy5pdCwgYXBwbCk7XG4gICAgICAgIHN1YnNjaGVtYV8xLmV4dGVuZFN1YnNjaGVtYU1vZGUoc3Vic2NoZW1hLCBhcHBsKTtcbiAgICAgICAgY29uc3QgbmV4dENvbnRleHQgPSB7IC4uLnRoaXMuaXQsIC4uLnN1YnNjaGVtYSwgaXRlbXM6IHVuZGVmaW5lZCwgcHJvcHM6IHVuZGVmaW5lZCB9O1xuICAgICAgICBzdWJzY2hlbWFDb2RlKG5leHRDb250ZXh0LCB2YWxpZCk7XG4gICAgICAgIHJldHVybiBuZXh0Q29udGV4dDtcbiAgICB9XG4gICAgbWVyZ2VFdmFsdWF0ZWQoc2NoZW1hQ3h0LCB0b05hbWUpIHtcbiAgICAgICAgY29uc3QgeyBpdCwgZ2VuIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIWl0Lm9wdHMudW5ldmFsdWF0ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChpdC5wcm9wcyAhPT0gdHJ1ZSAmJiBzY2hlbWFDeHQucHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaXQucHJvcHMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQucHJvcHMoZ2VuLCBzY2hlbWFDeHQucHJvcHMsIGl0LnByb3BzLCB0b05hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdC5pdGVtcyAhPT0gdHJ1ZSAmJiBzY2hlbWFDeHQuaXRlbXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaXQuaXRlbXMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQuaXRlbXMoZ2VuLCBzY2hlbWFDeHQuaXRlbXMsIGl0Lml0ZW1zLCB0b05hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1lcmdlVmFsaWRFdmFsdWF0ZWQoc2NoZW1hQ3h0LCB2YWxpZCkge1xuICAgICAgICBjb25zdCB7IGl0LCBnZW4gfSA9IHRoaXM7XG4gICAgICAgIGlmIChpdC5vcHRzLnVuZXZhbHVhdGVkICYmIChpdC5wcm9wcyAhPT0gdHJ1ZSB8fCBpdC5pdGVtcyAhPT0gdHJ1ZSkpIHtcbiAgICAgICAgICAgIGdlbi5pZih2YWxpZCwgKCkgPT4gdGhpcy5tZXJnZUV2YWx1YXRlZChzY2hlbWFDeHQsIGNvZGVnZW5fMS5OYW1lKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuS2V5d29yZEN4dCA9IEtleXdvcmRDeHQ7XG5mdW5jdGlvbiBrZXl3b3JkQ29kZShpdCwga2V5d29yZCwgZGVmLCBydWxlVHlwZSkge1xuICAgIGNvbnN0IGN4dCA9IG5ldyBLZXl3b3JkQ3h0KGl0LCBkZWYsIGtleXdvcmQpO1xuICAgIGlmIChcImNvZGVcIiBpbiBkZWYpIHtcbiAgICAgICAgZGVmLmNvZGUoY3h0LCBydWxlVHlwZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGN4dC4kZGF0YSAmJiBkZWYudmFsaWRhdGUpIHtcbiAgICAgICAga2V5d29yZF8xLmZ1bmNLZXl3b3JkQ29kZShjeHQsIGRlZik7XG4gICAgfVxuICAgIGVsc2UgaWYgKFwibWFjcm9cIiBpbiBkZWYpIHtcbiAgICAgICAga2V5d29yZF8xLm1hY3JvS2V5d29yZENvZGUoY3h0LCBkZWYpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkZWYuY29tcGlsZSB8fCBkZWYudmFsaWRhdGUpIHtcbiAgICAgICAga2V5d29yZF8xLmZ1bmNLZXl3b3JkQ29kZShjeHQsIGRlZik7XG4gICAgfVxufVxuY29uc3QgSlNPTl9QT0lOVEVSID0gL15cXC8oPzpbXn5dfH4wfH4xKSokLztcbmNvbnN0IFJFTEFUSVZFX0pTT05fUE9JTlRFUiA9IC9eKFswLTldKykoI3xcXC8oPzpbXn5dfH4wfH4xKSopPyQvO1xuZnVuY3Rpb24gZ2V0RGF0YSgkZGF0YSwgeyBkYXRhTGV2ZWwsIGRhdGFOYW1lcywgZGF0YVBhdGhBcnIgfSkge1xuICAgIGxldCBqc29uUG9pbnRlcjtcbiAgICBsZXQgZGF0YTtcbiAgICBpZiAoJGRhdGEgPT09IFwiXCIpXG4gICAgICAgIHJldHVybiBuYW1lc18xLmRlZmF1bHQucm9vdERhdGE7XG4gICAgaWYgKCRkYXRhWzBdID09PSBcIi9cIikge1xuICAgICAgICBpZiAoIUpTT05fUE9JTlRFUi50ZXN0KCRkYXRhKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBKU09OLXBvaW50ZXI6ICR7JGRhdGF9YCk7XG4gICAgICAgIGpzb25Qb2ludGVyID0gJGRhdGE7XG4gICAgICAgIGRhdGEgPSBuYW1lc18xLmRlZmF1bHQucm9vdERhdGE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gUkVMQVRJVkVfSlNPTl9QT0lOVEVSLmV4ZWMoJGRhdGEpO1xuICAgICAgICBpZiAoIW1hdGNoZXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgSlNPTi1wb2ludGVyOiAkeyRkYXRhfWApO1xuICAgICAgICBjb25zdCB1cCA9ICttYXRjaGVzWzFdO1xuICAgICAgICBqc29uUG9pbnRlciA9IG1hdGNoZXNbMl07XG4gICAgICAgIGlmIChqc29uUG9pbnRlciA9PT0gXCIjXCIpIHtcbiAgICAgICAgICAgIGlmICh1cCA+PSBkYXRhTGV2ZWwpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKFwicHJvcGVydHkvaW5kZXhcIiwgdXApKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhUGF0aEFycltkYXRhTGV2ZWwgLSB1cF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwID4gZGF0YUxldmVsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKFwiZGF0YVwiLCB1cCkpO1xuICAgICAgICBkYXRhID0gZGF0YU5hbWVzW2RhdGFMZXZlbCAtIHVwXTtcbiAgICAgICAgaWYgKCFqc29uUG9pbnRlcilcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBsZXQgZXhwciA9IGRhdGE7XG4gICAgY29uc3Qgc2VnbWVudHMgPSBqc29uUG9pbnRlci5zcGxpdChcIi9cIik7XG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgICAgICBkYXRhID0gY29kZWdlbl8xLl8gYCR7ZGF0YX0ke2NvZGVnZW5fMS5nZXRQcm9wZXJ0eSh1dGlsXzEudW5lc2NhcGVKc29uUG9pbnRlcihzZWdtZW50KSl9YDtcbiAgICAgICAgICAgIGV4cHIgPSBjb2RlZ2VuXzEuXyBgJHtleHByfSAmJiAke2RhdGF9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXhwcjtcbiAgICBmdW5jdGlvbiBlcnJvck1zZyhwb2ludGVyVHlwZSwgdXApIHtcbiAgICAgICAgcmV0dXJuIGBDYW5ub3QgYWNjZXNzICR7cG9pbnRlclR5cGV9ICR7dXB9IGxldmVscyB1cCwgY3VycmVudCBsZXZlbCBpcyAke2RhdGFMZXZlbH1gO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0RGF0YSA9IGdldERhdGE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIFZhbGlkYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihlcnJvcnMpIHtcbiAgICAgICAgc3VwZXIoXCJ2YWxpZGF0aW9uIGZhaWxlZFwiKTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIHRoaXMuYWp2ID0gdGhpcy52YWxpZGF0aW9uID0gdHJ1ZTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBWYWxpZGF0aW9uRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZGF0aW9uX2Vycm9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgcmVzb2x2ZV8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZVwiKTtcbmNsYXNzIE1pc3NpbmdSZWZFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihiYXNlSWQsIHJlZiwgbXNnKSB7XG4gICAgICAgIHN1cGVyKG1zZyB8fCBgY2FuJ3QgcmVzb2x2ZSByZWZlcmVuY2UgJHtyZWZ9IGZyb20gaWQgJHtiYXNlSWR9YCk7XG4gICAgICAgIHRoaXMubWlzc2luZ1JlZiA9IHJlc29sdmVfMS5yZXNvbHZlVXJsKGJhc2VJZCwgcmVmKTtcbiAgICAgICAgdGhpcy5taXNzaW5nU2NoZW1hID0gcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKHJlc29sdmVfMS5nZXRGdWxsUGF0aCh0aGlzLm1pc3NpbmdSZWYpKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBNaXNzaW5nUmVmRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWZfZXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlc29sdmVTY2hlbWEgPSBleHBvcnRzLmdldENvbXBpbGluZ1NjaGVtYSA9IGV4cG9ydHMucmVzb2x2ZVJlZiA9IGV4cG9ydHMuY29tcGlsZVNjaGVtYSA9IGV4cG9ydHMuU2NoZW1hRW52ID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4vY29kZWdlblwiKTtcbmNvbnN0IHZhbGlkYXRpb25fZXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3JcIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4vbmFtZXNcIik7XG5jb25zdCByZXNvbHZlXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IHZhbGlkYXRlXzEgPSByZXF1aXJlKFwiLi92YWxpZGF0ZVwiKTtcbmNvbnN0IFVSSSA9IHJlcXVpcmUoXCJ1cmktanNcIik7XG5jbGFzcyBTY2hlbWFFbnYge1xuICAgIGNvbnN0cnVjdG9yKGVudikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMucmVmcyA9IHt9O1xuICAgICAgICB0aGlzLmR5bmFtaWNBbmNob3JzID0ge307XG4gICAgICAgIGxldCBzY2hlbWE7XG4gICAgICAgIGlmICh0eXBlb2YgZW52LnNjaGVtYSA9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgc2NoZW1hID0gZW52LnNjaGVtYTtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBlbnYuc2NoZW1hO1xuICAgICAgICB0aGlzLnNjaGVtYUlkID0gZW52LnNjaGVtYUlkO1xuICAgICAgICB0aGlzLnJvb3QgPSBlbnYucm9vdCB8fCB0aGlzO1xuICAgICAgICB0aGlzLmJhc2VJZCA9IChfYSA9IGVudi5iYXNlSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHJlc29sdmVfMS5ub3JtYWxpemVJZChzY2hlbWEgPT09IG51bGwgfHwgc2NoZW1hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2hlbWFbZW52LnNjaGVtYUlkIHx8IFwiJGlkXCJdKTtcbiAgICAgICAgdGhpcy5zY2hlbWFQYXRoID0gZW52LnNjaGVtYVBhdGg7XG4gICAgICAgIHRoaXMubG9jYWxSZWZzID0gZW52LmxvY2FsUmVmcztcbiAgICAgICAgdGhpcy5tZXRhID0gZW52Lm1ldGE7XG4gICAgICAgIHRoaXMuJGFzeW5jID0gc2NoZW1hID09PSBudWxsIHx8IHNjaGVtYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoZW1hLiRhc3luYztcbiAgICAgICAgdGhpcy5yZWZzID0ge307XG4gICAgfVxufVxuZXhwb3J0cy5TY2hlbWFFbnYgPSBTY2hlbWFFbnY7XG4vLyBsZXQgY29kZVNpemUgPSAwXG4vLyBsZXQgbm9kZUNvdW50ID0gMFxuLy8gQ29tcGlsZXMgc2NoZW1hIGluIFNjaGVtYUVudlxuZnVuY3Rpb24gY29tcGlsZVNjaGVtYShzY2gpIHtcbiAgICAvLyBUT0RPIHJlZmFjdG9yIC0gcmVtb3ZlIGNvbXBpbGF0aW9uc1xuICAgIGNvbnN0IF9zY2ggPSBnZXRDb21waWxpbmdTY2hlbWEuY2FsbCh0aGlzLCBzY2gpO1xuICAgIGlmIChfc2NoKVxuICAgICAgICByZXR1cm4gX3NjaDtcbiAgICBjb25zdCByb290SWQgPSByZXNvbHZlXzEuZ2V0RnVsbFBhdGgoc2NoLnJvb3QuYmFzZUlkKTsgLy8gVE9ETyBpZiBnZXRGdWxsUGF0aCByZW1vdmVkIDEgdGVzdHMgZmFpbHNcbiAgICBjb25zdCB7IGVzNSwgbGluZXMgfSA9IHRoaXMub3B0cy5jb2RlO1xuICAgIGNvbnN0IHsgb3duUHJvcGVydGllcyB9ID0gdGhpcy5vcHRzO1xuICAgIGNvbnN0IGdlbiA9IG5ldyBjb2RlZ2VuXzEuQ29kZUdlbih0aGlzLnNjb3BlLCB7IGVzNSwgbGluZXMsIG93blByb3BlcnRpZXMgfSk7XG4gICAgbGV0IF9WYWxpZGF0aW9uRXJyb3I7XG4gICAgaWYgKHNjaC4kYXN5bmMpIHtcbiAgICAgICAgX1ZhbGlkYXRpb25FcnJvciA9IGdlbi5zY29wZVZhbHVlKFwiRXJyb3JcIiwge1xuICAgICAgICAgICAgcmVmOiB2YWxpZGF0aW9uX2Vycm9yXzEuZGVmYXVsdCxcbiAgICAgICAgICAgIGNvZGU6IGNvZGVnZW5fMS5fIGByZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS92YWxpZGF0aW9uX2Vycm9yXCIpLmRlZmF1bHRgLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgdmFsaWRhdGVOYW1lID0gZ2VuLnNjb3BlTmFtZShcInZhbGlkYXRlXCIpO1xuICAgIHNjaC52YWxpZGF0ZU5hbWUgPSB2YWxpZGF0ZU5hbWU7XG4gICAgY29uc3Qgc2NoZW1hQ3h0ID0ge1xuICAgICAgICBnZW4sXG4gICAgICAgIGFsbEVycm9yczogdGhpcy5vcHRzLmFsbEVycm9ycyxcbiAgICAgICAgZGF0YTogbmFtZXNfMS5kZWZhdWx0LmRhdGEsXG4gICAgICAgIHBhcmVudERhdGE6IG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhLFxuICAgICAgICBwYXJlbnREYXRhUHJvcGVydHk6IG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHksXG4gICAgICAgIGRhdGFOYW1lczogW25hbWVzXzEuZGVmYXVsdC5kYXRhXSxcbiAgICAgICAgZGF0YVBhdGhBcnI6IFtjb2RlZ2VuXzEubmlsXSxcbiAgICAgICAgZGF0YUxldmVsOiAwLFxuICAgICAgICBkYXRhVHlwZXM6IFtdLFxuICAgICAgICBkZWZpbmVkUHJvcGVydGllczogbmV3IFNldCgpLFxuICAgICAgICB0b3BTY2hlbWFSZWY6IGdlbi5zY29wZVZhbHVlKFwic2NoZW1hXCIsIHRoaXMub3B0cy5jb2RlLnNvdXJjZSA9PT0gdHJ1ZVxuICAgICAgICAgICAgPyB7IHJlZjogc2NoLnNjaGVtYSwgY29kZTogY29kZWdlbl8xLnN0cmluZ2lmeShzY2guc2NoZW1hKSB9XG4gICAgICAgICAgICA6IHsgcmVmOiBzY2guc2NoZW1hIH0pLFxuICAgICAgICB2YWxpZGF0ZU5hbWUsXG4gICAgICAgIFZhbGlkYXRpb25FcnJvcjogX1ZhbGlkYXRpb25FcnJvcixcbiAgICAgICAgc2NoZW1hOiBzY2guc2NoZW1hLFxuICAgICAgICBzY2hlbWFFbnY6IHNjaCxcbiAgICAgICAgcm9vdElkLFxuICAgICAgICBiYXNlSWQ6IHNjaC5iYXNlSWQgfHwgcm9vdElkLFxuICAgICAgICBzY2hlbWFQYXRoOiBjb2RlZ2VuXzEubmlsLFxuICAgICAgICBlcnJTY2hlbWFQYXRoOiBzY2guc2NoZW1hUGF0aCB8fCAodGhpcy5vcHRzLmp0ZCA/IFwiXCIgOiBcIiNcIiksXG4gICAgICAgIGVycm9yUGF0aDogY29kZWdlbl8xLl8gYFwiXCJgLFxuICAgICAgICBvcHRzOiB0aGlzLm9wdHMsXG4gICAgICAgIHNlbGY6IHRoaXMsXG4gICAgfTtcbiAgICBsZXQgc291cmNlQ29kZTtcbiAgICB0cnkge1xuICAgICAgICB0aGlzLl9jb21waWxhdGlvbnMuYWRkKHNjaCk7XG4gICAgICAgIHZhbGlkYXRlXzEudmFsaWRhdGVGdW5jdGlvbkNvZGUoc2NoZW1hQ3h0KTtcbiAgICAgICAgZ2VuLm9wdGltaXplKHRoaXMub3B0cy5jb2RlLm9wdGltaXplKTtcbiAgICAgICAgLy8gZ2VuLm9wdGltaXplKDEpXG4gICAgICAgIGNvbnN0IHZhbGlkYXRlQ29kZSA9IGdlbi50b1N0cmluZygpO1xuICAgICAgICBzb3VyY2VDb2RlID0gYCR7Z2VuLnNjb3BlUmVmcyhuYW1lc18xLmRlZmF1bHQuc2NvcGUpfXJldHVybiAke3ZhbGlkYXRlQ29kZX1gO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygoY29kZVNpemUgKz0gc291cmNlQ29kZS5sZW5ndGgpLCAobm9kZUNvdW50ICs9IGdlbi5ub2RlQ291bnQpKVxuICAgICAgICBpZiAodGhpcy5vcHRzLmNvZGUucHJvY2VzcylcbiAgICAgICAgICAgIHNvdXJjZUNvZGUgPSB0aGlzLm9wdHMuY29kZS5wcm9jZXNzKHNvdXJjZUNvZGUsIHNjaCk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiXFxuXFxuXFxuICoqKiBcXG5cIiwgc291cmNlQ29kZSlcbiAgICAgICAgY29uc3QgbWFrZVZhbGlkYXRlID0gbmV3IEZ1bmN0aW9uKGAke25hbWVzXzEuZGVmYXVsdC5zZWxmfWAsIGAke25hbWVzXzEuZGVmYXVsdC5zY29wZX1gLCBzb3VyY2VDb2RlKTtcbiAgICAgICAgY29uc3QgdmFsaWRhdGUgPSBtYWtlVmFsaWRhdGUodGhpcywgdGhpcy5zY29wZS5nZXQoKSk7XG4gICAgICAgIHRoaXMuc2NvcGUudmFsdWUodmFsaWRhdGVOYW1lLCB7IHJlZjogdmFsaWRhdGUgfSk7XG4gICAgICAgIHZhbGlkYXRlLmVycm9ycyA9IG51bGw7XG4gICAgICAgIHZhbGlkYXRlLnNjaGVtYSA9IHNjaC5zY2hlbWE7XG4gICAgICAgIHZhbGlkYXRlLnNjaGVtYUVudiA9IHNjaDtcbiAgICAgICAgaWYgKHNjaC4kYXN5bmMpXG4gICAgICAgICAgICB2YWxpZGF0ZS4kYXN5bmMgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5vcHRzLmNvZGUuc291cmNlID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZS5zb3VyY2UgPSB7IHZhbGlkYXRlTmFtZSwgdmFsaWRhdGVDb2RlLCBzY29wZVZhbHVlczogZ2VuLl92YWx1ZXMgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRzLnVuZXZhbHVhdGVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IHByb3BzLCBpdGVtcyB9ID0gc2NoZW1hQ3h0O1xuICAgICAgICAgICAgdmFsaWRhdGUuZXZhbHVhdGVkID0ge1xuICAgICAgICAgICAgICAgIHByb3BzOiBwcm9wcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lID8gdW5kZWZpbmVkIDogcHJvcHMsXG4gICAgICAgICAgICAgICAgaXRlbXM6IGl0ZW1zIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUgPyB1bmRlZmluZWQgOiBpdGVtcyxcbiAgICAgICAgICAgICAgICBkeW5hbWljUHJvcHM6IHByb3BzIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUsXG4gICAgICAgICAgICAgICAgZHluYW1pY0l0ZW1zOiBpdGVtcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZS5zb3VyY2UpXG4gICAgICAgICAgICAgICAgdmFsaWRhdGUuc291cmNlLmV2YWx1YXRlZCA9IGNvZGVnZW5fMS5zdHJpbmdpZnkodmFsaWRhdGUuZXZhbHVhdGVkKTtcbiAgICAgICAgfVxuICAgICAgICBzY2gudmFsaWRhdGUgPSB2YWxpZGF0ZTtcbiAgICAgICAgcmV0dXJuIHNjaDtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgZGVsZXRlIHNjaC52YWxpZGF0ZTtcbiAgICAgICAgZGVsZXRlIHNjaC52YWxpZGF0ZU5hbWU7XG4gICAgICAgIGlmIChzb3VyY2VDb2RlKVxuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJFcnJvciBjb21waWxpbmcgc2NoZW1hLCBmdW5jdGlvbiBjb2RlOlwiLCBzb3VyY2VDb2RlKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJcXG5cXG5cXG4gKioqIFxcblwiLCBzb3VyY2VDb2RlLCB0aGlzLm9wdHMpXG4gICAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0aGlzLl9jb21waWxhdGlvbnMuZGVsZXRlKHNjaCk7XG4gICAgfVxufVxuZXhwb3J0cy5jb21waWxlU2NoZW1hID0gY29tcGlsZVNjaGVtYTtcbmZ1bmN0aW9uIHJlc29sdmVSZWYocm9vdCwgYmFzZUlkLCByZWYpIHtcbiAgICB2YXIgX2E7XG4gICAgcmVmID0gcmVzb2x2ZV8xLnJlc29sdmVVcmwoYmFzZUlkLCByZWYpO1xuICAgIGNvbnN0IHNjaE9yRnVuYyA9IHJvb3QucmVmc1tyZWZdO1xuICAgIGlmIChzY2hPckZ1bmMpXG4gICAgICAgIHJldHVybiBzY2hPckZ1bmM7XG4gICAgbGV0IF9zY2ggPSByZXNvbHZlLmNhbGwodGhpcywgcm9vdCwgcmVmKTtcbiAgICBpZiAoX3NjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IChfYSA9IHJvb3QubG9jYWxSZWZzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbcmVmXTsgLy8gVE9ETyBtYXliZSBsb2NhbFJlZnMgc2hvdWxkIGhvbGQgU2NoZW1hRW52XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgaWYgKHNjaGVtYSlcbiAgICAgICAgICAgIF9zY2ggPSBuZXcgU2NoZW1hRW52KHsgc2NoZW1hLCBzY2hlbWFJZCwgcm9vdCwgYmFzZUlkIH0pO1xuICAgIH1cbiAgICBpZiAoX3NjaCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgcmV0dXJuIChyb290LnJlZnNbcmVmXSA9IGlubGluZU9yQ29tcGlsZS5jYWxsKHRoaXMsIF9zY2gpKTtcbn1cbmV4cG9ydHMucmVzb2x2ZVJlZiA9IHJlc29sdmVSZWY7XG5mdW5jdGlvbiBpbmxpbmVPckNvbXBpbGUoc2NoKSB7XG4gICAgaWYgKHJlc29sdmVfMS5pbmxpbmVSZWYoc2NoLnNjaGVtYSwgdGhpcy5vcHRzLmlubGluZVJlZnMpKVxuICAgICAgICByZXR1cm4gc2NoLnNjaGVtYTtcbiAgICByZXR1cm4gc2NoLnZhbGlkYXRlID8gc2NoIDogY29tcGlsZVNjaGVtYS5jYWxsKHRoaXMsIHNjaCk7XG59XG4vLyBJbmRleCBvZiBzY2hlbWEgY29tcGlsYXRpb24gaW4gdGhlIGN1cnJlbnRseSBjb21waWxlZCBsaXN0XG5mdW5jdGlvbiBnZXRDb21waWxpbmdTY2hlbWEoc2NoRW52KSB7XG4gICAgZm9yIChjb25zdCBzY2ggb2YgdGhpcy5fY29tcGlsYXRpb25zKSB7XG4gICAgICAgIGlmIChzYW1lU2NoZW1hRW52KHNjaCwgc2NoRW52KSlcbiAgICAgICAgICAgIHJldHVybiBzY2g7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRDb21waWxpbmdTY2hlbWEgPSBnZXRDb21waWxpbmdTY2hlbWE7XG5mdW5jdGlvbiBzYW1lU2NoZW1hRW52KHMxLCBzMikge1xuICAgIHJldHVybiBzMS5zY2hlbWEgPT09IHMyLnNjaGVtYSAmJiBzMS5yb290ID09PSBzMi5yb290ICYmIHMxLmJhc2VJZCA9PT0gczIuYmFzZUlkO1xufVxuLy8gcmVzb2x2ZSBhbmQgY29tcGlsZSB0aGUgcmVmZXJlbmNlcyAoJHJlZilcbi8vIFRPRE8gcmV0dXJucyBBbnlTY2hlbWFPYmplY3QgKGlmIHRoZSBzY2hlbWEgY2FuIGJlIGlubGluZWQpIG9yIHZhbGlkYXRpb24gZnVuY3Rpb25cbmZ1bmN0aW9uIHJlc29sdmUocm9vdCwgLy8gaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJvb3Qgc2NoZW1hIGZvciB0aGUgY3VycmVudCBzY2hlbWFcbnJlZiAvLyByZWZlcmVuY2UgdG8gcmVzb2x2ZVxuKSB7XG4gICAgbGV0IHNjaDtcbiAgICB3aGlsZSAodHlwZW9mIChzY2ggPSB0aGlzLnJlZnNbcmVmXSkgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmVmID0gc2NoO1xuICAgIHJldHVybiBzY2ggfHwgdGhpcy5zY2hlbWFzW3JlZl0gfHwgcmVzb2x2ZVNjaGVtYS5jYWxsKHRoaXMsIHJvb3QsIHJlZik7XG59XG4vLyBSZXNvbHZlIHNjaGVtYSwgaXRzIHJvb3QgYW5kIGJhc2VJZFxuZnVuY3Rpb24gcmVzb2x2ZVNjaGVtYShyb290LCAvLyByb290IG9iamVjdCB3aXRoIHByb3BlcnRpZXMgc2NoZW1hLCByZWZzIFRPRE8gYmVsb3cgU2NoZW1hRW52IGlzIGFzc2lnbmVkIHRvIGl0XG5yZWYgLy8gcmVmZXJlbmNlIHRvIHJlc29sdmVcbikge1xuICAgIGNvbnN0IHAgPSBVUkkucGFyc2UocmVmKTtcbiAgICBjb25zdCByZWZQYXRoID0gcmVzb2x2ZV8xLl9nZXRGdWxsUGF0aChwKTtcbiAgICBsZXQgYmFzZUlkID0gcmVzb2x2ZV8xLmdldEZ1bGxQYXRoKHJvb3QuYmFzZUlkKTtcbiAgICAvLyBUT0RPIGBPYmplY3Qua2V5cyhyb290LnNjaGVtYSkubGVuZ3RoID4gMGAgc2hvdWxkIG5vdCBiZSBuZWVkZWQgLSBidXQgcmVtb3ZpbmcgYnJlYWtzIDIgdGVzdHNcbiAgICBpZiAoT2JqZWN0LmtleXMocm9vdC5zY2hlbWEpLmxlbmd0aCA+IDAgJiYgcmVmUGF0aCA9PT0gYmFzZUlkKSB7XG4gICAgICAgIHJldHVybiBnZXRKc29uUG9pbnRlci5jYWxsKHRoaXMsIHAsIHJvb3QpO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IHJlc29sdmVfMS5ub3JtYWxpemVJZChyZWZQYXRoKTtcbiAgICBjb25zdCBzY2hPclJlZiA9IHRoaXMucmVmc1tpZF0gfHwgdGhpcy5zY2hlbWFzW2lkXTtcbiAgICBpZiAodHlwZW9mIHNjaE9yUmVmID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3Qgc2NoID0gcmVzb2x2ZVNjaGVtYS5jYWxsKHRoaXMsIHJvb3QsIHNjaE9yUmVmKTtcbiAgICAgICAgaWYgKHR5cGVvZiAoc2NoID09PSBudWxsIHx8IHNjaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoLnNjaGVtYSkgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJldHVybiBnZXRKc29uUG9pbnRlci5jYWxsKHRoaXMsIHAsIHNjaCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHNjaE9yUmVmID09PSBudWxsIHx8IHNjaE9yUmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2hPclJlZi5zY2hlbWEpICE9PSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCFzY2hPclJlZi52YWxpZGF0ZSlcbiAgICAgICAgY29tcGlsZVNjaGVtYS5jYWxsKHRoaXMsIHNjaE9yUmVmKTtcbiAgICBpZiAoaWQgPT09IHJlc29sdmVfMS5ub3JtYWxpemVJZChyZWYpKSB7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hIH0gPSBzY2hPclJlZjtcbiAgICAgICAgY29uc3QgeyBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICBjb25zdCBzY2hJZCA9IHNjaGVtYVtzY2hlbWFJZF07XG4gICAgICAgIGlmIChzY2hJZClcbiAgICAgICAgICAgIGJhc2VJZCA9IHJlc29sdmVfMS5yZXNvbHZlVXJsKGJhc2VJZCwgc2NoSWQpO1xuICAgICAgICByZXR1cm4gbmV3IFNjaGVtYUVudih7IHNjaGVtYSwgc2NoZW1hSWQsIHJvb3QsIGJhc2VJZCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEpzb25Qb2ludGVyLmNhbGwodGhpcywgcCwgc2NoT3JSZWYpO1xufVxuZXhwb3J0cy5yZXNvbHZlU2NoZW1hID0gcmVzb2x2ZVNjaGVtYTtcbmNvbnN0IFBSRVZFTlRfU0NPUEVfQ0hBTkdFID0gbmV3IFNldChbXG4gICAgXCJwcm9wZXJ0aWVzXCIsXG4gICAgXCJwYXR0ZXJuUHJvcGVydGllc1wiLFxuICAgIFwiZW51bVwiLFxuICAgIFwiZGVwZW5kZW5jaWVzXCIsXG4gICAgXCJkZWZpbml0aW9uc1wiLFxuXSk7XG5mdW5jdGlvbiBnZXRKc29uUG9pbnRlcihwYXJzZWRSZWYsIHsgYmFzZUlkLCBzY2hlbWEsIHJvb3QgfSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoKChfYSA9IHBhcnNlZFJlZi5mcmFnbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSAhPT0gXCIvXCIpXG4gICAgICAgIHJldHVybjtcbiAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFyc2VkUmVmLmZyYWdtZW50LnNsaWNlKDEpLnNwbGl0KFwiL1wiKSkge1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc2NoZW1hID0gc2NoZW1hW3V0aWxfMS51bmVzY2FwZUZyYWdtZW50KHBhcnQpXTtcbiAgICAgICAgaWYgKHNjaGVtYSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBUT0RPIFBSRVZFTlRfU0NPUEVfQ0hBTkdFIGNvdWxkIGJlIGRlZmluZWQgaW4ga2V5d29yZCBkZWY/XG4gICAgICAgIGNvbnN0IHNjaElkID0gdHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiICYmIHNjaGVtYVt0aGlzLm9wdHMuc2NoZW1hSWRdO1xuICAgICAgICBpZiAoIVBSRVZFTlRfU0NPUEVfQ0hBTkdFLmhhcyhwYXJ0KSAmJiBzY2hJZCkge1xuICAgICAgICAgICAgYmFzZUlkID0gcmVzb2x2ZV8xLnJlc29sdmVVcmwoYmFzZUlkLCBzY2hJZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGVudjtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSAhPSBcImJvb2xlYW5cIiAmJiBzY2hlbWEuJHJlZiAmJiAhdXRpbF8xLnNjaGVtYUhhc1J1bGVzQnV0UmVmKHNjaGVtYSwgdGhpcy5SVUxFUykpIHtcbiAgICAgICAgY29uc3QgJHJlZiA9IHJlc29sdmVfMS5yZXNvbHZlVXJsKGJhc2VJZCwgc2NoZW1hLiRyZWYpO1xuICAgICAgICBlbnYgPSByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgJHJlZik7XG4gICAgfVxuICAgIC8vIGV2ZW4gdGhvdWdoIHJlc29sdXRpb24gZmFpbGVkIHdlIG5lZWQgdG8gcmV0dXJuIFNjaGVtYUVudiB0byB0aHJvdyBleGNlcHRpb25cbiAgICAvLyBzbyB0aGF0IGNvbXBpbGVBc3luYyBsb2FkcyBtaXNzaW5nIHNjaGVtYS5cbiAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgZW52ID0gZW52IHx8IG5ldyBTY2hlbWFFbnYoeyBzY2hlbWEsIHNjaGVtYUlkLCByb290LCBiYXNlSWQgfSk7XG4gICAgaWYgKGVudi5zY2hlbWEgIT09IGVudi5yb290LnNjaGVtYSlcbiAgICAgICAgcmV0dXJuIGVudjtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvZGVHZW4gPSBleHBvcnRzLk5hbWUgPSBleHBvcnRzLm5pbCA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHIgPSBleHBvcnRzLl8gPSBleHBvcnRzLktleXdvcmRDeHQgPSB2b2lkIDA7XG52YXIgdmFsaWRhdGVfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvdmFsaWRhdGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJLZXl3b3JkQ3h0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWxpZGF0ZV8xLktleXdvcmRDeHQ7IH0gfSk7XG52YXIgY29kZWdlbl8xID0gcmVxdWlyZShcIi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLl87IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5zdHI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJpbmdpZnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5zdHJpbmdpZnk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJuaWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5uaWw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOYW1lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuTmFtZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvZGVHZW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5Db2RlR2VuOyB9IH0pO1xuY29uc3QgdmFsaWRhdGlvbl9lcnJvcl8xID0gcmVxdWlyZShcIi4vcnVudGltZS92YWxpZGF0aW9uX2Vycm9yXCIpO1xuY29uc3QgcmVmX2Vycm9yXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3JlZl9lcnJvclwiKTtcbmNvbnN0IHJ1bGVzXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3J1bGVzXCIpO1xuY29uc3QgY29tcGlsZV8xID0gcmVxdWlyZShcIi4vY29tcGlsZVwiKTtcbmNvbnN0IGNvZGVnZW5fMiA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHJlc29sdmVfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvcmVzb2x2ZVwiKTtcbmNvbnN0IGRhdGFUeXBlXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3ZhbGlkYXRlL2RhdGFUeXBlXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgJGRhdGFSZWZTY2hlbWEgPSByZXF1aXJlKFwiLi9yZWZzL2RhdGEuanNvblwiKTtcbmNvbnN0IE1FVEFfSUdOT1JFX09QVElPTlMgPSBbXCJyZW1vdmVBZGRpdGlvbmFsXCIsIFwidXNlRGVmYXVsdHNcIiwgXCJjb2VyY2VUeXBlc1wiXTtcbmNvbnN0IEVYVF9TQ09QRV9OQU1FUyA9IG5ldyBTZXQoW1xuICAgIFwidmFsaWRhdGVcIixcbiAgICBcInNlcmlhbGl6ZVwiLFxuICAgIFwicGFyc2VcIixcbiAgICBcIndyYXBwZXJcIixcbiAgICBcInJvb3RcIixcbiAgICBcInNjaGVtYVwiLFxuICAgIFwia2V5d29yZFwiLFxuICAgIFwicGF0dGVyblwiLFxuICAgIFwiZm9ybWF0c1wiLFxuICAgIFwidmFsaWRhdGUkZGF0YVwiLFxuICAgIFwiZnVuY1wiLFxuICAgIFwib2JqXCIsXG4gICAgXCJFcnJvclwiLFxuXSk7XG5jb25zdCByZW1vdmVkT3B0aW9ucyA9IHtcbiAgICBlcnJvckRhdGFQYXRoOiBcIlwiLFxuICAgIGZvcm1hdDogXCJgdmFsaWRhdGVGb3JtYXRzOiBmYWxzZWAgY2FuIGJlIHVzZWQgaW5zdGVhZC5cIixcbiAgICBudWxsYWJsZTogJ1wibnVsbGFibGVcIiBrZXl3b3JkIGlzIHN1cHBvcnRlZCBieSBkZWZhdWx0LicsXG4gICAganNvblBvaW50ZXJzOiBcIkRlcHJlY2F0ZWQganNQcm9wZXJ0eVN5bnRheCBjYW4gYmUgdXNlZCBpbnN0ZWFkLlwiLFxuICAgIGV4dGVuZFJlZnM6IFwiRGVwcmVjYXRlZCBpZ25vcmVLZXl3b3Jkc1dpdGhSZWYgY2FuIGJlIHVzZWQgaW5zdGVhZC5cIixcbiAgICBtaXNzaW5nUmVmczogXCJQYXNzIGVtcHR5IHNjaGVtYSB3aXRoICRpZCB0aGF0IHNob3VsZCBiZSBpZ25vcmVkIHRvIGFqdi5hZGRTY2hlbWEuXCIsXG4gICAgcHJvY2Vzc0NvZGU6IFwiVXNlIG9wdGlvbiBgY29kZToge3Byb2Nlc3M6IChjb2RlLCBzY2hlbWFFbnY6IG9iamVjdCkgPT4gc3RyaW5nfWBcIixcbiAgICBzb3VyY2VDb2RlOiBcIlVzZSBvcHRpb24gYGNvZGU6IHtzb3VyY2U6IHRydWV9YFwiLFxuICAgIHN0cmljdERlZmF1bHRzOiBcIkl0IGlzIGRlZmF1bHQgbm93LCBzZWUgb3B0aW9uIGBzdHJpY3RgLlwiLFxuICAgIHN0cmljdEtleXdvcmRzOiBcIkl0IGlzIGRlZmF1bHQgbm93LCBzZWUgb3B0aW9uIGBzdHJpY3RgLlwiLFxuICAgIHVuaXF1ZUl0ZW1zOiAnXCJ1bmlxdWVJdGVtc1wiIGtleXdvcmQgaXMgYWx3YXlzIHZhbGlkYXRlZC4nLFxuICAgIHVua25vd25Gb3JtYXRzOiBcIkRpc2FibGUgc3RyaWN0IG1vZGUgb3IgcGFzcyBgdHJ1ZWAgdG8gYGFqdi5hZGRGb3JtYXRgIChvciBgZm9ybWF0c2Agb3B0aW9uKS5cIixcbiAgICBjYWNoZTogXCJNYXAgaXMgdXNlZCBhcyBjYWNoZSwgc2NoZW1hIG9iamVjdCBhcyBrZXkuXCIsXG4gICAgc2VyaWFsaXplOiBcIk1hcCBpcyB1c2VkIGFzIGNhY2hlLCBzY2hlbWEgb2JqZWN0IGFzIGtleS5cIixcbiAgICBhanZFcnJvcnM6IFwiSXQgaXMgZGVmYXVsdCBub3cuXCIsXG59O1xuY29uc3QgZGVwcmVjYXRlZE9wdGlvbnMgPSB7XG4gICAgaWdub3JlS2V5d29yZHNXaXRoUmVmOiBcIlwiLFxuICAgIGpzUHJvcGVydHlTeW50YXg6IFwiXCIsXG4gICAgdW5pY29kZTogJ1wibWluTGVuZ3RoXCIvXCJtYXhMZW5ndGhcIiBhY2NvdW50IGZvciB1bmljb2RlIGNoYXJhY3RlcnMgYnkgZGVmYXVsdC4nLFxufTtcbmNvbnN0IE1BWF9FWFBSRVNTSU9OID0gMjAwO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHJlcXVpcmVkT3B0aW9ucyhvKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rLCBfbCwgX20sIF9vLCBfcCwgX3EsIF9yLCBfcywgX3QsIF91LCBfdiwgX3csIF94O1xuICAgIGNvbnN0IHMgPSBvLnN0cmljdDtcbiAgICBjb25zdCBfb3B0eiA9IChfYSA9IG8uY29kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wdGltaXplO1xuICAgIGNvbnN0IG9wdGltaXplID0gX29wdHogPT09IHRydWUgfHwgX29wdHogPT09IHVuZGVmaW5lZCA/IDEgOiBfb3B0eiB8fCAwO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0cmljdFNjaGVtYTogKF9jID0gKF9iID0gby5zdHJpY3RTY2hlbWEpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHRydWUsXG4gICAgICAgIHN0cmljdE51bWJlcnM6IChfZSA9IChfZCA9IG8uc3RyaWN0TnVtYmVycykgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogcykgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogdHJ1ZSxcbiAgICAgICAgc3RyaWN0VHlwZXM6IChfZyA9IChfZiA9IG8uc3RyaWN0VHlwZXMpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IHMpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IFwibG9nXCIsXG4gICAgICAgIHN0cmljdFR1cGxlczogKF9qID0gKF9oID0gby5zdHJpY3RUdXBsZXMpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IHMpICE9PSBudWxsICYmIF9qICE9PSB2b2lkIDAgPyBfaiA6IFwibG9nXCIsXG4gICAgICAgIHN0cmljdFJlcXVpcmVkOiAoX2wgPSAoX2sgPSBvLnN0cmljdFJlcXVpcmVkKSAhPT0gbnVsbCAmJiBfayAhPT0gdm9pZCAwID8gX2sgOiBzKSAhPT0gbnVsbCAmJiBfbCAhPT0gdm9pZCAwID8gX2wgOiBmYWxzZSxcbiAgICAgICAgY29kZTogby5jb2RlID8geyAuLi5vLmNvZGUsIG9wdGltaXplIH0gOiB7IG9wdGltaXplIH0sXG4gICAgICAgIGxvb3BSZXF1aXJlZDogKF9tID0gby5sb29wUmVxdWlyZWQpICE9PSBudWxsICYmIF9tICE9PSB2b2lkIDAgPyBfbSA6IE1BWF9FWFBSRVNTSU9OLFxuICAgICAgICBsb29wRW51bTogKF9vID0gby5sb29wRW51bSkgIT09IG51bGwgJiYgX28gIT09IHZvaWQgMCA/IF9vIDogTUFYX0VYUFJFU1NJT04sXG4gICAgICAgIG1ldGE6IChfcCA9IG8ubWV0YSkgIT09IG51bGwgJiYgX3AgIT09IHZvaWQgMCA/IF9wIDogdHJ1ZSxcbiAgICAgICAgbWVzc2FnZXM6IChfcSA9IG8ubWVzc2FnZXMpICE9PSBudWxsICYmIF9xICE9PSB2b2lkIDAgPyBfcSA6IHRydWUsXG4gICAgICAgIGlubGluZVJlZnM6IChfciA9IG8uaW5saW5lUmVmcykgIT09IG51bGwgJiYgX3IgIT09IHZvaWQgMCA/IF9yIDogdHJ1ZSxcbiAgICAgICAgc2NoZW1hSWQ6IChfcyA9IG8uc2NoZW1hSWQpICE9PSBudWxsICYmIF9zICE9PSB2b2lkIDAgPyBfcyA6IFwiJGlkXCIsXG4gICAgICAgIGFkZFVzZWRTY2hlbWE6IChfdCA9IG8uYWRkVXNlZFNjaGVtYSkgIT09IG51bGwgJiYgX3QgIT09IHZvaWQgMCA/IF90IDogdHJ1ZSxcbiAgICAgICAgdmFsaWRhdGVTY2hlbWE6IChfdSA9IG8udmFsaWRhdGVTY2hlbWEpICE9PSBudWxsICYmIF91ICE9PSB2b2lkIDAgPyBfdSA6IHRydWUsXG4gICAgICAgIHZhbGlkYXRlRm9ybWF0czogKF92ID0gby52YWxpZGF0ZUZvcm1hdHMpICE9PSBudWxsICYmIF92ICE9PSB2b2lkIDAgPyBfdiA6IHRydWUsXG4gICAgICAgIHVuaWNvZGVSZWdFeHA6IChfdyA9IG8udW5pY29kZVJlZ0V4cCkgIT09IG51bGwgJiYgX3cgIT09IHZvaWQgMCA/IF93IDogdHJ1ZSxcbiAgICAgICAgaW50MzJyYW5nZTogKF94ID0gby5pbnQzMnJhbmdlKSAhPT0gbnVsbCAmJiBfeCAhPT0gdm9pZCAwID8gX3ggOiB0cnVlLFxuICAgIH07XG59XG5jbGFzcyBBanYge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgICAgICB0aGlzLnNjaGVtYXMgPSB7fTtcbiAgICAgICAgdGhpcy5yZWZzID0ge307XG4gICAgICAgIHRoaXMuZm9ybWF0cyA9IHt9O1xuICAgICAgICB0aGlzLl9jb21waWxhdGlvbnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuX2xvYWRpbmcgPSB7fTtcbiAgICAgICAgdGhpcy5fY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIG9wdHMgPSB0aGlzLm9wdHMgPSB7IC4uLm9wdHMsIC4uLnJlcXVpcmVkT3B0aW9ucyhvcHRzKSB9O1xuICAgICAgICBjb25zdCB7IGVzNSwgbGluZXMgfSA9IHRoaXMub3B0cy5jb2RlO1xuICAgICAgICB0aGlzLnNjb3BlID0gbmV3IGNvZGVnZW5fMi5WYWx1ZVNjb3BlKHsgc2NvcGU6IHt9LCBwcmVmaXhlczogRVhUX1NDT1BFX05BTUVTLCBlczUsIGxpbmVzIH0pO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGdldExvZ2dlcihvcHRzLmxvZ2dlcik7XG4gICAgICAgIGNvbnN0IGZvcm1hdE9wdCA9IG9wdHMudmFsaWRhdGVGb3JtYXRzO1xuICAgICAgICBvcHRzLnZhbGlkYXRlRm9ybWF0cyA9IGZhbHNlO1xuICAgICAgICB0aGlzLlJVTEVTID0gcnVsZXNfMS5nZXRSdWxlcygpO1xuICAgICAgICBjaGVja09wdGlvbnMuY2FsbCh0aGlzLCByZW1vdmVkT3B0aW9ucywgb3B0cywgXCJOT1QgU1VQUE9SVEVEXCIpO1xuICAgICAgICBjaGVja09wdGlvbnMuY2FsbCh0aGlzLCBkZXByZWNhdGVkT3B0aW9ucywgb3B0cywgXCJERVBSRUNBVEVEXCIsIFwid2FyblwiKTtcbiAgICAgICAgdGhpcy5fbWV0YU9wdHMgPSBnZXRNZXRhU2NoZW1hT3B0aW9ucy5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAob3B0cy5mb3JtYXRzKVxuICAgICAgICAgICAgYWRkSW5pdGlhbEZvcm1hdHMuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fYWRkVm9jYWJ1bGFyaWVzKCk7XG4gICAgICAgIHRoaXMuX2FkZERlZmF1bHRNZXRhU2NoZW1hKCk7XG4gICAgICAgIGlmIChvcHRzLmtleXdvcmRzKVxuICAgICAgICAgICAgYWRkSW5pdGlhbEtleXdvcmRzLmNhbGwodGhpcywgb3B0cy5rZXl3b3Jkcyk7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5tZXRhID09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICB0aGlzLmFkZE1ldGFTY2hlbWEob3B0cy5tZXRhKTtcbiAgICAgICAgYWRkSW5pdGlhbFNjaGVtYXMuY2FsbCh0aGlzKTtcbiAgICAgICAgb3B0cy52YWxpZGF0ZUZvcm1hdHMgPSBmb3JtYXRPcHQ7XG4gICAgfVxuICAgIF9hZGRWb2NhYnVsYXJpZXMoKSB7XG4gICAgICAgIHRoaXMuYWRkS2V5d29yZChcIiRhc3luY1wiKTtcbiAgICB9XG4gICAgX2FkZERlZmF1bHRNZXRhU2NoZW1hKCkge1xuICAgICAgICBjb25zdCB7ICRkYXRhLCBtZXRhLCBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICBsZXQgX2RhdGFSZWZTY2hlbWEgPSAkZGF0YVJlZlNjaGVtYTtcbiAgICAgICAgaWYgKHNjaGVtYUlkID09PSBcImlkXCIpIHtcbiAgICAgICAgICAgIF9kYXRhUmVmU2NoZW1hID0geyAuLi4kZGF0YVJlZlNjaGVtYSB9O1xuICAgICAgICAgICAgX2RhdGFSZWZTY2hlbWEuaWQgPSBfZGF0YVJlZlNjaGVtYS4kaWQ7XG4gICAgICAgICAgICBkZWxldGUgX2RhdGFSZWZTY2hlbWEuJGlkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhICYmICRkYXRhKVxuICAgICAgICAgICAgdGhpcy5hZGRNZXRhU2NoZW1hKF9kYXRhUmVmU2NoZW1hLCBfZGF0YVJlZlNjaGVtYVtzY2hlbWFJZF0sIGZhbHNlKTtcbiAgICB9XG4gICAgZGVmYXVsdE1ldGEoKSB7XG4gICAgICAgIGNvbnN0IHsgbWV0YSwgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgcmV0dXJuICh0aGlzLm9wdHMuZGVmYXVsdE1ldGEgPSB0eXBlb2YgbWV0YSA9PSBcIm9iamVjdFwiID8gbWV0YVtzY2hlbWFJZF0gfHwgbWV0YSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHZhbGlkYXRlKHNjaGVtYUtleVJlZiwgLy8ga2V5LCByZWYgb3Igc2NoZW1hIG9iamVjdFxuICAgIGRhdGEgLy8gdG8gYmUgdmFsaWRhdGVkXG4gICAgKSB7XG4gICAgICAgIGxldCB2O1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYUtleVJlZiA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB2ID0gdGhpcy5nZXRTY2hlbWEoc2NoZW1hS2V5UmVmKTtcbiAgICAgICAgICAgIGlmICghdilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vIHNjaGVtYSB3aXRoIGtleSBvciByZWYgXCIke3NjaGVtYUtleVJlZn1cImApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdiA9IHRoaXMuY29tcGlsZShzY2hlbWFLZXlSZWYpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbGlkID0gdihkYXRhKTtcbiAgICAgICAgaWYgKCEoXCIkYXN5bmNcIiBpbiB2KSlcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzID0gdi5lcnJvcnM7XG4gICAgICAgIHJldHVybiB2YWxpZDtcbiAgICB9XG4gICAgY29tcGlsZShzY2hlbWEsIF9tZXRhKSB7XG4gICAgICAgIGNvbnN0IHNjaCA9IHRoaXMuX2FkZFNjaGVtYShzY2hlbWEsIF9tZXRhKTtcbiAgICAgICAgcmV0dXJuIChzY2gudmFsaWRhdGUgfHwgdGhpcy5fY29tcGlsZVNjaGVtYUVudihzY2gpKTtcbiAgICB9XG4gICAgY29tcGlsZUFzeW5jKHNjaGVtYSwgbWV0YSkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0cy5sb2FkU2NoZW1hICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3B0aW9ucy5sb2FkU2NoZW1hIHNob3VsZCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbG9hZFNjaGVtYSB9ID0gdGhpcy5vcHRzO1xuICAgICAgICByZXR1cm4gcnVuQ29tcGlsZUFzeW5jLmNhbGwodGhpcywgc2NoZW1hLCBtZXRhKTtcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gcnVuQ29tcGlsZUFzeW5jKF9zY2hlbWEsIF9tZXRhKSB7XG4gICAgICAgICAgICBhd2FpdCBsb2FkTWV0YVNjaGVtYS5jYWxsKHRoaXMsIF9zY2hlbWEuJHNjaGVtYSk7XG4gICAgICAgICAgICBjb25zdCBzY2ggPSB0aGlzLl9hZGRTY2hlbWEoX3NjaGVtYSwgX21ldGEpO1xuICAgICAgICAgICAgcmV0dXJuIHNjaC52YWxpZGF0ZSB8fCBfY29tcGlsZUFzeW5jLmNhbGwodGhpcywgc2NoKTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBmdW5jdGlvbiBsb2FkTWV0YVNjaGVtYSgkcmVmKSB7XG4gICAgICAgICAgICBpZiAoJHJlZiAmJiAhdGhpcy5nZXRTY2hlbWEoJHJlZikpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBydW5Db21waWxlQXN5bmMuY2FsbCh0aGlzLCB7ICRyZWYgfSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gX2NvbXBpbGVBc3luYyhzY2gpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBpbGVTY2hlbWFFbnYoc2NoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIHJlZl9lcnJvcl8xLmRlZmF1bHQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIGNoZWNrTG9hZGVkLmNhbGwodGhpcywgZSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgbG9hZE1pc3NpbmdTY2hlbWEuY2FsbCh0aGlzLCBlLm1pc3NpbmdTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29tcGlsZUFzeW5jLmNhbGwodGhpcywgc2NoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjaGVja0xvYWRlZCh7IG1pc3NpbmdTY2hlbWE6IHJlZiwgbWlzc2luZ1JlZiB9KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWZzW3JlZl0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFueVNjaGVtYSAke3JlZn0gaXMgbG9hZGVkIGJ1dCAke21pc3NpbmdSZWZ9IGNhbm5vdCBiZSByZXNvbHZlZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGxvYWRNaXNzaW5nU2NoZW1hKHJlZikge1xuICAgICAgICAgICAgY29uc3QgX3NjaGVtYSA9IGF3YWl0IF9sb2FkU2NoZW1hLmNhbGwodGhpcywgcmVmKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWZzW3JlZl0pXG4gICAgICAgICAgICAgICAgYXdhaXQgbG9hZE1ldGFTY2hlbWEuY2FsbCh0aGlzLCBfc2NoZW1hLiRzY2hlbWEpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlZnNbcmVmXSlcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFNjaGVtYShfc2NoZW1hLCByZWYsIG1ldGEpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIF9sb2FkU2NoZW1hKHJlZikge1xuICAgICAgICAgICAgY29uc3QgcCA9IHRoaXMuX2xvYWRpbmdbcmVmXTtcbiAgICAgICAgICAgIGlmIChwKVxuICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgKHRoaXMuX2xvYWRpbmdbcmVmXSA9IGxvYWRTY2hlbWEocmVmKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fbG9hZGluZ1tyZWZdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFkZHMgc2NoZW1hIHRvIHRoZSBpbnN0YW5jZVxuICAgIGFkZFNjaGVtYShzY2hlbWEsIC8vIElmIGFycmF5IGlzIHBhc3NlZCwgYGtleWAgd2lsbCBiZSBpZ25vcmVkXG4gICAga2V5LCAvLyBPcHRpb25hbCBzY2hlbWEga2V5LiBDYW4gYmUgcGFzc2VkIHRvIGB2YWxpZGF0ZWAgbWV0aG9kIGluc3RlYWQgb2Ygc2NoZW1hIG9iamVjdCBvciBpZC9yZWYuIE9uZSBzY2hlbWEgcGVyIGluc3RhbmNlIGNhbiBoYXZlIGVtcHR5IGBpZGAgYW5kIGBrZXlgLlxuICAgIF9tZXRhLCAvLyB0cnVlIGlmIHNjaGVtYSBpcyBhIG1ldGEtc2NoZW1hLiBVc2VkIGludGVybmFsbHksIGFkZE1ldGFTY2hlbWEgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cbiAgICBfdmFsaWRhdGVTY2hlbWEgPSB0aGlzLm9wdHMudmFsaWRhdGVTY2hlbWEgLy8gZmFsc2UgdG8gc2tpcCBzY2hlbWEgdmFsaWRhdGlvbi4gVXNlZCBpbnRlcm5hbGx5LCBvcHRpb24gdmFsaWRhdGVTY2hlbWEgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cbiAgICApIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBzY2ggb2Ygc2NoZW1hKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2NoZW1hKHNjaCwgdW5kZWZpbmVkLCBfbWV0YSwgX3ZhbGlkYXRlU2NoZW1hKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpZDtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgICAgIGlkID0gc2NoZW1hW3NjaGVtYUlkXTtcbiAgICAgICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBpZCAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzY2hlbWEgJHtzY2hlbWFJZH0gbXVzdCBiZSBzdHJpbmdgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBrZXkgPSByZXNvbHZlXzEubm9ybWFsaXplSWQoa2V5IHx8IGlkKTtcbiAgICAgICAgdGhpcy5fY2hlY2tVbmlxdWUoa2V5KTtcbiAgICAgICAgdGhpcy5zY2hlbWFzW2tleV0gPSB0aGlzLl9hZGRTY2hlbWEoc2NoZW1hLCBfbWV0YSwga2V5LCBfdmFsaWRhdGVTY2hlbWEsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gQWRkIHNjaGVtYSB0aGF0IHdpbGwgYmUgdXNlZCB0byB2YWxpZGF0ZSBvdGhlciBzY2hlbWFzXG4gICAgLy8gb3B0aW9ucyBpbiBNRVRBX0lHTk9SRV9PUFRJT05TIGFyZSBhbHdheSBzZXQgdG8gZmFsc2VcbiAgICBhZGRNZXRhU2NoZW1hKHNjaGVtYSwga2V5LCAvLyBzY2hlbWEga2V5XG4gICAgX3ZhbGlkYXRlU2NoZW1hID0gdGhpcy5vcHRzLnZhbGlkYXRlU2NoZW1hIC8vIGZhbHNlIHRvIHNraXAgc2NoZW1hIHZhbGlkYXRpb24sIGNhbiBiZSB1c2VkIHRvIG92ZXJyaWRlIHZhbGlkYXRlU2NoZW1hIG9wdGlvbiBmb3IgbWV0YS1zY2hlbWFcbiAgICApIHtcbiAgICAgICAgdGhpcy5hZGRTY2hlbWEoc2NoZW1hLCBrZXksIHRydWUsIF92YWxpZGF0ZVNjaGVtYSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyAgVmFsaWRhdGUgc2NoZW1hIGFnYWluc3QgaXRzIG1ldGEtc2NoZW1hXG4gICAgdmFsaWRhdGVTY2hlbWEoc2NoZW1hLCB0aHJvd09yTG9nRXJyb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbGV0ICRzY2hlbWE7XG4gICAgICAgICRzY2hlbWEgPSBzY2hlbWEuJHNjaGVtYTtcbiAgICAgICAgaWYgKCRzY2hlbWEgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgJHNjaGVtYSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIkc2NoZW1hIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgJHNjaGVtYSA9ICRzY2hlbWEgfHwgdGhpcy5vcHRzLmRlZmF1bHRNZXRhIHx8IHRoaXMuZGVmYXVsdE1ldGEoKTtcbiAgICAgICAgaWYgKCEkc2NoZW1hKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwibWV0YS1zY2hlbWEgbm90IGF2YWlsYWJsZVwiKTtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbGlkID0gdGhpcy52YWxpZGF0ZSgkc2NoZW1hLCBzY2hlbWEpO1xuICAgICAgICBpZiAoIXZhbGlkICYmIHRocm93T3JMb2dFcnJvcikge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IFwic2NoZW1hIGlzIGludmFsaWQ6IFwiICsgdGhpcy5lcnJvcnNUZXh0KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLnZhbGlkYXRlU2NoZW1hID09PSBcImxvZ1wiKVxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfVxuICAgIC8vIEdldCBjb21waWxlZCBzY2hlbWEgYnkgYGtleWAgb3IgYHJlZmAuXG4gICAgLy8gKGBrZXlgIHRoYXQgd2FzIHBhc3NlZCB0byBgYWRkU2NoZW1hYCBvciBmdWxsIHNjaGVtYSByZWZlcmVuY2UgLSBgc2NoZW1hLiRpZGAgb3IgcmVzb2x2ZWQgaWQpXG4gICAgZ2V0U2NoZW1hKGtleVJlZikge1xuICAgICAgICBsZXQgc2NoO1xuICAgICAgICB3aGlsZSAodHlwZW9mIChzY2ggPSBnZXRTY2hFbnYuY2FsbCh0aGlzLCBrZXlSZWYpKSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAga2V5UmVmID0gc2NoO1xuICAgICAgICBpZiAoc2NoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBuZXcgY29tcGlsZV8xLlNjaGVtYUVudih7IHNjaGVtYToge30sIHNjaGVtYUlkIH0pO1xuICAgICAgICAgICAgc2NoID0gY29tcGlsZV8xLnJlc29sdmVTY2hlbWEuY2FsbCh0aGlzLCByb290LCBrZXlSZWYpO1xuICAgICAgICAgICAgaWYgKCFzY2gpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5yZWZzW2tleVJlZl0gPSBzY2g7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChzY2gudmFsaWRhdGUgfHwgdGhpcy5fY29tcGlsZVNjaGVtYUVudihzY2gpKTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGNhY2hlZCBzY2hlbWEocykuXG4gICAgLy8gSWYgbm8gcGFyYW1ldGVyIGlzIHBhc3NlZCBhbGwgc2NoZW1hcyBidXQgbWV0YS1zY2hlbWFzIGFyZSByZW1vdmVkLlxuICAgIC8vIElmIFJlZ0V4cCBpcyBwYXNzZWQgYWxsIHNjaGVtYXMgd2l0aCBrZXkvaWQgbWF0Y2hpbmcgcGF0dGVybiBidXQgbWV0YS1zY2hlbWFzIGFyZSByZW1vdmVkLlxuICAgIC8vIEV2ZW4gaWYgc2NoZW1hIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgc2NoZW1hcyBpdCBzdGlsbCBjYW4gYmUgcmVtb3ZlZCBhcyBvdGhlciBzY2hlbWFzIGhhdmUgbG9jYWwgcmVmZXJlbmNlcy5cbiAgICByZW1vdmVTY2hlbWEoc2NoZW1hS2V5UmVmKSB7XG4gICAgICAgIGlmIChzY2hlbWFLZXlSZWYgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUFsbFNjaGVtYXModGhpcy5zY2hlbWFzLCBzY2hlbWFLZXlSZWYpO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQWxsU2NoZW1hcyh0aGlzLnJlZnMsIHNjaGVtYUtleVJlZik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHR5cGVvZiBzY2hlbWFLZXlSZWYpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVBbGxTY2hlbWFzKHRoaXMuc2NoZW1hcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQWxsU2NoZW1hcyh0aGlzLnJlZnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2ggPSBnZXRTY2hFbnYuY2FsbCh0aGlzLCBzY2hlbWFLZXlSZWYpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoID09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlLmRlbGV0ZShzY2guc2NoZW1hKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zY2hlbWFzW3NjaGVtYUtleVJlZl07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucmVmc1tzY2hlbWFLZXlSZWZdO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBzY2hlbWFLZXlSZWY7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGUuZGVsZXRlKGNhY2hlS2V5KTtcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSBzY2hlbWFLZXlSZWZbdGhpcy5vcHRzLnNjaGVtYUlkXTtcbiAgICAgICAgICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWQgPSByZXNvbHZlXzEubm9ybWFsaXplSWQoaWQpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zY2hlbWFzW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucmVmc1tpZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYucmVtb3ZlU2NoZW1hOiBpbnZhbGlkIHBhcmFtZXRlclwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgXCJ2b2NhYnVsYXJ5XCIgLSBhIGNvbGxlY3Rpb24gb2Yga2V5d29yZHNcbiAgICBhZGRWb2NhYnVsYXJ5KGRlZmluaXRpb25zKSB7XG4gICAgICAgIGZvciAoY29uc3QgZGVmIG9mIGRlZmluaXRpb25zKVxuICAgICAgICAgICAgdGhpcy5hZGRLZXl3b3JkKGRlZik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhZGRLZXl3b3JkKGt3ZE9yRGVmLCBkZWYgLy8gZGVwcmVjYXRlZFxuICAgICkge1xuICAgICAgICBsZXQga2V5d29yZDtcbiAgICAgICAgaWYgKHR5cGVvZiBrd2RPckRlZiA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBrZXl3b3JkID0ga3dkT3JEZWY7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlZiA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcInRoZXNlIHBhcmFtZXRlcnMgYXJlIGRlcHJlY2F0ZWQsIHNlZSBkb2NzIGZvciBhZGRLZXl3b3JkXCIpO1xuICAgICAgICAgICAgICAgIGRlZi5rZXl3b3JkID0ga2V5d29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Yga3dkT3JEZWYgPT0gXCJvYmplY3RcIiAmJiBkZWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVmID0ga3dkT3JEZWY7XG4gICAgICAgICAgICBrZXl3b3JkID0gZGVmLmtleXdvcmQ7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShrZXl3b3JkKSAmJiAha2V5d29yZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhZGRLZXl3b3Jkczoga2V5d29yZCBtdXN0IGJlIHN0cmluZyBvciBub24tZW1wdHkgYXJyYXlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGFkZEtleXdvcmRzIHBhcmFtZXRlcnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tLZXl3b3JkLmNhbGwodGhpcywga2V5d29yZCwgZGVmKTtcbiAgICAgICAgaWYgKCFkZWYpIHtcbiAgICAgICAgICAgIHV0aWxfMS5lYWNoSXRlbShrZXl3b3JkLCAoa3dkKSA9PiBhZGRSdWxlLmNhbGwodGhpcywga3dkKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBrZXl3b3JkTWV0YXNjaGVtYS5jYWxsKHRoaXMsIGRlZik7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSB7XG4gICAgICAgICAgICAuLi5kZWYsXG4gICAgICAgICAgICB0eXBlOiBkYXRhVHlwZV8xLmdldEpTT05UeXBlcyhkZWYudHlwZSksXG4gICAgICAgICAgICBzY2hlbWFUeXBlOiBkYXRhVHlwZV8xLmdldEpTT05UeXBlcyhkZWYuc2NoZW1hVHlwZSksXG4gICAgICAgIH07XG4gICAgICAgIHV0aWxfMS5lYWNoSXRlbShrZXl3b3JkLCBkZWZpbml0aW9uLnR5cGUubGVuZ3RoID09PSAwXG4gICAgICAgICAgICA/IChrKSA9PiBhZGRSdWxlLmNhbGwodGhpcywgaywgZGVmaW5pdGlvbilcbiAgICAgICAgICAgIDogKGspID0+IGRlZmluaXRpb24udHlwZS5mb3JFYWNoKCh0KSA9PiBhZGRSdWxlLmNhbGwodGhpcywgaywgZGVmaW5pdGlvbiwgdCkpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldEtleXdvcmQoa2V5d29yZCkge1xuICAgICAgICBjb25zdCBydWxlID0gdGhpcy5SVUxFUy5hbGxba2V5d29yZF07XG4gICAgICAgIHJldHVybiB0eXBlb2YgcnVsZSA9PSBcIm9iamVjdFwiID8gcnVsZS5kZWZpbml0aW9uIDogISFydWxlO1xuICAgIH1cbiAgICAvLyBSZW1vdmUga2V5d29yZFxuICAgIHJlbW92ZUtleXdvcmQoa2V5d29yZCkge1xuICAgICAgICAvLyBUT0RPIHJldHVybiB0eXBlIHNob3VsZCBiZSBBanZcbiAgICAgICAgY29uc3QgeyBSVUxFUyB9ID0gdGhpcztcbiAgICAgICAgZGVsZXRlIFJVTEVTLmtleXdvcmRzW2tleXdvcmRdO1xuICAgICAgICBkZWxldGUgUlVMRVMuYWxsW2tleXdvcmRdO1xuICAgICAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIFJVTEVTLnJ1bGVzKSB7XG4gICAgICAgICAgICBjb25zdCBpID0gZ3JvdXAucnVsZXMuZmluZEluZGV4KChydWxlKSA9PiBydWxlLmtleXdvcmQgPT09IGtleXdvcmQpO1xuICAgICAgICAgICAgaWYgKGkgPj0gMClcbiAgICAgICAgICAgICAgICBncm91cC5ydWxlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIEFkZCBmb3JtYXRcbiAgICBhZGRGb3JtYXQobmFtZSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0ID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBmb3JtYXQgPSBuZXcgUmVnRXhwKGZvcm1hdCk7XG4gICAgICAgIHRoaXMuZm9ybWF0c1tuYW1lXSA9IGZvcm1hdDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGVycm9yc1RleHQoZXJyb3JzID0gdGhpcy5lcnJvcnMsIC8vIG9wdGlvbmFsIGFycmF5IG9mIHZhbGlkYXRpb24gZXJyb3JzXG4gICAgeyBzZXBhcmF0b3IgPSBcIiwgXCIsIGRhdGFWYXIgPSBcImRhdGFcIiB9ID0ge30gLy8gb3B0aW9uYWwgb3B0aW9ucyB3aXRoIHByb3BlcnRpZXMgYHNlcGFyYXRvcmAgYW5kIGBkYXRhVmFyYFxuICAgICkge1xuICAgICAgICBpZiAoIWVycm9ycyB8fCBlcnJvcnMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIFwiTm8gZXJyb3JzXCI7XG4gICAgICAgIHJldHVybiBlcnJvcnNcbiAgICAgICAgICAgIC5tYXAoKGUpID0+IGAke2RhdGFWYXJ9JHtlLmluc3RhbmNlUGF0aH0gJHtlLm1lc3NhZ2V9YClcbiAgICAgICAgICAgIC5yZWR1Y2UoKHRleHQsIG1zZykgPT4gdGV4dCArIHNlcGFyYXRvciArIG1zZyk7XG4gICAgfVxuICAgICRkYXRhTWV0YVNjaGVtYShtZXRhU2NoZW1hLCBrZXl3b3Jkc0pzb25Qb2ludGVycykge1xuICAgICAgICBjb25zdCBydWxlcyA9IHRoaXMuUlVMRVMuYWxsO1xuICAgICAgICBtZXRhU2NoZW1hID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShtZXRhU2NoZW1hKSk7XG4gICAgICAgIGZvciAoY29uc3QganNvblBvaW50ZXIgb2Yga2V5d29yZHNKc29uUG9pbnRlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlZ21lbnRzID0ganNvblBvaW50ZXIuc3BsaXQoXCIvXCIpLnNsaWNlKDEpOyAvLyBmaXJzdCBzZWdtZW50IGlzIGFuIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgbGV0IGtleXdvcmRzID0gbWV0YVNjaGVtYTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2VnIG9mIHNlZ21lbnRzKVxuICAgICAgICAgICAgICAgIGtleXdvcmRzID0ga2V5d29yZHNbc2VnXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJ1bGVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcnVsZSA9IHJ1bGVzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBydWxlICE9IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgJGRhdGEgfSA9IHJ1bGUuZGVmaW5pdGlvbjtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWEgPSBrZXl3b3Jkc1trZXldO1xuICAgICAgICAgICAgICAgIGlmICgkZGF0YSAmJiBzY2hlbWEpXG4gICAgICAgICAgICAgICAgICAgIGtleXdvcmRzW2tleV0gPSBzY2hlbWFPckRhdGEoc2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0YVNjaGVtYTtcbiAgICB9XG4gICAgX3JlbW92ZUFsbFNjaGVtYXMoc2NoZW1hcywgcmVnZXgpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXlSZWYgaW4gc2NoZW1hcykge1xuICAgICAgICAgICAgY29uc3Qgc2NoID0gc2NoZW1hc1trZXlSZWZdO1xuICAgICAgICAgICAgaWYgKCFyZWdleCB8fCByZWdleC50ZXN0KGtleVJlZikpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNjaCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWFzW2tleVJlZl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjaCAmJiAhc2NoLm1ldGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGUuZGVsZXRlKHNjaC5zY2hlbWEpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2NoZW1hc1trZXlSZWZdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfYWRkU2NoZW1hKHNjaGVtYSwgbWV0YSwgYmFzZUlkLCB2YWxpZGF0ZVNjaGVtYSA9IHRoaXMub3B0cy52YWxpZGF0ZVNjaGVtYSwgYWRkU2NoZW1hID0gdGhpcy5vcHRzLmFkZFVzZWRTY2hlbWEpIHtcbiAgICAgICAgbGV0IGlkO1xuICAgICAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGlkID0gc2NoZW1hW3NjaGVtYUlkXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuanRkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNjaGVtYSBtdXN0IGJlIG9iamVjdFwiKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEgIT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2NoZW1hIG11c3QgYmUgb2JqZWN0IG9yIGJvb2xlYW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNjaCA9IHRoaXMuX2NhY2hlLmdldChzY2hlbWEpO1xuICAgICAgICBpZiAoc2NoICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gc2NoO1xuICAgICAgICBjb25zdCBsb2NhbFJlZnMgPSByZXNvbHZlXzEuZ2V0U2NoZW1hUmVmcy5jYWxsKHRoaXMsIHNjaGVtYSk7XG4gICAgICAgIGJhc2VJZCA9IHJlc29sdmVfMS5ub3JtYWxpemVJZChpZCB8fCBiYXNlSWQpO1xuICAgICAgICBzY2ggPSBuZXcgY29tcGlsZV8xLlNjaGVtYUVudih7IHNjaGVtYSwgc2NoZW1hSWQsIG1ldGEsIGJhc2VJZCwgbG9jYWxSZWZzIH0pO1xuICAgICAgICB0aGlzLl9jYWNoZS5zZXQoc2NoLnNjaGVtYSwgc2NoKTtcbiAgICAgICAgaWYgKGFkZFNjaGVtYSAmJiAhYmFzZUlkLnN0YXJ0c1dpdGgoXCIjXCIpKSB7XG4gICAgICAgICAgICAvLyBUT0RPIGF0bSBpdCBpcyBhbGxvd2VkIHRvIG92ZXJ3cml0ZSBzY2hlbWFzIHdpdGhvdXQgaWQgKGluc3RlYWQgb2Ygbm90IGFkZGluZyB0aGVtKVxuICAgICAgICAgICAgaWYgKGJhc2VJZClcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1VuaXF1ZShiYXNlSWQpO1xuICAgICAgICAgICAgdGhpcy5yZWZzW2Jhc2VJZF0gPSBzY2g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbGlkYXRlU2NoZW1hKVxuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVNjaGVtYShzY2hlbWEsIHRydWUpO1xuICAgICAgICByZXR1cm4gc2NoO1xuICAgIH1cbiAgICBfY2hlY2tVbmlxdWUoaWQpIHtcbiAgICAgICAgaWYgKHRoaXMuc2NoZW1hc1tpZF0gfHwgdGhpcy5yZWZzW2lkXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzY2hlbWEgd2l0aCBrZXkgb3IgaWQgXCIke2lkfVwiIGFscmVhZHkgZXhpc3RzYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2NvbXBpbGVTY2hlbWFFbnYoc2NoKSB7XG4gICAgICAgIGlmIChzY2gubWV0YSlcbiAgICAgICAgICAgIHRoaXMuX2NvbXBpbGVNZXRhU2NoZW1hKHNjaCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNvbXBpbGVfMS5jb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghc2NoLnZhbGlkYXRlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICByZXR1cm4gc2NoLnZhbGlkYXRlO1xuICAgIH1cbiAgICBfY29tcGlsZU1ldGFTY2hlbWEoc2NoKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRPcHRzID0gdGhpcy5vcHRzO1xuICAgICAgICB0aGlzLm9wdHMgPSB0aGlzLl9tZXRhT3B0cztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbXBpbGVfMS5jb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMub3B0cyA9IGN1cnJlbnRPcHRzO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gQWp2O1xuQWp2LlZhbGlkYXRpb25FcnJvciA9IHZhbGlkYXRpb25fZXJyb3JfMS5kZWZhdWx0O1xuQWp2Lk1pc3NpbmdSZWZFcnJvciA9IHJlZl9lcnJvcl8xLmRlZmF1bHQ7XG5mdW5jdGlvbiBjaGVja09wdGlvbnMoY2hlY2tPcHRzLCBvcHRpb25zLCBtc2csIGxvZyA9IFwiZXJyb3JcIikge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGNoZWNrT3B0cykge1xuICAgICAgICBjb25zdCBvcHQgPSBrZXk7XG4gICAgICAgIGlmIChvcHQgaW4gb3B0aW9ucylcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyW2xvZ10oYCR7bXNnfTogb3B0aW9uICR7a2V5fS4gJHtjaGVja09wdHNbb3B0XX1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRTY2hFbnYoa2V5UmVmKSB7XG4gICAga2V5UmVmID0gcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKGtleVJlZik7IC8vIFRPRE8gdGVzdHMgZmFpbCB3aXRob3V0IHRoaXMgbGluZVxuICAgIHJldHVybiB0aGlzLnNjaGVtYXNba2V5UmVmXSB8fCB0aGlzLnJlZnNba2V5UmVmXTtcbn1cbmZ1bmN0aW9uIGFkZEluaXRpYWxTY2hlbWFzKCkge1xuICAgIGNvbnN0IG9wdHNTY2hlbWFzID0gdGhpcy5vcHRzLnNjaGVtYXM7XG4gICAgaWYgKCFvcHRzU2NoZW1hcylcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdHNTY2hlbWFzKSlcbiAgICAgICAgdGhpcy5hZGRTY2hlbWEob3B0c1NjaGVtYXMpO1xuICAgIGVsc2VcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3B0c1NjaGVtYXMpXG4gICAgICAgICAgICB0aGlzLmFkZFNjaGVtYShvcHRzU2NoZW1hc1trZXldLCBrZXkpO1xufVxuZnVuY3Rpb24gYWRkSW5pdGlhbEZvcm1hdHMoKSB7XG4gICAgZm9yIChjb25zdCBuYW1lIGluIHRoaXMub3B0cy5mb3JtYXRzKSB7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMub3B0cy5mb3JtYXRzW25hbWVdO1xuICAgICAgICBpZiAoZm9ybWF0KVxuICAgICAgICAgICAgdGhpcy5hZGRGb3JtYXQobmFtZSwgZm9ybWF0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRJbml0aWFsS2V5d29yZHMoZGVmcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRlZnMpKSB7XG4gICAgICAgIHRoaXMuYWRkVm9jYWJ1bGFyeShkZWZzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxvZ2dlci53YXJuKFwia2V5d29yZHMgb3B0aW9uIGFzIG1hcCBpcyBkZXByZWNhdGVkLCBwYXNzIGFycmF5XCIpO1xuICAgIGZvciAoY29uc3Qga2V5d29yZCBpbiBkZWZzKSB7XG4gICAgICAgIGNvbnN0IGRlZiA9IGRlZnNba2V5d29yZF07XG4gICAgICAgIGlmICghZGVmLmtleXdvcmQpXG4gICAgICAgICAgICBkZWYua2V5d29yZCA9IGtleXdvcmQ7XG4gICAgICAgIHRoaXMuYWRkS2V5d29yZChkZWYpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldE1ldGFTY2hlbWFPcHRpb25zKCkge1xuICAgIGNvbnN0IG1ldGFPcHRzID0geyAuLi50aGlzLm9wdHMgfTtcbiAgICBmb3IgKGNvbnN0IG9wdCBvZiBNRVRBX0lHTk9SRV9PUFRJT05TKVxuICAgICAgICBkZWxldGUgbWV0YU9wdHNbb3B0XTtcbiAgICByZXR1cm4gbWV0YU9wdHM7XG59XG5jb25zdCBub0xvZ3MgPSB7IGxvZygpIHsgfSwgd2FybigpIHsgfSwgZXJyb3IoKSB7IH0gfTtcbmZ1bmN0aW9uIGdldExvZ2dlcihsb2dnZXIpIHtcbiAgICBpZiAobG9nZ2VyID09PSBmYWxzZSlcbiAgICAgICAgcmV0dXJuIG5vTG9ncztcbiAgICBpZiAobG9nZ2VyID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBjb25zb2xlO1xuICAgIGlmIChsb2dnZXIubG9nICYmIGxvZ2dlci53YXJuICYmIGxvZ2dlci5lcnJvcilcbiAgICAgICAgcmV0dXJuIGxvZ2dlcjtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJsb2dnZXIgbXVzdCBpbXBsZW1lbnQgbG9nLCB3YXJuIGFuZCBlcnJvciBtZXRob2RzXCIpO1xufVxuY29uc3QgS0VZV09SRF9OQU1FID0gL15bYS16XyRdW2EtejAtOV8kOi1dKiQvaTtcbmZ1bmN0aW9uIGNoZWNrS2V5d29yZChrZXl3b3JkLCBkZWYpIHtcbiAgICBjb25zdCB7IFJVTEVTIH0gPSB0aGlzO1xuICAgIHV0aWxfMS5lYWNoSXRlbShrZXl3b3JkLCAoa3dkKSA9PiB7XG4gICAgICAgIGlmIChSVUxFUy5rZXl3b3Jkc1trd2RdKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXl3b3JkICR7a3dkfSBpcyBhbHJlYWR5IGRlZmluZWRgKTtcbiAgICAgICAgaWYgKCFLRVlXT1JEX05BTUUudGVzdChrd2QpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXl3b3JkICR7a3dkfSBoYXMgaW52YWxpZCBuYW1lYCk7XG4gICAgfSk7XG4gICAgaWYgKCFkZWYpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoZGVmLiRkYXRhICYmICEoXCJjb2RlXCIgaW4gZGVmIHx8IFwidmFsaWRhdGVcIiBpbiBkZWYpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignJGRhdGEga2V5d29yZCBtdXN0IGhhdmUgXCJjb2RlXCIgb3IgXCJ2YWxpZGF0ZVwiIGZ1bmN0aW9uJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkUnVsZShrZXl3b3JkLCBkZWZpbml0aW9uLCBkYXRhVHlwZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBwb3N0ID0gZGVmaW5pdGlvbiA9PT0gbnVsbCB8fCBkZWZpbml0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZWZpbml0aW9uLnBvc3Q7XG4gICAgaWYgKGRhdGFUeXBlICYmIHBvc3QpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigna2V5d29yZCB3aXRoIFwicG9zdFwiIGZsYWcgY2Fubm90IGhhdmUgXCJ0eXBlXCInKTtcbiAgICBjb25zdCB7IFJVTEVTIH0gPSB0aGlzO1xuICAgIGxldCBydWxlR3JvdXAgPSBwb3N0ID8gUlVMRVMucG9zdCA6IFJVTEVTLnJ1bGVzLmZpbmQoKHsgdHlwZTogdCB9KSA9PiB0ID09PSBkYXRhVHlwZSk7XG4gICAgaWYgKCFydWxlR3JvdXApIHtcbiAgICAgICAgcnVsZUdyb3VwID0geyB0eXBlOiBkYXRhVHlwZSwgcnVsZXM6IFtdIH07XG4gICAgICAgIFJVTEVTLnJ1bGVzLnB1c2gocnVsZUdyb3VwKTtcbiAgICB9XG4gICAgUlVMRVMua2V5d29yZHNba2V5d29yZF0gPSB0cnVlO1xuICAgIGlmICghZGVmaW5pdGlvbilcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHJ1bGUgPSB7XG4gICAgICAgIGtleXdvcmQsXG4gICAgICAgIGRlZmluaXRpb246IHtcbiAgICAgICAgICAgIC4uLmRlZmluaXRpb24sXG4gICAgICAgICAgICB0eXBlOiBkYXRhVHlwZV8xLmdldEpTT05UeXBlcyhkZWZpbml0aW9uLnR5cGUpLFxuICAgICAgICAgICAgc2NoZW1hVHlwZTogZGF0YVR5cGVfMS5nZXRKU09OVHlwZXMoZGVmaW5pdGlvbi5zY2hlbWFUeXBlKSxcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIGlmIChkZWZpbml0aW9uLmJlZm9yZSlcbiAgICAgICAgYWRkQmVmb3JlUnVsZS5jYWxsKHRoaXMsIHJ1bGVHcm91cCwgcnVsZSwgZGVmaW5pdGlvbi5iZWZvcmUpO1xuICAgIGVsc2VcbiAgICAgICAgcnVsZUdyb3VwLnJ1bGVzLnB1c2gocnVsZSk7XG4gICAgUlVMRVMuYWxsW2tleXdvcmRdID0gcnVsZTtcbiAgICAoX2EgPSBkZWZpbml0aW9uLmltcGxlbWVudHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChrd2QpID0+IHRoaXMuYWRkS2V5d29yZChrd2QpKTtcbn1cbmZ1bmN0aW9uIGFkZEJlZm9yZVJ1bGUocnVsZUdyb3VwLCBydWxlLCBiZWZvcmUpIHtcbiAgICBjb25zdCBpID0gcnVsZUdyb3VwLnJ1bGVzLmZpbmRJbmRleCgoX3J1bGUpID0+IF9ydWxlLmtleXdvcmQgPT09IGJlZm9yZSk7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgICBydWxlR3JvdXAucnVsZXMuc3BsaWNlKGksIDAsIHJ1bGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcnVsZUdyb3VwLnJ1bGVzLnB1c2gocnVsZSk7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYHJ1bGUgJHtiZWZvcmV9IGlzIG5vdCBkZWZpbmVkYCk7XG4gICAgfVxufVxuZnVuY3Rpb24ga2V5d29yZE1ldGFzY2hlbWEoZGVmKSB7XG4gICAgbGV0IHsgbWV0YVNjaGVtYSB9ID0gZGVmO1xuICAgIGlmIChtZXRhU2NoZW1hID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoZGVmLiRkYXRhICYmIHRoaXMub3B0cy4kZGF0YSlcbiAgICAgICAgbWV0YVNjaGVtYSA9IHNjaGVtYU9yRGF0YShtZXRhU2NoZW1hKTtcbiAgICBkZWYudmFsaWRhdGVTY2hlbWEgPSB0aGlzLmNvbXBpbGUobWV0YVNjaGVtYSwgdHJ1ZSk7XG59XG5jb25zdCAkZGF0YVJlZiA9IHtcbiAgICAkcmVmOiBcImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9hanYtdmFsaWRhdG9yL2Fqdi9tYXN0ZXIvbGliL3JlZnMvZGF0YS5qc29uI1wiLFxufTtcbmZ1bmN0aW9uIHNjaGVtYU9yRGF0YShzY2hlbWEpIHtcbiAgICByZXR1cm4geyBhbnlPZjogW3NjaGVtYSwgJGRhdGFSZWZdIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3JlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiaWRcIixcbiAgICBjb2RlKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05PVCBTVVBQT1JURUQ6IGtleXdvcmQgXCJpZFwiLCB1c2UgXCIkaWRcIiBmb3Igc2NoZW1hIElEJyk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2FsbFJlZiA9IGV4cG9ydHMuZ2V0VmFsaWRhdGUgPSB2b2lkIDA7XG5jb25zdCByZWZfZXJyb3JfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3JlZl9lcnJvclwiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9uYW1lc1wiKTtcbmNvbnN0IGNvbXBpbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcIiRyZWZcIixcbiAgICBzY2hlbWFUeXBlOiBcInN0cmluZ1wiLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWE6ICRyZWYsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgYmFzZUlkLCBzY2hlbWFFbnY6IGVudiwgdmFsaWRhdGVOYW1lLCBvcHRzLCBzZWxmIH0gPSBpdDtcbiAgICAgICAgY29uc3QgeyByb290IH0gPSBlbnY7XG4gICAgICAgIGlmICgoJHJlZiA9PT0gXCIjXCIgfHwgJHJlZiA9PT0gXCIjL1wiKSAmJiBiYXNlSWQgPT09IHJvb3QuYmFzZUlkKVxuICAgICAgICAgICAgcmV0dXJuIGNhbGxSb290UmVmKCk7XG4gICAgICAgIGNvbnN0IHNjaE9yRW52ID0gY29tcGlsZV8xLnJlc29sdmVSZWYuY2FsbChzZWxmLCByb290LCBiYXNlSWQsICRyZWYpO1xuICAgICAgICBpZiAoc2NoT3JFbnYgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyByZWZfZXJyb3JfMS5kZWZhdWx0KGJhc2VJZCwgJHJlZik7XG4gICAgICAgIGlmIChzY2hPckVudiBpbnN0YW5jZW9mIGNvbXBpbGVfMS5TY2hlbWFFbnYpXG4gICAgICAgICAgICByZXR1cm4gY2FsbFZhbGlkYXRlKHNjaE9yRW52KTtcbiAgICAgICAgcmV0dXJuIGlubGluZVJlZlNjaGVtYShzY2hPckVudik7XG4gICAgICAgIGZ1bmN0aW9uIGNhbGxSb290UmVmKCkge1xuICAgICAgICAgICAgaWYgKGVudiA9PT0gcm9vdClcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbFJlZihjeHQsIHZhbGlkYXRlTmFtZSwgZW52LCBlbnYuJGFzeW5jKTtcbiAgICAgICAgICAgIGNvbnN0IHJvb3ROYW1lID0gZ2VuLnNjb3BlVmFsdWUoXCJyb290XCIsIHsgcmVmOiByb290IH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxSZWYoY3h0LCBjb2RlZ2VuXzEuXyBgJHtyb290TmFtZX0udmFsaWRhdGVgLCByb290LCByb290LiRhc3luYyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2FsbFZhbGlkYXRlKHNjaCkge1xuICAgICAgICAgICAgY29uc3QgdiA9IGdldFZhbGlkYXRlKGN4dCwgc2NoKTtcbiAgICAgICAgICAgIGNhbGxSZWYoY3h0LCB2LCBzY2gsIHNjaC4kYXN5bmMpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlubGluZVJlZlNjaGVtYShzY2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaE5hbWUgPSBnZW4uc2NvcGVWYWx1ZShcInNjaGVtYVwiLCBvcHRzLmNvZGUuc291cmNlID09PSB0cnVlID8geyByZWY6IHNjaCwgY29kZTogY29kZWdlbl8xLnN0cmluZ2lmeShzY2gpIH0gOiB7IHJlZjogc2NoIH0pO1xuICAgICAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAgc2NoZW1hOiBzY2gsXG4gICAgICAgICAgICAgICAgZGF0YVR5cGVzOiBbXSxcbiAgICAgICAgICAgICAgICBzY2hlbWFQYXRoOiBjb2RlZ2VuXzEubmlsLFxuICAgICAgICAgICAgICAgIHRvcFNjaGVtYVJlZjogc2NoTmFtZSxcbiAgICAgICAgICAgICAgICBlcnJTY2hlbWFQYXRoOiAkcmVmLFxuICAgICAgICAgICAgfSwgdmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dCk7XG4gICAgICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5mdW5jdGlvbiBnZXRWYWxpZGF0ZShjeHQsIHNjaCkge1xuICAgIGNvbnN0IHsgZ2VuIH0gPSBjeHQ7XG4gICAgcmV0dXJuIHNjaC52YWxpZGF0ZVxuICAgICAgICA/IGdlbi5zY29wZVZhbHVlKFwidmFsaWRhdGVcIiwgeyByZWY6IHNjaC52YWxpZGF0ZSB9KVxuICAgICAgICA6IGNvZGVnZW5fMS5fIGAke2dlbi5zY29wZVZhbHVlKFwid3JhcHBlclwiLCB7IHJlZjogc2NoIH0pfS52YWxpZGF0ZWA7XG59XG5leHBvcnRzLmdldFZhbGlkYXRlID0gZ2V0VmFsaWRhdGU7XG5mdW5jdGlvbiBjYWxsUmVmKGN4dCwgdiwgc2NoLCAkYXN5bmMpIHtcbiAgICBjb25zdCB7IGdlbiwgaXQgfSA9IGN4dDtcbiAgICBjb25zdCB7IGFsbEVycm9ycywgc2NoZW1hRW52OiBlbnYsIG9wdHMgfSA9IGl0O1xuICAgIGNvbnN0IHBhc3NDeHQgPSBvcHRzLnBhc3NDb250ZXh0ID8gbmFtZXNfMS5kZWZhdWx0LnRoaXMgOiBjb2RlZ2VuXzEubmlsO1xuICAgIGlmICgkYXN5bmMpXG4gICAgICAgIGNhbGxBc3luY1JlZigpO1xuICAgIGVsc2VcbiAgICAgICAgY2FsbFN5bmNSZWYoKTtcbiAgICBmdW5jdGlvbiBjYWxsQXN5bmNSZWYoKSB7XG4gICAgICAgIGlmICghZW52LiRhc3luYylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFzeW5jIHNjaGVtYSByZWZlcmVuY2VkIGJ5IHN5bmMgc2NoZW1hXCIpO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiKTtcbiAgICAgICAgZ2VuLnRyeSgoKSA9PiB7XG4gICAgICAgICAgICBnZW4uY29kZShjb2RlZ2VuXzEuXyBgYXdhaXQgJHtjb2RlXzEuY2FsbFZhbGlkYXRlQ29kZShjeHQsIHYsIHBhc3NDeHQpfWApO1xuICAgICAgICAgICAgYWRkRXZhbHVhdGVkRnJvbSh2KTsgLy8gVE9ETyB3aWxsIG5vdCB3b3JrIHdpdGggYXN5bmMsIGl0IGhhcyB0byBiZSByZXR1cm5lZCB3aXRoIHRoZSByZXN1bHRcbiAgICAgICAgICAgIGlmICghYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpO1xuICAgICAgICB9LCAoZSkgPT4ge1xuICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAhKCR7ZX0gaW5zdGFuY2VvZiAke2l0LlZhbGlkYXRpb25FcnJvcn0pYCwgKCkgPT4gZ2VuLnRocm93KGUpKTtcbiAgICAgICAgICAgIGFkZEVycm9yc0Zyb20oZSk7XG4gICAgICAgICAgICBpZiAoIWFsbEVycm9ycylcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYWxsU3luY1JlZigpIHtcbiAgICAgICAgY3h0LnJlc3VsdChjb2RlXzEuY2FsbFZhbGlkYXRlQ29kZShjeHQsIHYsIHBhc3NDeHQpLCAoKSA9PiBhZGRFdmFsdWF0ZWRGcm9tKHYpLCAoKSA9PiBhZGRFcnJvcnNGcm9tKHYpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkRXJyb3JzRnJvbShzb3VyY2UpIHtcbiAgICAgICAgY29uc3QgZXJycyA9IGNvZGVnZW5fMS5fIGAke3NvdXJjZX0uZXJyb3JzYDtcbiAgICAgICAgZ2VuLmFzc2lnbihuYW1lc18xLmRlZmF1bHQudkVycm9ycywgY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9ID09PSBudWxsID8gJHtlcnJzfSA6ICR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9LmNvbmNhdCgke2VycnN9KWApOyAvLyBUT0RPIHRhZ2dlZFxuICAgICAgICBnZW4uYXNzaWduKG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMsIGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfS5sZW5ndGhgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkRXZhbHVhdGVkRnJvbShzb3VyY2UpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIWl0Lm9wdHMudW5ldmFsdWF0ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHNjaEV2YWx1YXRlZCA9IChfYSA9IHNjaCA9PT0gbnVsbCB8fCBzY2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjaC52YWxpZGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmV2YWx1YXRlZDtcbiAgICAgICAgLy8gVE9ETyByZWZhY3RvclxuICAgICAgICBpZiAoaXQucHJvcHMgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmIChzY2hFdmFsdWF0ZWQgJiYgIXNjaEV2YWx1YXRlZC5keW5hbWljUHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NoRXZhbHVhdGVkLnByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaXQucHJvcHMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQucHJvcHMoZ2VuLCBzY2hFdmFsdWF0ZWQucHJvcHMsIGl0LnByb3BzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wcyA9IGdlbi52YXIoXCJwcm9wc1wiLCBjb2RlZ2VuXzEuXyBgJHtzb3VyY2V9LmV2YWx1YXRlZC5wcm9wc2ApO1xuICAgICAgICAgICAgICAgIGl0LnByb3BzID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgcHJvcHMsIGl0LnByb3BzLCBjb2RlZ2VuXzEuTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0Lml0ZW1zICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoc2NoRXZhbHVhdGVkICYmICFzY2hFdmFsdWF0ZWQuZHluYW1pY0l0ZW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjaEV2YWx1YXRlZC5pdGVtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0Lml0ZW1zID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLml0ZW1zKGdlbiwgc2NoRXZhbHVhdGVkLml0ZW1zLCBpdC5pdGVtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBnZW4udmFyKFwiaXRlbXNcIiwgY29kZWdlbl8xLl8gYCR7c291cmNlfS5ldmFsdWF0ZWQuaXRlbXNgKTtcbiAgICAgICAgICAgICAgICBpdC5pdGVtcyA9IHV0aWxfMS5tZXJnZUV2YWx1YXRlZC5pdGVtcyhnZW4sIGl0ZW1zLCBpdC5pdGVtcywgY29kZWdlbl8xLk5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5jYWxsUmVmID0gY2FsbFJlZjtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGlkXzEgPSByZXF1aXJlKFwiLi9pZFwiKTtcbmNvbnN0IHJlZl8xID0gcmVxdWlyZShcIi4vcmVmXCIpO1xuY29uc3QgY29yZSA9IFtcbiAgICBcIiRzY2hlbWFcIixcbiAgICBcIiRpZFwiLFxuICAgIFwiJGRlZnNcIixcbiAgICBcIiR2b2NhYnVsYXJ5XCIsXG4gICAgeyBrZXl3b3JkOiBcIiRjb21tZW50XCIgfSxcbiAgICBcImRlZmluaXRpb25zXCIsXG4gICAgaWRfMS5kZWZhdWx0LFxuICAgIHJlZl8xLmRlZmF1bHQsXG5dO1xuZXhwb3J0cy5kZWZhdWx0ID0gY29yZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IG9wcyA9IGNvZGVnZW5fMS5vcGVyYXRvcnM7XG5jb25zdCBLV0RzID0ge1xuICAgIG1heGltdW06IHsgb2tTdHI6IFwiPD1cIiwgb2s6IG9wcy5MVEUsIGZhaWw6IG9wcy5HVCB9LFxuICAgIG1pbmltdW06IHsgb2tTdHI6IFwiPj1cIiwgb2s6IG9wcy5HVEUsIGZhaWw6IG9wcy5MVCB9LFxuICAgIGV4Y2x1c2l2ZU1heGltdW06IHsgb2tTdHI6IFwiPFwiLCBvazogb3BzLkxULCBmYWlsOiBvcHMuR1RFIH0sXG4gICAgZXhjbHVzaXZlTWluaW11bTogeyBva1N0cjogXCI+XCIsIG9rOiBvcHMuR1QsIGZhaWw6IG9wcy5MVEUgfSxcbn07XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBrZXl3b3JkLCBzY2hlbWFDb2RlIH0pID0+IGNvZGVnZW5fMS5zdHIgYG11c3QgYmUgJHtLV0RzW2tleXdvcmRdLm9rU3RyfSAke3NjaGVtYUNvZGV9YCxcbiAgICBwYXJhbXM6ICh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkgPT4gY29kZWdlbl8xLl8gYHtjb21wYXJpc29uOiAke0tXRHNba2V5d29yZF0ub2tTdHJ9LCBsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBPYmplY3Qua2V5cyhLV0RzKSxcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBrZXl3b3JkLCBkYXRhLCBzY2hlbWFDb2RlIH0gPSBjeHQ7XG4gICAgICAgIGN4dC5mYWlsJGRhdGEoY29kZWdlbl8xLl8gYCR7ZGF0YX0gJHtLV0RzW2tleXdvcmRdLmZhaWx9ICR7c2NoZW1hQ29kZX0gfHwgaXNOYU4oJHtkYXRhfSlgKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbWl0TnVtYmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHNjaGVtYUNvZGUgfSkgPT4gY29kZWdlbl8xLnN0ciBgbXVzdCBiZSBtdWx0aXBsZSBvZiAke3NjaGVtYUNvZGV9YCxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gY29kZWdlbl8xLl8gYHttdWx0aXBsZU9mOiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwibXVsdGlwbGVPZlwiLFxuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgc2NoZW1hVHlwZTogXCJudW1iZXJcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgLy8gY29uc3QgYmR0ID0gYmFkJERhdGFUeXBlKHNjaGVtYUNvZGUsIDxzdHJpbmc+ZGVmLnNjaGVtYVR5cGUsICRkYXRhKVxuICAgICAgICBjb25zdCBwcmVjID0gaXQub3B0cy5tdWx0aXBsZU9mUHJlY2lzaW9uO1xuICAgICAgICBjb25zdCByZXMgPSBnZW4ubGV0KFwicmVzXCIpO1xuICAgICAgICBjb25zdCBpbnZhbGlkID0gcHJlY1xuICAgICAgICAgICAgPyBjb2RlZ2VuXzEuXyBgTWF0aC5hYnMoTWF0aC5yb3VuZCgke3Jlc30pIC0gJHtyZXN9KSA+IDFlLSR7cHJlY31gXG4gICAgICAgICAgICA6IGNvZGVnZW5fMS5fIGAke3Jlc30gIT09IHBhcnNlSW50KCR7cmVzfSlgO1xuICAgICAgICBjeHQuZmFpbCRkYXRhKGNvZGVnZW5fMS5fIGAoJHtzY2hlbWFDb2RlfSA9PT0gMCB8fCAoJHtyZXN9ID0gJHtkYXRhfS8ke3NjaGVtYUNvZGV9LCAke2ludmFsaWR9KSlgKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11bHRpcGxlT2YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZ1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jlc3RpZWpzL3B1bnljb2RlLmpzIC0gcHVueWNvZGUudWNzMi5kZWNvZGVcbmZ1bmN0aW9uIHVjczJsZW5ndGgoc3RyKSB7XG4gICAgY29uc3QgbGVuID0gc3RyLmxlbmd0aDtcbiAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICBsZXQgcG9zID0gMDtcbiAgICBsZXQgdmFsdWU7XG4gICAgd2hpbGUgKHBvcyA8IGxlbikge1xuICAgICAgICBsZW5ndGgrKztcbiAgICAgICAgdmFsdWUgPSBzdHIuY2hhckNvZGVBdChwb3MrKyk7XG4gICAgICAgIGlmICh2YWx1ZSA+PSAweGQ4MDAgJiYgdmFsdWUgPD0gMHhkYmZmICYmIHBvcyA8IGxlbikge1xuICAgICAgICAgICAgLy8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG4gICAgICAgICAgICB2YWx1ZSA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgICAgICBpZiAoKHZhbHVlICYgMHhmYzAwKSA9PT0gMHhkYzAwKVxuICAgICAgICAgICAgICAgIHBvcysrOyAvLyBsb3cgc3Vycm9nYXRlXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxlbmd0aDtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHVjczJsZW5ndGg7XG51Y3MybGVuZ3RoLmNvZGUgPSAncmVxdWlyZShcImFqdi9kaXN0L3J1bnRpbWUvdWNzMmxlbmd0aFwiKS5kZWZhdWx0Jztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVjczJsZW5ndGguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IHVjczJsZW5ndGhfMSA9IHJlcXVpcmUoXCIuLi8uLi9ydW50aW1lL3VjczJsZW5ndGhcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlKHsga2V5d29yZCwgc2NoZW1hQ29kZSB9KSB7XG4gICAgICAgIGNvbnN0IGNvbXAgPSBrZXl3b3JkID09PSBcIm1heExlbmd0aFwiID8gXCJtb3JlXCIgOiBcImZld2VyXCI7XG4gICAgICAgIHJldHVybiBjb2RlZ2VuXzEuc3RyIGBtdXN0IE5PVCBoYXZlICR7Y29tcH0gdGhhbiAke3NjaGVtYUNvZGV9IGNoYXJhY3RlcnNgO1xuICAgIH0sXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+IGNvZGVnZW5fMS5fIGB7bGltaXQ6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogW1wibWF4TGVuZ3RoXCIsIFwibWluTGVuZ3RoXCJdLFxuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgc2NoZW1hVHlwZTogXCJudW1iZXJcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGtleXdvcmQsIGRhdGEsIHNjaGVtYUNvZGUsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IG9wID0ga2V5d29yZCA9PT0gXCJtYXhMZW5ndGhcIiA/IGNvZGVnZW5fMS5vcGVyYXRvcnMuR1QgOiBjb2RlZ2VuXzEub3BlcmF0b3JzLkxUO1xuICAgICAgICBjb25zdCBsZW4gPSBpdC5vcHRzLnVuaWNvZGUgPT09IGZhbHNlID8gY29kZWdlbl8xLl8gYCR7ZGF0YX0ubGVuZ3RoYCA6IGNvZGVnZW5fMS5fIGAke3V0aWxfMS51c2VGdW5jKGN4dC5nZW4sIHVjczJsZW5ndGhfMS5kZWZhdWx0KX0oJHtkYXRhfSlgO1xuICAgICAgICBjeHQuZmFpbCRkYXRhKGNvZGVnZW5fMS5fIGAke2xlbn0gJHtvcH0gJHtzY2hlbWFDb2RlfWApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGltaXRMZW5ndGguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBzY2hlbWFDb2RlIH0pID0+IGNvZGVnZW5fMS5zdHIgYG11c3QgbWF0Y2ggcGF0dGVybiBcIiR7c2NoZW1hQ29kZX1cImAsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+IGNvZGVnZW5fMS5fIGB7cGF0dGVybjogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInBhdHRlcm5cIixcbiAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgIHNjaGVtYVR5cGU6IFwic3RyaW5nXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhLCAkZGF0YSwgc2NoZW1hLCBzY2hlbWFDb2RlLCBpdCB9ID0gY3h0O1xuICAgICAgICAvLyBUT0RPIHJlZ2V4cCBzaG91bGQgYmUgd3JhcHBlZCBpbiB0cnkvY2F0Y2hzXG4gICAgICAgIGNvbnN0IHUgPSBpdC5vcHRzLnVuaWNvZGVSZWdFeHAgPyBcInVcIiA6IFwiXCI7XG4gICAgICAgIGNvbnN0IHJlZ0V4cCA9ICRkYXRhID8gY29kZWdlbl8xLl8gYChuZXcgUmVnRXhwKCR7c2NoZW1hQ29kZX0sICR7dX0pKWAgOiBjb2RlXzEudXNlUGF0dGVybihjeHQsIHNjaGVtYSk7XG4gICAgICAgIGN4dC5mYWlsJGRhdGEoY29kZWdlbl8xLl8gYCEke3JlZ0V4cH0udGVzdCgke2RhdGF9KWApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF0dGVybi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlKHsga2V5d29yZCwgc2NoZW1hQ29kZSB9KSB7XG4gICAgICAgIGNvbnN0IGNvbXAgPSBrZXl3b3JkID09PSBcIm1heFByb3BlcnRpZXNcIiA/IFwibW9yZVwiIDogXCJmZXdlclwiO1xuICAgICAgICByZXR1cm4gY29kZWdlbl8xLnN0ciBgbXVzdCBOT1QgaGF2ZSAke2NvbXB9IHRoYW4gJHtzY2hlbWFDb2RlfSBpdGVtc2A7XG4gICAgfSxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gY29kZWdlbl8xLl8gYHtsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBbXCJtYXhQcm9wZXJ0aWVzXCIsIFwibWluUHJvcGVydGllc1wiXSxcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBrZXl3b3JkLCBkYXRhLCBzY2hlbWFDb2RlIH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IG9wID0ga2V5d29yZCA9PT0gXCJtYXhQcm9wZXJ0aWVzXCIgPyBjb2RlZ2VuXzEub3BlcmF0b3JzLkdUIDogY29kZWdlbl8xLm9wZXJhdG9ycy5MVDtcbiAgICAgICAgY3h0LmZhaWwkZGF0YShjb2RlZ2VuXzEuXyBgT2JqZWN0LmtleXMoJHtkYXRhfSkubGVuZ3RoICR7b3B9ICR7c2NoZW1hQ29kZX1gKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbWl0UHJvcGVydGllcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5IH0gfSkgPT4gY29kZWdlbl8xLnN0ciBgbXVzdCBoYXZlIHJlcXVpcmVkIHByb3BlcnR5ICcke21pc3NpbmdQcm9wZXJ0eX0nYCxcbiAgICBwYXJhbXM6ICh7IHBhcmFtczogeyBtaXNzaW5nUHJvcGVydHkgfSB9KSA9PiBjb2RlZ2VuXzEuXyBge21pc3NpbmdQcm9wZXJ0eTogJHttaXNzaW5nUHJvcGVydHl9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwicmVxdWlyZWRcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFwiYXJyYXlcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBzY2hlbWFDb2RlLCBkYXRhLCAkZGF0YSwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBvcHRzIH0gPSBpdDtcbiAgICAgICAgaWYgKCEkZGF0YSAmJiBzY2hlbWEubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB1c2VMb29wID0gc2NoZW1hLmxlbmd0aCA+PSBvcHRzLmxvb3BSZXF1aXJlZDtcbiAgICAgICAgaWYgKGl0LmFsbEVycm9ycylcbiAgICAgICAgICAgIGFsbEVycm9yc01vZGUoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZXhpdE9uRXJyb3JNb2RlKCk7XG4gICAgICAgIGlmIChvcHRzLnN0cmljdFJlcXVpcmVkKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IGN4dC5wYXJlbnRTY2hlbWEucHJvcGVydGllcztcbiAgICAgICAgICAgIGNvbnN0IHsgZGVmaW5lZFByb3BlcnRpZXMgfSA9IGN4dC5pdDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVxdWlyZWRLZXkgb2Ygc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgaWYgKChwcm9wcyA9PT0gbnVsbCB8fCBwcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvcHNbcmVxdWlyZWRLZXldKSA9PT0gdW5kZWZpbmVkICYmICFkZWZpbmVkUHJvcGVydGllcy5oYXMocmVxdWlyZWRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtYVBhdGggPSBpdC5zY2hlbWFFbnYuYmFzZUlkICsgaXQuZXJyU2NoZW1hUGF0aDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbXNnID0gYHJlcXVpcmVkIHByb3BlcnR5IFwiJHtyZXF1aXJlZEtleX1cIiBpcyBub3QgZGVmaW5lZCBhdCBcIiR7c2NoZW1hUGF0aH1cIiAoc3RyaWN0UmVxdWlyZWQpYDtcbiAgICAgICAgICAgICAgICAgICAgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZShpdCwgbXNnLCBpdC5vcHRzLnN0cmljdFJlcXVpcmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWxsRXJyb3JzTW9kZSgpIHtcbiAgICAgICAgICAgIGlmICh1c2VMb29wIHx8ICRkYXRhKSB7XG4gICAgICAgICAgICAgICAgY3h0LmJsb2NrJGRhdGEoY29kZWdlbl8xLm5pbCwgbG9vcEFsbFJlcXVpcmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZV8xLmNoZWNrUmVwb3J0TWlzc2luZ1Byb3AoY3h0LCBwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZXhpdE9uRXJyb3JNb2RlKCkge1xuICAgICAgICAgICAgY29uc3QgbWlzc2luZyA9IGdlbi5sZXQoXCJtaXNzaW5nXCIpO1xuICAgICAgICAgICAgaWYgKHVzZUxvb3AgfHwgJGRhdGEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBjeHQuYmxvY2skZGF0YSh2YWxpZCwgKCkgPT4gbG9vcFVudGlsTWlzc2luZyhtaXNzaW5nLCB2YWxpZCkpO1xuICAgICAgICAgICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZW4uaWYoY29kZV8xLmNoZWNrTWlzc2luZ1Byb3AoY3h0LCBzY2hlbWEsIG1pc3NpbmcpKTtcbiAgICAgICAgICAgICAgICBjb2RlXzEucmVwb3J0TWlzc2luZ1Byb3AoY3h0LCBtaXNzaW5nKTtcbiAgICAgICAgICAgICAgICBnZW4uZWxzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxvb3BBbGxSZXF1aXJlZCgpIHtcbiAgICAgICAgICAgIGdlbi5mb3JPZihcInByb3BcIiwgc2NoZW1hQ29kZSwgKHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgbWlzc2luZ1Byb3BlcnR5OiBwcm9wIH0pO1xuICAgICAgICAgICAgICAgIGdlbi5pZihjb2RlXzEubm9Qcm9wZXJ0eUluRGF0YShnZW4sIGRhdGEsIHByb3AsIG9wdHMub3duUHJvcGVydGllcyksICgpID0+IGN4dC5lcnJvcigpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxvb3BVbnRpbE1pc3NpbmcobWlzc2luZywgdmFsaWQpIHtcbiAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBtaXNzaW5nUHJvcGVydHk6IG1pc3NpbmcgfSk7XG4gICAgICAgICAgICBnZW4uZm9yT2YobWlzc2luZywgc2NoZW1hQ29kZSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGNvZGVfMS5wcm9wZXJ0eUluRGF0YShnZW4sIGRhdGEsIG1pc3NpbmcsIG9wdHMub3duUHJvcGVydGllcykpO1xuICAgICAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEubm90KHZhbGlkKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjeHQuZXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmJyZWFrKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBjb2RlZ2VuXzEubmlsKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVxdWlyZWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZSh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkge1xuICAgICAgICBjb25zdCBjb21wID0ga2V5d29yZCA9PT0gXCJtYXhJdGVtc1wiID8gXCJtb3JlXCIgOiBcImZld2VyXCI7XG4gICAgICAgIHJldHVybiBjb2RlZ2VuXzEuc3RyIGBtdXN0IE5PVCBoYXZlICR7Y29tcH0gdGhhbiAke3NjaGVtYUNvZGV9IGl0ZW1zYDtcbiAgICB9LFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuXyBge2xpbWl0OiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFtcIm1heEl0ZW1zXCIsIFwibWluSXRlbXNcIl0sXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBrZXl3b3JkLCBkYXRhLCBzY2hlbWFDb2RlIH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IG9wID0ga2V5d29yZCA9PT0gXCJtYXhJdGVtc1wiID8gY29kZWdlbl8xLm9wZXJhdG9ycy5HVCA6IGNvZGVnZW5fMS5vcGVyYXRvcnMuTFQ7XG4gICAgICAgIGN4dC5mYWlsJGRhdGEoY29kZWdlbl8xLl8gYCR7ZGF0YX0ubGVuZ3RoICR7b3B9ICR7c2NoZW1hQ29kZX1gKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbWl0SXRlbXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vYWp2LXZhbGlkYXRvci9hanYvaXNzdWVzLzg4OVxuY29uc3QgZXF1YWwgPSByZXF1aXJlKFwiZmFzdC1kZWVwLWVxdWFsXCIpO1xuZXF1YWwuY29kZSA9ICdyZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS9lcXVhbFwiKS5kZWZhdWx0JztcbmV4cG9ydHMuZGVmYXVsdCA9IGVxdWFsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXF1YWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBkYXRhVHlwZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGUvZGF0YVR5cGVcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVxdWFsXzEgPSByZXF1aXJlKFwiLi4vLi4vcnVudGltZS9lcXVhbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBpLCBqIH0gfSkgPT4gY29kZWdlbl8xLnN0ciBgbXVzdCBOT1QgaGF2ZSBkdXBsaWNhdGUgaXRlbXMgKGl0ZW1zICMjICR7an0gYW5kICR7aX0gYXJlIGlkZW50aWNhbClgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IGksIGogfSB9KSA9PiBjb2RlZ2VuXzEuXyBge2k6ICR7aX0sIGo6ICR7an19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJ1bmlxdWVJdGVtc1wiLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBcImJvb2xlYW5cIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgJGRhdGEsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBzY2hlbWFDb2RlLCBpdCB9ID0gY3h0O1xuICAgICAgICBpZiAoISRkYXRhICYmICFzY2hlbWEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIpO1xuICAgICAgICBjb25zdCBpdGVtVHlwZXMgPSBwYXJlbnRTY2hlbWEuaXRlbXMgPyBkYXRhVHlwZV8xLmdldFNjaGVtYVR5cGVzKHBhcmVudFNjaGVtYS5pdGVtcykgOiBbXTtcbiAgICAgICAgY3h0LmJsb2NrJGRhdGEodmFsaWQsIHZhbGlkYXRlVW5pcXVlSXRlbXMsIGNvZGVnZW5fMS5fIGAke3NjaGVtYUNvZGV9ID09PSBmYWxzZWApO1xuICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZVVuaXF1ZUl0ZW1zKCkge1xuICAgICAgICAgICAgY29uc3QgaSA9IGdlbi5sZXQoXCJpXCIsIGNvZGVnZW5fMS5fIGAke2RhdGF9Lmxlbmd0aGApO1xuICAgICAgICAgICAgY29uc3QgaiA9IGdlbi5sZXQoXCJqXCIpO1xuICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IGksIGogfSk7XG4gICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKTtcbiAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtpfSA+IDFgLCAoKSA9PiAoY2FuT3B0aW1pemUoKSA/IGxvb3BOIDogbG9vcE4yKShpLCBqKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2FuT3B0aW1pemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbVR5cGVzLmxlbmd0aCA+IDAgJiYgIWl0ZW1UeXBlcy5zb21lKCh0KSA9PiB0ID09PSBcIm9iamVjdFwiIHx8IHQgPT09IFwiYXJyYXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbG9vcE4oaSwgaikge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGdlbi5uYW1lKFwiaXRlbVwiKTtcbiAgICAgICAgICAgIGNvbnN0IHdyb25nVHlwZSA9IGRhdGFUeXBlXzEuY2hlY2tEYXRhVHlwZXMoaXRlbVR5cGVzLCBpdGVtLCBpdC5vcHRzLnN0cmljdE51bWJlcnMsIGRhdGFUeXBlXzEuRGF0YVR5cGUuV3JvbmcpO1xuICAgICAgICAgICAgY29uc3QgaW5kaWNlcyA9IGdlbi5jb25zdChcImluZGljZXNcIiwgY29kZWdlbl8xLl8gYHt9YCk7XG4gICAgICAgICAgICBnZW4uZm9yKGNvZGVnZW5fMS5fIGA7JHtpfS0tO2AsICgpID0+IHtcbiAgICAgICAgICAgICAgICBnZW4ubGV0KGl0ZW0sIGNvZGVnZW5fMS5fIGAke2RhdGF9WyR7aX1dYCk7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKHdyb25nVHlwZSwgY29kZWdlbl8xLl8gYGNvbnRpbnVlYCk7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1UeXBlcy5sZW5ndGggPiAxKVxuICAgICAgICAgICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLl8gYHR5cGVvZiAke2l0ZW19ID09IFwic3RyaW5nXCJgLCBjb2RlZ2VuXzEuXyBgJHtpdGVtfSArPSBcIl9cImApO1xuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuaWYoY29kZWdlbl8xLl8gYHR5cGVvZiAke2luZGljZXN9WyR7aXRlbX1dID09IFwibnVtYmVyXCJgLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oaiwgY29kZWdlbl8xLl8gYCR7aW5kaWNlc31bJHtpdGVtfV1gKTtcbiAgICAgICAgICAgICAgICAgICAgY3h0LmVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKS5icmVhaygpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jb2RlKGNvZGVnZW5fMS5fIGAke2luZGljZXN9WyR7aXRlbX1dID0gJHtpfWApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbG9vcE4yKGksIGopIHtcbiAgICAgICAgICAgIGNvbnN0IGVxbCA9IHV0aWxfMS51c2VGdW5jKGdlbiwgZXF1YWxfMS5kZWZhdWx0KTtcbiAgICAgICAgICAgIGNvbnN0IG91dGVyID0gZ2VuLm5hbWUoXCJvdXRlclwiKTtcbiAgICAgICAgICAgIGdlbi5sYWJlbChvdXRlcikuZm9yKGNvZGVnZW5fMS5fIGA7JHtpfS0tO2AsICgpID0+IGdlbi5mb3IoY29kZWdlbl8xLl8gYCR7an0gPSAke2l9OyAke2p9LS07YCwgKCkgPT4gZ2VuLmlmKGNvZGVnZW5fMS5fIGAke2VxbH0oJHtkYXRhfVske2l9XSwgJHtkYXRhfVske2p9XSlgLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY3h0LmVycm9yKCk7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpLmJyZWFrKG91dGVyKTtcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuaXF1ZUl0ZW1zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcXVhbF8xID0gcmVxdWlyZShcIi4uLy4uL3J1bnRpbWUvZXF1YWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiBcIm11c3QgYmUgZXF1YWwgdG8gY29uc3RhbnRcIixcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gY29kZWdlbl8xLl8gYHthbGxvd2VkVmFsdWU6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJjb25zdFwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCAkZGF0YSwgc2NoZW1hQ29kZSwgc2NoZW1hIH0gPSBjeHQ7XG4gICAgICAgIGlmICgkZGF0YSB8fCAoc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIikpIHtcbiAgICAgICAgICAgIGN4dC5mYWlsJGRhdGEoY29kZWdlbl8xLl8gYCEke3V0aWxfMS51c2VGdW5jKGdlbiwgZXF1YWxfMS5kZWZhdWx0KX0oJHtkYXRhfSwgJHtzY2hlbWFDb2RlfSlgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN4dC5mYWlsKGNvZGVnZW5fMS5fIGAke3NjaGVtYX0gIT09ICR7ZGF0YX1gKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVxdWFsXzEgPSByZXF1aXJlKFwiLi4vLi4vcnVudGltZS9lcXVhbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwibXVzdCBiZSBlcXVhbCB0byBvbmUgb2YgdGhlIGFsbG93ZWQgdmFsdWVzXCIsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+IGNvZGVnZW5fMS5fIGB7YWxsb3dlZFZhbHVlczogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImVudW1cIixcbiAgICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIGRhdGEsICRkYXRhLCBzY2hlbWEsIHNjaGVtYUNvZGUsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmICghJGRhdGEgJiYgc2NoZW1hLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImVudW0gbXVzdCBoYXZlIG5vbi1lbXB0eSBhcnJheVwiKTtcbiAgICAgICAgY29uc3QgdXNlTG9vcCA9IHNjaGVtYS5sZW5ndGggPj0gaXQub3B0cy5sb29wRW51bTtcbiAgICAgICAgY29uc3QgZXFsID0gdXRpbF8xLnVzZUZ1bmMoZ2VuLCBlcXVhbF8xLmRlZmF1bHQpO1xuICAgICAgICBsZXQgdmFsaWQ7XG4gICAgICAgIGlmICh1c2VMb29wIHx8ICRkYXRhKSB7XG4gICAgICAgICAgICB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiKTtcbiAgICAgICAgICAgIGN4dC5ibG9jayRkYXRhKHZhbGlkLCBsb29wRW51bSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICAgICAgICAgIGNvbnN0IHZTY2hlbWEgPSBnZW4uY29uc3QoXCJ2U2NoZW1hXCIsIHNjaGVtYUNvZGUpO1xuICAgICAgICAgICAgdmFsaWQgPSBjb2RlZ2VuXzEub3IoLi4uc2NoZW1hLm1hcCgoX3gsIGkpID0+IGVxdWFsQ29kZSh2U2NoZW1hLCBpKSkpO1xuICAgICAgICB9XG4gICAgICAgIGN4dC5wYXNzKHZhbGlkKTtcbiAgICAgICAgZnVuY3Rpb24gbG9vcEVudW0oKSB7XG4gICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSk7XG4gICAgICAgICAgICBnZW4uZm9yT2YoXCJ2XCIsIHNjaGVtYUNvZGUsICh2KSA9PiBnZW4uaWYoY29kZWdlbl8xLl8gYCR7ZXFsfSgke2RhdGF9LCAke3Z9KWAsICgpID0+IGdlbi5hc3NpZ24odmFsaWQsIHRydWUpLmJyZWFrKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBlcXVhbENvZGUodlNjaGVtYSwgaSkge1xuICAgICAgICAgICAgY29uc3Qgc2NoID0gc2NoZW1hW2ldO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBzY2ggPT09IFwib2JqZWN0XCIgJiYgc2NoICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBjb2RlZ2VuXzEuXyBgJHtlcWx9KCR7ZGF0YX0sICR7dlNjaGVtYX1bJHtpfV0pYFxuICAgICAgICAgICAgICAgIDogY29kZWdlbl8xLl8gYCR7ZGF0YX0gPT09ICR7c2NofWA7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVudW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBsaW1pdE51bWJlcl8xID0gcmVxdWlyZShcIi4vbGltaXROdW1iZXJcIik7XG5jb25zdCBtdWx0aXBsZU9mXzEgPSByZXF1aXJlKFwiLi9tdWx0aXBsZU9mXCIpO1xuY29uc3QgbGltaXRMZW5ndGhfMSA9IHJlcXVpcmUoXCIuL2xpbWl0TGVuZ3RoXCIpO1xuY29uc3QgcGF0dGVybl8xID0gcmVxdWlyZShcIi4vcGF0dGVyblwiKTtcbmNvbnN0IGxpbWl0UHJvcGVydGllc18xID0gcmVxdWlyZShcIi4vbGltaXRQcm9wZXJ0aWVzXCIpO1xuY29uc3QgcmVxdWlyZWRfMSA9IHJlcXVpcmUoXCIuL3JlcXVpcmVkXCIpO1xuY29uc3QgbGltaXRJdGVtc18xID0gcmVxdWlyZShcIi4vbGltaXRJdGVtc1wiKTtcbmNvbnN0IHVuaXF1ZUl0ZW1zXzEgPSByZXF1aXJlKFwiLi91bmlxdWVJdGVtc1wiKTtcbmNvbnN0IGNvbnN0XzEgPSByZXF1aXJlKFwiLi9jb25zdFwiKTtcbmNvbnN0IGVudW1fMSA9IHJlcXVpcmUoXCIuL2VudW1cIik7XG5jb25zdCB2YWxpZGF0aW9uID0gW1xuICAgIC8vIG51bWJlclxuICAgIGxpbWl0TnVtYmVyXzEuZGVmYXVsdCxcbiAgICBtdWx0aXBsZU9mXzEuZGVmYXVsdCxcbiAgICAvLyBzdHJpbmdcbiAgICBsaW1pdExlbmd0aF8xLmRlZmF1bHQsXG4gICAgcGF0dGVybl8xLmRlZmF1bHQsXG4gICAgLy8gb2JqZWN0XG4gICAgbGltaXRQcm9wZXJ0aWVzXzEuZGVmYXVsdCxcbiAgICByZXF1aXJlZF8xLmRlZmF1bHQsXG4gICAgLy8gYXJyYXlcbiAgICBsaW1pdEl0ZW1zXzEuZGVmYXVsdCxcbiAgICB1bmlxdWVJdGVtc18xLmRlZmF1bHQsXG4gICAgLy8gYW55XG4gICAgeyBrZXl3b3JkOiBcInR5cGVcIiwgc2NoZW1hVHlwZTogW1wic3RyaW5nXCIsIFwiYXJyYXlcIl0gfSxcbiAgICB7IGtleXdvcmQ6IFwibnVsbGFibGVcIiwgc2NoZW1hVHlwZTogXCJib29sZWFuXCIgfSxcbiAgICBjb25zdF8xLmRlZmF1bHQsXG4gICAgZW51bV8xLmRlZmF1bHQsXG5dO1xuZXhwb3J0cy5kZWZhdWx0ID0gdmFsaWRhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcyA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgcGFyYW1zOiB7IGxlbiB9IH0pID0+IGNvZGVnZW5fMS5zdHIgYG11c3QgTk9UIGhhdmUgbW9yZSB0aGFuICR7bGVufSBpdGVtc2AsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgbGVuIH0gfSkgPT4gY29kZWdlbl8xLl8gYHtsaW1pdDogJHtsZW59fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiYWRkaXRpb25hbEl0ZW1zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFtcImJvb2xlYW5cIiwgXCJvYmplY3RcIl0sXG4gICAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgaXRlbXMgfSA9IHBhcmVudFNjaGVtYTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICAgICAgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZShpdCwgJ1wiYWRkaXRpb25hbEl0ZW1zXCIgaXMgaWdub3JlZCB3aGVuIFwiaXRlbXNcIiBpcyBub3QgYW4gYXJyYXkgb2Ygc2NoZW1hcycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhbGlkYXRlQWRkaXRpb25hbEl0ZW1zKGN4dCwgaXRlbXMpO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gdmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMoY3h0LCBpdGVtcykge1xuICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIGRhdGEsIGtleXdvcmQsIGl0IH0gPSBjeHQ7XG4gICAgaXQuaXRlbXMgPSB0cnVlO1xuICAgIGNvbnN0IGxlbiA9IGdlbi5jb25zdChcImxlblwiLCBjb2RlZ2VuXzEuXyBgJHtkYXRhfS5sZW5ndGhgKTtcbiAgICBpZiAoc2NoZW1hID09PSBmYWxzZSkge1xuICAgICAgICBjeHQuc2V0UGFyYW1zKHsgbGVuOiBpdGVtcy5sZW5ndGggfSk7XG4gICAgICAgIGN4dC5wYXNzKGNvZGVnZW5fMS5fIGAke2xlbn0gPD0gJHtpdGVtcy5sZW5ndGh9YCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiAhdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLnZhcihcInZhbGlkXCIsIGNvZGVnZW5fMS5fIGAke2xlbn0gPD0gJHtpdGVtcy5sZW5ndGh9YCk7IC8vIFRPRE8gdmFyXG4gICAgICAgIGdlbi5pZihjb2RlZ2VuXzEubm90KHZhbGlkKSwgKCkgPT4gdmFsaWRhdGVJdGVtcyh2YWxpZCkpO1xuICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUl0ZW1zKHZhbGlkKSB7XG4gICAgICAgIGdlbi5mb3JSYW5nZShcImlcIiwgaXRlbXMubGVuZ3RoLCBsZW4sIChpKSA9PiB7XG4gICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHsga2V5d29yZCwgZGF0YVByb3A6IGksIGRhdGFQcm9wVHlwZTogdXRpbF8xLlR5cGUuTnVtIH0sIHZhbGlkKTtcbiAgICAgICAgICAgIGlmICghaXQuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEubm90KHZhbGlkKSwgKCkgPT4gZ2VuLmJyZWFrKCkpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlQWRkaXRpb25hbEl0ZW1zID0gdmFsaWRhdGVBZGRpdGlvbmFsSXRlbXM7XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRpdGlvbmFsSXRlbXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlVHVwbGUgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiaXRlbXNcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYXJyYXlcIiwgXCJib29sZWFuXCJdLFxuICAgIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlVHVwbGUoY3h0LCBcImFkZGl0aW9uYWxJdGVtc1wiLCBzY2hlbWEpO1xuICAgICAgICBpdC5pdGVtcyA9IHRydWU7XG4gICAgICAgIGlmICh1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGN4dC5vayhjb2RlXzEudmFsaWRhdGVBcnJheShjeHQpKTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIHZhbGlkYXRlVHVwbGUoY3h0LCBleHRyYUl0ZW1zLCBzY2hBcnIgPSBjeHQuc2NoZW1hKSB7XG4gICAgY29uc3QgeyBnZW4sIHBhcmVudFNjaGVtYSwgZGF0YSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICBjaGVja1N0cmljdFR1cGxlKHBhcmVudFNjaGVtYSk7XG4gICAgaWYgKGl0Lm9wdHMudW5ldmFsdWF0ZWQgJiYgc2NoQXJyLmxlbmd0aCAmJiBpdC5pdGVtcyAhPT0gdHJ1ZSkge1xuICAgICAgICBpdC5pdGVtcyA9IHV0aWxfMS5tZXJnZUV2YWx1YXRlZC5pdGVtcyhnZW4sIHNjaEFyci5sZW5ndGgsIGl0Lml0ZW1zKTtcbiAgICB9XG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgIGNvbnN0IGxlbiA9IGdlbi5jb25zdChcImxlblwiLCBjb2RlZ2VuXzEuXyBgJHtkYXRhfS5sZW5ndGhgKTtcbiAgICBzY2hBcnIuZm9yRWFjaCgoc2NoLCBpKSA9PiB7XG4gICAgICAgIGlmICh1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtsZW59ID4gJHtpfWAsICgpID0+IGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAga2V5d29yZCxcbiAgICAgICAgICAgIHNjaGVtYVByb3A6IGksXG4gICAgICAgICAgICBkYXRhUHJvcDogaSxcbiAgICAgICAgfSwgdmFsaWQpKTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBjaGVja1N0cmljdFR1cGxlKHNjaCkge1xuICAgICAgICBjb25zdCB7IG9wdHMsIGVyclNjaGVtYVBhdGggfSA9IGl0O1xuICAgICAgICBjb25zdCBsID0gc2NoQXJyLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZnVsbFR1cGxlID0gbCA9PT0gc2NoLm1pbkl0ZW1zICYmIChsID09PSBzY2gubWF4SXRlbXMgfHwgc2NoW2V4dHJhSXRlbXNdID09PSBmYWxzZSk7XG4gICAgICAgIGlmIChvcHRzLnN0cmljdFR1cGxlcyAmJiAhZnVsbFR1cGxlKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBgXCIke2tleXdvcmR9XCIgaXMgJHtsfS10dXBsZSwgYnV0IG1pbkl0ZW1zIG9yIG1heEl0ZW1zLyR7ZXh0cmFJdGVtc30gYXJlIG5vdCBzcGVjaWZpZWQgb3IgZGlmZmVyZW50IGF0IHBhdGggXCIke2VyclNjaGVtYVBhdGh9XCJgO1xuICAgICAgICAgICAgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZShpdCwgbXNnLCBvcHRzLnN0cmljdFR1cGxlcyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlVHVwbGUgPSB2YWxpZGF0ZVR1cGxlO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXRlbXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBpdGVtc18xID0gcmVxdWlyZShcIi4vaXRlbXNcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJwcmVmaXhJdGVtc1wiLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJhcnJheVwiXSxcbiAgICBiZWZvcmU6IFwidW5pcXVlSXRlbXNcIixcbiAgICBjb2RlOiAoY3h0KSA9PiBpdGVtc18xLnZhbGlkYXRlVHVwbGUoY3h0LCBcIml0ZW1zXCIpLFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZWZpeEl0ZW1zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGFkZGl0aW9uYWxJdGVtc18xID0gcmVxdWlyZShcIi4vYWRkaXRpb25hbEl0ZW1zXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgcGFyYW1zOiB7IGxlbiB9IH0pID0+IGNvZGVnZW5fMS5zdHIgYG11c3QgTk9UIGhhdmUgbW9yZSB0aGFuICR7bGVufSBpdGVtc2AsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgbGVuIH0gfSkgPT4gY29kZWdlbl8xLl8gYHtsaW1pdDogJHtsZW59fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiaXRlbXNcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgICBiZWZvcmU6IFwidW5pcXVlSXRlbXNcIixcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IHByZWZpeEl0ZW1zIH0gPSBwYXJlbnRTY2hlbWE7XG4gICAgICAgIGl0Lml0ZW1zID0gdHJ1ZTtcbiAgICAgICAgaWYgKHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHByZWZpeEl0ZW1zKVxuICAgICAgICAgICAgYWRkaXRpb25hbEl0ZW1zXzEudmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMoY3h0LCBwcmVmaXhJdGVtcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGN4dC5vayhjb2RlXzEudmFsaWRhdGVBcnJheShjeHQpKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWl0ZW1zMjAyMC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgcGFyYW1zOiB7IG1pbiwgbWF4IH0gfSkgPT4gbWF4ID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBjb2RlZ2VuXzEuc3RyIGBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgJHttaW59IHZhbGlkIGl0ZW0ocylgXG4gICAgICAgIDogY29kZWdlbl8xLnN0ciBgbXVzdCBjb250YWluIGF0IGxlYXN0ICR7bWlufSBhbmQgbm8gbW9yZSB0aGFuICR7bWF4fSB2YWxpZCBpdGVtKHMpYCxcbiAgICBwYXJhbXM6ICh7IHBhcmFtczogeyBtaW4sIG1heCB9IH0pID0+IG1heCA9PT0gdW5kZWZpbmVkID8gY29kZWdlbl8xLl8gYHttaW5Db250YWluczogJHttaW59fWAgOiBjb2RlZ2VuXzEuXyBge21pbkNvbnRhaW5zOiAke21pbn0sIG1heENvbnRhaW5zOiAke21heH19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJjb250YWluc1wiLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICAgIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICAgIHRyYWNrRXJyb3JzOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgZGF0YSwgaXQgfSA9IGN4dDtcbiAgICAgICAgbGV0IG1pbjtcbiAgICAgICAgbGV0IG1heDtcbiAgICAgICAgY29uc3QgeyBtaW5Db250YWlucywgbWF4Q29udGFpbnMgfSA9IHBhcmVudFNjaGVtYTtcbiAgICAgICAgaWYgKGl0Lm9wdHMubmV4dCkge1xuICAgICAgICAgICAgbWluID0gbWluQ29udGFpbnMgPT09IHVuZGVmaW5lZCA/IDEgOiBtaW5Db250YWlucztcbiAgICAgICAgICAgIG1heCA9IG1heENvbnRhaW5zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWluID0gMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW4gPSBnZW4uY29uc3QoXCJsZW5cIiwgY29kZWdlbl8xLl8gYCR7ZGF0YX0ubGVuZ3RoYCk7XG4gICAgICAgIGN4dC5zZXRQYXJhbXMoeyBtaW4sIG1heCB9KTtcbiAgICAgICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkICYmIG1pbiA9PT0gMCkge1xuICAgICAgICAgICAgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZShpdCwgYFwibWluQ29udGFpbnNcIiA9PSAwIHdpdGhvdXQgXCJtYXhDb250YWluc1wiOiBcImNvbnRhaW5zXCIga2V5d29yZCBpZ25vcmVkYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkICYmIG1pbiA+IG1heCkge1xuICAgICAgICAgICAgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZShpdCwgYFwibWluQ29udGFpbnNcIiA+IFwibWF4Q29udGFpbnNcIiBpcyBhbHdheXMgaW52YWxpZGApO1xuICAgICAgICAgICAgY3h0LmZhaWwoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpKSB7XG4gICAgICAgICAgICBsZXQgY29uZCA9IGNvZGVnZW5fMS5fIGAke2xlbn0gPj0gJHttaW59YDtcbiAgICAgICAgICAgIGlmIChtYXggIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBjb25kID0gY29kZWdlbl8xLl8gYCR7Y29uZH0gJiYgJHtsZW59IDw9ICR7bWF4fWA7XG4gICAgICAgICAgICBjeHQucGFzcyhjb25kKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpdC5pdGVtcyA9IHRydWU7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkICYmIG1pbiA9PT0gMSkge1xuICAgICAgICAgICAgdmFsaWRhdGVJdGVtcyh2YWxpZCwgKCkgPT4gZ2VuLmlmKHZhbGlkLCAoKSA9PiBnZW4uYnJlYWsoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2VuLmxldCh2YWxpZCwgZmFsc2UpO1xuICAgICAgICAgICAgY29uc3Qgc2NoVmFsaWQgPSBnZW4ubmFtZShcIl92YWxpZFwiKTtcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gZ2VuLmxldChcImNvdW50XCIsIDApO1xuICAgICAgICAgICAgdmFsaWRhdGVJdGVtcyhzY2hWYWxpZCwgKCkgPT4gZ2VuLmlmKHNjaFZhbGlkLCAoKSA9PiBjaGVja0xpbWl0cyhjb3VudCkpKTtcbiAgICAgICAgfVxuICAgICAgICBjeHQucmVzdWx0KHZhbGlkLCAoKSA9PiBjeHQucmVzZXQoKSk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlSXRlbXMoX3ZhbGlkLCBibG9jaykge1xuICAgICAgICAgICAgZ2VuLmZvclJhbmdlKFwiaVwiLCAwLCBsZW4sIChpKSA9PiB7XG4gICAgICAgICAgICAgICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwiY29udGFpbnNcIixcbiAgICAgICAgICAgICAgICAgICAgZGF0YVByb3A6IGksXG4gICAgICAgICAgICAgICAgICAgIGRhdGFQcm9wVHlwZTogdXRpbF8xLlR5cGUuTnVtLFxuICAgICAgICAgICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sIF92YWxpZCk7XG4gICAgICAgICAgICAgICAgYmxvY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrTGltaXRzKGNvdW50KSB7XG4gICAgICAgICAgICBnZW4uY29kZShjb2RlZ2VuXzEuXyBgJHtjb3VudH0rK2ApO1xuICAgICAgICAgICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke2NvdW50fSA+PSAke21pbn1gLCAoKSA9PiBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKS5icmVhaygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtjb3VudH0gPiAke21heH1gLCAoKSA9PiBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSkuYnJlYWsoKSk7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCR7Y291bnR9ID49ICR7bWlufWAsICgpID0+IGdlbi5hc3NpZ24odmFsaWQsIHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udGFpbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlU2NoZW1hRGVwcyA9IGV4cG9ydHMudmFsaWRhdGVQcm9wZXJ0eURlcHMgPSBleHBvcnRzLmVycm9yID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmV4cG9ydHMuZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgcGFyYW1zOiB7IHByb3BlcnR5LCBkZXBzQ291bnQsIGRlcHMgfSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHByb3BlcnR5X2llcyA9IGRlcHNDb3VudCA9PT0gMSA/IFwicHJvcGVydHlcIiA6IFwicHJvcGVydGllc1wiO1xuICAgICAgICByZXR1cm4gY29kZWdlbl8xLnN0ciBgbXVzdCBoYXZlICR7cHJvcGVydHlfaWVzfSAke2RlcHN9IHdoZW4gcHJvcGVydHkgJHtwcm9wZXJ0eX0gaXMgcHJlc2VudGA7XG4gICAgfSxcbiAgICBwYXJhbXM6ICh7IHBhcmFtczogeyBwcm9wZXJ0eSwgZGVwc0NvdW50LCBkZXBzLCBtaXNzaW5nUHJvcGVydHkgfSB9KSA9PiBjb2RlZ2VuXzEuXyBge3Byb3BlcnR5OiAke3Byb3BlcnR5fSxcbiAgICBtaXNzaW5nUHJvcGVydHk6ICR7bWlzc2luZ1Byb3BlcnR5fSxcbiAgICBkZXBzQ291bnQ6ICR7ZGVwc0NvdW50fSxcbiAgICBkZXBzOiAke2RlcHN9fWAsIC8vIFRPRE8gY2hhbmdlIHRvIHJlZmVyZW5jZVxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImRlcGVuZGVuY2llc1wiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogXCJvYmplY3RcIixcbiAgICBlcnJvcjogZXhwb3J0cy5lcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCBbcHJvcERlcHMsIHNjaERlcHNdID0gc3BsaXREZXBlbmRlbmNpZXMoY3h0KTtcbiAgICAgICAgdmFsaWRhdGVQcm9wZXJ0eURlcHMoY3h0LCBwcm9wRGVwcyk7XG4gICAgICAgIHZhbGlkYXRlU2NoZW1hRGVwcyhjeHQsIHNjaERlcHMpO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gc3BsaXREZXBlbmRlbmNpZXMoeyBzY2hlbWEgfSkge1xuICAgIGNvbnN0IHByb3BlcnR5RGVwcyA9IHt9O1xuICAgIGNvbnN0IHNjaGVtYURlcHMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJfX3Byb3RvX19cIilcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBkZXBzID0gQXJyYXkuaXNBcnJheShzY2hlbWFba2V5XSkgPyBwcm9wZXJ0eURlcHMgOiBzY2hlbWFEZXBzO1xuICAgICAgICBkZXBzW2tleV0gPSBzY2hlbWFba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIFtwcm9wZXJ0eURlcHMsIHNjaGVtYURlcHNdO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eURlcHMoY3h0LCBwcm9wZXJ0eURlcHMgPSBjeHQuc2NoZW1hKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgaWYgKE9iamVjdC5rZXlzKHByb3BlcnR5RGVwcykubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgbWlzc2luZyA9IGdlbi5sZXQoXCJtaXNzaW5nXCIpO1xuICAgIGZvciAoY29uc3QgcHJvcCBpbiBwcm9wZXJ0eURlcHMpIHtcbiAgICAgICAgY29uc3QgZGVwcyA9IHByb3BlcnR5RGVwc1twcm9wXTtcbiAgICAgICAgaWYgKGRlcHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGhhc1Byb3BlcnR5ID0gY29kZV8xLnByb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKTtcbiAgICAgICAgY3h0LnNldFBhcmFtcyh7XG4gICAgICAgICAgICBwcm9wZXJ0eTogcHJvcCxcbiAgICAgICAgICAgIGRlcHNDb3VudDogZGVwcy5sZW5ndGgsXG4gICAgICAgICAgICBkZXBzOiBkZXBzLmpvaW4oXCIsIFwiKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpdC5hbGxFcnJvcnMpIHtcbiAgICAgICAgICAgIGdlbi5pZihoYXNQcm9wZXJ0eSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZGVwUHJvcCBvZiBkZXBzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGVfMS5jaGVja1JlcG9ydE1pc3NpbmdQcm9wKGN4dCwgZGVwUHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCR7aGFzUHJvcGVydHl9ICYmICgke2NvZGVfMS5jaGVja01pc3NpbmdQcm9wKGN4dCwgZGVwcywgbWlzc2luZyl9KWApO1xuICAgICAgICAgICAgY29kZV8xLnJlcG9ydE1pc3NpbmdQcm9wKGN4dCwgbWlzc2luZyk7XG4gICAgICAgICAgICBnZW4uZWxzZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVByb3BlcnR5RGVwcyA9IHZhbGlkYXRlUHJvcGVydHlEZXBzO1xuZnVuY3Rpb24gdmFsaWRhdGVTY2hlbWFEZXBzKGN4dCwgc2NoZW1hRGVwcyA9IGN4dC5zY2hlbWEpIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgZm9yIChjb25zdCBwcm9wIGluIHNjaGVtYURlcHMpIHtcbiAgICAgICAgaWYgKHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hRGVwc1twcm9wXSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZ2VuLmlmKGNvZGVfMS5wcm9wZXJ0eUluRGF0YShnZW4sIGRhdGEsIHByb3AsIGl0Lm9wdHMub3duUHJvcGVydGllcyksICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoeyBrZXl3b3JkLCBzY2hlbWFQcm9wOiBwcm9wIH0sIHZhbGlkKTtcbiAgICAgICAgICAgIGN4dC5tZXJnZVZhbGlkRXZhbHVhdGVkKHNjaEN4dCwgdmFsaWQpO1xuICAgICAgICB9LCAoKSA9PiBnZW4udmFyKHZhbGlkLCB0cnVlKSAvLyBUT0RPIHZhclxuICAgICAgICApO1xuICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVTY2hlbWFEZXBzID0gdmFsaWRhdGVTY2hlbWFEZXBzO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVwZW5kZW5jaWVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiBcInByb3BlcnR5IG5hbWUgbXVzdCBiZSB2YWxpZFwiLFxuICAgIHBhcmFtczogKHsgcGFyYW1zIH0pID0+IGNvZGVnZW5fMS5fIGB7cHJvcGVydHlOYW1lOiAke3BhcmFtcy5wcm9wZXJ0eU5hbWV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwicHJvcGVydHlOYW1lc1wiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBkYXRhLCBpdCB9ID0gY3h0O1xuICAgICAgICBpZiAodXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIGdlbi5mb3JJbihcImtleVwiLCBkYXRhLCAoa2V5KSA9PiB7XG4gICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgcHJvcGVydHlOYW1lOiBrZXkgfSk7XG4gICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkOiBcInByb3BlcnR5TmFtZXNcIixcbiAgICAgICAgICAgICAgICBkYXRhOiBrZXksXG4gICAgICAgICAgICAgICAgZGF0YVR5cGVzOiBbXCJzdHJpbmdcIl0sXG4gICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lOiBrZXksXG4gICAgICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEubm90KHZhbGlkKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGN4dC5lcnJvcih0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoIWl0LmFsbEVycm9ycylcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmJyZWFrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9wZXJ0eU5hbWVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL25hbWVzXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwibXVzdCBOT1QgaGF2ZSBhZGRpdGlvbmFsIHByb3BlcnRpZXNcIixcbiAgICBwYXJhbXM6ICh7IHBhcmFtcyB9KSA9PiBjb2RlZ2VuXzEuXyBge2FkZGl0aW9uYWxQcm9wZXJ0eTogJHtwYXJhbXMuYWRkaXRpb25hbFByb3BlcnR5fX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIsXG4gICAgdHlwZTogW1wib2JqZWN0XCJdLFxuICAgIHNjaGVtYVR5cGU6IFtcImJvb2xlYW5cIiwgXCJvYmplY3RcIl0sXG4gICAgYWxsb3dVbmRlZmluZWQ6IHRydWUsXG4gICAgdHJhY2tFcnJvcnM6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBkYXRhLCBlcnJzQ291bnQsIGl0IH0gPSBjeHQ7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIWVycnNDb3VudClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICAgICAgY29uc3QgeyBhbGxFcnJvcnMsIG9wdHMgfSA9IGl0O1xuICAgICAgICBpdC5wcm9wcyA9IHRydWU7XG4gICAgICAgIGlmIChvcHRzLnJlbW92ZUFkZGl0aW9uYWwgIT09IFwiYWxsXCIgJiYgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBwcm9wcyA9IGNvZGVfMS5hbGxTY2hlbWFQcm9wZXJ0aWVzKHBhcmVudFNjaGVtYS5wcm9wZXJ0aWVzKTtcbiAgICAgICAgY29uc3QgcGF0UHJvcHMgPSBjb2RlXzEuYWxsU2NoZW1hUHJvcGVydGllcyhwYXJlbnRTY2hlbWEucGF0dGVyblByb3BlcnRpZXMpO1xuICAgICAgICBjaGVja0FkZGl0aW9uYWxQcm9wZXJ0aWVzKCk7XG4gICAgICAgIGN4dC5vayhjb2RlZ2VuXzEuXyBgJHtlcnJzQ291bnR9ID09PSAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9YCk7XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrQWRkaXRpb25hbFByb3BlcnRpZXMoKSB7XG4gICAgICAgICAgICBnZW4uZm9ySW4oXCJrZXlcIiwgZGF0YSwgKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcHJvcHMubGVuZ3RoICYmICFwYXRQcm9wcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0eUNvZGUoa2V5KTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZihpc0FkZGl0aW9uYWwoa2V5KSwgKCkgPT4gYWRkaXRpb25hbFByb3BlcnR5Q29kZShrZXkpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzQWRkaXRpb25hbChrZXkpIHtcbiAgICAgICAgICAgIGxldCBkZWZpbmVkUHJvcDtcbiAgICAgICAgICAgIGlmIChwcm9wcy5sZW5ndGggPiA4KSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBtYXliZSBhbiBvcHRpb24gaW5zdGVhZCBvZiBoYXJkLWNvZGVkIDg/XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcHNTY2hlbWEgPSB1dGlsXzEuc2NoZW1hUmVmT3JWYWwoaXQsIHBhcmVudFNjaGVtYS5wcm9wZXJ0aWVzLCBcInByb3BlcnRpZXNcIik7XG4gICAgICAgICAgICAgICAgZGVmaW5lZFByb3AgPSBjb2RlXzEuaXNPd25Qcm9wZXJ0eShnZW4sIHByb3BzU2NoZW1hLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lZFByb3AgPSBjb2RlZ2VuXzEub3IoLi4ucHJvcHMubWFwKChwKSA9PiBjb2RlZ2VuXzEuXyBgJHtrZXl9ID09PSAke3B9YCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lZFByb3AgPSBjb2RlZ2VuXzEubmlsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhdFByb3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRlZmluZWRQcm9wID0gY29kZWdlbl8xLm9yKGRlZmluZWRQcm9wLCAuLi5wYXRQcm9wcy5tYXAoKHApID0+IGNvZGVnZW5fMS5fIGAke2NvZGVfMS51c2VQYXR0ZXJuKGN4dCwgcCl9LnRlc3QoJHtrZXl9KWApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEubm90KGRlZmluZWRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkZWxldGVBZGRpdGlvbmFsKGtleSkge1xuICAgICAgICAgICAgZ2VuLmNvZGUoY29kZWdlbl8xLl8gYGRlbGV0ZSAke2RhdGF9WyR7a2V5fV1gKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhZGRpdGlvbmFsUHJvcGVydHlDb2RlKGtleSkge1xuICAgICAgICAgICAgaWYgKG9wdHMucmVtb3ZlQWRkaXRpb25hbCA9PT0gXCJhbGxcIiB8fCAob3B0cy5yZW1vdmVBZGRpdGlvbmFsICYmIHNjaGVtYSA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlQWRkaXRpb25hbChrZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IGFkZGl0aW9uYWxQcm9wZXJ0eToga2V5IH0pO1xuICAgICAgICAgICAgICAgIGN4dC5lcnJvcigpO1xuICAgICAgICAgICAgICAgIGlmICghYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgICAgICBnZW4uYnJlYWsoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiICYmICF1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgICAgICAgICAgaWYgKG9wdHMucmVtb3ZlQWRkaXRpb25hbCA9PT0gXCJmYWlsaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwbHlBZGRpdGlvbmFsU2NoZW1hKGtleSwgdmFsaWQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5ub3QodmFsaWQpLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjeHQucmVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUFkZGl0aW9uYWwoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhcHBseUFkZGl0aW9uYWxTY2hlbWEoa2V5LCB2YWxpZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5ub3QodmFsaWQpLCAoKSA9PiBnZW4uYnJlYWsoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFwcGx5QWRkaXRpb25hbFNjaGVtYShrZXksIHZhbGlkLCBlcnJvcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YnNjaGVtYSA9IHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkOiBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICAgICAgZGF0YVByb3A6IGtleSxcbiAgICAgICAgICAgICAgICBkYXRhUHJvcFR5cGU6IHV0aWxfMS5UeXBlLlN0cixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZXJyb3JzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc3Vic2NoZW1hLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVycm9yczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGFsbEVycm9yczogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHN1YnNjaGVtYSwgdmFsaWQpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRpdGlvbmFsUHJvcGVydGllcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHZhbGlkYXRlXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGFkZGl0aW9uYWxQcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiLi9hZGRpdGlvbmFsUHJvcGVydGllc1wiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInByb3BlcnRpZXNcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFwib2JqZWN0XCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBkYXRhLCBpdCB9ID0gY3h0O1xuICAgICAgICBpZiAoaXQub3B0cy5yZW1vdmVBZGRpdGlvbmFsID09PSBcImFsbFwiICYmIHBhcmVudFNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllc18xLmRlZmF1bHQuY29kZShuZXcgdmFsaWRhdGVfMS5LZXl3b3JkQ3h0KGl0LCBhZGRpdGlvbmFsUHJvcGVydGllc18xLmRlZmF1bHQsIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFsbFByb3BzID0gY29kZV8xLmFsbFNjaGVtYVByb3BlcnRpZXMoc2NoZW1hKTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIGFsbFByb3BzKSB7XG4gICAgICAgICAgICBpdC5kZWZpbmVkUHJvcGVydGllcy5hZGQocHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0Lm9wdHMudW5ldmFsdWF0ZWQgJiYgYWxsUHJvcHMubGVuZ3RoICYmIGl0LnByb3BzICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBpdC5wcm9wcyA9IHV0aWxfMS5tZXJnZUV2YWx1YXRlZC5wcm9wcyhnZW4sIHV0aWxfMS50b0hhc2goYWxsUHJvcHMpLCBpdC5wcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IGFsbFByb3BzLmZpbHRlcigocCkgPT4gIXV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hW3BdKSk7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgcHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKGhhc0RlZmF1bHQocHJvcCkpIHtcbiAgICAgICAgICAgICAgICBhcHBseVByb3BlcnR5U2NoZW1hKHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKGNvZGVfMS5wcm9wZXJ0eUluRGF0YShnZW4sIGRhdGEsIHByb3AsIGl0Lm9wdHMub3duUHJvcGVydGllcykpO1xuICAgICAgICAgICAgICAgIGFwcGx5UHJvcGVydHlTY2hlbWEocHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpdC5hbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgICAgIGdlbi5lbHNlKCkudmFyKHZhbGlkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBnZW4uZW5kSWYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN4dC5pdC5kZWZpbmVkUHJvcGVydGllcy5hZGQocHJvcCk7XG4gICAgICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhc0RlZmF1bHQocHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIGl0Lm9wdHMudXNlRGVmYXVsdHMgJiYgIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgc2NoZW1hW3Byb3BdLmRlZmF1bHQgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhcHBseVByb3BlcnR5U2NoZW1hKHByb3ApIHtcbiAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwicHJvcGVydGllc1wiLFxuICAgICAgICAgICAgICAgIHNjaGVtYVByb3A6IHByb3AsXG4gICAgICAgICAgICAgICAgZGF0YVByb3A6IHByb3AsXG4gICAgICAgICAgICB9LCB2YWxpZCk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3BlcnRpZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgdXRpbF8yID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcIm9iamVjdFwiLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIGRhdGEsIHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBvcHRzIH0gPSBpdDtcbiAgICAgICAgY29uc3QgcGF0dGVybnMgPSBjb2RlXzEuYWxsU2NoZW1hUHJvcGVydGllcyhzY2hlbWEpO1xuICAgICAgICBjb25zdCBhbHdheXNWYWxpZFBhdHRlcm5zID0gcGF0dGVybnMuZmlsdGVyKChwKSA9PiB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYVtwXSkpO1xuICAgICAgICBpZiAocGF0dGVybnMubGVuZ3RoID09PSAwIHx8XG4gICAgICAgICAgICAoYWx3YXlzVmFsaWRQYXR0ZXJucy5sZW5ndGggPT09IHBhdHRlcm5zLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICghaXQub3B0cy51bmV2YWx1YXRlZCB8fCBpdC5wcm9wcyA9PT0gdHJ1ZSkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hlY2tQcm9wZXJ0aWVzID0gb3B0cy5zdHJpY3RTY2hlbWEgJiYgIW9wdHMuYWxsb3dNYXRjaGluZ1Byb3BlcnRpZXMgJiYgcGFyZW50U2NoZW1hLnByb3BlcnRpZXM7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgaWYgKGl0LnByb3BzICE9PSB0cnVlICYmICEoaXQucHJvcHMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSkpIHtcbiAgICAgICAgICAgIGl0LnByb3BzID0gdXRpbF8yLmV2YWx1YXRlZFByb3BzVG9OYW1lKGdlbiwgaXQucHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IGl0O1xuICAgICAgICB2YWxpZGF0ZVBhdHRlcm5Qcm9wZXJ0aWVzKCk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlUGF0dGVyblByb3BlcnRpZXMoKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhdCBvZiBwYXR0ZXJucykge1xuICAgICAgICAgICAgICAgIGlmIChjaGVja1Byb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrTWF0Y2hpbmdQcm9wZXJ0aWVzKHBhdCk7XG4gICAgICAgICAgICAgICAgaWYgKGl0LmFsbEVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZVByb3BlcnRpZXMocGF0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdlbi52YXIodmFsaWQsIHRydWUpOyAvLyBUT0RPIHZhclxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZVByb3BlcnRpZXMocGF0KTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKHZhbGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tNYXRjaGluZ1Byb3BlcnRpZXMocGF0KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gY2hlY2tQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ldyBSZWdFeHAocGF0KS50ZXN0KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWxfMS5jaGVja1N0cmljdE1vZGUoaXQsIGBwcm9wZXJ0eSAke3Byb3B9IG1hdGNoZXMgcGF0dGVybiAke3BhdH0gKHVzZSBhbGxvd01hdGNoaW5nUHJvcGVydGllcylgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzKHBhdCkge1xuICAgICAgICAgICAgZ2VuLmZvckluKFwia2V5XCIsIGRhdGEsIChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCR7Y29kZV8xLnVzZVBhdHRlcm4oY3h0LCBwYXQpfS50ZXN0KCR7a2V5fSlgLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsd2F5c1ZhbGlkID0gYWx3YXlzVmFsaWRQYXR0ZXJucy5pbmNsdWRlcyhwYXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFsd2F5c1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXl3b3JkOiBcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1hUHJvcDogcGF0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQcm9wOiBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVByb3BUeXBlOiB1dGlsXzIuVHlwZS5TdHIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB2YWxpZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMudW5ldmFsdWF0ZWQgJiYgcHJvcHMgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oY29kZWdlbl8xLl8gYCR7cHJvcHN9WyR7a2V5fV1gLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghYWx3YXlzVmFsaWQgJiYgIWl0LmFsbEVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FuIHNob3J0LWNpcmN1aXQgaWYgYHVuZXZhbHVhdGVkUHJvcGVydGllc2AgaXMgbm90IHN1cHBvcnRlZCAob3B0cy5uZXh0ID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIGlmIGFsbCBwcm9wZXJ0aWVzIHdlcmUgZXZhbHVhdGVkIChwcm9wcyA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEubm90KHZhbGlkKSwgKCkgPT4gZ2VuLmJyZWFrKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF0dGVyblByb3BlcnRpZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwibm90XCIsXG4gICAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICBpZiAodXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpKSB7XG4gICAgICAgICAgICBjeHQuZmFpbCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICBrZXl3b3JkOiBcIm5vdFwiLFxuICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNyZWF0ZUVycm9yczogZmFsc2UsXG4gICAgICAgICAgICBhbGxFcnJvcnM6IGZhbHNlLFxuICAgICAgICB9LCB2YWxpZCk7XG4gICAgICAgIGN4dC5mYWlsUmVzdWx0KHZhbGlkLCAoKSA9PiBjeHQucmVzZXQoKSwgKCkgPT4gY3h0LmVycm9yKCkpO1xuICAgIH0sXG4gICAgZXJyb3I6IHsgbWVzc2FnZTogXCJtdXN0IE5PVCBiZSB2YWxpZFwiIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm90LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJhbnlPZlwiLFxuICAgIHNjaGVtYVR5cGU6IFwiYXJyYXlcIixcbiAgICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgICBjb2RlOiBjb2RlXzEudmFsaWRhdGVVbmlvbixcbiAgICBlcnJvcjogeyBtZXNzYWdlOiBcIm11c3QgbWF0Y2ggYSBzY2hlbWEgaW4gYW55T2ZcIiB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFueU9mLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiBcIm11c3QgbWF0Y2ggZXhhY3RseSBvbmUgc2NoZW1hIGluIG9uZU9mXCIsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXMgfSkgPT4gY29kZWdlbl8xLl8gYHtwYXNzaW5nU2NoZW1hczogJHtwYXJhbXMucGFzc2luZ319YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJvbmVPZlwiLFxuICAgIHNjaGVtYVR5cGU6IFwiYXJyYXlcIixcbiAgICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICAgICAgaWYgKGl0Lm9wdHMuZGlzY3JpbWluYXRvciAmJiBwYXJlbnRTY2hlbWEuZGlzY3JpbWluYXRvcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3Qgc2NoQXJyID0gc2NoZW1hO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiLCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IHBhc3NpbmcgPSBnZW4ubGV0KFwicGFzc2luZ1wiLCBudWxsKTtcbiAgICAgICAgY29uc3Qgc2NoVmFsaWQgPSBnZW4ubmFtZShcIl92YWxpZFwiKTtcbiAgICAgICAgY3h0LnNldFBhcmFtcyh7IHBhc3NpbmcgfSk7XG4gICAgICAgIC8vIFRPRE8gcG9zc2libHkgZmFpbCBzdHJhaWdodCBhd2F5ICh3aXRoIHdhcm5pbmcgb3IgZXhjZXB0aW9uKSBpZiB0aGVyZSBhcmUgdHdvIGVtcHR5IGFsd2F5cyB2YWxpZCBzY2hlbWFzXG4gICAgICAgIGdlbi5ibG9jayh2YWxpZGF0ZU9uZU9mKTtcbiAgICAgICAgY3h0LnJlc3VsdCh2YWxpZCwgKCkgPT4gY3h0LnJlc2V0KCksICgpID0+IGN4dC5lcnJvcih0cnVlKSk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlT25lT2YoKSB7XG4gICAgICAgICAgICBzY2hBcnIuZm9yRWFjaCgoc2NoLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHNjaEN4dDtcbiAgICAgICAgICAgICAgICBpZiAodXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlbi52YXIoc2NoVmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXl3b3JkOiBcIm9uZU9mXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWFQcm9wOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSwgc2NoVmFsaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgICAgICAuaWYoY29kZWdlbl8xLl8gYCR7c2NoVmFsaWR9ICYmICR7dmFsaWR9YClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hc3NpZ24odmFsaWQsIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihwYXNzaW5nLCBjb2RlZ2VuXzEuXyBgWyR7cGFzc2luZ30sICR7aX1dYClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5lbHNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdlbi5pZihzY2hWYWxpZCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihwYXNzaW5nLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjaEN4dClcbiAgICAgICAgICAgICAgICAgICAgICAgIGN4dC5tZXJnZUV2YWx1YXRlZChzY2hDeHQsIGNvZGVnZW5fMS5OYW1lKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vbmVPZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJhbGxPZlwiLFxuICAgIHNjaGVtYVR5cGU6IFwiYXJyYXlcIixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgc2NoZW1hLmZvckVhY2goKHNjaCwgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHsga2V5d29yZDogXCJhbGxPZlwiLCBzY2hlbWFQcm9wOiBpIH0sIHZhbGlkKTtcbiAgICAgICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbGxPZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgcGFyYW1zIH0pID0+IGNvZGVnZW5fMS5zdHIgYG11c3QgbWF0Y2ggXCIke3BhcmFtcy5pZkNsYXVzZX1cIiBzY2hlbWFgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zIH0pID0+IGNvZGVnZW5fMS5fIGB7ZmFpbGluZ0tleXdvcmQ6ICR7cGFyYW1zLmlmQ2xhdXNlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImlmXCIsXG4gICAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgcGFyZW50U2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICBpZiAocGFyZW50U2NoZW1hLnRoZW4gPT09IHVuZGVmaW5lZCAmJiBwYXJlbnRTY2hlbWEuZWxzZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKGl0LCAnXCJpZlwiIHdpdGhvdXQgXCJ0aGVuXCIgYW5kIFwiZWxzZVwiIGlzIGlnbm9yZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYXNUaGVuID0gaGFzU2NoZW1hKGl0LCBcInRoZW5cIik7XG4gICAgICAgIGNvbnN0IGhhc0Vsc2UgPSBoYXNTY2hlbWEoaXQsIFwiZWxzZVwiKTtcbiAgICAgICAgaWYgKCFoYXNUaGVuICYmICFoYXNFbHNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiLCB0cnVlKTtcbiAgICAgICAgY29uc3Qgc2NoVmFsaWQgPSBnZW4ubmFtZShcIl92YWxpZFwiKTtcbiAgICAgICAgdmFsaWRhdGVJZigpO1xuICAgICAgICBjeHQucmVzZXQoKTtcbiAgICAgICAgaWYgKGhhc1RoZW4gJiYgaGFzRWxzZSkge1xuICAgICAgICAgICAgY29uc3QgaWZDbGF1c2UgPSBnZW4ubGV0KFwiaWZDbGF1c2VcIik7XG4gICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgaWZDbGF1c2UgfSk7XG4gICAgICAgICAgICBnZW4uaWYoc2NoVmFsaWQsIHZhbGlkYXRlQ2xhdXNlKFwidGhlblwiLCBpZkNsYXVzZSksIHZhbGlkYXRlQ2xhdXNlKFwiZWxzZVwiLCBpZkNsYXVzZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhc1RoZW4pIHtcbiAgICAgICAgICAgIGdlbi5pZihzY2hWYWxpZCwgdmFsaWRhdGVDbGF1c2UoXCJ0aGVuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEubm90KHNjaFZhbGlkKSwgdmFsaWRhdGVDbGF1c2UoXCJlbHNlXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBjeHQucGFzcyh2YWxpZCwgKCkgPT4gY3h0LmVycm9yKHRydWUpKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVJZigpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwiaWZcIixcbiAgICAgICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVycm9yczogZmFsc2UsXG4gICAgICAgICAgICAgICAgYWxsRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICAgIH0sIHNjaFZhbGlkKTtcbiAgICAgICAgICAgIGN4dC5tZXJnZUV2YWx1YXRlZChzY2hDeHQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlQ2xhdXNlKGtleXdvcmQsIGlmQ2xhdXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoeyBrZXl3b3JkIH0sIHNjaFZhbGlkKTtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBzY2hWYWxpZCk7XG4gICAgICAgICAgICAgICAgY3h0Lm1lcmdlVmFsaWRFdmFsdWF0ZWQoc2NoQ3h0LCB2YWxpZCk7XG4gICAgICAgICAgICAgICAgaWYgKGlmQ2xhdXNlKVxuICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKGlmQ2xhdXNlLCBjb2RlZ2VuXzEuXyBgJHtrZXl3b3JkfWApO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IGlmQ2xhdXNlOiBrZXl3b3JkIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZnVuY3Rpb24gaGFzU2NoZW1hKGl0LCBrZXl3b3JkKSB7XG4gICAgY29uc3Qgc2NoZW1hID0gaXQuc2NoZW1hW2tleXdvcmRdO1xuICAgIHJldHVybiBzY2hlbWEgIT09IHVuZGVmaW5lZCAmJiAhdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFtcInRoZW5cIiwgXCJlbHNlXCJdLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgY29kZSh7IGtleXdvcmQsIHBhcmVudFNjaGVtYSwgaXQgfSkge1xuICAgICAgICBpZiAocGFyZW50U2NoZW1hLmlmID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKGl0LCBgXCIke2tleXdvcmR9XCIgd2l0aG91dCBcImlmXCIgaXMgaWdub3JlZGApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGhlbkVsc2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBhZGRpdGlvbmFsSXRlbXNfMSA9IHJlcXVpcmUoXCIuL2FkZGl0aW9uYWxJdGVtc1wiKTtcbmNvbnN0IHByZWZpeEl0ZW1zXzEgPSByZXF1aXJlKFwiLi9wcmVmaXhJdGVtc1wiKTtcbmNvbnN0IGl0ZW1zXzEgPSByZXF1aXJlKFwiLi9pdGVtc1wiKTtcbmNvbnN0IGl0ZW1zMjAyMF8xID0gcmVxdWlyZShcIi4vaXRlbXMyMDIwXCIpO1xuY29uc3QgY29udGFpbnNfMSA9IHJlcXVpcmUoXCIuL2NvbnRhaW5zXCIpO1xuY29uc3QgZGVwZW5kZW5jaWVzXzEgPSByZXF1aXJlKFwiLi9kZXBlbmRlbmNpZXNcIik7XG5jb25zdCBwcm9wZXJ0eU5hbWVzXzEgPSByZXF1aXJlKFwiLi9wcm9wZXJ0eU5hbWVzXCIpO1xuY29uc3QgYWRkaXRpb25hbFByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCIuL2FkZGl0aW9uYWxQcm9wZXJ0aWVzXCIpO1xuY29uc3QgcHJvcGVydGllc18xID0gcmVxdWlyZShcIi4vcHJvcGVydGllc1wiKTtcbmNvbnN0IHBhdHRlcm5Qcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiLi9wYXR0ZXJuUHJvcGVydGllc1wiKTtcbmNvbnN0IG5vdF8xID0gcmVxdWlyZShcIi4vbm90XCIpO1xuY29uc3QgYW55T2ZfMSA9IHJlcXVpcmUoXCIuL2FueU9mXCIpO1xuY29uc3Qgb25lT2ZfMSA9IHJlcXVpcmUoXCIuL29uZU9mXCIpO1xuY29uc3QgYWxsT2ZfMSA9IHJlcXVpcmUoXCIuL2FsbE9mXCIpO1xuY29uc3QgaWZfMSA9IHJlcXVpcmUoXCIuL2lmXCIpO1xuY29uc3QgdGhlbkVsc2VfMSA9IHJlcXVpcmUoXCIuL3RoZW5FbHNlXCIpO1xuZnVuY3Rpb24gZ2V0QXBwbGljYXRvcihkcmFmdDIwMjAgPSBmYWxzZSkge1xuICAgIGNvbnN0IGFwcGxpY2F0b3IgPSBbXG4gICAgICAgIC8vIGFueVxuICAgICAgICBub3RfMS5kZWZhdWx0LFxuICAgICAgICBhbnlPZl8xLmRlZmF1bHQsXG4gICAgICAgIG9uZU9mXzEuZGVmYXVsdCxcbiAgICAgICAgYWxsT2ZfMS5kZWZhdWx0LFxuICAgICAgICBpZl8xLmRlZmF1bHQsXG4gICAgICAgIHRoZW5FbHNlXzEuZGVmYXVsdCxcbiAgICAgICAgLy8gb2JqZWN0XG4gICAgICAgIHByb3BlcnR5TmFtZXNfMS5kZWZhdWx0LFxuICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllc18xLmRlZmF1bHQsXG4gICAgICAgIGRlcGVuZGVuY2llc18xLmRlZmF1bHQsXG4gICAgICAgIHByb3BlcnRpZXNfMS5kZWZhdWx0LFxuICAgICAgICBwYXR0ZXJuUHJvcGVydGllc18xLmRlZmF1bHQsXG4gICAgXTtcbiAgICAvLyBhcnJheVxuICAgIGlmIChkcmFmdDIwMjApXG4gICAgICAgIGFwcGxpY2F0b3IucHVzaChwcmVmaXhJdGVtc18xLmRlZmF1bHQsIGl0ZW1zMjAyMF8xLmRlZmF1bHQpO1xuICAgIGVsc2VcbiAgICAgICAgYXBwbGljYXRvci5wdXNoKGFkZGl0aW9uYWxJdGVtc18xLmRlZmF1bHQsIGl0ZW1zXzEuZGVmYXVsdCk7XG4gICAgYXBwbGljYXRvci5wdXNoKGNvbnRhaW5zXzEuZGVmYXVsdCk7XG4gICAgcmV0dXJuIGFwcGxpY2F0b3I7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBnZXRBcHBsaWNhdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuc3RyIGBtdXN0IG1hdGNoIGZvcm1hdCBcIiR7c2NoZW1hQ29kZX1cImAsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+IGNvZGVnZW5fMS5fIGB7Zm9ybWF0OiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiZm9ybWF0XCIsXG4gICAgdHlwZTogW1wibnVtYmVyXCIsIFwic3RyaW5nXCJdLFxuICAgIHNjaGVtYVR5cGU6IFwic3RyaW5nXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQsIHJ1bGVUeXBlKSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCAkZGF0YSwgc2NoZW1hLCBzY2hlbWFDb2RlLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IG9wdHMsIGVyclNjaGVtYVBhdGgsIHNjaGVtYUVudiwgc2VsZiB9ID0gaXQ7XG4gICAgICAgIGlmICghb3B0cy52YWxpZGF0ZUZvcm1hdHMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICgkZGF0YSlcbiAgICAgICAgICAgIHZhbGlkYXRlJERhdGFGb3JtYXQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmFsaWRhdGVGb3JtYXQoKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGUkRGF0YUZvcm1hdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGZtdHMgPSBnZW4uc2NvcGVWYWx1ZShcImZvcm1hdHNcIiwge1xuICAgICAgICAgICAgICAgIHJlZjogc2VsZi5mb3JtYXRzLFxuICAgICAgICAgICAgICAgIGNvZGU6IG9wdHMuY29kZS5mb3JtYXRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBmRGVmID0gZ2VuLmNvbnN0KFwiZkRlZlwiLCBjb2RlZ2VuXzEuXyBgJHtmbXRzfVske3NjaGVtYUNvZGV9XWApO1xuICAgICAgICAgICAgY29uc3QgZlR5cGUgPSBnZW4ubGV0KFwiZlR5cGVcIik7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXQgPSBnZW4ubGV0KFwiZm9ybWF0XCIpO1xuICAgICAgICAgICAgLy8gVE9ETyBzaW1wbGlmeVxuICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGB0eXBlb2YgJHtmRGVmfSA9PSBcIm9iamVjdFwiICYmICEoJHtmRGVmfSBpbnN0YW5jZW9mIFJlZ0V4cClgLCAoKSA9PiBnZW4uYXNzaWduKGZUeXBlLCBjb2RlZ2VuXzEuXyBgJHtmRGVmfS50eXBlIHx8IFwic3RyaW5nXCJgKS5hc3NpZ24oZm9ybWF0LCBjb2RlZ2VuXzEuXyBgJHtmRGVmfS52YWxpZGF0ZWApLCAoKSA9PiBnZW4uYXNzaWduKGZUeXBlLCBjb2RlZ2VuXzEuXyBgXCJzdHJpbmdcImApLmFzc2lnbihmb3JtYXQsIGZEZWYpKTtcbiAgICAgICAgICAgIGN4dC5mYWlsJGRhdGEoY29kZWdlbl8xLm9yKHVua25vd25GbXQoKSwgaW52YWxpZEZtdCgpKSk7XG4gICAgICAgICAgICBmdW5jdGlvbiB1bmtub3duRm10KCkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLnN0cmljdFNjaGVtYSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEubmlsO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEuXyBgJHtzY2hlbWFDb2RlfSAmJiAhJHtmb3JtYXR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGludmFsaWRGbXQoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbEZvcm1hdCA9IHNjaGVtYUVudi4kYXN5bmNcbiAgICAgICAgICAgICAgICAgICAgPyBjb2RlZ2VuXzEuXyBgKCR7ZkRlZn0uYXN5bmMgPyBhd2FpdCAke2Zvcm1hdH0oJHtkYXRhfSkgOiAke2Zvcm1hdH0oJHtkYXRhfSkpYFxuICAgICAgICAgICAgICAgICAgICA6IGNvZGVnZW5fMS5fIGAke2Zvcm1hdH0oJHtkYXRhfSlgO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkRGF0YSA9IGNvZGVnZW5fMS5fIGAodHlwZW9mICR7Zm9ybWF0fSA9PSBcImZ1bmN0aW9uXCIgPyAke2NhbGxGb3JtYXR9IDogJHtmb3JtYXR9LnRlc3QoJHtkYXRhfSkpYDtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLl8gYCR7Zm9ybWF0fSAmJiAke2Zvcm1hdH0gIT09IHRydWUgJiYgJHtmVHlwZX0gPT09ICR7cnVsZVR5cGV9ICYmICEke3ZhbGlkRGF0YX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KCkge1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0RGVmID0gc2VsZi5mb3JtYXRzW3NjaGVtYV07XG4gICAgICAgICAgICBpZiAoIWZvcm1hdERlZikge1xuICAgICAgICAgICAgICAgIHVua25vd25Gb3JtYXQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9ybWF0RGVmID09PSB0cnVlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IFtmbXRUeXBlLCBmb3JtYXQsIGZtdFJlZl0gPSBnZXRGb3JtYXQoZm9ybWF0RGVmKTtcbiAgICAgICAgICAgIGlmIChmbXRUeXBlID09PSBydWxlVHlwZSlcbiAgICAgICAgICAgICAgICBjeHQucGFzcyh2YWxpZENvbmRpdGlvbigpKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHVua25vd25Gb3JtYXQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdHMuc3RyaWN0U2NoZW1hID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmxvZ2dlci53YXJuKHVua25vd25Nc2coKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHVua25vd25Nc2coKSk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdW5rbm93bk1zZygpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGB1bmtub3duIGZvcm1hdCBcIiR7c2NoZW1hfVwiIGlnbm9yZWQgaW4gc2NoZW1hIGF0IHBhdGggXCIke2VyclNjaGVtYVBhdGh9XCJgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldEZvcm1hdChmbXREZWYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gZm10RGVmIGluc3RhbmNlb2YgUmVnRXhwXG4gICAgICAgICAgICAgICAgICAgID8gY29kZWdlbl8xLnJlZ2V4cENvZGUoZm10RGVmKVxuICAgICAgICAgICAgICAgICAgICA6IG9wdHMuY29kZS5mb3JtYXRzXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvZGVnZW5fMS5fIGAke29wdHMuY29kZS5mb3JtYXRzfSR7Y29kZWdlbl8xLmdldFByb3BlcnR5KHNjaGVtYSl9YFxuICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZm10ID0gZ2VuLnNjb3BlVmFsdWUoXCJmb3JtYXRzXCIsIHsga2V5OiBzY2hlbWEsIHJlZjogZm10RGVmLCBjb2RlIH0pO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm10RGVmID09IFwib2JqZWN0XCIgJiYgIShmbXREZWYgaW5zdGFuY2VvZiBSZWdFeHApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbZm10RGVmLnR5cGUgfHwgXCJzdHJpbmdcIiwgZm10RGVmLnZhbGlkYXRlLCBjb2RlZ2VuXzEuXyBgJHtmbXR9LnZhbGlkYXRlYF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbXCJzdHJpbmdcIiwgZm10RGVmLCBmbXRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gdmFsaWRDb25kaXRpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXREZWYgPT0gXCJvYmplY3RcIiAmJiAhKGZvcm1hdERlZiBpbnN0YW5jZW9mIFJlZ0V4cCkgJiYgZm9ybWF0RGVmLmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2NoZW1hRW52LiRhc3luYylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFzeW5jIGZvcm1hdCBpbiBzeW5jIHNjaGVtYVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5fIGBhd2FpdCAke2ZtdFJlZn0oJHtkYXRhfSlgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGZvcm1hdCA9PSBcImZ1bmN0aW9uXCIgPyBjb2RlZ2VuXzEuXyBgJHtmbXRSZWZ9KCR7ZGF0YX0pYCA6IGNvZGVnZW5fMS5fIGAke2ZtdFJlZn0udGVzdCgke2RhdGF9KWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1hdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGZvcm1hdF8xID0gcmVxdWlyZShcIi4vZm9ybWF0XCIpO1xuY29uc3QgZm9ybWF0ID0gW2Zvcm1hdF8xLmRlZmF1bHRdO1xuZXhwb3J0cy5kZWZhdWx0ID0gZm9ybWF0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbnRlbnRWb2NhYnVsYXJ5ID0gZXhwb3J0cy5tZXRhZGF0YVZvY2FidWxhcnkgPSB2b2lkIDA7XG5leHBvcnRzLm1ldGFkYXRhVm9jYWJ1bGFyeSA9IFtcbiAgICBcInRpdGxlXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiLFxuICAgIFwiZGVmYXVsdFwiLFxuICAgIFwiZGVwcmVjYXRlZFwiLFxuICAgIFwicmVhZE9ubHlcIixcbiAgICBcIndyaXRlT25seVwiLFxuICAgIFwiZXhhbXBsZXNcIixcbl07XG5leHBvcnRzLmNvbnRlbnRWb2NhYnVsYXJ5ID0gW1xuICAgIFwiY29udGVudE1lZGlhVHlwZVwiLFxuICAgIFwiY29udGVudEVuY29kaW5nXCIsXG4gICAgXCJjb250ZW50U2NoZW1hXCIsXG5dO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0YWRhdGEuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xuY29uc3QgdmFsaWRhdGlvbl8xID0gcmVxdWlyZShcIi4vdmFsaWRhdGlvblwiKTtcbmNvbnN0IGFwcGxpY2F0b3JfMSA9IHJlcXVpcmUoXCIuL2FwcGxpY2F0b3JcIik7XG5jb25zdCBmb3JtYXRfMSA9IHJlcXVpcmUoXCIuL2Zvcm1hdFwiKTtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IGRyYWZ0N1ZvY2FidWxhcmllcyA9IFtcbiAgICBjb3JlXzEuZGVmYXVsdCxcbiAgICB2YWxpZGF0aW9uXzEuZGVmYXVsdCxcbiAgICBhcHBsaWNhdG9yXzEuZGVmYXVsdCgpLFxuICAgIGZvcm1hdF8xLmRlZmF1bHQsXG4gICAgbWV0YWRhdGFfMS5tZXRhZGF0YVZvY2FidWxhcnksXG4gICAgbWV0YWRhdGFfMS5jb250ZW50Vm9jYWJ1bGFyeSxcbl07XG5leHBvcnRzLmRlZmF1bHQgPSBkcmFmdDdWb2NhYnVsYXJpZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kcmFmdDcuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRpc2NyRXJyb3IgPSB2b2lkIDA7XG52YXIgRGlzY3JFcnJvcjtcbihmdW5jdGlvbiAoRGlzY3JFcnJvcikge1xuICAgIERpc2NyRXJyb3JbXCJUYWdcIl0gPSBcInRhZ1wiO1xuICAgIERpc2NyRXJyb3JbXCJNYXBwaW5nXCJdID0gXCJtYXBwaW5nXCI7XG59KShEaXNjckVycm9yID0gZXhwb3J0cy5EaXNjckVycm9yIHx8IChleHBvcnRzLkRpc2NyRXJyb3IgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi9kaXNjcmltaW5hdG9yL3R5cGVzXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgcGFyYW1zOiB7IGRpc2NyRXJyb3IsIHRhZ05hbWUgfSB9KSA9PiBkaXNjckVycm9yID09PSB0eXBlc18xLkRpc2NyRXJyb3IuVGFnXG4gICAgICAgID8gYHRhZyBcIiR7dGFnTmFtZX1cIiBtdXN0IGJlIHN0cmluZ2BcbiAgICAgICAgOiBgdmFsdWUgb2YgdGFnIFwiJHt0YWdOYW1lfVwiIG11c3QgYmUgaW4gb25lT2ZgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IGRpc2NyRXJyb3IsIHRhZywgdGFnTmFtZSB9IH0pID0+IGNvZGVnZW5fMS5fIGB7ZXJyb3I6ICR7ZGlzY3JFcnJvcn0sIHRhZzogJHt0YWdOYW1lfSwgdGFnVmFsdWU6ICR7dGFnfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImRpc2NyaW1pbmF0b3JcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFwib2JqZWN0XCIsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIGRhdGEsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IG9uZU9mIH0gPSBwYXJlbnRTY2hlbWE7XG4gICAgICAgIGlmICghaXQub3B0cy5kaXNjcmltaW5hdG9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXNjcmltaW5hdG9yOiByZXF1aXJlcyBkaXNjcmltaW5hdG9yIG9wdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YWdOYW1lID0gc2NoZW1hLnByb3BlcnR5TmFtZTtcbiAgICAgICAgaWYgKHR5cGVvZiB0YWdOYW1lICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXNjcmltaW5hdG9yOiByZXF1aXJlcyBwcm9wZXJ0eU5hbWVcIik7XG4gICAgICAgIGlmIChzY2hlbWEubWFwcGluZylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImRpc2NyaW1pbmF0b3I6IG1hcHBpbmcgaXMgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgaWYgKCFvbmVPZilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImRpc2NyaW1pbmF0b3I6IHJlcXVpcmVzIG9uZU9mIGtleXdvcmRcIik7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIGZhbHNlKTtcbiAgICAgICAgY29uc3QgdGFnID0gZ2VuLmNvbnN0KFwidGFnXCIsIGNvZGVnZW5fMS5fIGAke2RhdGF9JHtjb2RlZ2VuXzEuZ2V0UHJvcGVydHkodGFnTmFtZSl9YCk7XG4gICAgICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgdHlwZW9mICR7dGFnfSA9PSBcInN0cmluZ1wiYCwgKCkgPT4gdmFsaWRhdGVNYXBwaW5nKCksICgpID0+IGN4dC5lcnJvcihmYWxzZSwgeyBkaXNjckVycm9yOiB0eXBlc18xLkRpc2NyRXJyb3IuVGFnLCB0YWcsIHRhZ05hbWUgfSkpO1xuICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZU1hcHBpbmcoKSB7XG4gICAgICAgICAgICBjb25zdCBtYXBwaW5nID0gZ2V0TWFwcGluZygpO1xuICAgICAgICAgICAgZ2VuLmlmKGZhbHNlKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdGFnVmFsdWUgaW4gbWFwcGluZykge1xuICAgICAgICAgICAgICAgIGdlbi5lbHNlSWYoY29kZWdlbl8xLl8gYCR7dGFnfSA9PT0gJHt0YWdWYWx1ZX1gKTtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBhcHBseVRhZ1NjaGVtYShtYXBwaW5nW3RhZ1ZhbHVlXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VuLmVsc2UoKTtcbiAgICAgICAgICAgIGN4dC5lcnJvcihmYWxzZSwgeyBkaXNjckVycm9yOiB0eXBlc18xLkRpc2NyRXJyb3IuTWFwcGluZywgdGFnLCB0YWdOYW1lIH0pO1xuICAgICAgICAgICAgZ2VuLmVuZElmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYXBwbHlUYWdTY2hlbWEoc2NoZW1hUHJvcCkge1xuICAgICAgICAgICAgY29uc3QgX3ZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoeyBrZXl3b3JkOiBcIm9uZU9mXCIsIHNjaGVtYVByb3AgfSwgX3ZhbGlkKTtcbiAgICAgICAgICAgIGN4dC5tZXJnZUV2YWx1YXRlZChzY2hDeHQsIGNvZGVnZW5fMS5OYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBfdmFsaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0TWFwcGluZygpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IG9uZU9mTWFwcGluZyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgdG9wUmVxdWlyZWQgPSBoYXNSZXF1aXJlZChwYXJlbnRTY2hlbWEpO1xuICAgICAgICAgICAgbGV0IHRhZ1JlcXVpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb25lT2YubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2ggPSBvbmVPZltpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wU2NoID0gKF9hID0gc2NoLnByb3BlcnRpZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVt0YWdOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3BTY2ggIT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpc2NyaW1pbmF0b3I6IG9uZU9mIHNjaGVtYXMgbXVzdCBoYXZlIFwicHJvcGVydGllcy8ke3RhZ05hbWV9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFnUmVxdWlyZWQgPSB0YWdSZXF1aXJlZCAmJiAodG9wUmVxdWlyZWQgfHwgaGFzUmVxdWlyZWQoc2NoKSk7XG4gICAgICAgICAgICAgICAgYWRkTWFwcGluZ3MocHJvcFNjaCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRhZ1JlcXVpcmVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlzY3JpbWluYXRvcjogXCIke3RhZ05hbWV9XCIgbXVzdCBiZSByZXF1aXJlZGApO1xuICAgICAgICAgICAgcmV0dXJuIG9uZU9mTWFwcGluZztcbiAgICAgICAgICAgIGZ1bmN0aW9uIGhhc1JlcXVpcmVkKHsgcmVxdWlyZWQgfSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHJlcXVpcmVkKSAmJiByZXF1aXJlZC5pbmNsdWRlcyh0YWdOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmdzKHNjaCwgaSkge1xuICAgICAgICAgICAgICAgIGlmIChzY2guY29uc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkTWFwcGluZyhzY2guY29uc3QsIGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzY2guZW51bSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRhZ1ZhbHVlIG9mIHNjaC5lbnVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRNYXBwaW5nKHRhZ1ZhbHVlLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaXNjcmltaW5hdG9yOiBcInByb3BlcnRpZXMvJHt0YWdOYW1lfVwiIG11c3QgaGF2ZSBcImNvbnN0XCIgb3IgXCJlbnVtXCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRNYXBwaW5nKHRhZ1ZhbHVlLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0YWdWYWx1ZSAhPSBcInN0cmluZ1wiIHx8IHRhZ1ZhbHVlIGluIG9uZU9mTWFwcGluZykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpc2NyaW1pbmF0b3I6IFwiJHt0YWdOYW1lfVwiIHZhbHVlcyBtdXN0IGJlIHVuaXF1ZSBzdHJpbmdzYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9uZU9mTWFwcGluZ1t0YWdWYWx1ZV0gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29kZUdlbiA9IGV4cG9ydHMuTmFtZSA9IGV4cG9ydHMubmlsID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBleHBvcnRzLnN0ciA9IGV4cG9ydHMuXyA9IGV4cG9ydHMuS2V5d29yZEN4dCA9IHZvaWQgMDtcbmNvbnN0IGNvcmVfMSA9IHJlcXVpcmUoXCIuL2NvcmVcIik7XG5jb25zdCBkcmFmdDdfMSA9IHJlcXVpcmUoXCIuL3ZvY2FidWxhcmllcy9kcmFmdDdcIik7XG5jb25zdCBkaXNjcmltaW5hdG9yXzEgPSByZXF1aXJlKFwiLi92b2NhYnVsYXJpZXMvZGlzY3JpbWluYXRvclwiKTtcbmNvbnN0IGRyYWZ0N01ldGFTY2hlbWEgPSByZXF1aXJlKFwiLi9yZWZzL2pzb24tc2NoZW1hLWRyYWZ0LTA3Lmpzb25cIik7XG5jb25zdCBNRVRBX1NVUFBPUlRfREFUQSA9IFtcIi9wcm9wZXJ0aWVzXCJdO1xuY29uc3QgTUVUQV9TQ0hFTUFfSUQgPSBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDcvc2NoZW1hXCI7XG5jbGFzcyBBanYgZXh0ZW5kcyBjb3JlXzEuZGVmYXVsdCB7XG4gICAgX2FkZFZvY2FidWxhcmllcygpIHtcbiAgICAgICAgc3VwZXIuX2FkZFZvY2FidWxhcmllcygpO1xuICAgICAgICBkcmFmdDdfMS5kZWZhdWx0LmZvckVhY2goKHYpID0+IHRoaXMuYWRkVm9jYWJ1bGFyeSh2KSk7XG4gICAgICAgIGlmICh0aGlzLm9wdHMuZGlzY3JpbWluYXRvcilcbiAgICAgICAgICAgIHRoaXMuYWRkS2V5d29yZChkaXNjcmltaW5hdG9yXzEuZGVmYXVsdCk7XG4gICAgfVxuICAgIF9hZGREZWZhdWx0TWV0YVNjaGVtYSgpIHtcbiAgICAgICAgc3VwZXIuX2FkZERlZmF1bHRNZXRhU2NoZW1hKCk7XG4gICAgICAgIGlmICghdGhpcy5vcHRzLm1ldGEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IG1ldGFTY2hlbWEgPSB0aGlzLm9wdHMuJGRhdGFcbiAgICAgICAgICAgID8gdGhpcy4kZGF0YU1ldGFTY2hlbWEoZHJhZnQ3TWV0YVNjaGVtYSwgTUVUQV9TVVBQT1JUX0RBVEEpXG4gICAgICAgICAgICA6IGRyYWZ0N01ldGFTY2hlbWE7XG4gICAgICAgIHRoaXMuYWRkTWV0YVNjaGVtYShtZXRhU2NoZW1hLCBNRVRBX1NDSEVNQV9JRCwgZmFsc2UpO1xuICAgICAgICB0aGlzLnJlZnNbXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL3NjaGVtYVwiXSA9IE1FVEFfU0NIRU1BX0lEO1xuICAgIH1cbiAgICBkZWZhdWx0TWV0YSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLm9wdHMuZGVmYXVsdE1ldGEgPVxuICAgICAgICAgICAgc3VwZXIuZGVmYXVsdE1ldGEoKSB8fCAodGhpcy5nZXRTY2hlbWEoTUVUQV9TQ0hFTUFfSUQpID8gTUVUQV9TQ0hFTUFfSUQgOiB1bmRlZmluZWQpKTtcbiAgICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBBanY7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBBanY7XG52YXIgdmFsaWRhdGVfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvdmFsaWRhdGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJLZXl3b3JkQ3h0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWxpZGF0ZV8xLktleXdvcmRDeHQ7IH0gfSk7XG52YXIgY29kZWdlbl8xID0gcmVxdWlyZShcIi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLl87IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5zdHI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJpbmdpZnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5zdHJpbmdpZnk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJuaWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5uaWw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOYW1lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuTmFtZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvZGVHZW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5Db2RlR2VuOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWp2LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mb3JtYXROYW1lcyA9IGV4cG9ydHMuZmFzdEZvcm1hdHMgPSBleHBvcnRzLmZ1bGxGb3JtYXRzID0gdm9pZCAwO1xuZnVuY3Rpb24gZm10RGVmKHZhbGlkYXRlLCBjb21wYXJlKSB7XG4gICAgcmV0dXJuIHsgdmFsaWRhdGUsIGNvbXBhcmUgfTtcbn1cbmV4cG9ydHMuZnVsbEZvcm1hdHMgPSB7XG4gICAgLy8gZGF0ZTogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNzZWN0aW9uLTUuNlxuICAgIGRhdGU6IGZtdERlZihkYXRlLCBjb21wYXJlRGF0ZSksXG4gICAgLy8gZGF0ZS10aW1lOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gICAgdGltZTogZm10RGVmKHRpbWUsIGNvbXBhcmVUaW1lKSxcbiAgICBcImRhdGUtdGltZVwiOiBmbXREZWYoZGF0ZV90aW1lLCBjb21wYXJlRGF0ZVRpbWUpLFxuICAgIC8vIGR1cmF0aW9uOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNhcHBlbmRpeC1BXG4gICAgZHVyYXRpb246IC9eUCg/ISQpKChcXGQrWSk/KFxcZCtNKT8oXFxkK0QpPyhUKD89XFxkKShcXGQrSCk/KFxcZCtNKT8oXFxkK1MpPyk/fChcXGQrVyk/KSQvLFxuICAgIHVyaSxcbiAgICBcInVyaS1yZWZlcmVuY2VcIjogL14oPzpbYS16XVthLXowLTkrXFwtLl0qOik/KD86XFwvP1xcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpdfCVbMC05YS1mXXsyfSkqQCk/KD86XFxbKD86KD86KD86KD86WzAtOWEtZl17MSw0fTopezZ9fDo6KD86WzAtOWEtZl17MSw0fTopezV9fCg/OlswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDF9WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7M318KD86KD86WzAtOWEtZl17MSw0fTopezAsMn1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXsyfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwzfVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fTp8KD86KD86WzAtOWEtZl17MSw0fTopezAsNH1bMC05YS1mXXsxLDR9KT86OikoPzpbMC05YS1mXXsxLDR9OlswLTlhLWZdezEsNH18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw1fVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw2fVswLTlhLWZdezEsNH0pPzo6KXxbVnZdWzAtOWEtZl0rXFwuW2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol0rKVxcXXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPyl8KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz1dfCVbMC05YS1mXXsyfSkqKSg/OjpcXGQqKT8oPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqfFxcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSopKik/fCg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSopKik/KD86XFw/KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/KD86Iyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkAvP118JVswLTlhLWZdezJ9KSopPyQvaSxcbiAgICAvLyB1cmktdGVtcGxhdGU6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NTcwXG4gICAgXCJ1cmktdGVtcGxhdGVcIjogL14oPzooPzpbXlxceDAwLVxceDIwXCInPD4lXFxcXF5ge3x9XXwlWzAtOWEtZl17Mn0pfFxce1srIy4vOz8mPSwhQHxdPyg/OlthLXowLTlfXXwlWzAtOWEtZl17Mn0pKyg/OjpbMS05XVswLTldezAsM318XFwqKT8oPzosKD86W2EtejAtOV9dfCVbMC05YS1mXXsyfSkrKD86OlsxLTldWzAtOV17MCwzfXxcXCopPykqXFx9KSokL2ksXG4gICAgLy8gRm9yIHRoZSBzb3VyY2U6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2RwZXJpbmkvNzI5Mjk0XG4gICAgLy8gRm9yIHRlc3QgY2FzZXM6IGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9kZW1vL3VybC1yZWdleFxuICAgIHVybDogL14oPzpodHRwcz98ZnRwKTpcXC9cXC8oPzpcXFMrKD86OlxcUyopP0ApPyg/Oig/ISg/OjEwfDEyNykoPzpcXC5cXGR7MSwzfSl7M30pKD8hKD86MTY5XFwuMjU0fDE5MlxcLjE2OCkoPzpcXC5cXGR7MSwzfSl7Mn0pKD8hMTcyXFwuKD86MVs2LTldfDJcXGR8M1swLTFdKSg/OlxcLlxcZHsxLDN9KXsyfSkoPzpbMS05XVxcZD98MVxcZFxcZHwyWzAxXVxcZHwyMlswLTNdKSg/OlxcLig/OjE/XFxkezEsMn18MlswLTRdXFxkfDI1WzAtNV0pKXsyfSg/OlxcLig/OlsxLTldXFxkP3wxXFxkXFxkfDJbMC00XVxcZHwyNVswLTRdKSl8KD86KD86W2EtejAtOVxcdXswMGExfS1cXHV7ZmZmZn1dKy0pKlthLXowLTlcXHV7MDBhMX0tXFx1e2ZmZmZ9XSspKD86XFwuKD86W2EtejAtOVxcdXswMGExfS1cXHV7ZmZmZn1dKy0pKlthLXowLTlcXHV7MDBhMX0tXFx1e2ZmZmZ9XSspKig/OlxcLig/OlthLXpcXHV7MDBhMX0tXFx1e2ZmZmZ9XXsyLH0pKSkoPzo6XFxkezIsNX0pPyg/OlxcL1teXFxzXSopPyQvaXUsXG4gICAgZW1haWw6IC9eW2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKyg/OlxcLlthLXowLTkhIyQlJicqKy89P15fYHt8fX4tXSspKkAoPzpbYS16MC05XSg/OlthLXowLTktXSpbYS16MC05XSk/XFwuKStbYS16MC05XSg/OlthLXowLTktXSpbYS16MC05XSk/JC9pLFxuICAgIGhvc3RuYW1lOiAvXig/PS57MSwyNTN9XFwuPyQpW2EtejAtOV0oPzpbYS16MC05LV17MCw2MX1bYS16MC05XSk/KD86XFwuW2EtejAtOV0oPzpbLTAtOWEtel17MCw2MX1bMC05YS16XSk/KSpcXC4/JC9pLFxuICAgIC8vIG9wdGltaXplZCBodHRwczovL3d3dy5zYWZhcmlib29rc29ubGluZS5jb20vbGlicmFyeS92aWV3L3JlZ3VsYXItZXhwcmVzc2lvbnMtY29va2Jvb2svOTc4MDU5NjgwMjgzNy9jaDA3czE2Lmh0bWxcbiAgICBpcHY0OiAvXig/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KSQvLFxuICAgIGlwdjY6IC9eKCgoWzAtOWEtZl17MSw0fTopezd9KFswLTlhLWZdezEsNH18OikpfCgoWzAtOWEtZl17MSw0fTopezZ9KDpbMC05YS1mXXsxLDR9fCgoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KXw6KSl8KChbMC05YS1mXXsxLDR9Oil7NX0oKCg6WzAtOWEtZl17MSw0fSl7MSwyfSl8OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KXw6KSl8KChbMC05YS1mXXsxLDR9Oil7NH0oKCg6WzAtOWEtZl17MSw0fSl7MSwzfSl8KCg6WzAtOWEtZl17MSw0fSk/OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOWEtZl17MSw0fTopezN9KCgoOlswLTlhLWZdezEsNH0pezEsNH0pfCgoOlswLTlhLWZdezEsNH0pezAsMn06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05YS1mXXsxLDR9Oil7Mn0oKCg6WzAtOWEtZl17MSw0fSl7MSw1fSl8KCg6WzAtOWEtZl17MSw0fSl7MCwzfTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlhLWZdezEsNH06KXsxfSgoKDpbMC05YS1mXXsxLDR9KXsxLDZ9KXwoKDpbMC05YS1mXXsxLDR9KXswLDR9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCg6KCgoOlswLTlhLWZdezEsNH0pezEsN30pfCgoOlswLTlhLWZdezEsNH0pezAsNX06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSkpJC9pLFxuICAgIHJlZ2V4LFxuICAgIC8vIHV1aWQ6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQxMjJcbiAgICB1dWlkOiAvXig/OnVybjp1dWlkOik/WzAtOWEtZl17OH0tKD86WzAtOWEtZl17NH0tKXszfVswLTlhLWZdezEyfSQvaSxcbiAgICAvLyBKU09OLXBvaW50ZXI6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2OTAxXG4gICAgLy8gdXJpIGZyYWdtZW50OiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNhcHBlbmRpeC1BXG4gICAgXCJqc29uLXBvaW50ZXJcIjogL14oPzpcXC8oPzpbXn4vXXx+MHx+MSkqKSokLyxcbiAgICBcImpzb24tcG9pbnRlci11cmktZnJhZ21lbnRcIjogL14jKD86XFwvKD86W2EtejAtOV9cXC0uISQmJygpKissOzo9QF18JVswLTlhLWZdezJ9fH4wfH4xKSopKiQvaSxcbiAgICAvLyByZWxhdGl2ZSBKU09OLXBvaW50ZXI6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWx1ZmYtcmVsYXRpdmUtanNvbi1wb2ludGVyLTAwXG4gICAgXCJyZWxhdGl2ZS1qc29uLXBvaW50ZXJcIjogL14oPzowfFsxLTldWzAtOV0qKSg/OiN8KD86XFwvKD86W15+L118fjB8fjEpKikqKSQvLFxuICAgIC8vIHRoZSBmb2xsb3dpbmcgZm9ybWF0cyBhcmUgdXNlZCBieSB0aGUgb3BlbmFwaSBzcGVjaWZpY2F0aW9uOiBodHRwczovL3NwZWMub3BlbmFwaXMub3JnL29hcy92My4wLjAjZGF0YS10eXBlc1xuICAgIC8vIGJ5dGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9taWd1ZWxtb3RhL2lzLWJhc2U2NFxuICAgIGJ5dGUsXG4gICAgLy8gc2lnbmVkIDMyIGJpdCBpbnRlZ2VyXG4gICAgaW50MzI6IHsgdHlwZTogXCJudW1iZXJcIiwgdmFsaWRhdGU6IHZhbGlkYXRlSW50MzIgfSxcbiAgICAvLyBzaWduZWQgNjQgYml0IGludGVnZXJcbiAgICBpbnQ2NDogeyB0eXBlOiBcIm51bWJlclwiLCB2YWxpZGF0ZTogdmFsaWRhdGVJbnQ2NCB9LFxuICAgIC8vIEMtdHlwZSBmbG9hdFxuICAgIGZsb2F0OiB7IHR5cGU6IFwibnVtYmVyXCIsIHZhbGlkYXRlOiB2YWxpZGF0ZU51bWJlciB9LFxuICAgIC8vIEMtdHlwZSBkb3VibGVcbiAgICBkb3VibGU6IHsgdHlwZTogXCJudW1iZXJcIiwgdmFsaWRhdGU6IHZhbGlkYXRlTnVtYmVyIH0sXG4gICAgLy8gaGludCB0byB0aGUgVUkgdG8gaGlkZSBpbnB1dCBzdHJpbmdzXG4gICAgcGFzc3dvcmQ6IHRydWUsXG4gICAgLy8gdW5jaGVja2VkIHN0cmluZyBwYXlsb2FkXG4gICAgYmluYXJ5OiB0cnVlLFxufTtcbmV4cG9ydHMuZmFzdEZvcm1hdHMgPSB7XG4gICAgLi4uZXhwb3J0cy5mdWxsRm9ybWF0cyxcbiAgICBkYXRlOiBmbXREZWYoL15cXGRcXGRcXGRcXGQtWzAtMV1cXGQtWzAtM11cXGQkLywgY29tcGFyZURhdGUpLFxuICAgIHRpbWU6IGZtdERlZigvXig/OlswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkfDIzOjU5OjYwKSg/OlxcLlxcZCspPyg/Onp8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8pPyQvaSwgY29tcGFyZVRpbWUpLFxuICAgIFwiZGF0ZS10aW1lXCI6IGZtdERlZigvXlxcZFxcZFxcZFxcZC1bMC0xXVxcZC1bMC0zXVxcZFt0XFxzXSg/OlswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkfDIzOjU5OjYwKSg/OlxcLlxcZCspPyg/Onp8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8pJC9pLCBjb21wYXJlRGF0ZVRpbWUpLFxuICAgIC8vIHVyaTogaHR0cHM6Ly9naXRodWIuY29tL21hZmludG9zaC9pcy1teS1qc29uLXZhbGlkL2Jsb2IvbWFzdGVyL2Zvcm1hdHMuanNcbiAgICB1cmk6IC9eKD86W2Etel1bYS16MC05K1xcLS5dKjopKD86XFwvP1xcLyk/W15cXHNdKiQvaSxcbiAgICBcInVyaS1yZWZlcmVuY2VcIjogL14oPzooPzpbYS16XVthLXowLTkrXFwtLl0qOik/XFwvP1xcLyk/KD86W15cXFxcXFxzI11bXlxccyNdKik/KD86I1teXFxcXFxcc10qKT8kL2ksXG4gICAgLy8gZW1haWwgKHNvdXJjZXMgZnJvbSBqc2VuIHZhbGlkYXRvcik6XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMDEzMjMvdXNpbmctYS1yZWd1bGFyLWV4cHJlc3Npb24tdG8tdmFsaWRhdGUtYW4tZW1haWwtYWRkcmVzcyNhbnN3ZXItODgyOTM2M1xuICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2Zvcm1zLmh0bWwjdmFsaWQtZS1tYWlsLWFkZHJlc3MgKHNlYXJjaCBmb3IgJ3dpbGZ1bCB2aW9sYXRpb24nKVxuICAgIGVtYWlsOiAvXlthLXowLTkuISMkJSYnKisvPT9eX2B7fH1+LV0rQFthLXowLTldKD86W2EtejAtOS1dezAsNjF9W2EtejAtOV0pPyg/OlxcLlthLXowLTldKD86W2EtejAtOS1dezAsNjF9W2EtejAtOV0pPykqJC9pLFxufTtcbmV4cG9ydHMuZm9ybWF0TmFtZXMgPSBPYmplY3Qua2V5cyhleHBvcnRzLmZ1bGxGb3JtYXRzKTtcbmZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I2FwcGVuZGl4LUNcbiAgICByZXR1cm4geWVhciAlIDQgPT09IDAgJiYgKHllYXIgJSAxMDAgIT09IDAgfHwgeWVhciAlIDQwMCA9PT0gMCk7XG59XG5jb25zdCBEQVRFID0gL14oXFxkXFxkXFxkXFxkKS0oXFxkXFxkKS0oXFxkXFxkKSQvO1xuY29uc3QgREFZUyA9IFswLCAzMSwgMjgsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXTtcbmZ1bmN0aW9uIGRhdGUoc3RyKSB7XG4gICAgLy8gZnVsbC1kYXRlIGZyb20gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNzZWN0aW9uLTUuNlxuICAgIGNvbnN0IG1hdGNoZXMgPSBEQVRFLmV4ZWMoc3RyKTtcbiAgICBpZiAoIW1hdGNoZXMpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCB5ZWFyID0gK21hdGNoZXNbMV07XG4gICAgY29uc3QgbW9udGggPSArbWF0Y2hlc1syXTtcbiAgICBjb25zdCBkYXkgPSArbWF0Y2hlc1szXTtcbiAgICByZXR1cm4gKG1vbnRoID49IDEgJiZcbiAgICAgICAgbW9udGggPD0gMTIgJiZcbiAgICAgICAgZGF5ID49IDEgJiZcbiAgICAgICAgZGF5IDw9IChtb250aCA9PT0gMiAmJiBpc0xlYXBZZWFyKHllYXIpID8gMjkgOiBEQVlTW21vbnRoXSkpO1xufVxuZnVuY3Rpb24gY29tcGFyZURhdGUoZDEsIGQyKSB7XG4gICAgaWYgKCEoZDEgJiYgZDIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGlmIChkMSA+IGQyKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAoZDEgPCBkMilcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIHJldHVybiAwO1xufVxuY29uc3QgVElNRSA9IC9eKFxcZFxcZCk6KFxcZFxcZCk6KFxcZFxcZCkoXFwuXFxkKyk/KHp8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8pPyQvaTtcbmZ1bmN0aW9uIHRpbWUoc3RyLCB3aXRoVGltZVpvbmUpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gVElNRS5leGVjKHN0cik7XG4gICAgaWYgKCFtYXRjaGVzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgaG91ciA9ICttYXRjaGVzWzFdO1xuICAgIGNvbnN0IG1pbnV0ZSA9ICttYXRjaGVzWzJdO1xuICAgIGNvbnN0IHNlY29uZCA9ICttYXRjaGVzWzNdO1xuICAgIGNvbnN0IHRpbWVab25lID0gbWF0Y2hlc1s1XTtcbiAgICByZXR1cm4gKCgoaG91ciA8PSAyMyAmJiBtaW51dGUgPD0gNTkgJiYgc2Vjb25kIDw9IDU5KSB8fFxuICAgICAgICAoaG91ciA9PT0gMjMgJiYgbWludXRlID09PSA1OSAmJiBzZWNvbmQgPT09IDYwKSkgJiZcbiAgICAgICAgKCF3aXRoVGltZVpvbmUgfHwgdGltZVpvbmUgIT09IFwiXCIpKTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVUaW1lKHQxLCB0Mikge1xuICAgIGlmICghKHQxICYmIHQyKSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBhMSA9IFRJTUUuZXhlYyh0MSk7XG4gICAgY29uc3QgYTIgPSBUSU1FLmV4ZWModDIpO1xuICAgIGlmICghKGExICYmIGEyKSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB0MSA9IGExWzFdICsgYTFbMl0gKyBhMVszXSArIChhMVs0XSB8fCBcIlwiKTtcbiAgICB0MiA9IGEyWzFdICsgYTJbMl0gKyBhMlszXSArIChhMls0XSB8fCBcIlwiKTtcbiAgICBpZiAodDEgPiB0MilcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKHQxIDwgdDIpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICByZXR1cm4gMDtcbn1cbmNvbnN0IERBVEVfVElNRV9TRVBBUkFUT1IgPSAvdHxcXHMvaTtcbmZ1bmN0aW9uIGRhdGVfdGltZShzdHIpIHtcbiAgICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gICAgY29uc3QgZGF0ZVRpbWUgPSBzdHIuc3BsaXQoREFURV9USU1FX1NFUEFSQVRPUik7XG4gICAgcmV0dXJuIGRhdGVUaW1lLmxlbmd0aCA9PT0gMiAmJiBkYXRlKGRhdGVUaW1lWzBdKSAmJiB0aW1lKGRhdGVUaW1lWzFdLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVEYXRlVGltZShkdDEsIGR0Mikge1xuICAgIGlmICghKGR0MSAmJiBkdDIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IFtkMSwgdDFdID0gZHQxLnNwbGl0KERBVEVfVElNRV9TRVBBUkFUT1IpO1xuICAgIGNvbnN0IFtkMiwgdDJdID0gZHQyLnNwbGl0KERBVEVfVElNRV9TRVBBUkFUT1IpO1xuICAgIGNvbnN0IHJlcyA9IGNvbXBhcmVEYXRlKGQxLCBkMik7XG4gICAgaWYgKHJlcyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXMgfHwgY29tcGFyZVRpbWUodDEsIHQyKTtcbn1cbmNvbnN0IE5PVF9VUklfRlJBR01FTlQgPSAvXFwvfDovO1xuY29uc3QgVVJJID0gL14oPzpbYS16XVthLXowLTkrXFwtLl0qOikoPzpcXC8/XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol18JVswLTlhLWZdezJ9KSpAKT8oPzpcXFsoPzooPzooPzooPzpbMC05YS1mXXsxLDR9Oil7Nn18OjooPzpbMC05YS1mXXsxLDR9Oil7NX18KD86WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7NH18KD86KD86WzAtOWEtZl17MSw0fTopezAsMX1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXszfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwyfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezJ9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDN9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9OnwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw0fVswLTlhLWZdezEsNH0pPzo6KSg/OlswLTlhLWZdezEsNH06WzAtOWEtZl17MSw0fXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPykpfCg/Oig/OlswLTlhLWZdezEsNH06KXswLDV9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDZ9WzAtOWEtZl17MSw0fSk/OjopfFtWdl1bMC05YS1mXStcXC5bYS16MC05XFwtLl9+ISQmJygpKissOz06XSspXFxdfCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KXwoPzpbYS16MC05XFwtLl9+ISQmJygpKissOz1dfCVbMC05YS1mXXsyfSkqKSg/OjpcXGQqKT8oPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSopKnxcXC8oPzooPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSopKik/fCg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKSg/OlxcPyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8oPzojKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkAvP118JVswLTlhLWZdezJ9KSopPyQvaTtcbmZ1bmN0aW9uIHVyaShzdHIpIHtcbiAgICAvLyBodHRwOi8vam1yd2FyZS5jb20vYXJ0aWNsZXMvMjAwOS91cmlfcmVnZXhwL1VSSV9yZWdleC5odG1sICsgb3B0aW9uYWwgcHJvdG9jb2wgKyByZXF1aXJlZCBcIi5cIlxuICAgIHJldHVybiBOT1RfVVJJX0ZSQUdNRU5ULnRlc3Qoc3RyKSAmJiBVUkkudGVzdChzdHIpO1xufVxuY29uc3QgQllURSA9IC9eKD86W0EtWmEtejAtOSsvXXs0fSkqKD86W0EtWmEtejAtOSsvXXsyfT09fFtBLVphLXowLTkrL117M309KT8kL2dtO1xuZnVuY3Rpb24gYnl0ZShzdHIpIHtcbiAgICBCWVRFLmxhc3RJbmRleCA9IDA7XG4gICAgcmV0dXJuIEJZVEUudGVzdChzdHIpO1xufVxuY29uc3QgTUlOX0lOVDMyID0gLSgyICoqIDMxKTtcbmNvbnN0IE1BWF9JTlQzMiA9IDIgKiogMzEgLSAxO1xuZnVuY3Rpb24gdmFsaWRhdGVJbnQzMih2YWx1ZSkge1xuICAgIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSAmJiB2YWx1ZSA8PSBNQVhfSU5UMzIgJiYgdmFsdWUgPj0gTUlOX0lOVDMyO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVJbnQ2NCh2YWx1ZSkge1xuICAgIC8vIEpTT04gYW5kIGphdmFzY3JpcHQgbWF4IEludCBpcyAyKio1Mywgc28gYW55IGludCB0aGF0IHBhc3NlcyBpc0ludGVnZXIgaXMgdmFsaWQgZm9yIEludDY0XG4gICAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIodmFsdWUpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRydWU7XG59XG5jb25zdCBaX0FOQ0hPUiA9IC9bXlxcXFxdXFxcXFovO1xuZnVuY3Rpb24gcmVnZXgoc3RyKSB7XG4gICAgaWYgKFpfQU5DSE9SLnRlc3Qoc3RyKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIG5ldyBSZWdFeHAoc3RyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtYXRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mb3JtYXRMaW1pdERlZmluaXRpb24gPSB2b2lkIDA7XG5jb25zdCBhanZfMSA9IHJlcXVpcmUoXCJhanZcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiYWp2L2Rpc3QvY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3Qgb3BzID0gY29kZWdlbl8xLm9wZXJhdG9ycztcbmNvbnN0IEtXRHMgPSB7XG4gICAgZm9ybWF0TWF4aW11bTogeyBva1N0cjogXCI8PVwiLCBvazogb3BzLkxURSwgZmFpbDogb3BzLkdUIH0sXG4gICAgZm9ybWF0TWluaW11bTogeyBva1N0cjogXCI+PVwiLCBvazogb3BzLkdURSwgZmFpbDogb3BzLkxUIH0sXG4gICAgZm9ybWF0RXhjbHVzaXZlTWF4aW11bTogeyBva1N0cjogXCI8XCIsIG9rOiBvcHMuTFQsIGZhaWw6IG9wcy5HVEUgfSxcbiAgICBmb3JtYXRFeGNsdXNpdmVNaW5pbXVtOiB7IG9rU3RyOiBcIj5cIiwgb2s6IG9wcy5HVCwgZmFpbDogb3BzLkxURSB9LFxufTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkgPT4gY29kZWdlbl8xLnN0ciBgc2hvdWxkIGJlICR7S1dEc1trZXl3b3JkXS5va1N0cn0gJHtzY2hlbWFDb2RlfWAsXG4gICAgcGFyYW1zOiAoeyBrZXl3b3JkLCBzY2hlbWFDb2RlIH0pID0+IGNvZGVnZW5fMS5fIGB7Y29tcGFyaXNvbjogJHtLV0RzW2tleXdvcmRdLm9rU3RyfSwgbGltaXQ6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5leHBvcnRzLmZvcm1hdExpbWl0RGVmaW5pdGlvbiA9IHtcbiAgICBrZXl3b3JkOiBPYmplY3Qua2V5cyhLV0RzKSxcbiAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgIHNjaGVtYVR5cGU6IFwic3RyaW5nXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIGRhdGEsIHNjaGVtYUNvZGUsIGtleXdvcmQsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgb3B0cywgc2VsZiB9ID0gaXQ7XG4gICAgICAgIGlmICghb3B0cy52YWxpZGF0ZUZvcm1hdHMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGZDeHQgPSBuZXcgYWp2XzEuS2V5d29yZEN4dChpdCwgc2VsZi5SVUxFUy5hbGwuZm9ybWF0LmRlZmluaXRpb24sIFwiZm9ybWF0XCIpO1xuICAgICAgICBpZiAoZkN4dC4kZGF0YSlcbiAgICAgICAgICAgIHZhbGlkYXRlJERhdGFGb3JtYXQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmFsaWRhdGVGb3JtYXQoKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGUkRGF0YUZvcm1hdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGZtdHMgPSBnZW4uc2NvcGVWYWx1ZShcImZvcm1hdHNcIiwge1xuICAgICAgICAgICAgICAgIHJlZjogc2VsZi5mb3JtYXRzLFxuICAgICAgICAgICAgICAgIGNvZGU6IG9wdHMuY29kZS5mb3JtYXRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBmbXQgPSBnZW4uY29uc3QoXCJmbXRcIiwgY29kZWdlbl8xLl8gYCR7Zm10c31bJHtmQ3h0LnNjaGVtYUNvZGV9XWApO1xuICAgICAgICAgICAgY3h0LmZhaWwkZGF0YShjb2RlZ2VuXzEub3IoY29kZWdlbl8xLl8gYHR5cGVvZiAke2ZtdH0gIT0gXCJvYmplY3RcImAsIGNvZGVnZW5fMS5fIGAke2ZtdH0gaW5zdGFuY2VvZiBSZWdFeHBgLCBjb2RlZ2VuXzEuXyBgdHlwZW9mICR7Zm10fS5jb21wYXJlICE9IFwiZnVuY3Rpb25cImAsIGNvbXBhcmVDb2RlKGZtdCkpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdCA9IGZDeHQuc2NoZW1hO1xuICAgICAgICAgICAgY29uc3QgZm10RGVmID0gc2VsZi5mb3JtYXRzW2Zvcm1hdF07XG4gICAgICAgICAgICBpZiAoIWZtdERlZiB8fCBmbXREZWYgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmbXREZWYgIT0gXCJvYmplY3RcIiB8fFxuICAgICAgICAgICAgICAgIGZtdERlZiBpbnN0YW5jZW9mIFJlZ0V4cCB8fFxuICAgICAgICAgICAgICAgIHR5cGVvZiBmbXREZWYuY29tcGFyZSAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtrZXl3b3JkfVwiOiBmb3JtYXQgXCIke2Zvcm1hdH1cIiBkb2VzIG5vdCBkZWZpbmUgXCJjb21wYXJlXCIgZnVuY3Rpb25gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZtdCA9IGdlbi5zY29wZVZhbHVlKFwiZm9ybWF0c1wiLCB7XG4gICAgICAgICAgICAgICAga2V5OiBmb3JtYXQsXG4gICAgICAgICAgICAgICAgcmVmOiBmbXREZWYsXG4gICAgICAgICAgICAgICAgY29kZTogb3B0cy5jb2RlLmZvcm1hdHMgPyBjb2RlZ2VuXzEuXyBgJHtvcHRzLmNvZGUuZm9ybWF0c30ke2NvZGVnZW5fMS5nZXRQcm9wZXJ0eShmb3JtYXQpfWAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGN4dC5mYWlsJGRhdGEoY29tcGFyZUNvZGUoZm10KSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29tcGFyZUNvZGUoZm10KSB7XG4gICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLl8gYCR7Zm10fS5jb21wYXJlKCR7ZGF0YX0sICR7c2NoZW1hQ29kZX0pICR7S1dEc1trZXl3b3JkXS5mYWlsfSAwYDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbXCJmb3JtYXRcIl0sXG59O1xuY29uc3QgZm9ybWF0TGltaXRQbHVnaW4gPSAoYWp2KSA9PiB7XG4gICAgYWp2LmFkZEtleXdvcmQoZXhwb3J0cy5mb3JtYXRMaW1pdERlZmluaXRpb24pO1xuICAgIHJldHVybiBhanY7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZm9ybWF0TGltaXRQbHVnaW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW1pdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGZvcm1hdHNfMSA9IHJlcXVpcmUoXCIuL2Zvcm1hdHNcIik7XG5jb25zdCBsaW1pdF8xID0gcmVxdWlyZShcIi4vbGltaXRcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiYWp2L2Rpc3QvY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgZnVsbE5hbWUgPSBuZXcgY29kZWdlbl8xLk5hbWUoXCJmdWxsRm9ybWF0c1wiKTtcbmNvbnN0IGZhc3ROYW1lID0gbmV3IGNvZGVnZW5fMS5OYW1lKFwiZmFzdEZvcm1hdHNcIik7XG5jb25zdCBmb3JtYXRzUGx1Z2luID0gKGFqdiwgb3B0cyA9IHsga2V5d29yZHM6IHRydWUgfSkgPT4ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdHMpKSB7XG4gICAgICAgIGFkZEZvcm1hdHMoYWp2LCBvcHRzLCBmb3JtYXRzXzEuZnVsbEZvcm1hdHMsIGZ1bGxOYW1lKTtcbiAgICAgICAgcmV0dXJuIGFqdjtcbiAgICB9XG4gICAgY29uc3QgW2Zvcm1hdHMsIGV4cG9ydE5hbWVdID0gb3B0cy5tb2RlID09PSBcImZhc3RcIiA/IFtmb3JtYXRzXzEuZmFzdEZvcm1hdHMsIGZhc3ROYW1lXSA6IFtmb3JtYXRzXzEuZnVsbEZvcm1hdHMsIGZ1bGxOYW1lXTtcbiAgICBjb25zdCBsaXN0ID0gb3B0cy5mb3JtYXRzIHx8IGZvcm1hdHNfMS5mb3JtYXROYW1lcztcbiAgICBhZGRGb3JtYXRzKGFqdiwgbGlzdCwgZm9ybWF0cywgZXhwb3J0TmFtZSk7XG4gICAgaWYgKG9wdHMua2V5d29yZHMpXG4gICAgICAgIGxpbWl0XzEuZGVmYXVsdChhanYpO1xuICAgIHJldHVybiBhanY7XG59O1xuZm9ybWF0c1BsdWdpbi5nZXQgPSAobmFtZSwgbW9kZSA9IFwiZnVsbFwiKSA9PiB7XG4gICAgY29uc3QgZm9ybWF0cyA9IG1vZGUgPT09IFwiZmFzdFwiID8gZm9ybWF0c18xLmZhc3RGb3JtYXRzIDogZm9ybWF0c18xLmZ1bGxGb3JtYXRzO1xuICAgIGNvbnN0IGYgPSBmb3JtYXRzW25hbWVdO1xuICAgIGlmICghZilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGZvcm1hdCBcIiR7bmFtZX1cImApO1xuICAgIHJldHVybiBmO1xufTtcbmZ1bmN0aW9uIGFkZEZvcm1hdHMoYWp2LCBsaXN0LCBmcywgZXhwb3J0TmFtZSkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgX2I7XG4gICAgKF9hID0gKF9iID0gYWp2Lm9wdHMuY29kZSkuZm9ybWF0cykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKF9iLmZvcm1hdHMgPSBjb2RlZ2VuXzEuXyBgcmVxdWlyZShcImFqdi1mb3JtYXRzL2Rpc3QvZm9ybWF0c1wiKS4ke2V4cG9ydE5hbWV9YCk7XG4gICAgZm9yIChjb25zdCBmIG9mIGxpc3QpXG4gICAgICAgIGFqdi5hZGRGb3JtYXQoZiwgZnNbZl0pO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZm9ybWF0c1BsdWdpbjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZvcm1hdHNQbHVnaW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGNvcHlQcm9wZXJ0eSA9ICh0bywgZnJvbSwgcHJvcGVydHksIGlnbm9yZU5vbkNvbmZpZ3VyYWJsZSkgPT4ge1xuXHQvLyBgRnVuY3Rpb24jbGVuZ3RoYCBzaG91bGQgcmVmbGVjdCB0aGUgcGFyYW1ldGVycyBvZiBgdG9gIG5vdCBgZnJvbWAgc2luY2Ugd2Uga2VlcCBpdHMgYm9keS5cblx0Ly8gYEZ1bmN0aW9uI3Byb3RvdHlwZWAgaXMgbm9uLXdyaXRhYmxlIGFuZCBub24tY29uZmlndXJhYmxlIHNvIGNhbiBuZXZlciBiZSBtb2RpZmllZC5cblx0aWYgKHByb3BlcnR5ID09PSAnbGVuZ3RoJyB8fCBwcm9wZXJ0eSA9PT0gJ3Byb3RvdHlwZScpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBgRnVuY3Rpb24jYXJndW1lbnRzYCBhbmQgYEZ1bmN0aW9uI2NhbGxlcmAgc2hvdWxkIG5vdCBiZSBjb3BpZWQuIFRoZXkgd2VyZSByZXBvcnRlZCB0byBiZSBwcmVzZW50IGluIGBSZWZsZWN0Lm93bktleXNgIGZvciBzb21lIGRldmljZXMgaW4gUmVhY3QgTmF0aXZlICgjNDEpLCBzbyB3ZSBleHBsaWNpdGx5IGlnbm9yZSB0aGVtIGhlcmUuXG5cdGlmIChwcm9wZXJ0eSA9PT0gJ2FyZ3VtZW50cycgfHwgcHJvcGVydHkgPT09ICdjYWxsZXInKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Y29uc3QgdG9EZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0bywgcHJvcGVydHkpO1xuXHRjb25zdCBmcm9tRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZnJvbSwgcHJvcGVydHkpO1xuXG5cdGlmICghY2FuQ29weVByb3BlcnR5KHRvRGVzY3JpcHRvciwgZnJvbURlc2NyaXB0b3IpICYmIGlnbm9yZU5vbkNvbmZpZ3VyYWJsZSkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0bywgcHJvcGVydHksIGZyb21EZXNjcmlwdG9yKTtcbn07XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHkoKWAgdGhyb3dzIGlmIHRoZSBwcm9wZXJ0eSBleGlzdHMsIGlzIG5vdCBjb25maWd1cmFibGUgYW5kIGVpdGhlcjpcbi8vICAtIG9uZSBpdHMgZGVzY3JpcHRvcnMgaXMgY2hhbmdlZFxuLy8gIC0gaXQgaXMgbm9uLXdyaXRhYmxlIGFuZCBpdHMgdmFsdWUgaXMgY2hhbmdlZFxuY29uc3QgY2FuQ29weVByb3BlcnR5ID0gZnVuY3Rpb24gKHRvRGVzY3JpcHRvciwgZnJvbURlc2NyaXB0b3IpIHtcblx0cmV0dXJuIHRvRGVzY3JpcHRvciA9PT0gdW5kZWZpbmVkIHx8IHRvRGVzY3JpcHRvci5jb25maWd1cmFibGUgfHwgKFxuXHRcdHRvRGVzY3JpcHRvci53cml0YWJsZSA9PT0gZnJvbURlc2NyaXB0b3Iud3JpdGFibGUgJiZcblx0XHR0b0Rlc2NyaXB0b3IuZW51bWVyYWJsZSA9PT0gZnJvbURlc2NyaXB0b3IuZW51bWVyYWJsZSAmJlxuXHRcdHRvRGVzY3JpcHRvci5jb25maWd1cmFibGUgPT09IGZyb21EZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSAmJlxuXHRcdCh0b0Rlc2NyaXB0b3Iud3JpdGFibGUgfHwgdG9EZXNjcmlwdG9yLnZhbHVlID09PSBmcm9tRGVzY3JpcHRvci52YWx1ZSlcblx0KTtcbn07XG5cbmNvbnN0IGNoYW5nZVByb3RvdHlwZSA9ICh0bywgZnJvbSkgPT4ge1xuXHRjb25zdCBmcm9tUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGZyb20pO1xuXHRpZiAoZnJvbVByb3RvdHlwZSA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRvKSkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdE9iamVjdC5zZXRQcm90b3R5cGVPZih0bywgZnJvbVByb3RvdHlwZSk7XG59O1xuXG5jb25zdCB3cmFwcGVkVG9TdHJpbmcgPSAod2l0aE5hbWUsIGZyb21Cb2R5KSA9PiBgLyogV3JhcHBlZCAke3dpdGhOYW1lfSovXFxuJHtmcm9tQm9keX1gO1xuXG5jb25zdCB0b1N0cmluZ0Rlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEZ1bmN0aW9uLnByb3RvdHlwZSwgJ3RvU3RyaW5nJyk7XG5jb25zdCB0b1N0cmluZ05hbWUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZywgJ25hbWUnKTtcblxuLy8gV2UgY2FsbCBgZnJvbS50b1N0cmluZygpYCBlYXJseSAobm90IGxhemlseSkgdG8gZW5zdXJlIGBmcm9tYCBjYW4gYmUgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4vLyBXZSB1c2UgYGJpbmQoKWAgaW5zdGVhZCBvZiBhIGNsb3N1cmUgZm9yIHRoZSBzYW1lIHJlYXNvbi5cbi8vIENhbGxpbmcgYGZyb20udG9TdHJpbmcoKWAgZWFybHkgYWxzbyBhbGxvd3MgY2FjaGluZyBpdCBpbiBjYXNlIGB0by50b1N0cmluZygpYCBpcyBjYWxsZWQgc2V2ZXJhbCB0aW1lcy5cbmNvbnN0IGNoYW5nZVRvU3RyaW5nID0gKHRvLCBmcm9tLCBuYW1lKSA9PiB7XG5cdGNvbnN0IHdpdGhOYW1lID0gbmFtZSA9PT0gJycgPyAnJyA6IGB3aXRoICR7bmFtZS50cmltKCl9KCkgYDtcblx0Y29uc3QgbmV3VG9TdHJpbmcgPSB3cmFwcGVkVG9TdHJpbmcuYmluZChudWxsLCB3aXRoTmFtZSwgZnJvbS50b1N0cmluZygpKTtcblx0Ly8gRW5zdXJlIGB0by50b1N0cmluZy50b1N0cmluZ2AgaXMgbm9uLWVudW1lcmFibGUgYW5kIGhhcyB0aGUgc2FtZSBgc2FtZWBcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld1RvU3RyaW5nLCAnbmFtZScsIHRvU3RyaW5nTmFtZSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0bywgJ3RvU3RyaW5nJywgey4uLnRvU3RyaW5nRGVzY3JpcHRvciwgdmFsdWU6IG5ld1RvU3RyaW5nfSk7XG59O1xuXG5jb25zdCBtaW1pY0ZuID0gKHRvLCBmcm9tLCB7aWdub3JlTm9uQ29uZmlndXJhYmxlID0gZmFsc2V9ID0ge30pID0+IHtcblx0Y29uc3Qge25hbWV9ID0gdG87XG5cblx0Zm9yIChjb25zdCBwcm9wZXJ0eSBvZiBSZWZsZWN0Lm93bktleXMoZnJvbSkpIHtcblx0XHRjb3B5UHJvcGVydHkodG8sIGZyb20sIHByb3BlcnR5LCBpZ25vcmVOb25Db25maWd1cmFibGUpO1xuXHR9XG5cblx0Y2hhbmdlUHJvdG90eXBlKHRvLCBmcm9tKTtcblx0Y2hhbmdlVG9TdHJpbmcodG8sIGZyb20sIG5hbWUpO1xuXG5cdHJldHVybiB0bztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbWltaWNGbjtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IG1pbWljRm4gPSByZXF1aXJlKCdtaW1pYy1mbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChpbnB1dEZ1bmN0aW9uLCBvcHRpb25zID0ge30pID0+IHtcblx0aWYgKHR5cGVvZiBpbnB1dEZ1bmN0aW9uICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIGJlIGEgZnVuY3Rpb24sIGdvdCBcXGAke3R5cGVvZiBpbnB1dEZ1bmN0aW9ufVxcYGApO1xuXHR9XG5cblx0Y29uc3Qge1xuXHRcdHdhaXQgPSAwLFxuXHRcdGJlZm9yZSA9IGZhbHNlLFxuXHRcdGFmdGVyID0gdHJ1ZVxuXHR9ID0gb3B0aW9ucztcblxuXHRpZiAoIWJlZm9yZSAmJiAhYWZ0ZXIpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0JvdGggYGJlZm9yZWAgYW5kIGBhZnRlcmAgYXJlIGZhbHNlLCBmdW5jdGlvbiB3b3VsZG5cXCd0IGJlIGNhbGxlZC4nKTtcblx0fVxuXG5cdGxldCB0aW1lb3V0O1xuXHRsZXQgcmVzdWx0O1xuXG5cdGNvbnN0IGRlYm91bmNlZEZ1bmN0aW9uID0gZnVuY3Rpb24gKC4uLmFyZ3VtZW50c18pIHtcblx0XHRjb25zdCBjb250ZXh0ID0gdGhpcztcblxuXHRcdGNvbnN0IGxhdGVyID0gKCkgPT4ge1xuXHRcdFx0dGltZW91dCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKGFmdGVyKSB7XG5cdFx0XHRcdHJlc3VsdCA9IGlucHV0RnVuY3Rpb24uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzXyk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGNvbnN0IHNob3VsZENhbGxOb3cgPSBiZWZvcmUgJiYgIXRpbWVvdXQ7XG5cdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHRcdHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcblxuXHRcdGlmIChzaG91bGRDYWxsTm93KSB7XG5cdFx0XHRyZXN1bHQgPSBpbnB1dEZ1bmN0aW9uLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50c18pO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0bWltaWNGbihkZWJvdW5jZWRGdW5jdGlvbiwgaW5wdXRGdW5jdGlvbik7XG5cblx0ZGVib3VuY2VkRnVuY3Rpb24uY2FuY2VsID0gKCkgPT4ge1xuXHRcdGlmICh0aW1lb3V0KSB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdFx0XHR0aW1lb3V0ID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gZGVib3VuY2VkRnVuY3Rpb247XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBtaW1pY0ZuID0gKHRvLCBmcm9tKSA9PiB7XG5cdGZvciAoY29uc3QgcHJvcCBvZiBSZWZsZWN0Lm93bktleXMoZnJvbSkpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodG8sIHByb3AsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZnJvbSwgcHJvcCkpO1xuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBtaW1pY0ZuO1xuLy8gVE9ETzogUmVtb3ZlIHRoaXMgZm9yIHRoZSBuZXh0IG1ham9yIHJlbGVhc2Vcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBtaW1pY0ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgbWltaWNGbiA9IHJlcXVpcmUoJ21pbWljLWZuJyk7XG5cbmNvbnN0IGNhbGxlZEZ1bmN0aW9ucyA9IG5ldyBXZWFrTWFwKCk7XG5cbmNvbnN0IG9uZXRpbWUgPSAoZnVuY3Rpb25fLCBvcHRpb25zID0ge30pID0+IHtcblx0aWYgKHR5cGVvZiBmdW5jdGlvbl8gIT09ICdmdW5jdGlvbicpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIGZ1bmN0aW9uJyk7XG5cdH1cblxuXHRsZXQgcmV0dXJuVmFsdWU7XG5cdGxldCBjYWxsQ291bnQgPSAwO1xuXHRjb25zdCBmdW5jdGlvbk5hbWUgPSBmdW5jdGlvbl8uZGlzcGxheU5hbWUgfHwgZnVuY3Rpb25fLm5hbWUgfHwgJzxhbm9ueW1vdXM+JztcblxuXHRjb25zdCBvbmV0aW1lID0gZnVuY3Rpb24gKC4uLmFyZ3VtZW50c18pIHtcblx0XHRjYWxsZWRGdW5jdGlvbnMuc2V0KG9uZXRpbWUsICsrY2FsbENvdW50KTtcblxuXHRcdGlmIChjYWxsQ291bnQgPT09IDEpIHtcblx0XHRcdHJldHVyblZhbHVlID0gZnVuY3Rpb25fLmFwcGx5KHRoaXMsIGFyZ3VtZW50c18pO1xuXHRcdFx0ZnVuY3Rpb25fID0gbnVsbDtcblx0XHR9IGVsc2UgaWYgKG9wdGlvbnMudGhyb3cgPT09IHRydWUpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgRnVuY3Rpb24gXFxgJHtmdW5jdGlvbk5hbWV9XFxgIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlYCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldHVyblZhbHVlO1xuXHR9O1xuXG5cdG1pbWljRm4ob25ldGltZSwgZnVuY3Rpb25fKTtcblx0Y2FsbGVkRnVuY3Rpb25zLnNldChvbmV0aW1lLCBjYWxsQ291bnQpO1xuXG5cdHJldHVybiBvbmV0aW1lO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBvbmV0aW1lO1xuLy8gVE9ETzogUmVtb3ZlIHRoaXMgZm9yIHRoZSBuZXh0IG1ham9yIHJlbGVhc2Vcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBvbmV0aW1lO1xuXG5tb2R1bGUuZXhwb3J0cy5jYWxsQ291bnQgPSBmdW5jdGlvbl8gPT4ge1xuXHRpZiAoIWNhbGxlZEZ1bmN0aW9ucy5oYXMoZnVuY3Rpb25fKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihgVGhlIGdpdmVuIGZ1bmN0aW9uIFxcYCR7ZnVuY3Rpb25fLm5hbWV9XFxgIGlzIG5vdCB3cmFwcGVkIGJ5IHRoZSBcXGBvbmV0aW1lXFxgIHBhY2thZ2VgKTtcblx0fVxuXG5cdHJldHVybiBjYWxsZWRGdW5jdGlvbnMuZ2V0KGZ1bmN0aW9uXyk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX2EsIF9iO1xudmFyIF9Db25mX3ZhbGlkYXRvciwgX0NvbmZfZW5jcnlwdGlvbktleSwgX0NvbmZfb3B0aW9ucywgX0NvbmZfZGVmYXVsdFZhbHVlcztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKFwiY3J5cHRvXCIpO1xuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IGRvdFByb3AgPSByZXF1aXJlKFwiZG90LXByb3BcIik7XG5jb25zdCBwa2dVcCA9IHJlcXVpcmUoXCJwa2ctdXBcIik7XG5jb25zdCBlbnZQYXRocyA9IHJlcXVpcmUoXCJlbnYtcGF0aHNcIik7XG5jb25zdCBhdG9taWNhbGx5ID0gcmVxdWlyZShcImF0b21pY2FsbHlcIik7XG5jb25zdCBhanZfMSA9IHJlcXVpcmUoXCJhanZcIik7XG5jb25zdCBhanZfZm9ybWF0c18xID0gcmVxdWlyZShcImFqdi1mb3JtYXRzXCIpO1xuY29uc3QgZGVib3VuY2VGbiA9IHJlcXVpcmUoXCJkZWJvdW5jZS1mblwiKTtcbmNvbnN0IHNlbXZlciA9IHJlcXVpcmUoXCJzZW12ZXJcIik7XG5jb25zdCBvbmV0aW1lID0gcmVxdWlyZShcIm9uZXRpbWVcIik7XG5jb25zdCBlbmNyeXB0aW9uQWxnb3JpdGhtID0gJ2Flcy0yNTYtY2JjJztcbmNvbnN0IGNyZWF0ZVBsYWluT2JqZWN0ID0gKCkgPT4ge1xuICAgIHJldHVybiBPYmplY3QuY3JlYXRlKG51bGwpO1xufTtcbmNvbnN0IGlzRXhpc3QgPSAoZGF0YSkgPT4ge1xuICAgIHJldHVybiBkYXRhICE9PSB1bmRlZmluZWQgJiYgZGF0YSAhPT0gbnVsbDtcbn07XG5sZXQgcGFyZW50RGlyID0gJyc7XG50cnkge1xuICAgIC8vIFByZXZlbnQgY2FjaGluZyBvZiB0aGlzIG1vZHVsZSBzbyBtb2R1bGUucGFyZW50IGlzIGFsd2F5cyBhY2N1cmF0ZS5cbiAgICAvLyBOb3RlOiBUaGlzIHRyaWNrIHdvbid0IHdvcmsgd2l0aCBFU00gb3IgaW5zaWRlIGEgd2Vid29ya2VyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1keW5hbWljLWRlbGV0ZVxuICAgIGRlbGV0ZSByZXF1aXJlLmNhY2hlW19fZmlsZW5hbWVdO1xuICAgIHBhcmVudERpciA9IHBhdGguZGlybmFtZSgoX2IgPSAoX2EgPSBtb2R1bGUucGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmlsZW5hbWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcuJyk7XG59XG5jYXRjaCAoX2MpIHsgfVxuY29uc3QgY2hlY2tWYWx1ZVR5cGUgPSAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IG5vbkpzb25UeXBlcyA9IG5ldyBTZXQoW1xuICAgICAgICAndW5kZWZpbmVkJyxcbiAgICAgICAgJ3N5bWJvbCcsXG4gICAgICAgICdmdW5jdGlvbidcbiAgICBdKTtcbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIGlmIChub25Kc29uVHlwZXMuaGFzKHR5cGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFNldHRpbmcgYSB2YWx1ZSBvZiB0eXBlIFxcYCR7dHlwZX1cXGAgZm9yIGtleSBcXGAke2tleX1cXGAgaXMgbm90IGFsbG93ZWQgYXMgaXQncyBub3Qgc3VwcG9ydGVkIGJ5IEpTT05gKTtcbiAgICB9XG59O1xuY29uc3QgSU5URVJOQUxfS0VZID0gJ19faW50ZXJuYWxfXyc7XG5jb25zdCBNSUdSQVRJT05fS0VZID0gYCR7SU5URVJOQUxfS0VZfS5taWdyYXRpb25zLnZlcnNpb25gO1xuY2xhc3MgQ29uZiB7XG4gICAgY29uc3RydWN0b3IocGFydGlhbE9wdGlvbnMgPSB7fSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIF9Db25mX3ZhbGlkYXRvci5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0NvbmZfZW5jcnlwdGlvbktleS5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0NvbmZfb3B0aW9ucy5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0NvbmZfZGVmYXVsdFZhbHVlcy5zZXQodGhpcywge30pO1xuICAgICAgICB0aGlzLl9kZXNlcmlhbGl6ZSA9IHZhbHVlID0+IEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICB0aGlzLl9zZXJpYWxpemUgPSB2YWx1ZSA9PiBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgdW5kZWZpbmVkLCAnXFx0Jyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBjb25maWdOYW1lOiAnY29uZmlnJyxcbiAgICAgICAgICAgIGZpbGVFeHRlbnNpb246ICdqc29uJyxcbiAgICAgICAgICAgIHByb2plY3RTdWZmaXg6ICdub2RlanMnLFxuICAgICAgICAgICAgY2xlYXJJbnZhbGlkQ29uZmlnOiBmYWxzZSxcbiAgICAgICAgICAgIGFjY2Vzc1Byb3BlcnRpZXNCeURvdE5vdGF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgLi4ucGFydGlhbE9wdGlvbnNcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZ2V0UGFja2FnZURhdGEgPSBvbmV0aW1lKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhY2thZ2VQYXRoID0gcGtnVXAuc3luYyh7IGN3ZDogcGFyZW50RGlyIH0pO1xuICAgICAgICAgICAgLy8gQ2FuJ3QgdXNlIGByZXF1aXJlYCBiZWNhdXNlIG9mIFdlYnBhY2sgYmVpbmcgYW5ub3lpbmc6XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrL2lzc3Vlcy8xOTZcbiAgICAgICAgICAgIGNvbnN0IHBhY2thZ2VEYXRhID0gcGFja2FnZVBhdGggJiYgSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMocGFja2FnZVBhdGgsICd1dGY4JykpO1xuICAgICAgICAgICAgcmV0dXJuIHBhY2thZ2VEYXRhICE9PSBudWxsICYmIHBhY2thZ2VEYXRhICE9PSB2b2lkIDAgPyBwYWNrYWdlRGF0YSA6IHt9O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFvcHRpb25zLmN3ZCkge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnByb2plY3ROYW1lKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wcm9qZWN0TmFtZSA9IGdldFBhY2thZ2VEYXRhKCkubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5wcm9qZWN0TmFtZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvamVjdCBuYW1lIGNvdWxkIG5vdCBiZSBpbmZlcnJlZC4gUGxlYXNlIHNwZWNpZnkgdGhlIGBwcm9qZWN0TmFtZWAgb3B0aW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucy5jd2QgPSBlbnZQYXRocyhvcHRpb25zLnByb2plY3ROYW1lLCB7IHN1ZmZpeDogb3B0aW9ucy5wcm9qZWN0U3VmZml4IH0pLmNvbmZpZztcbiAgICAgICAgfVxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Db25mX29wdGlvbnMsIG9wdGlvbnMsIFwiZlwiKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2NoZW1hKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuc2NoZW1hICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBgc2NoZW1hYCBvcHRpb24gbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhanYgPSBuZXcgYWp2XzEuZGVmYXVsdCh7XG4gICAgICAgICAgICAgICAgYWxsRXJyb3JzOiB0cnVlLFxuICAgICAgICAgICAgICAgIHVzZURlZmF1bHRzOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFqdl9mb3JtYXRzXzEuZGVmYXVsdChhanYpO1xuICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IG9wdGlvbnMuc2NoZW1hXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ29uZl92YWxpZGF0b3IsIGFqdi5jb21waWxlKHNjaGVtYSksIFwiZlwiKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMuc2NoZW1hKSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUuZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX2RlZmF1bHRWYWx1ZXMsIFwiZlwiKVtrZXldID0gdmFsdWUuZGVmYXVsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NvbmZfZGVmYXVsdFZhbHVlcywge1xuICAgICAgICAgICAgICAgIC4uLl9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfZGVmYXVsdFZhbHVlcywgXCJmXCIpLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMuZGVmYXVsdHNcbiAgICAgICAgICAgIH0sIFwiZlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5zZXJpYWxpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlcmlhbGl6ZSA9IG9wdGlvbnMuc2VyaWFsaXplO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmRlc2VyaWFsaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9kZXNlcmlhbGl6ZSA9IG9wdGlvbnMuZGVzZXJpYWxpemU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudHMgPSBuZXcgZXZlbnRzXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NvbmZfZW5jcnlwdGlvbktleSwgb3B0aW9ucy5lbmNyeXB0aW9uS2V5LCBcImZcIik7XG4gICAgICAgIGNvbnN0IGZpbGVFeHRlbnNpb24gPSBvcHRpb25zLmZpbGVFeHRlbnNpb24gPyBgLiR7b3B0aW9ucy5maWxlRXh0ZW5zaW9ufWAgOiAnJztcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aC5yZXNvbHZlKG9wdGlvbnMuY3dkLCBgJHsoX2EgPSBvcHRpb25zLmNvbmZpZ05hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICdjb25maWcnfSR7ZmlsZUV4dGVuc2lvbn1gKTtcbiAgICAgICAgY29uc3QgZmlsZVN0b3JlID0gdGhpcy5zdG9yZTtcbiAgICAgICAgY29uc3Qgc3RvcmUgPSBPYmplY3QuYXNzaWduKGNyZWF0ZVBsYWluT2JqZWN0KCksIG9wdGlvbnMuZGVmYXVsdHMsIGZpbGVTdG9yZSk7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlKHN0b3JlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGFzc2VydC5kZWVwRXF1YWwoZmlsZVN0b3JlLCBzdG9yZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9iKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMud2F0Y2gpIHtcbiAgICAgICAgICAgIHRoaXMuX3dhdGNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMubWlncmF0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnByb2plY3RWZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wcm9qZWN0VmVyc2lvbiA9IGdldFBhY2thZ2VEYXRhKCkudmVyc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5wcm9qZWN0VmVyc2lvbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvamVjdCB2ZXJzaW9uIGNvdWxkIG5vdCBiZSBpbmZlcnJlZC4gUGxlYXNlIHNwZWNpZnkgdGhlIGBwcm9qZWN0VmVyc2lvbmAgb3B0aW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWlncmF0ZShvcHRpb25zLm1pZ3JhdGlvbnMsIG9wdGlvbnMucHJvamVjdFZlcnNpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldChrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9vcHRpb25zLCBcImZcIikuYWNjZXNzUHJvcGVydGllc0J5RG90Tm90YXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXQoa2V5LCBkZWZhdWx0VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc3RvcmUgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBrZXkgaW4gc3RvcmUgPyBzdG9yZVtrZXldIDogZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGtleSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIFxcYGtleVxcYCB0byBiZSBvZiB0eXBlIFxcYHN0cmluZ1xcYCBvciBcXGBvYmplY3RcXGAsIGdvdCAke3R5cGVvZiBrZXl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdvYmplY3QnICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VzZSBgZGVsZXRlKClgIHRvIGNsZWFyIHZhbHVlcycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jb250YWluc1Jlc2VydmVkS2V5KGtleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBsZWFzZSBkb24ndCB1c2UgdGhlICR7SU5URVJOQUxfS0VZfSBrZXksIGFzIGl0J3MgdXNlZCB0byBtYW5hZ2UgdGhpcyBtb2R1bGUgaW50ZXJuYWwgb3BlcmF0aW9ucy5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN0b3JlIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBzZXQgPSAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgY2hlY2tWYWx1ZVR5cGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9vcHRpb25zLCBcImZcIikuYWNjZXNzUHJvcGVydGllc0J5RG90Tm90YXRpb24pIHtcbiAgICAgICAgICAgICAgICBkb3RQcm9wLnNldChzdG9yZSwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdG9yZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc3Qgb2JqZWN0ID0ga2V5O1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob2JqZWN0KSkge1xuICAgICAgICAgICAgICAgIHNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgfVxuICAgIC8qKlxuICAgIENoZWNrIGlmIGFuIGl0ZW0gZXhpc3RzLlxuXG4gICAgQHBhcmFtIGtleSAtIFRoZSBrZXkgb2YgdGhlIGl0ZW0gdG8gY2hlY2suXG4gICAgKi9cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX29wdGlvbnMsIFwiZlwiKS5hY2Nlc3NQcm9wZXJ0aWVzQnlEb3ROb3RhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGRvdFByb3AuaGFzKHRoaXMuc3RvcmUsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleSBpbiB0aGlzLnN0b3JlO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXNldCBpdGVtcyB0byB0aGVpciBkZWZhdWx0IHZhbHVlcywgYXMgZGVmaW5lZCBieSB0aGUgYGRlZmF1bHRzYCBvciBgc2NoZW1hYCBvcHRpb24uXG5cbiAgICBAc2VlIGBjbGVhcigpYCB0byByZXNldCBhbGwgaXRlbXMuXG5cbiAgICBAcGFyYW0ga2V5cyAtIFRoZSBrZXlzIG9mIHRoZSBpdGVtcyB0byByZXNldC5cbiAgICAqL1xuICAgIHJlc2V0KC4uLmtleXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICAgICAgaWYgKGlzRXhpc3QoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9kZWZhdWx0VmFsdWVzLCBcImZcIilba2V5XSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldChrZXksIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfZGVmYXVsdFZhbHVlcywgXCJmXCIpW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIERlbGV0ZSBhbiBpdGVtLlxuXG4gICAgQHBhcmFtIGtleSAtIFRoZSBrZXkgb2YgdGhlIGl0ZW0gdG8gZGVsZXRlLlxuICAgICovXG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICBjb25zdCB7IHN0b3JlIH0gPSB0aGlzO1xuICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9vcHRpb25zLCBcImZcIikuYWNjZXNzUHJvcGVydGllc0J5RG90Tm90YXRpb24pIHtcbiAgICAgICAgICAgIGRvdFByb3AuZGVsZXRlKHN0b3JlLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1keW5hbWljLWRlbGV0ZVxuICAgICAgICAgICAgZGVsZXRlIHN0b3JlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdG9yZSA9IHN0b3JlO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWxldGUgYWxsIGl0ZW1zLlxuXG4gICAgVGhpcyByZXNldHMga25vd24gaXRlbXMgdG8gdGhlaXIgZGVmYXVsdCB2YWx1ZXMsIGlmIGRlZmluZWQgYnkgdGhlIGBkZWZhdWx0c2Agb3IgYHNjaGVtYWAgb3B0aW9uLlxuICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuc3RvcmUgPSBjcmVhdGVQbGFpbk9iamVjdCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX2RlZmF1bHRWYWx1ZXMsIFwiZlwiKSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBXYXRjaGVzIHRoZSBnaXZlbiBga2V5YCwgY2FsbGluZyBgY2FsbGJhY2tgIG9uIGFueSBjaGFuZ2VzLlxuXG4gICAgQHBhcmFtIGtleSAtIFRoZSBrZXkgd28gd2F0Y2guXG4gICAgQHBhcmFtIGNhbGxiYWNrIC0gQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBvbiBhbnkgY2hhbmdlcy4gV2hlbiBhIGBrZXlgIGlzIGZpcnN0IHNldCBgb2xkVmFsdWVgIHdpbGwgYmUgYHVuZGVmaW5lZGAsIGFuZCB3aGVuIGEga2V5IGlzIGRlbGV0ZWQgYG5ld1ZhbHVlYCB3aWxsIGJlIGB1bmRlZmluZWRgLlxuICAgIEByZXR1cm5zIEEgZnVuY3Rpb24sIHRoYXQgd2hlbiBjYWxsZWQsIHdpbGwgdW5zdWJzY3JpYmUuXG4gICAgKi9cbiAgICBvbkRpZENoYW5nZShrZXksIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgXFxga2V5XFxgIHRvIGJlIG9mIHR5cGUgXFxgc3RyaW5nXFxgLCBnb3QgJHt0eXBlb2Yga2V5fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIFxcYGNhbGxiYWNrXFxgIHRvIGJlIG9mIHR5cGUgXFxgZnVuY3Rpb25cXGAsIGdvdCAke3R5cGVvZiBjYWxsYmFja31gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlQ2hhbmdlKCgpID0+IHRoaXMuZ2V0KGtleSksIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgV2F0Y2hlcyB0aGUgd2hvbGUgY29uZmlnIG9iamVjdCwgY2FsbGluZyBgY2FsbGJhY2tgIG9uIGFueSBjaGFuZ2VzLlxuXG4gICAgQHBhcmFtIGNhbGxiYWNrIC0gQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBvbiBhbnkgY2hhbmdlcy4gV2hlbiBhIGBrZXlgIGlzIGZpcnN0IHNldCBgb2xkVmFsdWVgIHdpbGwgYmUgYHVuZGVmaW5lZGAsIGFuZCB3aGVuIGEga2V5IGlzIGRlbGV0ZWQgYG5ld1ZhbHVlYCB3aWxsIGJlIGB1bmRlZmluZWRgLlxuICAgIEByZXR1cm5zIEEgZnVuY3Rpb24sIHRoYXQgd2hlbiBjYWxsZWQsIHdpbGwgdW5zdWJzY3JpYmUuXG4gICAgKi9cbiAgICBvbkRpZEFueUNoYW5nZShjYWxsYmFjaykge1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBcXGBjYWxsYmFja1xcYCB0byBiZSBvZiB0eXBlIFxcYGZ1bmN0aW9uXFxgLCBnb3QgJHt0eXBlb2YgY2FsbGJhY2t9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUNoYW5nZSgoKSA9PiB0aGlzLnN0b3JlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5zdG9yZSkubGVuZ3RoO1xuICAgIH1cbiAgICBnZXQgc3RvcmUoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gZnMucmVhZEZpbGVTeW5jKHRoaXMucGF0aCwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9lbmNyeXB0aW9uS2V5LCBcImZcIikgPyBudWxsIDogJ3V0ZjgnKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFTdHJpbmcgPSB0aGlzLl9lbmNyeXB0RGF0YShkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IGRlc2VyaWFsaXplZERhdGEgPSB0aGlzLl9kZXNlcmlhbGl6ZShkYXRhU3RyaW5nKTtcbiAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlKGRlc2VyaWFsaXplZERhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oY3JlYXRlUGxhaW5PYmplY3QoKSwgZGVzZXJpYWxpemVkRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbnN1cmVEaXJlY3RvcnkoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlUGxhaW5PYmplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX29wdGlvbnMsIFwiZlwiKS5jbGVhckludmFsaWRDb25maWcgJiYgZXJyb3IubmFtZSA9PT0gJ1N5bnRheEVycm9yJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVQbGFpbk9iamVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0IHN0b3JlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2Vuc3VyZURpcmVjdG9yeSgpO1xuICAgICAgICB0aGlzLl92YWxpZGF0ZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMuX3dyaXRlKHZhbHVlKTtcbiAgICAgICAgdGhpcy5ldmVudHMuZW1pdCgnY2hhbmdlJyk7XG4gICAgfVxuICAgICpbKF9Db25mX3ZhbGlkYXRvciA9IG5ldyBXZWFrTWFwKCksIF9Db25mX2VuY3J5cHRpb25LZXkgPSBuZXcgV2Vha01hcCgpLCBfQ29uZl9vcHRpb25zID0gbmV3IFdlYWtNYXAoKSwgX0NvbmZfZGVmYXVsdFZhbHVlcyA9IG5ldyBXZWFrTWFwKCksIFN5bWJvbC5pdGVyYXRvcildKCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLnN0b3JlKSkge1xuICAgICAgICAgICAgeWllbGQgW2tleSwgdmFsdWVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9lbmNyeXB0RGF0YShkYXRhKSB7XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9lbmNyeXB0aW9uS2V5LCBcImZcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGFuIGluaXRpYWxpemF0aW9uIHZlY3RvciBoYXMgYmVlbiB1c2VkIHRvIGVuY3J5cHQgdGhlIGRhdGFcbiAgICAgICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX2VuY3J5cHRpb25LZXksIFwiZlwiKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnNsaWNlKDE2LCAxNykudG9TdHJpbmcoKSA9PT0gJzonKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbml0aWFsaXphdGlvblZlY3RvciA9IGRhdGEuc2xpY2UoMCwgMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFzc3dvcmQgPSBjcnlwdG8ucGJrZGYyU3luYyhfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX2VuY3J5cHRpb25LZXksIFwiZlwiKSwgaW5pdGlhbGl6YXRpb25WZWN0b3IudG9TdHJpbmcoKSwgMTAwMDAsIDMyLCAnc2hhNTEyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KGVuY3J5cHRpb25BbGdvcml0aG0sIHBhc3N3b3JkLCBpbml0aWFsaXphdGlvblZlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gQnVmZmVyLmNvbmNhdChbZGVjaXBoZXIudXBkYXRlKEJ1ZmZlci5mcm9tKGRhdGEuc2xpY2UoMTcpKSksIGRlY2lwaGVyLmZpbmFsKCldKS50b1N0cmluZygndXRmOCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXIoZW5jcnlwdGlvbkFsZ29yaXRobSwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9lbmNyeXB0aW9uS2V5LCBcImZcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IEJ1ZmZlci5jb25jYXQoW2RlY2lwaGVyLnVwZGF0ZShCdWZmZXIuZnJvbShkYXRhKSksIGRlY2lwaGVyLmZpbmFsKCldKS50b1N0cmluZygndXRmOCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9iKSB7IH1cbiAgICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgX2hhbmRsZUNoYW5nZShnZXR0ZXIsIGNhbGxiYWNrKSB7XG4gICAgICAgIGxldCBjdXJyZW50VmFsdWUgPSBnZXR0ZXIoKTtcbiAgICAgICAgY29uc3Qgb25DaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gZ2V0dGVyKCk7XG4gICAgICAgICAgICBpZiAodXRpbF8xLmlzRGVlcFN0cmljdEVxdWFsKG5ld1ZhbHVlLCBvbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgbmV3VmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ldmVudHMub24oJ2NoYW5nZScsIG9uQ2hhbmdlKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHRoaXMuZXZlbnRzLnJlbW92ZUxpc3RlbmVyKCdjaGFuZ2UnLCBvbkNoYW5nZSk7XG4gICAgfVxuICAgIF92YWxpZGF0ZShkYXRhKSB7XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl92YWxpZGF0b3IsIFwiZlwiKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbGlkID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl92YWxpZGF0b3IsIFwiZlwiKS5jYWxsKHRoaXMsIGRhdGEpO1xuICAgICAgICBpZiAodmFsaWQgfHwgIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfdmFsaWRhdG9yLCBcImZcIikuZXJyb3JzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3JzID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl92YWxpZGF0b3IsIFwiZlwiKS5lcnJvcnNcbiAgICAgICAgICAgIC5tYXAoKHsgaW5zdGFuY2VQYXRoLCBtZXNzYWdlID0gJycgfSkgPT4gYFxcYCR7aW5zdGFuY2VQYXRoLnNsaWNlKDEpfVxcYCAke21lc3NhZ2V9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ29uZmlnIHNjaGVtYSB2aW9sYXRpb246ICcgKyBlcnJvcnMuam9pbignOyAnKSk7XG4gICAgfVxuICAgIF9lbnN1cmVEaXJlY3RvcnkoKSB7XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgZGlyZWN0b3J5IGV4aXN0cyBhcyBpdCBjb3VsZCBoYXZlIGJlZW4gZGVsZXRlZCBpbiB0aGUgbWVhbnRpbWUuXG4gICAgICAgIGZzLm1rZGlyU3luYyhwYXRoLmRpcm5hbWUodGhpcy5wYXRoKSwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgfVxuICAgIF93cml0ZSh2YWx1ZSkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuX3NlcmlhbGl6ZSh2YWx1ZSk7XG4gICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX2VuY3J5cHRpb25LZXksIFwiZlwiKSkge1xuICAgICAgICAgICAgY29uc3QgaW5pdGlhbGl6YXRpb25WZWN0b3IgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoMTYpO1xuICAgICAgICAgICAgY29uc3QgcGFzc3dvcmQgPSBjcnlwdG8ucGJrZGYyU3luYyhfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX2VuY3J5cHRpb25LZXksIFwiZlwiKSwgaW5pdGlhbGl6YXRpb25WZWN0b3IudG9TdHJpbmcoKSwgMTAwMDAsIDMyLCAnc2hhNTEyJyk7XG4gICAgICAgICAgICBjb25zdCBjaXBoZXIgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYoZW5jcnlwdGlvbkFsZ29yaXRobSwgcGFzc3dvcmQsIGluaXRpYWxpemF0aW9uVmVjdG9yKTtcbiAgICAgICAgICAgIGRhdGEgPSBCdWZmZXIuY29uY2F0KFtpbml0aWFsaXphdGlvblZlY3RvciwgQnVmZmVyLmZyb20oJzonKSwgY2lwaGVyLnVwZGF0ZShCdWZmZXIuZnJvbShkYXRhKSksIGNpcGhlci5maW5hbCgpXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGVtcG9yYXJ5IHdvcmthcm91bmQgZm9yIENvbmYgYmVpbmcgcGFja2FnZWQgaW4gYSBVYnVudHUgU25hcCBhcHAuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL2NvbmYvcHVsbC84MlxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuU05BUCkge1xuICAgICAgICAgICAgZnMud3JpdGVGaWxlU3luYyh0aGlzLnBhdGgsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhdG9taWNhbGx5LndyaXRlRmlsZVN5bmModGhpcy5wYXRoLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIEZpeCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9lbGVjdHJvbi1zdG9yZS9pc3N1ZXMvMTA2XG4gICAgICAgICAgICAgICAgLy8gU29tZXRpbWVzIG9uIFdpbmRvd3MsIHdlIHdpbGwgZ2V0IGFuIEVYREVWIGVycm9yIHdoZW4gYXRvbWljIHdyaXRpbmdcbiAgICAgICAgICAgICAgICAvLyAoZXZlbiB0aG91Z2ggdG8gdGhlIHNhbWUgZGlyZWN0b3J5KSwgc28gd2UgZmFsbCBiYWNrIHRvIG5vbiBhdG9taWMgd3JpdGVcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gJ0VYREVWJykge1xuICAgICAgICAgICAgICAgICAgICBmcy53cml0ZUZpbGVTeW5jKHRoaXMucGF0aCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3dhdGNoKCkge1xuICAgICAgICB0aGlzLl9lbnN1cmVEaXJlY3RvcnkoKTtcbiAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKHRoaXMucGF0aCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3dyaXRlKGNyZWF0ZVBsYWluT2JqZWN0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgICAgICAgICBmcy53YXRjaCh0aGlzLnBhdGgsIHsgcGVyc2lzdGVudDogZmFsc2UgfSwgZGVib3VuY2VGbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gT24gTGludXggYW5kIFdpbmRvd3MsIHdyaXRpbmcgdG8gdGhlIGNvbmZpZyBmaWxlIGVtaXRzIGEgYHJlbmFtZWAgZXZlbnQsIHNvIHdlIHNraXAgY2hlY2tpbmcgdGhlIGV2ZW50IHR5cGUuXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuZW1pdCgnY2hhbmdlJyk7XG4gICAgICAgICAgICB9LCB7IHdhaXQ6IDEwMCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmcy53YXRjaEZpbGUodGhpcy5wYXRoLCB7IHBlcnNpc3RlbnQ6IGZhbHNlIH0sIGRlYm91bmNlRm4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmVtaXQoJ2NoYW5nZScpO1xuICAgICAgICAgICAgfSwgeyB3YWl0OiA1MDAwIH0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfbWlncmF0ZShtaWdyYXRpb25zLCB2ZXJzaW9uVG9NaWdyYXRlKSB7XG4gICAgICAgIGxldCBwcmV2aW91c01pZ3JhdGVkVmVyc2lvbiA9IHRoaXMuX2dldChNSUdSQVRJT05fS0VZLCAnMC4wLjAnKTtcbiAgICAgICAgY29uc3QgbmV3ZXJWZXJzaW9ucyA9IE9iamVjdC5rZXlzKG1pZ3JhdGlvbnMpXG4gICAgICAgICAgICAuZmlsdGVyKGNhbmRpZGF0ZVZlcnNpb24gPT4gdGhpcy5fc2hvdWxkUGVyZm9ybU1pZ3JhdGlvbihjYW5kaWRhdGVWZXJzaW9uLCBwcmV2aW91c01pZ3JhdGVkVmVyc2lvbiwgdmVyc2lvblRvTWlncmF0ZSkpO1xuICAgICAgICBsZXQgc3RvcmVCYWNrdXAgPSB7IC4uLnRoaXMuc3RvcmUgfTtcbiAgICAgICAgZm9yIChjb25zdCB2ZXJzaW9uIG9mIG5ld2VyVmVyc2lvbnMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWlncmF0aW9uID0gbWlncmF0aW9uc1t2ZXJzaW9uXTtcbiAgICAgICAgICAgICAgICBtaWdyYXRpb24odGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0KE1JR1JBVElPTl9LRVksIHZlcnNpb24pO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzTWlncmF0ZWRWZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgICAgICAgICBzdG9yZUJhY2t1cCA9IHsgLi4udGhpcy5zdG9yZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yZSA9IHN0b3JlQmFja3VwO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU29tZXRoaW5nIHdlbnQgd3JvbmcgZHVyaW5nIHRoZSBtaWdyYXRpb24hIENoYW5nZXMgYXBwbGllZCB0byB0aGUgc3RvcmUgdW50aWwgdGhpcyBmYWlsZWQgbWlncmF0aW9uIHdpbGwgYmUgcmVzdG9yZWQuICR7ZXJyb3J9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2lzVmVyc2lvbkluUmFuZ2VGb3JtYXQocHJldmlvdXNNaWdyYXRlZFZlcnNpb24pIHx8ICFzZW12ZXIuZXEocHJldmlvdXNNaWdyYXRlZFZlcnNpb24sIHZlcnNpb25Ub01pZ3JhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXQoTUlHUkFUSU9OX0tFWSwgdmVyc2lvblRvTWlncmF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2NvbnRhaW5zUmVzZXJ2ZWRLZXkoa2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc3QgZmlyc0tleSA9IE9iamVjdC5rZXlzKGtleSlbMF07XG4gICAgICAgICAgICBpZiAoZmlyc0tleSA9PT0gSU5URVJOQUxfS0VZKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfb3B0aW9ucywgXCJmXCIpLmFjY2Vzc1Byb3BlcnRpZXNCeURvdE5vdGF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoYCR7SU5URVJOQUxfS0VZfS5gKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgX2lzVmVyc2lvbkluUmFuZ2VGb3JtYXQodmVyc2lvbikge1xuICAgICAgICByZXR1cm4gc2VtdmVyLmNsZWFuKHZlcnNpb24pID09PSBudWxsO1xuICAgIH1cbiAgICBfc2hvdWxkUGVyZm9ybU1pZ3JhdGlvbihjYW5kaWRhdGVWZXJzaW9uLCBwcmV2aW91c01pZ3JhdGVkVmVyc2lvbiwgdmVyc2lvblRvTWlncmF0ZSkge1xuICAgICAgICBpZiAodGhpcy5faXNWZXJzaW9uSW5SYW5nZUZvcm1hdChjYW5kaWRhdGVWZXJzaW9uKSkge1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzTWlncmF0ZWRWZXJzaW9uICE9PSAnMC4wLjAnICYmIHNlbXZlci5zYXRpc2ZpZXMocHJldmlvdXNNaWdyYXRlZFZlcnNpb24sIGNhbmRpZGF0ZVZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNlbXZlci5zYXRpc2ZpZXModmVyc2lvblRvTWlncmF0ZSwgY2FuZGlkYXRlVmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbXZlci5sdGUoY2FuZGlkYXRlVmVyc2lvbiwgcHJldmlvdXNNaWdyYXRlZFZlcnNpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbXZlci5ndChjYW5kaWRhdGVWZXJzaW9uLCB2ZXJzaW9uVG9NaWdyYXRlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBfZ2V0KGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHJldHVybiBkb3RQcm9wLmdldCh0aGlzLnN0b3JlLCBrZXksIGRlZmF1bHRWYWx1ZSk7XG4gICAgfVxuICAgIF9zZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCB7IHN0b3JlIH0gPSB0aGlzO1xuICAgICAgICBkb3RQcm9wLnNldChzdG9yZSwga2V5LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBDb25mO1xuLy8gRm9yIENvbW1vbkpTIGRlZmF1bHQgZXhwb3J0IHN1cHBvcnRcbm1vZHVsZS5leHBvcnRzID0gQ29uZjtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBDb25mO1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IHthcHAsIGlwY01haW4sIGlwY1JlbmRlcmVyLCBzaGVsbH0gPSByZXF1aXJlKCdlbGVjdHJvbicpO1xuY29uc3QgQ29uZiA9IHJlcXVpcmUoJ2NvbmYnKTtcblxubGV0IGlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuLy8gU2V0IHVwIHRoZSBgaXBjTWFpbmAgaGFuZGxlciBmb3IgY29tbXVuaWNhdGlvbiBiZXR3ZWVuIHJlbmRlcmVyIGFuZCBtYWluIHByb2Nlc3MuXG5jb25zdCBpbml0RGF0YUxpc3RlbmVyID0gKCkgPT4ge1xuXHRpZiAoIWlwY01haW4gfHwgIWFwcCkge1xuXHRcdHRocm93IG5ldyBFcnJvcignRWxlY3Ryb24gU3RvcmU6IFlvdSBuZWVkIHRvIGNhbGwgYC5pbml0UmVuZGVyZXIoKWAgZnJvbSB0aGUgbWFpbiBwcm9jZXNzLicpO1xuXHR9XG5cblx0Y29uc3QgYXBwRGF0YSA9IHtcblx0XHRkZWZhdWx0Q3dkOiBhcHAuZ2V0UGF0aCgndXNlckRhdGEnKSxcblx0XHRhcHBWZXJzaW9uOiBhcHAuZ2V0VmVyc2lvbigpXG5cdH07XG5cblx0aWYgKGlzSW5pdGlhbGl6ZWQpIHtcblx0XHRyZXR1cm4gYXBwRGF0YTtcblx0fVxuXG5cdGlwY01haW4ub24oJ2VsZWN0cm9uLXN0b3JlLWdldC1kYXRhJywgZXZlbnQgPT4ge1xuXHRcdGV2ZW50LnJldHVyblZhbHVlID0gYXBwRGF0YTtcblx0fSk7XG5cblx0aXNJbml0aWFsaXplZCA9IHRydWU7XG5cblx0cmV0dXJuIGFwcERhdGE7XG59O1xuXG5jbGFzcyBFbGVjdHJvblN0b3JlIGV4dGVuZHMgQ29uZiB7XG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHRsZXQgZGVmYXVsdEN3ZDtcblx0XHRsZXQgYXBwVmVyc2lvbjtcblxuXHRcdC8vIElmIHdlIGFyZSBpbiB0aGUgcmVuZGVyZXIgcHJvY2Vzcywgd2UgY29tbXVuaWNhdGUgd2l0aCB0aGUgbWFpbiBwcm9jZXNzXG5cdFx0Ly8gdG8gZ2V0IHRoZSByZXF1aXJlZCBkYXRhIGZvciB0aGUgbW9kdWxlIG90aGVyd2lzZSwgd2UgcHVsbCBmcm9tIHRoZSBtYWluIHByb2Nlc3MuXG5cdFx0aWYgKGlwY1JlbmRlcmVyKSB7XG5cdFx0XHRjb25zdCBhcHBEYXRhID0gaXBjUmVuZGVyZXIuc2VuZFN5bmMoJ2VsZWN0cm9uLXN0b3JlLWdldC1kYXRhJyk7XG5cblx0XHRcdGlmICghYXBwRGF0YSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0VsZWN0cm9uIFN0b3JlOiBZb3UgbmVlZCB0byBjYWxsIGAuaW5pdFJlbmRlcmVyKClgIGZyb20gdGhlIG1haW4gcHJvY2Vzcy4nKTtcblx0XHRcdH1cblxuXHRcdFx0KHtkZWZhdWx0Q3dkLCBhcHBWZXJzaW9ufSA9IGFwcERhdGEpO1xuXHRcdH0gZWxzZSBpZiAoaXBjTWFpbiAmJiBhcHApIHtcblx0XHRcdCh7ZGVmYXVsdEN3ZCwgYXBwVmVyc2lvbn0gPSBpbml0RGF0YUxpc3RlbmVyKCkpO1xuXHRcdH1cblxuXHRcdG9wdGlvbnMgPSB7XG5cdFx0XHRuYW1lOiAnY29uZmlnJyxcblx0XHRcdC4uLm9wdGlvbnNcblx0XHR9O1xuXG5cdFx0aWYgKCFvcHRpb25zLnByb2plY3RWZXJzaW9uKSB7XG5cdFx0XHRvcHRpb25zLnByb2plY3RWZXJzaW9uID0gYXBwVmVyc2lvbjtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5jd2QpIHtcblx0XHRcdG9wdGlvbnMuY3dkID0gcGF0aC5pc0Fic29sdXRlKG9wdGlvbnMuY3dkKSA/IG9wdGlvbnMuY3dkIDogcGF0aC5qb2luKGRlZmF1bHRDd2QsIG9wdGlvbnMuY3dkKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b3B0aW9ucy5jd2QgPSBkZWZhdWx0Q3dkO1xuXHRcdH1cblxuXHRcdG9wdGlvbnMuY29uZmlnTmFtZSA9IG9wdGlvbnMubmFtZTtcblx0XHRkZWxldGUgb3B0aW9ucy5uYW1lO1xuXG5cdFx0c3VwZXIob3B0aW9ucyk7XG5cdH1cblxuXHRzdGF0aWMgaW5pdFJlbmRlcmVyKCkge1xuXHRcdGluaXREYXRhTGlzdGVuZXIoKTtcblx0fVxuXG5cdG9wZW5JbkVkaXRvcigpIHtcblx0XHRzaGVsbC5vcGVuUGF0aCh0aGlzLnBhdGgpO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRWxlY3Ryb25TdG9yZTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLW1peGVkLXNwYWNlcy1hbmQtdGFicyAqL1xuaW1wb3J0IFN0b3JlIGZyb20gJ2VsZWN0cm9uLXN0b3JlJztcblxuY29uc3Qgc2NoZW1hID0ge1xuXHRub3Rlczoge1xuXHRcdHR5cGU6ICdvYmplY3QnLFxuICAgIHBhdHRlcm5Qcm9wZXJ0aWVzOiB7XG4gICAgICAnW0EtWmEtejAtOV8tXSc6IHtcbiAgICAgIFx0dHlwZTogJ29iamVjdCcsXG4gICAgICBcdHByb3BlcnRpZXM6IHtcbiAgICAgIFx0XHRpZDogeyB0eXBlOiAnc3RyaW5nJywgZGVmYXVsdDogJycgfSxcbiAgICAgIFx0XHR0aXRsZTogeyB0eXBlOiAnc3RyaW5nJywgZGVmYXVsdDogJycgfSxcbiAgICAgIFx0XHRjb250ZW50OiB7IHR5cGU6ICdvYmplY3QnLCBkZWZhdWx0OiB7IHR5cGU6ICdkb2MnLCBjb250ZW50OiBbXSB9IH0sXG4gICAgICBcdFx0bGFiZWxzOiB7IHR5cGU6ICdhcnJheScsIGRlZmF1bHQ6IFtdIH0sXG4gICAgICBcdFx0Y3JlYXRlZEF0OiB7IHR5cGU6ICdudW1iZXInLCBkZWZhdWx0OiBEYXRlLm5vdygpIH0sXG4gICAgICBcdFx0dXBkYXRlZEF0OiB7IHR5cGU6ICdudW1iZXInLCBkZWZhdWx0OiBEYXRlLm5vdygpIH0sXG4gICAgICBcdFx0aXNCb29rbWFya2VkOiB7IHR5cGU6ICdib29sZWFuJywgZGVmYXVsdDogZmFsc2UgfSxcbiAgICAgIFx0XHRpc0FyY2hpdmVkOiB7IHR5cGU6ICdib29sZWFuJywgZGVmYXVsdDogZmFsc2UgfSxcbiAgICAgICAgICBsYXN0Q3Vyc29yUG9zaXRpb246IHsgdHlwZTogJ251bWJlcicsIGRlZmF1bHQ6IDAgfSxcbiAgICAgIFx0fSxcbiAgICAgIH0sXG4gICAgfSxcblx0fSxcbiAgbGFiZWxzOiB7XG4gICAgdHlwZTogJ2FycmF5JyxcbiAgfSxcbn07XG5cbmNvbnN0IHN0b3JlID0gbmV3IFN0b3JlKHtcblx0c2NoZW1hLFxuICBlbmNyeXB0aW9uS2V5OiBpbXBvcnQubWV0YS5lbnYuVklURV9FTkNSWVBUX0tFWSxcbn0pO1xuXG4vLyBzdG9yZS5vbkRpZENoYW5nZSgnbm90ZXMnLCAodmFsdWUpID0+IHtcbi8vICAgY29uc29sZS5sb2codmFsdWUpO1xuLy8gfSk7XG5cbmV4cG9ydCBkZWZhdWx0IHN0b3JlO1xuIiwiaW1wb3J0IFN0b3JlIGZyb20gJ2VsZWN0cm9uLXN0b3JlJztcbmltcG9ydCB7IGFwcCB9IGZyb20gJ2VsZWN0cm9uJztcblxuY29uc3Qgc2NoZW1hID0ge1xuXHRkYXRhRGlyOiB7XG5cdFx0dHlwZTogJ3N0cmluZycsXG5cdFx0ZGVmYXVsdDogYXBwLmdldFBhdGgoJ3VzZXJEYXRhJyksXG5cdH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBuZXcgU3RvcmUoeyBuYW1lOiAnc2V0dGluZ3MnLCBzY2hlbWEsIGVuY3J5cHRpb25LZXk6IHByb2Nlc3MuZW52LlZJVEVfRU5DUllQVF9LRVkgfSk7XG4iLCJpbXBvcnQgZGF0YSBmcm9tICcuL21vZHVsZXMvZGF0YS5zdG9yZSc7XG5pbXBvcnQgc2V0dGluZ3MgZnJvbSAnLi9tb2R1bGVzL3NldHRpbmdzLnN0b3JlJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXHRkYXRhLFxuXHRzZXR0aW5ncyxcbn07XG4iLCJpbXBvcnQgeyBhcHAsIEJyb3dzZXJXaW5kb3csIGRpYWxvZywgcHJvdG9jb2wsIG5hdGl2ZVRoZW1lLCBzaGVsbCB9IGZyb20gJ2VsZWN0cm9uJztcbmltcG9ydCB7IGlwY01haW4gfSBmcm9tICdlbGVjdHJvbi1iZXR0ZXItaXBjJztcbmltcG9ydCB7IGpvaW4sIG5vcm1hbGl6ZSB9IGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgVVJMIH0gZnJvbSAndXJsJztcbmltcG9ydCB7IHJlbW92ZSwgcmVhZEpzb24sIGVuc3VyZURpciwgY29weSwgb3V0cHV0SnNvbiwgcGF0aEV4aXN0c1N5bmMgfSBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgeyBhdXRvVXBkYXRlciB9IGZyb20gJ2VsZWN0cm9uLXVwZGF0ZXInO1xuaW1wb3J0IHN0b3JlIGZyb20gJy4vc3RvcmUnO1xuXG5jb25zdCBpc1NpbmdsZUluc3RhbmNlID0gYXBwLnJlcXVlc3RTaW5nbGVJbnN0YW5jZUxvY2soKTtcblxuaWYgKCFpc1NpbmdsZUluc3RhbmNlKSB7XG4gIGFwcC5xdWl0KCk7XG4gIHByb2Nlc3MuZXhpdCgwKTtcbn1cblxuYXBwLmRpc2FibGVIYXJkd2FyZUFjY2VsZXJhdGlvbigpO1xuXG4vKipcbiAqIFdvcmthcm91bmQgZm9yIFR5cGVTY3JpcHQgYnVnXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvNDE0NjgjaXNzdWVjb21tZW50LTcyNzU0MzQwMFxuICovXG5jb25zdCBlbnYgPSBpbXBvcnQubWV0YS5lbnY7XG5cblxuLy8gSW5zdGFsbCBcIlZ1ZS5qcyBkZXZ0b29sc1wiXG5pZiAoZW52Lk1PREUgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgYXBwLndoZW5SZWFkeSgpXG4gICAgLnRoZW4oKCkgPT4gaW1wb3J0KCdlbGVjdHJvbi1kZXZ0b29scy1pbnN0YWxsZXInKSlcbiAgICAudGhlbigoe2RlZmF1bHQ6IGluc3RhbGxFeHRlbnNpb24sIFZVRUpTM19ERVZUT09MU30pID0+IGluc3RhbGxFeHRlbnNpb24oVlVFSlMzX0RFVlRPT0xTLCB7XG4gICAgICBsb2FkRXh0ZW5zaW9uT3B0aW9uczoge1xuICAgICAgICBhbGxvd0ZpbGVBY2Nlc3M6IHRydWUsXG4gICAgICB9LFxuICAgIH0pKVxuICAgIC5jYXRjaChlID0+IGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCBpbnN0YWxsIGV4dGVuc2lvbjonLCBlKSk7XG59XG5cbmxldCBtYWluV2luZG93ID0gbnVsbDtcblxuY29uc3QgY3JlYXRlV2luZG93ID0gYXN5bmMgKCkgPT4ge1xuICBtYWluV2luZG93ID0gbmV3IEJyb3dzZXJXaW5kb3coe1xuICAgIHNob3c6IGZhbHNlLCAvLyBVc2UgJ3JlYWR5LXRvLXNob3cnIGV2ZW50IHRvIHNob3cgd2luZG93XG4gICAgd2lkdGg6IDk1MCxcbiAgICBoZWlnaHQ6IDYwMCxcbiAgICB3ZWJQcmVmZXJlbmNlczoge1xuICAgICAgcHJlbG9hZDogam9pbihfX2Rpcm5hbWUsICcuLi8uLi9wcmVsb2FkL2Rpc3QvaW5kZXguY2pzJyksXG4gICAgICBjb250ZXh0SXNvbGF0aW9uOiBlbnYuTU9ERSAhPT0gJ3Rlc3QnLCAgIC8vIFNwZWN0cm9uIHRlc3RzIGNhbid0IHdvcmsgd2l0aCBjb250ZXh0SXNvbGF0aW9uOiB0cnVlXG4gICAgICBlbmFibGVSZW1vdGVNb2R1bGU6IGVudi5NT0RFID09PSAndGVzdCcsIC8vIFNwZWN0cm9uIHRlc3RzIGNhbid0IHdvcmsgd2l0aCBlbmFibGVSZW1vdGVNb2R1bGU6IGZhbHNlXG4gICAgfSxcbiAgfSk7XG5cbiAgbWFpbldpbmRvdy5zZXRNZW51QmFyVmlzaWJpbGl0eShmYWxzZSk7XG5cbiAgLyoqXG4gICAqIElmIHlvdSBpbnN0YWxsIGBzaG93OiB0cnVlYCB0aGVuIGl0IGNhbiBjYXVzZSBpc3N1ZXMgd2hlbiB0cnlpbmcgdG8gY2xvc2UgdGhlIHdpbmRvdy5cbiAgICogVXNlIGBzaG93OiBmYWxzZWAgYW5kIGxpc3RlbmVyIGV2ZW50cyBgcmVhZHktdG8tc2hvd2AgdG8gZml4IHRoZXNlIGlzc3Vlcy5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vZWxlY3Ryb24vZWxlY3Ryb24vaXNzdWVzLzI1MDEyXG4gICAqL1xuICBtYWluV2luZG93Lm9uKCdyZWFkeS10by1zaG93JywgKCkgPT4ge1xuICAgIG1haW5XaW5kb3c/LnNob3coKTtcblxuICAgIGlmIChlbnYuTU9ERSA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgbWFpbldpbmRvdz8ud2ViQ29udGVudHMub3BlbkRldlRvb2xzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF1dG9VcGRhdGVyLmNoZWNrRm9yVXBkYXRlc0FuZE5vdGlmeSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgbWFpbldpbmRvdz8ud2ViQ29udGVudHMub24oJ25ldy13aW5kb3cnLCBmdW5jdGlvbihldmVudCwgdXJsKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIGlmICh1cmwuc3RhcnRzV2l0aCgnbm90ZTovLycpKSByZXR1cm47XG5cbiAgICBzaGVsbC5vcGVuRXh0ZXJuYWwodXJsKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFVSTCBmb3IgbWFpbiB3aW5kb3cuXG4gICAqIFZpdGUgZGV2IHNlcnZlciBmb3IgZGV2ZWxvcG1lbnQuXG4gICAqIGBmaWxlOi8vLi4vcmVuZGVyZXIvaW5kZXguaHRtbGAgZm9yIHByb2R1Y3Rpb24gYW5kIHRlc3RcbiAgICovXG4gIGNvbnN0IHBhZ2VVcmwgPSBlbnYuTU9ERSA9PT0gJ2RldmVsb3BtZW50J1xuICAgID8gZW52LlZJVEVfREVWX1NFUlZFUl9VUkxcbiAgICA6IG5ldyBVUkwoJy4uL3JlbmRlcmVyL2Rpc3QvaW5kZXguaHRtbCcsICdmaWxlOi8vJyArIF9fZGlybmFtZSkudG9TdHJpbmcoKTtcblxuXG4gIGF3YWl0IG1haW5XaW5kb3cubG9hZFVSTChwYWdlVXJsKTtcbn07XG5cblxuYXBwLm9uKCdzZWNvbmQtaW5zdGFuY2UnLCAoKSA9PiB7XG4gIC8vIFNvbWVvbmUgdHJpZWQgdG8gcnVuIGEgc2Vjb25kIGluc3RhbmNlLCB3ZSBzaG91bGQgZm9jdXMgb3VyIHdpbmRvdy5cbiAgaWYgKG1haW5XaW5kb3cpIHtcbiAgICBpZiAobWFpbldpbmRvdy5pc01pbmltaXplZCgpKSBtYWluV2luZG93LnJlc3RvcmUoKTtcbiAgICBtYWluV2luZG93LmZvY3VzKCk7XG4gIH1cbn0pO1xuXG5cbmFwcC5vbignd2luZG93LWFsbC1jbG9zZWQnLCAoKSA9PiB7XG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtICE9PSAnZGFyd2luJykge1xuICAgIGFwcC5xdWl0KCk7XG4gIH1cbn0pO1xuXG5cbmFwcC53aGVuUmVhZHkoKVxuICAudGhlbihhc3luYyAoKSA9PiB7XG4gICAgcHJvdG9jb2wucmVnaXN0ZXJGaWxlUHJvdG9jb2woJ2Fzc2V0cycsIChyZXF1ZXN0LCBjYWxsYmFjaykgPT4ge1xuICAgICAgY29uc3QgdXJsID0gcmVxdWVzdC51cmwuc3Vic3RyKDkpO1xuXG4gICAgICBjb25zdCBkaXIgPSBzdG9yZS5zZXR0aW5ncy5nZXQoJ2RhdGFEaXInKTtcbiAgICAgIGNvbnN0IGltZ1BhdGggPSBgJHtkaXJ9L25vdGVzLWFzc2V0cy8ke3VybH1gO1xuXG4gICAgICBjYWxsYmFjayh7IHBhdGg6IG5vcm1hbGl6ZShpbWdQYXRoKSB9KTtcbiAgICB9KTtcblxuICAgIGF3YWl0IGVuc3VyZURpcihqb2luKGFwcC5nZXRQYXRoKCd1c2VyRGF0YScpLCAnbm90ZXMtYXNzZXRzJykpO1xuICAgIGF3YWl0IGNyZWF0ZVdpbmRvdygpO1xuICB9KVxuICAuY2F0Y2goKGUpID0+IGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCBjcmVhdGUgd2luZG93OicsIGUpKTtcblxuXG4vLyBBdXRvLXVwZGF0ZXNcbmlmIChlbnYuUFJPRCkge1xuICBhcHAud2hlblJlYWR5KClcbiAgICAudGhlbigoKSA9PiBpbXBvcnQoJ2VsZWN0cm9uLXVwZGF0ZXInKSlcbiAgICAudGhlbigoeyBhdXRvVXBkYXRlciB9KSA9PiBhdXRvVXBkYXRlci5jaGVja0ZvclVwZGF0ZXNBbmROb3RpZnkoKSlcbiAgICAuY2F0Y2goKGUpID0+IGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCBjaGVjayB1cGRhdGVzOicsIGUpKTtcbn1cblxuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignYXBwOmluZm8nLCAoKSA9PiAoe1xuICBuYW1lOiBhcHAuZ2V0TmFtZSgpLFxuICB2ZXJzaW9uOiBhcHAuZ2V0VmVyc2lvbigpLFxufSkpO1xuXG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdkaWFsb2c6b3BlbicsIChwcm9wcykgPT4gZGlhbG9nLnNob3dPcGVuRGlhbG9nKHByb3BzKSk7XG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdkaWFsb2c6bWVzc2FnZScsIChwcm9wcykgPT4gZGlhbG9nLnNob3dNZXNzYWdlQm94KHByb3BzKSk7XG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdkaWFsb2c6c2F2ZScsIChwcm9wcykgPT4gZGlhbG9nLnNob3dTYXZlRGlhbG9nKHByb3BzKSk7XG5cbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ2ZzOmNvcHknLCAoeyBwYXRoLCBkZXN0IH0pID0+IGNvcHkocGF0aCwgZGVzdCkpO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignZnM6b3V0cHV0LWpzb24nLCAoeyBwYXRoLCBkYXRhIH0pID0+IG91dHB1dEpzb24ocGF0aCwgZGF0YSkpO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignZnM6cmVhZC1qc29uJywgKHBhdGgpID0+IHJlYWRKc29uKHBhdGgpKTtcbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ2ZzOmVuc3VyZURpcicsIChwYXRoKSA9PiBlbnN1cmVEaXIocGF0aCkpO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignZnM6cGF0aEV4aXN0cycsIChwYXRoKSA9PiBwYXRoRXhpc3RzU3luYyhwYXRoKSk7XG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdmczpyZW1vdmUnLCAocGF0aCkgPT4gcmVtb3ZlKHBhdGgpKTtcblxuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignaGVscGVyOnJlbGF1bmNoJywgKG9wdGlvbnMgPSB7fSkgPT4ge1xuICBhcHAucmVsYXVuY2goeyBhcmdzOiBwcm9jZXNzLmFyZ3Yuc2xpY2UoMSkuY29uY2F0KFsnLS1yZWxhdW5jaCddKSwgLi4ub3B0aW9ucyB9KTtcbiAgYXBwLmV4aXQoMCk7XG59KTtcbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ2hlbHBlcjpnZXQtcGF0aCcsIChuYW1lKSA9PiBhcHAuZ2V0UGF0aChuYW1lKSk7XG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdoZWxwZXI6aXMtZGFyay10aGVtZScsICgpID0+IG5hdGl2ZVRoZW1lLnNob3VsZFVzZURhcmtDb2xvcnMpO1xuXG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdzdG9yYWdlOnN0b3JlJywgKG5hbWUpID0+IHN0b3JlW25hbWVdPy5zdG9yZSk7XG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdzdG9yYWdlOnJlcGxhY2UnLCAoeyBuYW1lLCBkYXRhIH0pID0+IChzdG9yZVtuYW1lXS5zdG9yZSA9IGRhdGEpKTtcbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ3N0b3JhZ2U6Z2V0JywgKHsgbmFtZSwga2V5LCBkZWYgfSkgPT4gc3RvcmVbbmFtZV0/LmdldChrZXksIGRlZikpO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignc3RvcmFnZTpzZXQnLCAoeyBuYW1lLCBrZXksIHZhbHVlIH0pID0+IHN0b3JlW25hbWVdPy5zZXQoa2V5LCB2YWx1ZSkpO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignc3RvcmFnZTpkZWxldGUnLCAoeyBuYW1lLCBrZXkgfSkgPT4gc3RvcmVbbmFtZV0/LmRlbGV0ZShrZXkpKTtcbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ3N0b3JhZ2U6aGFzJywgKHsgbmFtZSwga2V5IH0pID0+IHN0b3JlW25hbWVdPy5oYXMoa2V5KSk7XG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdzdG9yYWdlOmNsZWFyJywgKG5hbWUpID0+IHN0b3JlW25hbWVdPy5jbGVhcigpKTtcbiJdLCJuYW1lcyI6WyJzZXJpYWxpemVFcnJvciIsImRlc2VyaWFsaXplRXJyb3IiLCJlbGVjdHJvbiIsInJlcXVpcmUkJDAiLCJyZXF1aXJlJCQxIiwidXRpbCIsInJlcXVpcmUkJDIiLCJpcGNSZW5kZXJlciIsImlwYyIsImlwY01haW4iLCJtYWluIiwiY29uc3RhbnRzIiwicG9seWZpbGxzIiwicGF0Y2giLCJsZWdhY3kiLCJjbG9uZSIsImZzIiwicmVxdWlyZSQkMyIsInJlcXVpcmUkJDQiLCJkZWJ1ZyIsImdsb2JhbCIsInJlcXVpcmUkJDUiLCJwYXRoIiwidSIsIm1rZGlycyIsInV0aW1lc01pbGxpcyIsInV0aW1lc01pbGxpc1N5bmMiLCJnZXRTdGF0cyIsImFyZUlkZW50aWNhbCIsInN0YXQiLCJta2RpcnNTeW5jIiwib25EaXIiLCJvbkZpbGUiLCJvbkxpbmsiLCJjb3B5RmlsZSIsIm1heUNvcHlGaWxlIiwic2V0RGVzdE1vZGUiLCJmaWxlSXNOb3RXcml0YWJsZSIsIm1ha2VGaWxlV3JpdGFibGUiLCJzZXREZXN0VGltZXN0YW1wcyIsIm1rRGlyQW5kQ29weSIsImNvcHlEaXIiLCJjb3B5RGlySXRlbSIsInN0YXJ0Q29weSIsImNvcHlMaW5rIiwiY29weVN5bmMiLCJwYXRoRXhpc3RzIiwiY29weSIsImRlZmF1bHRzIiwicmltcmFmIiwicmVtb3ZlIiwicmVtb3ZlU3luYyIsIm1rZGlyIiwiZmlsZSIsImxpbmsiLCJzeW1saW5rUGF0aHMiLCJzeW1saW5rUGF0aHNTeW5jIiwic3ltbGlua1R5cGUiLCJzeW1saW5rVHlwZVN5bmMiLCJyZXF1aXJlJCQ2IiwicmVxdWlyZSQkNyIsInN5bWxpbmsiLCJzdHJpbmdpZnkiLCJzdHJpcEJvbSIsInJlYWRGaWxlIiwid3JpdGVGaWxlIiwianNvbmZpbGUiLCJyZWFkRmlsZVN5bmMiLCJ3cml0ZUZpbGVTeW5jIiwianNvbkZpbGUiLCJvdXRwdXRGaWxlIiwib3V0cHV0RmlsZVN5bmMiLCJqc29uIiwiaXNQYXJlbnRSb290IiwiZG9SZW5hbWUiLCJyZW5hbWUiLCJtb3ZlQWNyb3NzRGV2aWNlIiwibW92ZVN5bmMiLCJtb3ZlIiwicmVxdWlyZSQkOCIsInJlcXVpcmUkJDkiLCJyZXF1aXJlJCQxMCIsInJlcXVpcmUkJDExIiwiQ2FuY2VsbGF0aW9uVG9rZW5fMSIsImV2ZW50c18xIiwicGFyc2UiLCJjb21tb24iLCJQcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtXzEiLCJzdHJlYW1fMSIsImNyeXB0b18xIiwiZGVidWdfMSIsImZzXzEiLCJ1cmxfMSIsImluZGV4XzEiLCJZQU1MRXhjZXB0aW9uIiwibWFrZVNuaXBwZXQiLCJ0eXBlIiwiVHlwZSIsIlNjaGVtYSIsInNjaGVtYSIsImNvcmUiLCJfaGFzT3duUHJvcGVydHkiLCJfdG9TdHJpbmciLCJERUZBVUxUX1NDSEVNQSIsIlN0YXRlIiwicmVxdWlyZSQkMTIiLCJNQVhfTEVOR1RIIiwiTUFYX1NBRkVfSU5URUdFUiIsInBhcnNlT3B0aW9ucyIsImNvbXBhcmVJZGVudGlmaWVycyIsInJlIiwidCIsIlNlbVZlciIsInNlbXZlciIsInZhbGlkIiwiY29tcGFyZSIsImVxIiwiY29tcGFyZUJ1aWxkIiwiZ3QiLCJsdCIsIm5lcSIsImd0ZSIsImx0ZSIsImNtcCIsIllhbGxpc3QiLCJSYW5nZSIsIkNvbXBhcmF0b3IiLCJBTlkiLCJzYXRpc2ZpZXMiLCJvdXRzaWRlIiwicmVxdWlyZSQkMTMiLCJyZXF1aXJlJCQxNCIsInJlcXVpcmUkJDE1IiwicmVxdWlyZSQkMTYiLCJyZXF1aXJlJCQxNyIsInJlcXVpcmUkJDE4IiwicmVxdWlyZSQkMTkiLCJyZXF1aXJlJCQyMCIsInJlcXVpcmUkJDIxIiwicmVxdWlyZSQkMjIiLCJyZXF1aXJlJCQyMyIsInJlcXVpcmUkJDI0IiwicmVxdWlyZSQkMjUiLCJyZXF1aXJlJCQyNiIsInJlcXVpcmUkJDI3IiwicmVxdWlyZSQkMjgiLCJyZXF1aXJlJCQyOSIsInJlcXVpcmUkJDMwIiwicmVxdWlyZSQkMzEiLCJyZXF1aXJlJCQzMiIsInJlcXVpcmUkJDMzIiwicmVxdWlyZSQkMzQiLCJyZXF1aXJlJCQzNSIsInJlcXVpcmUkJDM2IiwicmVxdWlyZSQkMzciLCJyZXF1aXJlJCQzOCIsInJlcXVpcmUkJDM5IiwicmVxdWlyZSQkNDAiLCJEb3dubG9hZGVkVXBkYXRlSGVscGVyXzEiLCJmc19leHRyYV8xIiwiRWxlY3Ryb25BcHBBZGFwdGVyXzEiLCJTeW1ib2wiLCJlc2NhcGVSZWdFeHAiLCJQcm92aWRlcl8xIiwiYnVpbGRlcl91dGlsX3J1bnRpbWVfMSIsImpzX3lhbWxfMSIsInV0aWxfMSIsIkdlbmVyaWNQcm92aWRlcl8xIiwiQmludHJheVByb3ZpZGVyXzEiLCJHaXRIdWJQcm92aWRlcl8xIiwiS2V5Z2VuUHJvdmlkZXJfMSIsIlByaXZhdGVHaXRIdWJQcm92aWRlcl8xIiwiQXBwVXBkYXRlcl8xIiwibWFpbl8xIiwiQmFzZVVwZGF0ZXJfMSIsIkRhdGFTcGxpdHRlcl8xIiwiZG93bmxvYWRQbGFuQnVpbGRlcl8xIiwiUHJvZ3Jlc3NEaWZmZXJlbnRpYWxEb3dubG9hZENhbGxiYWNrVHJhbnNmb3JtXzEiLCJEaWZmZXJlbnRpYWxEb3dubG9hZGVyXzEiLCJGaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyXzEiLCJ6bGliXzEiLCJBcHBJbWFnZVVwZGF0ZXJfMSIsImNoaWxkX3Byb2Nlc3NfMSIsIk1hY1VwZGF0ZXJfMSIsIkdlbmVyaWNEaWZmZXJlbnRpYWxEb3dubG9hZGVyXzEiLCJvcyIsIk5zaXNVcGRhdGVyXzEiLCJpc09iaiIsInBhdGhFeGlzdHNNb2R1bGUiLCJwVHJ5IiwicFRyeU1vZHVsZSIsInBMaW1pdCIsInBMaW1pdE1vZHVsZSIsInBMb2NhdGUiLCJsb2NhdGVQYXRoTW9kdWxlIiwiZmluZFVwTW9kdWxlIiwicGtnVXBNb2R1bGUiLCJlbnYiLCJlbnZQYXRoc01vZHVsZSIsImNvbnN0c18xIiwiZGlzdCIsIm5hbWVzXzEiLCJjb2RlZ2VuXzEiLCJlcnJvcnNfMSIsImNvZGVfMSIsInRyYXZlcnNlIiwianNvblNjaGVtYVRyYXZlcnNlTW9kdWxlIiwidGhpcyIsInJlc29sdmUiLCJlcXVhbCIsIlVSSSIsImRhdGFUeXBlXzEiLCJyZXNvbHZlXzEiLCJ2YWxpZGF0ZV8xIiwiZGVmIiwiY29yZV8xIiwiZXJyb3IiLCJ1Y3MybGVuZ3RoXzEiLCJlcXVhbF8xIiwidmFsaWRhdGlvbl8xIiwiaXRlbXNfMSIsImFkZGl0aW9uYWxJdGVtc18xIiwicHJvcGVydGllcyIsImFkZGl0aW9uYWxQcm9wZXJ0aWVzXzEiLCJmb3JtYXQiLCJmb3JtYXRfMiIsImZvcm1hdF8xIiwibWltaWNGbiIsIm1pbWljRm5Nb2R1bGUiLCJvbmV0aW1lTW9kdWxlIiwiZG90UHJvcCIsInBrZ1VwIiwiZGVib3VuY2VGbiIsInN0b3JlIiwiU3RvcmUiLCJhcHAiLCJkYXRhIiwiQnJvd3NlcldpbmRvdyIsImpvaW4iLCJzaGVsbCIsInByb3RvY29sIiwibm9ybWFsaXplIiwiZW5zdXJlRGlyIiwiZGlhbG9nIiwib3V0cHV0SnNvbiIsInJlYWRKc29uIiwicGF0aEV4aXN0c1N5bmMiLCJuYXRpdmVUaGVtZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLHVCQUF1QixNQUFNO0FBQUEsRUFDNUIsWUFBWSxTQUFTO0FBQ3BCLFVBQU0sU0FBUyxxQkFBcUI7QUFDcEMsV0FBTyxlQUFlLE1BQU0sUUFBUTtBQUFBLE1BQ25DLE9BQU87QUFBQSxNQUNQLGNBQWM7QUFBQSxNQUNkLFVBQVU7QUFBQTtBQUdYLFFBQUksTUFBTSxtQkFBbUI7QUFDNUIsWUFBTSxrQkFBa0IsTUFBTTtBQUFBO0FBQUE7QUFBQSxTQUl6QixxQkFBcUIsU0FBUztBQUNwQyxRQUFJO0FBQ0gsYUFBTyxLQUFLLFVBQVU7QUFBQSxZQUNyQjtBQUNELGFBQU8sT0FBTztBQUFBO0FBQUE7QUFBQTtBQUtqQixNQUFNLG1CQUFtQjtBQUFBLEVBQ3hCLEVBQUMsVUFBVSxRQUFRLFlBQVk7QUFBQSxFQUMvQixFQUFDLFVBQVUsV0FBVyxZQUFZO0FBQUEsRUFDbEMsRUFBQyxVQUFVLFNBQVMsWUFBWTtBQUFBLEVBQ2hDLEVBQUMsVUFBVSxRQUFRLFlBQVk7QUFBQTtBQUdoQyxNQUFNLFdBQVcsT0FBTztBQUV4QixNQUFNLFNBQVMsVUFBUTtBQUN0QixPQUFLLFlBQVk7QUFDakIsUUFBTSxRQUFPLEtBQUs7QUFDbEIsU0FBTyxLQUFLO0FBQ1osU0FBTztBQUFBO0FBR1IsTUFBTSxrQkFBa0IsQ0FBQztBQUFBLEVBQ3hCO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxNQUNLO0FBQ0wsUUFBTSxLQUFLLE9BQVEsT0FBTSxRQUFRLFFBQVEsS0FBSztBQUU5QyxPQUFLLEtBQUs7QUFFVixNQUFJLFNBQVMsVUFBVTtBQUN0QixXQUFPO0FBQUE7QUFHUixNQUFJLE9B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Q2IsV0FBVztBQUFBLE1BQ1gsV0FBVztBQUFBLE1BQ1gsa0JBQWtCO0FBQUEsTUFDbEIsU0FBUztBQUFBLE1BQ1QsZ0JBQWdCO0FBQUEsTUFDaEIsYUFBYTtBQUFBLE1BQ2Isb0JBQW9CO0FBQUEsTUFDcEIsa0JBQWtCO0FBQUEsTUFDbEIsU0FBUztBQUFBLE1BQ1QsZ0JBQWdCO0FBQUEsTUFDaEIsZUFBZTtBQUFBLE1BQ2YsT0FBTztBQUFBLE1BQ1AsY0FBYztBQUFBLE1BQ2QsZ0JBQWdCO0FBQUEsTUFDaEIsV0FBVztBQUFBLE1BQ1gsZ0JBQWdCO0FBQUEsTUFDaEIsa0JBQWtCO0FBQUEsTUFDbEIsVUFBVTtBQUFBLE1BQ1YsZ0JBQWdCO0FBQUEsTUFDaEIsUUFBUTtBQUFBLE1BQ1IsYUFBYTtBQUFBLE1BQ2IsdUJBQXVCO0FBQUEsTUFDdkIsY0FBYztBQUFBLE1BQ2QscUJBQXFCO0FBQUEsTUFDckIscUJBQXFCO0FBQUEsTUFDckIsdUJBQXVCO0FBQUEsTUFDdkIsdUJBQXVCO0FBQUEsTUFDdkIsdUJBQXVCO0FBQUEsTUFDdkIsV0FBVztBQUFBLE1BQ1gscUJBQXFCO0FBQUEsTUFDckIsUUFBUTtBQUFBLE1BQ1IsZUFBZTtBQUFBO0FBR2pCLFNBQUksZUFBZTtBQUFBLE1BQ2pCLE9BQU87QUFBQSxNQUNQLE1BQU07QUFBQSxNQUNOLE1BQU07QUFBQSxNQUNOLFFBQVE7QUFBQSxNQUNSLFFBQVE7QUFBQTtBQUdWLFNBQUksV0FBVztBQUFBLE1BQ2IsT0FBTztBQUFBLE1BQ1AsTUFBTTtBQUFBLE1BQ04sTUFBTTtBQUFBLE1BQ04sUUFBUTtBQUFBLE1BQ1IsUUFBUTtBQUFBLE1BQ1IsU0FBUztBQUFBLE1BQ1QsVUFBVTtBQUFBLE1BQ1YsU0FBUztBQUFBLE1BQ1QsVUFBVTtBQUFBLE1BQ1YsU0FBUztBQUFBLE1BQ1QsVUFBVTtBQUFBLE1BQ1YsUUFBUTtBQUFBLE1BQ1IsVUFBVTtBQUFBLE1BQ1YsT0FBTztBQUFBLE1BQ1AsVUFBVTtBQUFBLE1BQ1YsU0FBUztBQUFBLE1BQ1QsVUFBVTtBQUFBLE1BQ1YsUUFBUTtBQUFBLE1BQ1IsVUFBVTtBQUFBLE1BQ1YsU0FBUztBQUFBLE1BQ1QsVUFBVTtBQUFBLE1BQ1YsUUFBUTtBQUFBLE1BQ1IsVUFBVTtBQUFBLE1BQ1YsVUFBVTtBQUFBLE1BQ1YsU0FBUztBQUFBLE1BQ1QsVUFBVTtBQUFBLE1BQ1YsVUFBVTtBQUFBLE1BQ1YsVUFBVTtBQUFBLE1BQ1YsUUFBUTtBQUFBLE1BQ1IsU0FBUztBQUFBLE1BQ1QsVUFBVTtBQUFBLE1BQ1YsU0FBUztBQUFBLE1BQ1QsVUFBVTtBQUFBLE1BQ1YsUUFBUTtBQUFBLE1BQ1IsVUFBVTtBQUFBLE1BQ1YsVUFBVTtBQUFBLE1BQ1YsU0FBUztBQUFBLE1BQ1QsU0FBUztBQUFBLE1BQ1QsVUFBVTtBQUFBLE1BQ1YsU0FBUztBQUFBLE1BQ1QsVUFBVTtBQUFBLE1BQ1YsUUFBUTtBQUFBLE1BQ1IsVUFBVTtBQUFBLE1BQ1YsVUFBVTtBQUFBLE1BQ1YsU0FBUztBQUFBLE1BQ1QsVUFBVTtBQUFBLE1BQ1YsT0FBTztBQUFBLE1BQ1AsUUFBUTtBQUFBLE1BQ1IsVUFBVTtBQUFBLE1BQ1YsU0FBUztBQUFBLE1BQ1QsVUFBVTtBQUFBLE1BQ1YsUUFBUTtBQUFBLE1BQ1IsVUFBVTtBQUFBLE1BQ1YsVUFBVTtBQUFBLE1BQ1YsU0FBUztBQUFBLE1BQ1QsVUFBVTtBQUFBLE1BQ1YsVUFBVTtBQUFBLE1BQ1YsVUFBVTtBQUFBLE1BQ1YsUUFBUTtBQUFBLE1BQ1IsU0FBUztBQUFBLE1BQ1QsU0FBUztBQUFBLE1BQ1QsVUFBVTtBQUFBLE1BQ1YsU0FBUztBQUFBLE1BQ1QsVUFBVTtBQUFBLE1BQ1YsUUFBUTtBQUFBLE1BQ1IsVUFBVTtBQUFBLE1BQ1YsUUFBUTtBQUFBLE1BQ1IsUUFBUTtBQUFBLE1BQ1IsT0FBTztBQUFBLE1BQ1AsUUFBUTtBQUFBLE1BQ1IsU0FBUztBQUFBLE1BQ1QsUUFBUTtBQUFBLE1BQ1IsU0FBUztBQUFBLE1BQ1QsVUFBVTtBQUFBLE1BQ1YsT0FBTztBQUFBLE1BQ1AsVUFBVTtBQUFBLE1BQ1YsUUFBUTtBQUFBLE1BQ1IsT0FBTztBQUFBLE1BQ1AsUUFBUTtBQUFBLE1BQ1IsU0FBUztBQUFBLE1BQ1QsT0FBTztBQUFBLE1BQ1AsT0FBTztBQUFBLE1BQ1AsUUFBUTtBQUFBLE1BQ1IsT0FBTztBQUFBLE1BQ1AsVUFBVTtBQUFBLE1BQ1YsUUFBUTtBQUFBLE1BQ1IsUUFBUTtBQUFBLE1BQ1IsUUFBUTtBQUFBLE1BQ1IsU0FBUztBQUFBLE1BQ1QsU0FBUztBQUFBLE1BQ1QsUUFBUTtBQUFBLE1BQ1IsVUFBVTtBQUFBLE1BQ1YsU0FBUztBQUFBLE1BQ1QsUUFBUTtBQUFBLE1BQ1IsU0FBUztBQUFBLE1BQ1QsVUFBVTtBQUFBLE1BQ1YsVUFBVTtBQUFBLE1BQ1YsVUFBVTtBQUFBLE1BQ1YsVUFBVTtBQUFBLE1BQ1YsU0FBUztBQUFBLE1BQ1QsVUFBVTtBQUFBLE1BQ1YsU0FBUztBQUFBLE1BQ1QsU0FBUztBQUFBLE1BQ1QsVUFBVTtBQUFBLE1BQ1YsVUFBVTtBQUFBLE1BQ1YsUUFBUTtBQUFBLE1BQ1IsUUFBUTtBQUFBLE1BQ1IsUUFBUTtBQUFBLE1BQ1IsU0FBUztBQUFBLE1BQ1QsU0FBUztBQUFBLE1BQ1QsUUFBUTtBQUFBLE1BQ1IsU0FBUztBQUFBLE1BQ1QsU0FBUztBQUFBLE1BQ1QsV0FBVztBQUFBLE1BQ1gsUUFBUTtBQUFBLE1BQ1IsT0FBTztBQUFBLE1BQ1AsU0FBUztBQUFBLE1BQ1QsUUFBUTtBQUFBLE1BQ1IsU0FBUztBQUFBLE1BQ1QsVUFBVTtBQUFBLE1BQ1YsTUFBTTtBQUFBLE1BQ04sTUFBTTtBQUFBLE1BQ04sTUFBTTtBQUFBLE1BQ04sV0FBVztBQUFBLE1BQ1gsTUFBTTtBQUFBLE1BQ04sT0FBTztBQUFBLE1BQ1AsU0FBUztBQUFBLE1BQ1QsT0FBTztBQUFBLE1BQ1AsV0FBVztBQUFBLE1BQ1gsT0FBTztBQUFBLE1BQ1AsT0FBTztBQUFBLE1BQ1AsT0FBTztBQUFBLE1BQ1AsU0FBUztBQUFBLE1BQ1QsU0FBUztBQUFBLE1BQ1QsUUFBUTtBQUFBLE1BQ1IsU0FBUztBQUFBLE1BQ1QsU0FBUztBQUFBLE1BQ1QsV0FBVztBQUFBLE1BQ1gsUUFBUTtBQUFBLE1BQ1IsT0FBTztBQUFBLE1BQ1AsU0FBUztBQUFBLE1BQ1QsUUFBUTtBQUFBLE1BQ1IsU0FBUztBQUFBLE1BQ1QsVUFBVTtBQUFBLE1BQ1YsTUFBTTtBQUFBLE1BQ04sTUFBTTtBQUFBLE1BQ04sTUFBTTtBQUFBLE1BQ04sV0FBVztBQUFBLE1BQ1gsTUFBTTtBQUFBLE1BQ04sT0FBTztBQUFBLE1BQ1AsVUFBVTtBQUFBLE1BQ1YsU0FBUztBQUFBLE1BQ1QsT0FBTztBQUFBLE1BQ1AsV0FBVztBQUFBLE1BQ1gsT0FBTztBQUFBLE1BQ1AsT0FBTztBQUFBLE1BQ1AsT0FBTztBQUFBLE1BQ1AsU0FBUztBQUFBLE1BQ1QsWUFBWTtBQUFBLE1BQ1osU0FBUztBQUFBLE1BQ1QsT0FBTztBQUFBLE1BQ1AsUUFBUTtBQUFBLE1BQ1IsUUFBUTtBQUFBLE1BQ1IsVUFBVTtBQUFBLE1BQ1YsUUFBUTtBQUFBLE1BQ1IsT0FBTztBQUFBLE1BQ1AsT0FBTztBQUFBLE1BQ1AsT0FBTztBQUFBLE1BQ1AsU0FBUztBQUFBLE1BQ1QsU0FBUztBQUFBLE1BQ1QsU0FBUztBQUFBLE1BQ1QsU0FBUztBQUFBLE1BQ1QsU0FBUztBQUFBLE1BQ1QsU0FBUztBQUFBLE1BQ1QsU0FBUztBQUFBLE1BQ1QsU0FBUztBQUFBLE1BQ1QsVUFBVTtBQUFBLE1BQ1YsVUFBVTtBQUFBLE1BQ1YsUUFBUTtBQUFBLE1BQ1IsVUFBVTtBQUFBLE1BQ1YsVUFBVTtBQUFBLE1BQ1YsU0FBUztBQUFBLE1BQ1QsU0FBUztBQUFBLE1BQ1QsVUFBVTtBQUFBLE1BQ1YsVUFBVTtBQUFBLE1BQ1YsU0FBUztBQUFBLE1BQ1QsU0FBUztBQUFBLE1BQ1QsUUFBUTtBQUFBLE1BQ1IsU0FBUztBQUFBLE1BQ1QsVUFBVTtBQUFBLE1BQ1YsUUFBUTtBQUFBLE1BQ1IsU0FBUztBQUFBLE1BQ1QsV0FBVztBQUFBLE1BQ1gsUUFBUTtBQUFBLE1BQ1IsUUFBUTtBQUFBLE1BQ1IsUUFBUTtBQUFBLE1BQ1IsUUFBUTtBQUFBLE1BQ1IsUUFBUTtBQUFBLE1BQ1IsU0FBUztBQUFBLE1BQ1QsUUFBUTtBQUFBLE1BQ1IsUUFBUTtBQUFBLE1BQ1IsUUFBUTtBQUFBLE1BQ1IsUUFBUTtBQUFBLE1BQ1IsUUFBUTtBQUFBLE1BQ1IsVUFBVTtBQUFBLE1BQ1YsUUFBUTtBQUFBLE1BQ1IsU0FBUztBQUFBLE1BQ1QsU0FBUztBQUFBLE1BQ1QsU0FBUztBQUFBLE1BQ1QsUUFBUTtBQUFBLE1BQ1IsU0FBUztBQUFBLE1BQ1QsTUFBTTtBQUFBLE1BQ04sUUFBUTtBQUFBLE1BQ1IsT0FBTztBQUFBLE1BQ1AsU0FBUztBQUFBLE1BQ1QsVUFBVTtBQUFBLE1BQ1YsU0FBUztBQUFBLE1BQ1QsUUFBUTtBQUFBLE1BQ1IsU0FBUztBQUFBLE1BQ1QsT0FBTztBQUFBLE1BQ1AsT0FBTztBQUFBLE1BQ1AsTUFBTTtBQUFBLE1BQ04sT0FBTztBQUFBLE1BQ1AsT0FBTztBQUFBLE1BQ1AsT0FBTztBQUFBLE1BQ1AsVUFBVTtBQUFBLE1BQ1YsT0FBTztBQUFBLE1BQ1AsUUFBUTtBQUFBLE1BQ1IsU0FBUztBQUFBLE1BQ1QsTUFBTTtBQUFBLE1BQ04sU0FBUztBQUFBLE1BQ1QsTUFBTTtBQUFBLE1BQ04sTUFBTTtBQUFBLE1BQ04sT0FBTztBQUFBLE1BQ1AsT0FBTztBQUFBLE1BQ1AsUUFBUTtBQUFBLE1BQ1IsUUFBUTtBQUFBLE1BQ1IsUUFBUTtBQUFBLE1BQ1IsU0FBUztBQUFBLE1BQ1QsVUFBVTtBQUFBLE1BQ1YsUUFBUTtBQUFBLE1BQ1IsUUFBUTtBQUFBLE1BQ1IsU0FBUztBQUFBLE1BQ1QsU0FBUztBQUFBLE1BQ1QsVUFBVTtBQUFBLE1BQ1YsVUFBVTtBQUFBLE1BQ1YsUUFBUTtBQUFBLE1BQ1IsUUFBUTtBQUFBLE1BQ1IsT0FBTztBQUFBLE1BQ1AsVUFBVTtBQUFBLE1BQ1YsU0FBUztBQUFBLE1BQ1QsVUFBVTtBQUFBLE1BQ1YsU0FBUztBQUFBO0FBR1gsV0FBTyxLQUFLLEtBQUksVUFBVSxRQUFRLFNBQVUsS0FBSztBQUMvQyxVQUFJLElBQUksS0FBSSxT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
